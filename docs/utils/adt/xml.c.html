<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/adt/xml.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/adt/xml.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L143">LibxmlContext</a></li>
<li><a href="#L223">XmlTableRoutine</a></li>
<li><a href="#L109">xmlbinary</a></li>
<li><a href="#L110">xmloption</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L117">PgXmlErrorContext</a></li>
<li><a href="#L196">XmlTableBuilderData</a></li>
<li><a href="#L208">XmlTableBuilderData</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L4587">GetXmlTableBuilderPrivateData</a></li>
<li><a href="#L4021">SPI_sql_row_to_xmlelement</a></li>
<li><a href="#L5002">XmlTableDestroyOpaque</a></li>
<li><a href="#L4805">XmlTableFetchRow</a></li>
<li><a href="#L4850">XmlTableGetValue</a></li>
<li><a href="#L4613">XmlTableInitOpaque</a></li>
<li><a href="#L4773">XmlTableSetColumnFilter</a></li>
<li><a href="#L4661">XmlTableSetDocument</a></li>
<li><a href="#L4718">XmlTableSetNamespace</a></li>
<li><a href="#L4744">XmlTableSetRowFilter</a></li>
<li><a href="#L2664">_SPI_strdup</a></li>
<li><a href="#L2259">appendStringInfoLineSeparator</a></li>
<li><a href="#L459">appendStringInfoText</a></li>
<li><a href="#L2248">chopStringInfoNewlines</a></li>
<li><a href="#L474">cstring_to_xmltype</a></li>
<li><a href="#L2848">cursor_to_xml</a></li>
<li><a href="#L3029">cursor_to_xmlschema</a></li>
<li><a href="#L2777">database_get_xml_visible_schemas</a></li>
<li><a href="#L2784">database_get_xml_visible_tables</a></li>
<li><a href="#L3334">database_to_xml</a></li>
<li><a href="#L3401">database_to_xml_and_xmlschema</a></li>
<li><a href="#L3291">database_to_xml_internal</a></li>
<li><a href="#L3389">database_to_xmlschema</a></li>
<li><a href="#L3346">database_to_xmlschema_internal</a></li>
<li><a href="#L2211">errdetail_for_xml_code</a></li>
<li><a href="#L2632">escape_xml</a></li>
<li><a href="#L2299">is_valid_xml_namechar</a></li>
<li><a href="#L2290">is_valid_xml_namefirst</a></li>
<li><a href="#L3420">map_multipart_sql_identifier_to_xml_name</a></li>
<li><a href="#L3629">map_sql_catalog_to_xmlschema_types</a></li>
<li><a href="#L2315">map_sql_identifier_to_xml_name</a></li>
<li><a href="#L3556">map_sql_schema_to_xmlschema_types</a></li>
<li><a href="#L3451">map_sql_table_to_xmlschema</a></li>
<li><a href="#L3686">map_sql_type_to_xml_name</a></li>
<li><a href="#L3846">map_sql_type_to_xmlschema_type</a></li>
<li><a href="#L3791">map_sql_typecoll_to_xmlschema_types</a></li>
<li><a href="#L2413">map_sql_value_to_xml_value</a></li>
<li><a href="#L2371">map_xml_name_to_sql_identifier</a></li>
<li><a href="#L1400">parse_xml_decl</a></li>
<li><a href="#L1354">pg_xmlCharStrndup</a></li>
<li><a href="#L1259">pg_xml_done</a></li>
<li><a href="#L1307">pg_xml_error_occurred</a></li>
<li><a href="#L1178">pg_xml_init</a></li>
<li><a href="#L1132">pg_xml_init_library</a></li>
<li><a href="#L1573">print_xml_decl</a></li>
<li><a href="#L2721">query_to_oid_list</a></li>
<li><a href="#L2834">query_to_xml</a></li>
<li><a href="#L3080">query_to_xml_and_xmlschema</a></li>
<li><a href="#L2936">query_to_xml_internal</a></li>
<li><a href="#L3000">query_to_xmlschema</a></li>
<li><a href="#L2750">schema_get_xml_visible_tables</a></li>
<li><a href="#L3159">schema_to_xml</a></li>
<li><a href="#L3263">schema_to_xml_and_xmlschema</a></li>
<li><a href="#L3116">schema_to_xml_internal</a></li>
<li><a href="#L3250">schema_to_xmlschema</a></li>
<li><a href="#L3205">schema_to_xmlschema_internal</a></li>
<li><a href="#L2271">sqlchar_to_unicode</a></li>
<li><a href="#L467">stringinfo_to_xmltype</a></li>
<li><a href="#L2820">table_to_xml</a></li>
<li><a href="#L3059">table_to_xml_and_xmlschema</a></li>
<li><a href="#L2803">table_to_xml_internal</a></li>
<li><a href="#L2981">table_to_xmlschema</a></li>
<li><a href="#L637">texttoxml</a></li>
<li><a href="#L4520">wellformed_xml</a></li>
<li><a href="#L482">xmlBuffer_to_xmltype</a></li>
<li><a href="#L251">xmlChar_to_encoding</a></li>
<li><a href="#L1952">xmlPgEntityLoader</a></li>
<li><a href="#L1639">xml_doctype_in_content</a></li>
<li><a href="#L1970">xml_ereport</a></li>
<li><a href="#L2036">xml_errorHandler</a></li>
<li><a href="#L2007">xml_errsave</a></li>
<li><a href="#L273">xml_in</a></li>
<li><a href="#L1096">xml_is_document</a></li>
<li><a href="#L4538">xml_is_well_formed</a></li>
<li><a href="#L4564">xml_is_well_formed_content</a></li>
<li><a href="#L4551">xml_is_well_formed_document</a></li>
<li><a href="#L1894">xml_memory_init</a></li>
<li><a href="#L356">xml_out</a></li>
<li><a href="#L312">xml_out_internal</a></li>
<li><a href="#L1910">xml_palloc</a></li>
<li><a href="#L1715">xml_parse</a></li>
<li><a href="#L1924">xml_pfree</a></li>
<li><a href="#L1342">xml_pnstrdup</a></li>
<li><a href="#L1933">xml_pstrdup</a></li>
<li><a href="#L1371">xml_pstrdup_and_free</a></li>
<li><a href="#L371">xml_recv</a></li>
<li><a href="#L1917">xml_repalloc</a></li>
<li><a href="#L438">xml_send</a></li>
<li><a href="#L1881">xml_text2xmlChar</a></li>
<li><a href="#L4091">xml_xmlnodetoxmltype</a></li>
<li><a href="#L4181">xml_xpathobjtoxmlarray</a></li>
<li><a href="#L491">xmlcomment</a></li>
<li><a href="#L553">xmlconcat</a></li>
<li><a href="#L619">xmlconcat2</a></li>
<li><a href="#L2929">xmldata_root_element_end</a></li>
<li><a href="#L2902">xmldata_root_element_start</a></li>
<li><a href="#L836">xmlelement</a></li>
<li><a href="#L4473">xmlexists</a></li>
<li><a href="#L960">xmlparse</a></li>
<li><a href="#L978">xmlpi</a></li>
<li><a href="#L1030">xmlroot</a></li>
<li><a href="#L527">xmltext</a></li>
<li><a href="#L646">xmltotext</a></li>
<li><a href="#L656">xmltotext_with_options</a></li>
<li><a href="#L1086">xmlvalidate</a></li>
<li><a href="#L4450">xpath</a></li>
<li><a href="#L4496">xpath_exists</a></li>
<li><a href="#L4259">xpath_internal</a></li>
<li><a href="#L3198">xsd_schema_element_end</a></li>
<li><a href="#L3181">xsd_schema_element_start</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L1322">CHECK_XML_SPACE</a></li>
<li><a href="#L115">ERRCXT_MAGIC</a></li>
<li><a href="#L68">HAVE_XMLSTRUCTUREDERRORCONTEXT</a></li>
<li><a href="#L245">NAMESPACE_SQLXML</a></li>
<li><a href="#L243">NAMESPACE_XSD</a></li>
<li><a href="#L244">NAMESPACE_XSI</a></li>
<li><a href="#L235">NO_XML_SUPPORT</a></li>
<li><a href="#L1333">PG_XMLISNAMECHAR</a></li>
<li><a href="#L301">PG_XML_DEFAULT_VERSION</a></li>
<li><a href="#L75">PgXmlErrorPtr</a></li>
<li><a href="#L77">PgXmlErrorPtr</a></li>
<li><a href="#L1328">SKIP_XML_SPACE</a></li>
<li><a href="#L195">XMLTABLE_CONTEXT_MAGIC</a></li>
<li><a href="#L2773">XML_VISIBLE_SCHEMAS</a></li>
<li><a href="#L2771">XML_VISIBLE_SCHEMAS_EXCLUDE</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * xml.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; XML data type support.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * src/backend/utils/adt/xml.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Generally, XML type support is only available when libxml use was<br/></li>
<li></span><span class="Comment"> * configured during the build.&nbsp; But even if that is not done, the<br/></li>
<li></span><span class="Comment"> * type and all the <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> are available, but most of them will<br/></li>
<li></span><span class="Comment"> * fail.&nbsp; For one thing, this avoids having to manage variant catalog<br/></li>
<li></span><span class="Comment"> * installations.&nbsp; But it also has nice effects such as that you can<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a> a database containing XML type data even if the server is not<br/></li>
<li></span><span class="Comment"> * linked with libxml.&nbsp; Thus, make sure <a href="#L356" title="utils/adt/xml.c:356">xml_out</a>() works even if nothing<br/></li>
<li></span><span class="Comment"> * else does.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Notes on memory management:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Sometimes libxml allocates global structures in the hope that it can reuse<br/></li>
<li></span><span class="Comment"> * them later on.&nbsp; This makes it impractical to change the xmlMemSetup<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> on-the-fly; that is likely to lead to trying to <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>() chunks<br/></li>
<li></span><span class="Comment"> * allocated with malloc() or vice versa.&nbsp; Since libxml might be used by<br/></li>
<li></span><span class="Comment"> * loadable modules, eg libperl, our only safe choices are to change the<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> at postmaster/backend launch or not at all.&nbsp; Since we'd rather<br/></li>
<li></span><span class="Comment"> * not activate libxml in sessions that might never use it, the latter choice<br/></li>
<li></span><span class="Comment"> * is the preferred one.&nbsp; However, for debugging purposes it can be awfully<br/></li>
<li></span><span class="Comment"> * handy to constrain libxml's allocations to be done in a specific <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a><br/></li>
<li></span><span class="Comment"> * context, where they're easy to track.&nbsp; Therefore there is code here that<br/></li>
<li></span><span class="Comment"> * can be enabled in debug builds to redirect libxml's allocations into a<br/></li>
<li></span><span class="Comment"> * special context <a href="#L143" title="utils/adt/xml.c:143">LibxmlContext</a>.&nbsp; It's not recommended to turn this on in<br/></li>
<li></span><span class="Comment"> * a production build because of the possibility of bad interactions with<br/></li>
<li></span><span class="Comment"> * external modules.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Comment">/* #define USE_LIBXMLCONTEXT */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef USE_LIBXML<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;libxml/chvalid.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;libxml/entities.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;libxml/parser.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;libxml/parserInternals.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;libxml/tree.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;libxml/uri.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;libxml/xmlerror.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;libxml/xmlsave.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;libxml/xmlversion.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;libxml/xmlwriter.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;libxml/<a href="#L4450" title="utils/adt/xml.c:4450">xpath</a>.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;libxml/xpathInternals.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * We used to check for xmlStructuredErrorContext via a configure test; but<br/></li>
<li></span><span class="Comment"> * that doesn't work on Windows, so instead use this grottier method of<br/></li>
<li></span><span class="Comment"> * testing the library version number.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#if LIBXML_VERSION &gt;= </span><span class="Constant">20704<br/></li>
<li><a id="L68">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">HAVE_XMLSTRUCTUREDERRORCONTEXT</span> </span><span class="Constant">1<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * libxml2 2.12 decided to insert &quot;const&quot; into the error handler API.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#if LIBXML_VERSION &gt;= </span><span class="Constant">21200<br/></li>
<li><a id="L75">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PgXmlErrorPtr</span> </span><span class="Type">const</span><span class="PreProc"> xmlError *<br/></li>
<li></span><span class="PreProc">#else<br/></li>
<li><a id="L77">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PgXmlErrorPtr</span> xmlErrorPtr<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* USE_LIBXML */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/table.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/namespace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_class.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/dbcommands.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/spi.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/tablefunc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;fmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lib/stringinfo.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/pqformat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;mb/pg_wchar.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/execnodes.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/miscnodes.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/nodeFuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/array.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/date.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/datetime.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/syscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/xml.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* GUC variables */<br/></li>
<li><a id="L109">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">xmlbinary</span> = XMLBINARY_BASE64;<br/></li>
<li><a id="L110">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">xmloption</span> = XMLOPTION_CONTENT;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_LIBXML<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* random number to identify <a href="#L117" title="utils/adt/xml.c:117">PgXmlErrorContext</a> */<br/></li>
<li><a id="L115">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ERRCXT_MAGIC</span>&nbsp; &nbsp; </span><span class="Constant">68275028<br/></li>
<li></span><br/></li>
<li><a id="L117">&#x200c;</a><span class="Type">struct</span> <span class="linkable">PgXmlErrorContext</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; magic;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* strictness argument passed to <a href="#L1178" title="utils/adt/xml.c:1178">pg_xml_init</a> */<br/></li>
<li></span>&nbsp; &nbsp; PgXmlStrictness strictness;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* current error status and accumulated message, if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; err_occurred;<br/></li>
<li>&nbsp; &nbsp; StringInfoData err_buf;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* previous libxml error handling state (saved by <a href="#L1178" title="utils/adt/xml.c:1178">pg_xml_init</a>) */<br/></li>
<li></span>&nbsp; &nbsp; xmlStructuredErrorFunc saved_errfunc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *saved_errcxt;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* previous libxml entity handler (saved by <a href="#L1178" title="utils/adt/xml.c:1178">pg_xml_init</a>) */<br/></li>
<li></span>&nbsp; &nbsp; xmlExternalEntityLoader saved_entityfunc;<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><span class="Type">static</span> xmlParserInputPtr <a href="#L1952" title="utils/adt/xml.c:1952">xmlPgEntityLoader</a>(<span class="Type">const</span> <span class="Type">char</span> *URL, <span class="Type">const</span> <span class="Type">char</span> *ID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xmlParserCtxtPtr ctxt);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2007" title="utils/adt/xml.c:2007">xml_errsave</a>(Node *escontext, <a href="#L117" title="utils/adt/xml.c:117">PgXmlErrorContext</a> *errcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> sqlcode, <span class="Type">const</span> <span class="Type">char</span> *msg);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2036" title="utils/adt/xml.c:2036">xml_errorHandler</a>(<span class="Type">void</span> *data, <a href="#L75" title="utils/adt/xml.c:75">PgXmlErrorPtr</a> error);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L2211" title="utils/adt/xml.c:2211">errdetail_for_xml_code</a>(<span class="Type">int</span> code);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2248" title="utils/adt/xml.c:2248">chopStringInfoNewlines</a>(StringInfo str);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2259" title="utils/adt/xml.c:2259">appendStringInfoLineSeparator</a>(StringInfo str);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_LIBXMLCONTEXT<br/></li>
<li></span><br/></li>
<li><a id="L143">&#x200c;</a><span class="Type">static</span> MemoryContext <span class="linkable">LibxmlContext</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1894" title="utils/adt/xml.c:1894">xml_memory_init</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> *<a href="#L1910" title="utils/adt/xml.c:1910">xml_palloc</a>(<span class="Type">size_t</span> size);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> *<a href="#L1917" title="utils/adt/xml.c:1917">xml_repalloc</a>(<span class="Type">void</span> *ptr, <span class="Type">size_t</span> size);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1924" title="utils/adt/xml.c:1924">xml_pfree</a>(<span class="Type">void</span> *ptr);<br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<a href="#L1933" title="utils/adt/xml.c:1933">xml_pstrdup</a>(<span class="Type">const</span> <span class="Type">char</span> *string);<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* USE_LIBXMLCONTEXT */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> xmlChar *<a href="#L1881" title="utils/adt/xml.c:1881">xml_text2xmlChar</a>(text *in);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1400" title="utils/adt/xml.c:1400">parse_xml_decl</a>(<span class="Type">const</span> xmlChar *str, <span class="Type">size_t</span> *lenp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xmlChar **version, xmlChar **encoding, <span class="Type">int</span> *standalone);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1573" title="utils/adt/xml.c:1573">print_xml_decl</a>(StringInfo buf, <span class="Type">const</span> xmlChar *version,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pg_enc encoding, <span class="Type">int</span> standalone);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1639" title="utils/adt/xml.c:1639">xml_doctype_in_content</a>(<span class="Type">const</span> xmlChar *str);<br/></li>
<li><span class="Type">static</span> xmlDocPtr <a href="#L1715" title="utils/adt/xml.c:1715">xml_parse</a>(text *data, XmlOptionType xmloption_arg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> preserve_whitespace, <span class="Type">int</span> encoding,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XmlOptionType *parsed_xmloptiontype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xmlNodePtr *parsed_nodes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Node *escontext);<br/></li>
<li><span class="Type">static</span> text *<a href="#L4091" title="utils/adt/xml.c:4091">xml_xmlnodetoxmltype</a>(xmlNodePtr cur, <a href="#L117" title="utils/adt/xml.c:117">PgXmlErrorContext</a> *xmlerrcxt);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L4181" title="utils/adt/xml.c:4181">xml_xpathobjtoxmlarray</a>(xmlXPathObjectPtr xpathobj,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ArrayBuildState *astate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L117" title="utils/adt/xml.c:117">PgXmlErrorContext</a> *xmlerrcxt);<br/></li>
<li><span class="Type">static</span> xmlChar *<a href="#L1354" title="utils/adt/xml.c:1354">pg_xmlCharStrndup</a>(<span class="Type">const</span> <span class="Type">char</span> *str, <span class="Type">size_t</span> len);<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* USE_LIBXML */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2902" title="utils/adt/xml.c:2902">xmldata_root_element_start</a>(StringInfo result, <span class="Type">const</span> <span class="Type">char</span> *eltname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *xmlschema, <span class="Type">const</span> <span class="Type">char</span> *targetns,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> top_level);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2929" title="utils/adt/xml.c:2929">xmldata_root_element_end</a>(StringInfo result, <span class="Type">const</span> <span class="Type">char</span> *eltname);<br/></li>
<li><span class="Type">static</span> StringInfo <a href="#L2936" title="utils/adt/xml.c:2936">query_to_xml_internal</a>(<span class="Type">const</span> <span class="Type">char</span> *query, <span class="Type">char</span> *tablename,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *xmlschema, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nulls, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> tableforest,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *targetns, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> top_level);<br/></li>
<li><span class="Type">static</span> <span class="Type">const</span> <span class="Type">char</span> *<a href="#L3451" title="utils/adt/xml.c:3451">map_sql_table_to_xmlschema</a>(TupleDesc tupdesc, Oid relid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nulls, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> tableforest, <span class="Type">const</span> <span class="Type">char</span> *targetns);<br/></li>
<li><span class="Type">static</span> <span class="Type">const</span> <span class="Type">char</span> *<a href="#L3556" title="utils/adt/xml.c:3556">map_sql_schema_to_xmlschema_types</a>(Oid nspid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *relid_list, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nulls,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> tableforest, <span class="Type">const</span> <span class="Type">char</span> *targetns);<br/></li>
<li><span class="Type">static</span> <span class="Type">const</span> <span class="Type">char</span> *<a href="#L3629" title="utils/adt/xml.c:3629">map_sql_catalog_to_xmlschema_types</a>(List *nspid_list,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nulls, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> tableforest,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *targetns);<br/></li>
<li><span class="Type">static</span> <span class="Type">const</span> <span class="Type">char</span> *<a href="#L3686" title="utils/adt/xml.c:3686">map_sql_type_to_xml_name</a>(Oid typeoid, <span class="Type">int</span> typmod);<br/></li>
<li><span class="Type">static</span> <span class="Type">const</span> <span class="Type">char</span> *<a href="#L3791" title="utils/adt/xml.c:3791">map_sql_typecoll_to_xmlschema_types</a>(List *tupdesc_list);<br/></li>
<li><span class="Type">static</span> <span class="Type">const</span> <span class="Type">char</span> *<a href="#L3846" title="utils/adt/xml.c:3846">map_sql_type_to_xmlschema_type</a>(Oid typeoid, <span class="Type">int</span> typmod);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4021" title="utils/adt/xml.c:4021">SPI_sql_row_to_xmlelement</a>(uint64 rownum, StringInfo result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span> *tablename, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nulls, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> tableforest,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *targetns, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> top_level);<br/></li>
<li><br/></li>
<li><span class="Comment">/* XMLTABLE support */<br/></li>
<li></span><span class="PreProc">#ifdef USE_LIBXML<br/></li>
<li></span><span class="Comment">/* random number to identify XmlTableContext */<br/></li>
<li><a id="L195">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">XMLTABLE_CONTEXT_MAGIC</span>&nbsp; &nbsp; </span><span class="Constant">46922182<br/></li>
<li><a id="L196">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">XmlTableBuilderData</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; magic;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; natts;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span> <span class="Type">int</span>&nbsp; &nbsp; row_count;<br/></li>
<li>&nbsp; &nbsp; <a href="#L117" title="utils/adt/xml.c:117">PgXmlErrorContext</a> *xmlerrcxt;<br/></li>
<li>&nbsp; &nbsp; xmlParserCtxtPtr ctxt;<br/></li>
<li>&nbsp; &nbsp; xmlDocPtr&nbsp; &nbsp; doc;<br/></li>
<li>&nbsp; &nbsp; xmlXPathContextPtr xpathcxt;<br/></li>
<li>&nbsp; &nbsp; xmlXPathCompExprPtr xpathcomp;<br/></li>
<li>&nbsp; &nbsp; xmlXPathObjectPtr xpathobj;<br/></li>
<li>&nbsp; &nbsp; xmlXPathCompExprPtr *xpathscomp;<br/></li>
<li><a id="L208">&#x200c;</a>} <span class="linkable">XmlTableBuilderData</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4613" title="utils/adt/xml.c:4613">XmlTableInitOpaque</a>(<span class="Type">struct</span> TableFuncScanState *state, <span class="Type">int</span> natts);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4661" title="utils/adt/xml.c:4661">XmlTableSetDocument</a>(<span class="Type">struct</span> TableFuncScanState *state, Datum value);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4718" title="utils/adt/xml.c:4718">XmlTableSetNamespace</a>(<span class="Type">struct</span> TableFuncScanState *state, <span class="Type">const</span> <span class="Type">char</span> *name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *uri);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4744" title="utils/adt/xml.c:4744">XmlTableSetRowFilter</a>(<span class="Type">struct</span> TableFuncScanState *state, <span class="Type">const</span> <span class="Type">char</span> *path);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4773" title="utils/adt/xml.c:4773">XmlTableSetColumnFilter</a>(<span class="Type">struct</span> TableFuncScanState *state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *path, <span class="Type">int</span> colnum);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L4805" title="utils/adt/xml.c:4805">XmlTableFetchRow</a>(<span class="Type">struct</span> TableFuncScanState *state);<br/></li>
<li><span class="Type">static</span> Datum <a href="#L4850" title="utils/adt/xml.c:4850">XmlTableGetValue</a>(<span class="Type">struct</span> TableFuncScanState *state, <span class="Type">int</span> colnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid typid, int32 typmod, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L5002" title="utils/adt/xml.c:5002">XmlTableDestroyOpaque</a>(<span class="Type">struct</span> TableFuncScanState *state);<br/></li>
<li><br/></li>
<li><a id="L223">&#x200c;</a><span class="Type">const</span> TableFuncRoutine <span class="linkable">XmlTableRoutine</span> =<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; .InitOpaque = <a href="#L4613" title="utils/adt/xml.c:4613">XmlTableInitOpaque</a>,<br/></li>
<li>&nbsp; &nbsp; .SetDocument = <a href="#L4661" title="utils/adt/xml.c:4661">XmlTableSetDocument</a>,<br/></li>
<li>&nbsp; &nbsp; .SetNamespace = <a href="#L4718" title="utils/adt/xml.c:4718">XmlTableSetNamespace</a>,<br/></li>
<li>&nbsp; &nbsp; .SetRowFilter = <a href="#L4744" title="utils/adt/xml.c:4744">XmlTableSetRowFilter</a>,<br/></li>
<li>&nbsp; &nbsp; .SetColumnFilter = <a href="#L4773" title="utils/adt/xml.c:4773">XmlTableSetColumnFilter</a>,<br/></li>
<li>&nbsp; &nbsp; .FetchRow = <a href="#L4805" title="utils/adt/xml.c:4805">XmlTableFetchRow</a>,<br/></li>
<li>&nbsp; &nbsp; .GetValue = <a href="#L4850" title="utils/adt/xml.c:4850">XmlTableGetValue</a>,<br/></li>
<li>&nbsp; &nbsp; .DestroyOpaque = <a href="#L5002" title="utils/adt/xml.c:5002">XmlTableDestroyOpaque</a><br/></li>
<li>};<br/></li>
<li><br/></li>
<li><a id="L235">&#x200c;</a><span class="PreProc">#define <span class="linkable">NO_XML_SUPPORT</span>() \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ereport(ERROR, \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(</span><span class="Constant">&quot;unsupported XML feature&quot;</span><span class="PreProc">), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(</span><span class="Constant">&quot;This functionality requires the server to be built with libxml support.&quot;</span><span class="PreProc">)))<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* from SQL/XML:2008 section 4.9 */<br/></li>
<li><a id="L243">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NAMESPACE_XSD</span> </span><span class="Constant">&quot;http://www.w3.org/2001/XMLSchema&quot;<br/></li>
<li><a id="L244">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NAMESPACE_XSI</span> </span><span class="Constant">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br/></li>
<li><a id="L245">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NAMESPACE_SQLXML</span> </span><span class="Constant">&quot;http://standards.iso.org/iso/9075/2003/sqlxml&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_LIBXML<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L251">&#x200c;</a></span><span class="linkable">xmlChar_to_encoding</span>(<span class="Type">const</span> xmlChar *encoding_name)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; encoding = pg_char_to_encoding((<span class="Type">const</span> <span class="Type">char</span> *) encoding_name);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (encoding &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid encoding name </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">const</span> <span class="Type">char</span> *) encoding_name)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> encoding;<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L273" title="utils/adt/xml.c:273">xml_in</a> uses a plain C string to VARDATA conversion, so for the time being<br/></li>
<li></span><span class="Comment"> * we use the conversion function for the text datatype.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is only acceptable so long as xmltype and text use the same<br/></li>
<li></span><span class="Comment"> * representation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L273">&#x200c;</a><span class="linkable">xml_in</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef USE_LIBXML<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *s = PG_GETARG_CSTRING(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; xmltype&nbsp; &nbsp; *vardata;<br/></li>
<li>&nbsp; &nbsp; xmlDocPtr&nbsp; &nbsp; doc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Build the result object. */<br/></li>
<li></span>&nbsp; &nbsp; vardata = (xmltype *) <a href="varlena.c.html#L184" title="utils/adt/varlena.c:184">cstring_to_text</a>(s);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Parse the data to check if it is well-formed XML data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: we don't need to worry about whether a soft error is detected.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; doc = <a href="#L1715" title="utils/adt/xml.c:1715">xml_parse</a>(vardata, <a href="#L110" title="utils/adt/xml.c:110">xmloption</a>, <span class="Constant">true</span>, <a href="../mb/mbutils.c.html#L1261" title="utils/mb/mbutils.c:1261">GetDatabaseEncoding</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">NULL</span>, fcinfo-&gt;context);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (doc != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xmlFreeDoc(doc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_XML_P(vardata);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L235" title="utils/adt/xml.c:235">NO_XML_SUPPORT</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L301">&#x200c;</a><span class="PreProc">#define <span class="linkable">PG_XML_DEFAULT_VERSION</span> </span><span class="Constant">&quot;1.0&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L312" title="utils/adt/xml.c:312">xml_out_internal</a> uses a plain VARDATA to C string conversion, so for the<br/></li>
<li></span><span class="Comment"> * time being we use the conversion function for the text datatype.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is only acceptable so long as xmltype and text use the same<br/></li>
<li></span><span class="Comment"> * representation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L312">&#x200c;</a><span class="linkable">xml_out_internal</span>(xmltype *x, pg_enc target_encoding)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *str = <a href="varlena.c.html#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>((text *) x);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_LIBXML<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; len = strlen(str);<br/></li>
<li>&nbsp; &nbsp; xmlChar&nbsp; &nbsp; *version;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; standalone;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res_code;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((res_code = <a href="#L1400" title="utils/adt/xml.c:1400">parse_xml_decl</a>((xmlChar *) str,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;len, &amp;version, <span class="Constant">NULL</span>, &amp;standalone)) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; StringInfoData buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; initStringInfo(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L1573" title="utils/adt/xml.c:1573">print_xml_decl</a>(&amp;buf, version, target_encoding, standalone))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we are not going to produce an XML declaration, eat a single<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_lex.c.html#L1010" title="regex/regc_lex.c:1010">newline</a> in the original string to prevent empty first lines in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the output.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*(str + len) == <span class="Special">'\n'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len += <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;buf, str + len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(str);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> buf.data;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INTERNAL_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;could not <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> XML declaration in stored value&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2211" title="utils/adt/xml.c:2211">errdetail_for_xml_code</a>(res_code));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> str;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L356">&#x200c;</a><span class="linkable">xml_out</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; xmltype&nbsp; &nbsp; *x = PG_GETARG_XML_P(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L356" title="utils/adt/xml.c:356">xml_out</a> removes the encoding property in all cases.&nbsp; This is because we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cannot control from here whether the datum will be converted to a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * different client encoding, so we'd do more harm than good by including<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; PG_RETURN_CSTRING(<a href="#L312" title="utils/adt/xml.c:312">xml_out_internal</a>(x, <span class="Constant">0</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L371">&#x200c;</a><span class="linkable">xml_recv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef USE_LIBXML<br/></li>
<li></span>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; buf = (StringInfo) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; xmltype&nbsp; &nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *str;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *newstr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbytes;<br/></li>
<li>&nbsp; &nbsp; xmlDocPtr&nbsp; &nbsp; doc;<br/></li>
<li>&nbsp; &nbsp; xmlChar&nbsp; &nbsp; *encodingStr = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; encoding;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Read the data in raw format. We don't know yet what the encoding is, as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that information is embedded in the xml declaration; so we have to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> that <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> converting to server encoding.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; nbytes = buf-&gt;len - buf-&gt;cursor;<br/></li>
<li>&nbsp; &nbsp; str = (<span class="Type">char</span> *) <a href="../../libpq/pqformat.c.html#L508" title="libpq/pqformat.c:508">pq_getmsgbytes</a>(buf, nbytes);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need a null-terminated string to pass to <a href="#L1400" title="utils/adt/xml.c:1400">parse_xml_decl</a>().&nbsp; Rather<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * than make a separate copy, make the temporary result one byte bigger<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * than it needs to be.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; result = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(nbytes + <span class="Constant">1</span> + VARHDRSZ);<br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(result, nbytes + VARHDRSZ);<br/></li>
<li>&nbsp; &nbsp; memcpy(VARDATA(result), str, nbytes);<br/></li>
<li>&nbsp; &nbsp; str = VARDATA(result);<br/></li>
<li>&nbsp; &nbsp; str[nbytes] = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1400" title="utils/adt/xml.c:1400">parse_xml_decl</a>((<span class="Type">const</span> xmlChar *) str, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>, &amp;encodingStr, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If encoding wasn't explicitly specified in the XML header, treat it as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * UTF-8, as that's the default in XML. This is different from <a href="#L273" title="utils/adt/xml.c:273">xml_in</a>(),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * where the input has to go through the normal client to server encoding<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * conversion.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; encoding = encodingStr ? <a href="#L251" title="utils/adt/xml.c:251">xmlChar_to_encoding</a>(encodingStr) : PG_UTF8;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Parse the data to check if it is well-formed XML data.&nbsp; Assume that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L1715" title="utils/adt/xml.c:1715">xml_parse</a> will throw ERROR if not.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; doc = <a href="#L1715" title="utils/adt/xml.c:1715">xml_parse</a>(result, <a href="#L110" title="utils/adt/xml.c:110">xmloption</a>, <span class="Constant">true</span>, encoding, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; xmlFreeDoc(doc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now that we know what we're dealing with, convert to server encoding */<br/></li>
<li></span>&nbsp; &nbsp; newstr = <a href="../mb/mbutils.c.html#L676" title="utils/mb/mbutils.c:676">pg_any_to_server</a>(str, nbytes, encoding);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newstr != str)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = (xmltype *) <a href="varlena.c.html#L184" title="utils/adt/varlena.c:184">cstring_to_text</a>(newstr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(newstr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_XML_P(result);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L235" title="utils/adt/xml.c:235">NO_XML_SUPPORT</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L438">&#x200c;</a><span class="linkable">xml_send</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; xmltype&nbsp; &nbsp; *x = PG_GETARG_XML_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *outval;<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L312" title="utils/adt/xml.c:312">xml_out_internal</a> doesn't convert the encoding, it just prints the right<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * declaration. <a href="../../libpq/pqformat.c.html#L172" title="libpq/pqformat.c:172">pq_sendtext</a> will do the conversion.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; outval = <a href="#L312" title="utils/adt/xml.c:312">xml_out_internal</a>(x, <a href="../mb/mbutils.c.html#L336" title="utils/mb/mbutils.c:336">pg_get_client_encoding</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L326" title="libpq/pqformat.c:326">pq_begintypsend</a>(&amp;buf);<br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L172" title="libpq/pqformat.c:172">pq_sendtext</a>(&amp;buf, outval, strlen(outval));<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(outval);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BYTEA_P(<a href="../../libpq/pqformat.c.html#L346" title="libpq/pqformat.c:346">pq_endtypsend</a>(&amp;buf));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_LIBXML<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L459">&#x200c;</a></span><span class="linkable">appendStringInfoText</span>(StringInfo str, <span class="Type">const</span> text *t)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; appendBinaryStringInfo(str, VARDATA_ANY(t), VARSIZE_ANY_EXHDR(t));<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Type">static</span> xmltype *<br/></li>
<li><a id="L467">&#x200c;</a><span class="linkable">stringinfo_to_xmltype</span>(StringInfo buf)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (xmltype *) <a href="varlena.c.html#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(buf-&gt;data, buf-&gt;len);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">static</span> xmltype *<br/></li>
<li><a id="L474">&#x200c;</a><span class="linkable">cstring_to_xmltype</span>(<span class="Type">const</span> <span class="Type">char</span> *string)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (xmltype *) <a href="varlena.c.html#L184" title="utils/adt/varlena.c:184">cstring_to_text</a>(string);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_LIBXML<br/></li>
<li></span><span class="Type">static</span> xmltype *<br/></li>
<li><a id="L482">&#x200c;</a><span class="linkable">xmlBuffer_to_xmltype</span>(xmlBufferPtr buf)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (xmltype *) <a href="varlena.c.html#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>((<span class="Type">const</span> <span class="Type">char</span> *) xmlBufferContent(buf),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmlBufferLength(buf));<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L491">&#x200c;</a><span class="linkable">xmlcomment</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef USE_LIBXML<br/></li>
<li></span>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *arg = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *argdata = VARDATA_ANY(arg);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len = VARSIZE_ANY_EXHDR(arg);<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check for &quot;--&quot; in string or &quot;-&quot; at the end */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt; len; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (argdata[i] == <span class="Constant">'-'</span> &amp;&amp; argdata[i - <span class="Constant">1</span>] == <span class="Constant">'-'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_XML_COMMENT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid XML comment&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (len &gt; <span class="Constant">0</span> &amp;&amp; argdata[len - <span class="Constant">1</span>] == <span class="Constant">'-'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_XML_COMMENT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid XML comment&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;buf);<br/></li>
<li>&nbsp; &nbsp; appendStringInfoString(&amp;buf, <span class="Constant">&quot;&lt;!--&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L459" title="utils/adt/xml.c:459">appendStringInfoText</a>(&amp;buf, arg);<br/></li>
<li>&nbsp; &nbsp; appendStringInfoString(&amp;buf, <span class="Constant">&quot;--&gt;&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_XML_P(<a href="#L467" title="utils/adt/xml.c:467">stringinfo_to_xmltype</a>(&amp;buf));<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L235" title="utils/adt/xml.c:235">NO_XML_SUPPORT</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L527">&#x200c;</a><span class="linkable">xmltext</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef USE_LIBXML<br/></li>
<li></span>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *arg = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; xmlChar&nbsp; &nbsp; *xmlbuf = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xmlbuf = xmlEncodeSpecialChars(<span class="Constant">NULL</span>, <a href="#L1881" title="utils/adt/xml.c:1881">xml_text2xmlChar</a>(arg));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(xmlbuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="varlena.c.html#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>((<span class="Type">const</span> <span class="Type">char</span> *) xmlbuf, xmlStrlen(xmlbuf));<br/></li>
<li>&nbsp; &nbsp; xmlFree(xmlbuf);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_XML_P(result);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L235" title="utils/adt/xml.c:235">NO_XML_SUPPORT</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not USE_LIBXML */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">TODO</span><span class="Comment">: <a href="#L553" title="utils/adt/xml.c:553">xmlconcat</a> needs to <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> the notations and unparsed entities<br/></li>
<li></span><span class="Comment"> * of the argument <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.&nbsp; Not very important in practice, though.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>xmltype *<br/></li>
<li><a id="L553">&#x200c;</a><span class="linkable">xmlconcat</span>(List *args)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef USE_LIBXML<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; global_standalone = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; xmlChar&nbsp; &nbsp; *global_version = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; global_version_no_value = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *v;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;buf);<br/></li>
<li>&nbsp; &nbsp; foreach(v, args)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xmltype&nbsp; &nbsp; *x = DatumGetXmlP(PointerGetDatum(lfirst(v)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xmlChar&nbsp; &nbsp; *version;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; standalone;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *str;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len = VARSIZE(x) - VARHDRSZ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; str = <a href="varlena.c.html#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>((text *) x);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1400" title="utils/adt/xml.c:1400">parse_xml_decl</a>((xmlChar *) str, &amp;len, &amp;version, <span class="Constant">NULL</span>, &amp;standalone);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (standalone == <span class="Constant">0</span> &amp;&amp; global_standalone == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; global_standalone = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (standalone &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; global_standalone = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!version)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; global_version_no_value = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!global_version)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; global_version = version;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (xmlStrcmp(version, global_version) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; global_version_no_value = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;buf, str + len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(str);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!global_version_no_value || global_standalone &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; StringInfoData buf2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; initStringInfo(&amp;buf2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1573" title="utils/adt/xml.c:1573">print_xml_decl</a>(&amp;buf2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (!global_version_no_value) ? global_version : <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; global_standalone);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendBinaryStringInfo(&amp;buf2, buf.data, buf.len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf = buf2;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L467" title="utils/adt/xml.c:467">stringinfo_to_xmltype</a>(&amp;buf);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L235" title="utils/adt/xml.c:235">NO_XML_SUPPORT</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * XMLAGG support<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L619">&#x200c;</a><span class="linkable">xmlconcat2</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PG_ARGISNULL(<span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PG_ARGISNULL(<span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_XML_P(PG_GETARG_XML_P(<span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (PG_ARGISNULL(<span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_XML_P(PG_GETARG_XML_P(<span class="Constant">0</span>));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_XML_P(<a href="#L553" title="utils/adt/xml.c:553">xmlconcat</a>(list_make2(PG_GETARG_XML_P(<span class="Constant">0</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PG_GETARG_XML_P(<span class="Constant">1</span>))));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L637">&#x200c;</a><span class="linkable">texttoxml</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *data = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_XML_P(<a href="#L960" title="utils/adt/xml.c:960">xmlparse</a>(data, <a href="#L110" title="utils/adt/xml.c:110">xmloption</a>, <span class="Constant">true</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L646">&#x200c;</a><span class="linkable">xmltotext</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; xmltype&nbsp; &nbsp; *data = PG_GETARG_XML_P(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* It's actually binary compatible. */<br/></li>
<li></span>&nbsp; &nbsp; PG_RETURN_TEXT_P((text *) data);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>text *<br/></li>
<li><a id="L656">&#x200c;</a><span class="linkable">xmltotext_with_options</span>(xmltype *data, XmlOptionType xmloption_arg, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> indent)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef USE_LIBXML<br/></li>
<li></span>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *<span class="Type">volatile</span> result;<br/></li>
<li>&nbsp; &nbsp; xmlDocPtr&nbsp; &nbsp; doc;<br/></li>
<li>&nbsp; &nbsp; XmlOptionType parsed_xmloptiontype;<br/></li>
<li>&nbsp; &nbsp; xmlNodePtr&nbsp; &nbsp; content_nodes;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">volatile</span> xmlBufferPtr buf = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">volatile</span> xmlSaveCtxtPtr ctxt = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; ErrorSaveContext escontext = {T_ErrorSaveContext};<br/></li>
<li>&nbsp; &nbsp; <a href="#L117" title="utils/adt/xml.c:117">PgXmlErrorContext</a> *xmlerrcxt;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xmloption_arg != XMLOPTION_DOCUMENT &amp;&amp; !indent)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't actually need to do anything, so just return the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * binary-compatible input.&nbsp; For backwards-compatibility reasons,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * allow such cases to succeed even without USE_LIBXML.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (text *) data;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_LIBXML<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Parse the input according to the <a href="#L110" title="utils/adt/xml.c:110">xmloption</a> */<br/></li>
<li></span>&nbsp; &nbsp; doc = <a href="#L1715" title="utils/adt/xml.c:1715">xml_parse</a>(data, xmloption_arg, <span class="Constant">true</span>, <a href="../mb/mbutils.c.html#L1261" title="utils/mb/mbutils.c:1261">GetDatabaseEncoding</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;parsed_xmloptiontype, &amp;content_nodes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Node *) &amp;escontext);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (doc == <span class="Constant">NULL</span> || escontext.error_occurred)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (doc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmlFreeDoc(doc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* A soft error must be failure to conform to XMLOPTION_DOCUMENT */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NOT_AN_XML_DOCUMENT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;not an XML document&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we weren't asked to indent, we're done. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!indent)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xmlFreeDoc(doc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (text *) data;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Otherwise, we gotta spin up some error handling. */<br/></li>
<li></span>&nbsp; &nbsp; xmlerrcxt = <a href="#L1178" title="utils/adt/xml.c:1178">pg_xml_init</a>(PG_XML_STRICTNESS_ALL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_TRY();<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; decl_len = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The serialized data will go into this buffer. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; buf = xmlBufferCreate();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (buf == <span class="Constant">NULL</span> || xmlerrcxt-&gt;err_occurred)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1970" title="utils/adt/xml.c:1970">xml_ereport</a>(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;could not allocate xmlBuffer&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Detect whether there's an XML declaration */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1400" title="utils/adt/xml.c:1400">parse_xml_decl</a>(<a href="#L1881" title="utils/adt/xml.c:1881">xml_text2xmlChar</a>(data), &amp;decl_len, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Emit declaration only if the input had one.&nbsp; Note: some versions of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * xmlSaveToBuffer leak memory if a non-null encoding argument is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * passed, so don't do that.&nbsp; We don't want <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> encoding conversion<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (decl_len == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ctxt = xmlSaveToBuffer(buf, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XML_SAVE_NO_DECL | XML_SAVE_FORMAT);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ctxt = xmlSaveToBuffer(buf, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XML_SAVE_FORMAT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ctxt == <span class="Constant">NULL</span> || xmlerrcxt-&gt;err_occurred)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1970" title="utils/adt/xml.c:1970">xml_ereport</a>(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;could not allocate xmlSaveCtxt&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (parsed_xmloptiontype == XMLOPTION_DOCUMENT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If it's a document, saving is easy. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xmlSaveDoc(ctxt, doc) == -<span class="Constant">1</span> || xmlerrcxt-&gt;err_occurred)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1970" title="utils/adt/xml.c:1970">xml_ereport</a>(xmlerrcxt, ERROR, ERRCODE_INTERNAL_ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;could not save document to xmlBuffer&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (content_nodes != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Deal with the case where we have non-singly-rooted XML.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * libxml's <a href="../../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a> <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> don't work well for that without <a href="../../main/main.c.html#L320" title="main/main.c:320">help</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We build a fake root node that serves as a container for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * content nodes, and then iterate over the nodes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmlNodePtr&nbsp; &nbsp; root;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmlNodePtr&nbsp; &nbsp; <a href="../../regex/regc_lex.c.html#L1010" title="regex/regc_lex.c:1010">newline</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root = xmlNewNode(<span class="Constant">NULL</span>, (<span class="Type">const</span> xmlChar *) <span class="Constant">&quot;content-root&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (root == <span class="Constant">NULL</span> || xmlerrcxt-&gt;err_occurred)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1970" title="utils/adt/xml.c:1970">xml_ereport</a>(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;could not allocate xml node&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This attaches root to doc, so we need not free it separately. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmlDocSetRootElement(doc, root);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmlAddChild(root, content_nodes);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We use this node to insert newlines in the <a href="../../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a>.&nbsp; Note: in at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * least some libxml versions, xmlNewDocText would not attach the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * node to the document even if we passed it.&nbsp; Therefore, manage<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * freeing of this node manually, and pass NULL here to make sure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there's not a dangling link.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_lex.c.html#L1010" title="regex/regc_lex.c:1010">newline</a> = xmlNewDocText(<span class="Constant">NULL</span>, (<span class="Type">const</span> xmlChar *) <span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regc_lex.c.html#L1010" title="regex/regc_lex.c:1010">newline</a> == <span class="Constant">NULL</span> || xmlerrcxt-&gt;err_occurred)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1970" title="utils/adt/xml.c:1970">xml_ereport</a>(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;could not allocate xml node&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (xmlNodePtr node = root-&gt;children; node; node = node-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* insert newlines between nodes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;type != XML_TEXT_NODE &amp;&amp; node-&gt;prev != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xmlSaveTree(ctxt, <a href="../../regex/regc_lex.c.html#L1010" title="regex/regc_lex.c:1010">newline</a>) == -<span class="Constant">1</span> || xmlerrcxt-&gt;err_occurred)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmlFreeNode(<a href="../../regex/regc_lex.c.html#L1010" title="regex/regc_lex.c:1010">newline</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1970" title="utils/adt/xml.c:1970">xml_ereport</a>(xmlerrcxt, ERROR, ERRCODE_INTERNAL_ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;could not save <a href="../../regex/regc_lex.c.html#L1010" title="regex/regc_lex.c:1010">newline</a> to xmlBuffer&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xmlSaveTree(ctxt, node) == -<span class="Constant">1</span> || xmlerrcxt-&gt;err_occurred)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmlFreeNode(<a href="../../regex/regc_lex.c.html#L1010" title="regex/regc_lex.c:1010">newline</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1970" title="utils/adt/xml.c:1970">xml_ereport</a>(xmlerrcxt, ERROR, ERRCODE_INTERNAL_ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;could not save content to xmlBuffer&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmlFreeNode(<a href="../../regex/regc_lex.c.html#L1010" title="regex/regc_lex.c:1010">newline</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xmlSaveClose(ctxt) == -<span class="Constant">1</span> || xmlerrcxt-&gt;err_occurred)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ctxt = <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* don't try to close it again */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1970" title="utils/adt/xml.c:1970">xml_ereport</a>(xmlerrcxt, ERROR, ERRCODE_INTERNAL_ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;could not close xmlSaveCtxtPtr&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = (text *) <a href="#L482" title="utils/adt/xml.c:482">xmlBuffer_to_xmltype</a>(buf);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_CATCH();<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ctxt)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmlSaveClose(ctxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (buf)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmlBufferFree(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (doc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmlFreeDoc(doc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1259" title="utils/adt/xml.c:1259">pg_xml_done</a>(xmlerrcxt, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RE_THROW();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_END_TRY();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xmlBufferFree(buf);<br/></li>
<li>&nbsp; &nbsp; xmlFreeDoc(doc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1259" title="utils/adt/xml.c:1259">pg_xml_done</a>(xmlerrcxt, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L235" title="utils/adt/xml.c:235">NO_XML_SUPPORT</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>xmltype *<br/></li>
<li><a id="L836">&#x200c;</a><span class="linkable">xmlelement</span>(XmlExpr *xexpr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum *named_argvalue, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *named_argnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum *argvalue, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *argnull)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef USE_LIBXML<br/></li>
<li></span>&nbsp; &nbsp; xmltype&nbsp; &nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *named_arg_strings;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *arg_strings;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *arg;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *narg;<br/></li>
<li>&nbsp; &nbsp; <a href="#L117" title="utils/adt/xml.c:117">PgXmlErrorContext</a> *xmlerrcxt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">volatile</span> xmlBufferPtr buf = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">volatile</span> xmlTextWriterPtr writer = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * All arguments are already evaluated, and their <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are passed in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * named_argvalue/named_argnull or argvalue/argnull arrays.&nbsp; This avoids<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * issues if one of the arguments involves a call to some other function<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * or subsystem that wants to use libxml on its own terms.&nbsp; We examine the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * original XmlExpr to identify the numbers and types of the arguments.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; named_arg_strings = NIL;<br/></li>
<li>&nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(arg, xexpr-&gt;named_args)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *e = (Expr *) lfirst(arg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *str;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (named_argnull[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = <a href="#L2413" title="utils/adt/xml.c:2413">map_sql_value_to_xml_value</a>(named_argvalue[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>((Node *) e),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; named_arg_strings = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(named_arg_strings, str);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; arg_strings = NIL;<br/></li>
<li>&nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(arg, xexpr-&gt;args)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *e = (Expr *) lfirst(arg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *str;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* here we can just forget NULL elements immediately */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!argnull[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = <a href="#L2413" title="utils/adt/xml.c:2413">map_sql_value_to_xml_value</a>(argvalue[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>((Node *) e),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arg_strings = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(arg_strings, str);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xmlerrcxt = <a href="#L1178" title="utils/adt/xml.c:1178">pg_xml_init</a>(PG_XML_STRICTNESS_ALL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_TRY();<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf = xmlBufferCreate();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (buf == <span class="Constant">NULL</span> || xmlerrcxt-&gt;err_occurred)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1970" title="utils/adt/xml.c:1970">xml_ereport</a>(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;could not allocate xmlBuffer&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; writer = xmlNewTextWriterMemory(buf, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (writer == <span class="Constant">NULL</span> || xmlerrcxt-&gt;err_occurred)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1970" title="utils/adt/xml.c:1970">xml_ereport</a>(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;could not allocate xmlTextWriter&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xmlTextWriterStartElement(writer, (xmlChar *) xexpr-&gt;name);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; forboth(arg, named_arg_strings, narg, xexpr-&gt;arg_names)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *str = (<span class="Type">char</span> *) lfirst(arg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *argname = strVal(lfirst(narg));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (str)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmlTextWriterWriteAttribute(writer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (xmlChar *) argname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (xmlChar *) str);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(arg, arg_strings)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *str = (<span class="Type">char</span> *) lfirst(arg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmlTextWriterWriteRaw(writer, (xmlChar *) str);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xmlTextWriterEndElement(writer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we MUST do this <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> to flush data out to the buffer ... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; xmlFreeTextWriter(writer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; writer = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L482" title="utils/adt/xml.c:482">xmlBuffer_to_xmltype</a>(buf);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_CATCH();<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (writer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmlFreeTextWriter(writer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (buf)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmlBufferFree(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1259" title="utils/adt/xml.c:1259">pg_xml_done</a>(xmlerrcxt, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RE_THROW();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_END_TRY();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xmlBufferFree(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1259" title="utils/adt/xml.c:1259">pg_xml_done</a>(xmlerrcxt, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L235" title="utils/adt/xml.c:235">NO_XML_SUPPORT</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>xmltype *<br/></li>
<li><a id="L960">&#x200c;</a><span class="linkable">xmlparse</span>(text *data, XmlOptionType xmloption_arg, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> preserve_whitespace)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef USE_LIBXML<br/></li>
<li></span>&nbsp; &nbsp; xmlDocPtr&nbsp; &nbsp; doc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; doc = <a href="#L1715" title="utils/adt/xml.c:1715">xml_parse</a>(data, xmloption_arg, preserve_whitespace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mb/mbutils.c.html#L1261" title="utils/mb/mbutils.c:1261">GetDatabaseEncoding</a>(), <span class="Constant">NULL</span>, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; xmlFreeDoc(doc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (xmltype *) data;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L235" title="utils/adt/xml.c:235">NO_XML_SUPPORT</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>xmltype *<br/></li>
<li><a id="L978">&#x200c;</a><span class="linkable">xmlpi</span>(<span class="Type">const</span> <span class="Type">char</span> *target, text *arg, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> arg_is_null, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *result_is_null)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef USE_LIBXML<br/></li>
<li></span>&nbsp; &nbsp; xmltype&nbsp; &nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pg_strcasecmp(target, <span class="Constant">&quot;xml&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR), <span class="Comment">/* really */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid XML processing instruction&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;XML processing instruction target name cannot be </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">.&quot;</span>, target)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Following the SQL standard, the null check comes after the syntax check<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * above.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; *result_is_null = arg_is_null;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*result_is_null)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfo(&amp;buf, <span class="Constant">&quot;&lt;?</span><span class="Special">%s</span><span class="Constant">&quot;</span>, target);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (arg != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *string;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; string = <a href="varlena.c.html#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>(arg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strstr(string, <span class="Constant">&quot;?&gt;&quot;</span>) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_XML_PROCESSING_INSTRUCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid XML processing instruction&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;XML processing instruction cannot contain </span><span class="Special">\&quot;</span><span class="Constant">?&gt;</span><span class="Special">\&quot;</span><span class="Constant">.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(&amp;buf, <span class="Constant">' '</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;buf, string + strspn(string, <span class="Constant">&quot; &quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(string);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; appendStringInfoString(&amp;buf, <span class="Constant">&quot;?&gt;&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L467" title="utils/adt/xml.c:467">stringinfo_to_xmltype</a>(&amp;buf);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(buf.data);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L235" title="utils/adt/xml.c:235">NO_XML_SUPPORT</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>xmltype *<br/></li>
<li><a id="L1030">&#x200c;</a><span class="linkable">xmlroot</span>(xmltype *data, text *version, <span class="Type">int</span> standalone)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef USE_LIBXML<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *str;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; xmlChar&nbsp; &nbsp; *orig_version;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; orig_standalone;<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len = VARSIZE(data) - VARHDRSZ;<br/></li>
<li>&nbsp; &nbsp; str = <a href="varlena.c.html#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>((text *) data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1400" title="utils/adt/xml.c:1400">parse_xml_decl</a>((xmlChar *) str, &amp;len, &amp;orig_version, <span class="Constant">NULL</span>, &amp;orig_standalone);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (version)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; orig_version = <a href="#L1881" title="utils/adt/xml.c:1881">xml_text2xmlChar</a>(version);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; orig_version = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (standalone)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XML_STANDALONE_YES:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; orig_standalone = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XML_STANDALONE_NO:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; orig_standalone = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XML_STANDALONE_NO_VALUE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; orig_standalone = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XML_STANDALONE_OMITTED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* leave original value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;buf);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1573" title="utils/adt/xml.c:1573">print_xml_decl</a>(&amp;buf, orig_version, <span class="Constant">0</span>, orig_standalone);<br/></li>
<li>&nbsp; &nbsp; appendStringInfoString(&amp;buf, str + len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L467" title="utils/adt/xml.c:467">stringinfo_to_xmltype</a>(&amp;buf);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L235" title="utils/adt/xml.c:235">NO_XML_SUPPORT</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Validate document (given as string) against DTD (given as external link)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This has been removed because it is a security hole: unprivileged users<br/></li>
<li></span><span class="Comment"> * should not be able to use Postgres to fetch arbitrary external files,<br/></li>
<li></span><span class="Comment"> * which unfortunately is exactly what libxml is willing to do with the DTD<br/></li>
<li></span><span class="Comment"> * parameter.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1086">&#x200c;</a><span class="linkable">xmlvalidate</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;<a href="#L1086" title="utils/adt/xml.c:1086">xmlvalidate</a> is not implemented&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1096">&#x200c;</a></span><span class="linkable">xml_is_document</span>(xmltype *arg)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef USE_LIBXML<br/></li>
<li></span>&nbsp; &nbsp; xmlDocPtr&nbsp; &nbsp; doc;<br/></li>
<li>&nbsp; &nbsp; ErrorSaveContext escontext = {T_ErrorSaveContext};<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We'll report &quot;true&quot; if no soft error is reported by <a href="#L1715" title="utils/adt/xml.c:1715">xml_parse</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; doc = <a href="#L1715" title="utils/adt/xml.c:1715">xml_parse</a>((text *) arg, XMLOPTION_DOCUMENT, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mb/mbutils.c.html#L1261" title="utils/mb/mbutils.c:1261">GetDatabaseEncoding</a>(), <span class="Constant">NULL</span>, <span class="Constant">NULL</span>, (Node *) &amp;escontext);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (doc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xmlFreeDoc(doc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> !escontext.error_occurred;<br/></li>
<li><span class="PreProc">#else</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not USE_LIBXML */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L235" title="utils/adt/xml.c:235">NO_XML_SUPPORT</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not USE_LIBXML */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_LIBXML<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1132" title="utils/adt/xml.c:1132">pg_xml_init_library</a> --- set up for use of libxml<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This should be called by each function that is about to use libxml<br/></li>
<li></span><span class="Comment"> * facilities but doesn't require error handling.&nbsp; It initializes libxml<br/></li>
<li></span><span class="Comment"> * and verifies compatibility with the loaded libxml version.&nbsp; These are<br/></li>
<li></span><span class="Comment"> * once-per-session activities.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">TODO</span><span class="Comment">: xmlChar is utf8-char, make proper tuning (initdb with enc!=utf8 and<br/></li>
<li></span><span class="Comment"> * check)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1132">&#x200c;</a></span><span class="linkable">pg_xml_init_library</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> first_time = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (first_time)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Stuff we need do only once per session */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Currently, we have no pure UTF-8 support for internals -- check if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we can work.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">char</span>) != <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(xmlChar))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> XML library&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;libxml2 has incompatible char type: <a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a>(char)=</span><span class="Special">%zu</span><span class="Constant">, <a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a>(xmlChar)=</span><span class="Special">%zu</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">char</span>), <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(xmlChar))));<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_LIBXMLCONTEXT<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set up libxml's memory allocation our way */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1894" title="utils/adt/xml.c:1894">xml_memory_init</a>();<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check library compatibility */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; LIBXML_TEST_VERSION;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; first_time = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1178" title="utils/adt/xml.c:1178">pg_xml_init</a> --- set up for use of libxml and register an error handler<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This should be called by each function that is about to use libxml<br/></li>
<li></span><span class="Comment"> * facilities and requires error handling.&nbsp; It initializes libxml with<br/></li>
<li></span><span class="Comment"> * <a href="#L1132" title="utils/adt/xml.c:1132">pg_xml_init_library</a>() and establishes our libxml error handler.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * strictness determines which errors are reported and which are ignored.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Calls to this function MUST be followed by a PG_TRY block that guarantees<br/></li>
<li></span><span class="Comment"> * that <a href="#L1259" title="utils/adt/xml.c:1259">pg_xml_done</a>() is called during either normal or error exit.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is exported for use by contrib/xml2, as well as other code that might<br/></li>
<li></span><span class="Comment"> * wish to share use of this module's libxml error handler.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><a href="#L117" title="utils/adt/xml.c:117">PgXmlErrorContext</a> *<br/></li>
<li><a id="L1178">&#x200c;</a><span class="linkable">pg_xml_init</span>(PgXmlStrictness strictness)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L117" title="utils/adt/xml.c:117">PgXmlErrorContext</a> *errcxt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *new_errcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Do one-time setup if needed */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1132" title="utils/adt/xml.c:1132">pg_xml_init_library</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create error handling context structure */<br/></li>
<li></span>&nbsp; &nbsp; errcxt = (<a href="#L117" title="utils/adt/xml.c:117">PgXmlErrorContext</a> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L117" title="utils/adt/xml.c:117">PgXmlErrorContext</a>));<br/></li>
<li>&nbsp; &nbsp; errcxt-&gt;magic = <a href="#L115" title="utils/adt/xml.c:115">ERRCXT_MAGIC</a>;<br/></li>
<li>&nbsp; &nbsp; errcxt-&gt;strictness = strictness;<br/></li>
<li>&nbsp; &nbsp; errcxt-&gt;err_occurred = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;errcxt-&gt;err_buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Save original error handler and install ours. libxml originally didn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * distinguish between the contexts for generic and for structured error<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * handlers.&nbsp; If we're using an old libxml version, we must thus save the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * generic error context, even though we're using a structured error<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * handler.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; errcxt-&gt;saved_errfunc = xmlStructuredError;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef <a href="#L68" title="utils/adt/xml.c:68">HAVE_XMLSTRUCTUREDERRORCONTEXT</a><br/></li>
<li></span>&nbsp; &nbsp; errcxt-&gt;saved_errcxt = xmlStructuredErrorContext;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; errcxt-&gt;saved_errcxt = xmlGenericErrorContext;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; xmlSetStructuredErrorFunc((<span class="Type">void</span> *) errcxt, <a href="#L2036" title="utils/adt/xml.c:2036">xml_errorHandler</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Verify that xmlSetStructuredErrorFunc set the context variable we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * expected it to.&nbsp; If not, the error context pointer we just saved is not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the correct thing to restore, and since that leaves us without a way to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * restore the context in <a href="#L1259" title="utils/adt/xml.c:1259">pg_xml_done</a>, we must fail.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The only known situation in which this test fails is if we compile with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * headers from a libxml2 that doesn't track the structured error context<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * separately (&lt; 2.7.4), but at runtime use a version that does, or vice<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * versa.&nbsp; The libxml2 authors did not treat that change as constituting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * an ABI break, so the LIBXML_TEST_VERSION test in <a href="#L1132" title="utils/adt/xml.c:1132">pg_xml_init_library</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fails to protect us from this.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef <a href="#L68" title="utils/adt/xml.c:68">HAVE_XMLSTRUCTUREDERRORCONTEXT</a><br/></li>
<li></span>&nbsp; &nbsp; new_errcxt = xmlStructuredErrorContext;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; new_errcxt = xmlGenericErrorContext;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (new_errcxt != (<span class="Type">void</span> *) errcxt)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not set up XML error handler&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;This probably indicates that the version of libxml2&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot; being used is not compatible with the libxml2&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot; header files that PostgreSQL was built with.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also, install an entity loader to prevent unwanted fetches of external<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * files and URLs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; errcxt-&gt;saved_entityfunc = xmlGetExternalEntityLoader();<br/></li>
<li>&nbsp; &nbsp; xmlSetExternalEntityLoader(<a href="#L1952" title="utils/adt/xml.c:1952">xmlPgEntityLoader</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> errcxt;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1259" title="utils/adt/xml.c:1259">pg_xml_done</a> --- restore previous libxml error handling<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Resets libxml's global error-handling state to what it was <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment"> * <a href="#L1178" title="utils/adt/xml.c:1178">pg_xml_init</a>() was called.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This routine verifies that all pending errors have been dealt with<br/></li>
<li></span><span class="Comment"> * (in assert-enabled builds, anyway).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1259">&#x200c;</a></span><span class="linkable">pg_xml_done</span>(<a href="#L117" title="utils/adt/xml.c:117">PgXmlErrorContext</a> *errcxt, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isError)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *cur_errcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* An assert seems like enough protection here */<br/></li>
<li></span>&nbsp; &nbsp; Assert(errcxt-&gt;magic == <a href="#L115" title="utils/adt/xml.c:115">ERRCXT_MAGIC</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In a normal exit, there should be no un-handled libxml errors.&nbsp; But we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * shouldn't try to enforce this during error recovery, since the longjmp<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * could have been thrown <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="#L1970" title="utils/adt/xml.c:1970">xml_ereport</a> had a chance to run.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!errcxt-&gt;err_occurred || isError);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check that libxml's global state is correct, warn if not.&nbsp; This is a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * real test and not an Assert because it has a higher probability of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * happening.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef <a href="#L68" title="utils/adt/xml.c:68">HAVE_XMLSTRUCTUREDERRORCONTEXT</a><br/></li>
<li></span>&nbsp; &nbsp; cur_errcxt = xmlStructuredErrorContext;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; cur_errcxt = xmlGenericErrorContext;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cur_errcxt != (<span class="Type">void</span> *) errcxt)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;libxml error handling state is out of sync with xml.c&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Restore the saved handlers */<br/></li>
<li></span>&nbsp; &nbsp; xmlSetStructuredErrorFunc(errcxt-&gt;saved_errcxt, errcxt-&gt;saved_errfunc);<br/></li>
<li>&nbsp; &nbsp; xmlSetExternalEntityLoader(errcxt-&gt;saved_entityfunc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Mark the struct as invalid, just in case somebody somehow manages to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * call <a href="#L2036" title="utils/adt/xml.c:2036">xml_errorHandler</a> or <a href="#L1970" title="utils/adt/xml.c:1970">xml_ereport</a> with it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; errcxt-&gt;magic = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Release memory */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(errcxt-&gt;err_buf.data);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(errcxt);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1307" title="utils/adt/xml.c:1307">pg_xml_error_occurred</a>() --- test the error flag<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1307">&#x200c;</a></span><span class="linkable">pg_xml_error_occurred</span>(<a href="#L117" title="utils/adt/xml.c:117">PgXmlErrorContext</a> *errcxt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> errcxt-&gt;err_occurred;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * SQL/XML allows storing &quot;XML documents&quot; or &quot;XML content&quot;.&nbsp; &quot;XML<br/></li>
<li></span><span class="Comment"> * documents&quot; are specified by the XML specification and are parsed<br/></li>
<li></span><span class="Comment"> * easily by libxml.&nbsp; &quot;XML content&quot; is specified by SQL/XML as the<br/></li>
<li></span><span class="Comment"> * production &quot;XMLDecl? content&quot;.&nbsp; But libxml can only <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> the<br/></li>
<li></span><span class="Comment"> * &quot;content&quot; part, so we have to <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> the XML declaration ourselves<br/></li>
<li></span><span class="Comment"> * to complete this.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><a id="L1322">&#x200c;</a><span class="PreProc">#define <span class="linkable">CHECK_XML_SPACE</span>(p) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">do</span><span class="PreProc"> { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="PreProc"> (!xmlIsBlank_ch(*(p))) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">return</span><span class="PreProc"> XML_ERR_SPACE_REQUIRED; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; } </span><span class="Statement">while</span><span class="PreProc"> (</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><a id="L1328">&#x200c;</a><span class="PreProc">#define <span class="linkable">SKIP_XML_SPACE</span>(p) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">while</span><span class="PreProc"> (xmlIsBlank_ch(*(p))) (p)++<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Letter | Digit | '.' | '-' | '<a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>' | ':' | CombiningChar | Extender */<br/></li>
<li></span><span class="Comment">/* Beware of multiple evaluations of argument! */<br/></li>
<li><a id="L1333">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PG_XMLISNAMECHAR</span>(c) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (xmlIsBaseChar_ch(c) || xmlIsIdeographicQ(c) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || xmlIsDigit_ch(c) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || c == </span><span class="Constant">'.'</span><span class="PreProc"> || c == </span><span class="Constant">'-'</span><span class="PreProc"> || c == </span><span class="Constant">'<a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>'</span><span class="PreProc"> || c == </span><span class="Constant">':'</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || xmlIsCombiningQ(c) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || xmlIsExtender_ch(c))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* <a href="../mmgr/mcxt.c.html#L1706" title="utils/mmgr/mcxt.c:1706">pnstrdup</a>, but deal with xmlChar not char; len is measured in xmlChars */<br/></li>
<li></span><span class="Type">static</span> xmlChar *<br/></li>
<li><a id="L1342">&#x200c;</a><span class="linkable">xml_pnstrdup</span>(<span class="Type">const</span> xmlChar *str, <span class="Type">size_t</span> len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; xmlChar&nbsp; &nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (xmlChar *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>((len + <span class="Constant">1</span>) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(xmlChar));<br/></li>
<li>&nbsp; &nbsp; memcpy(result, str, len * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(xmlChar));<br/></li>
<li>&nbsp; &nbsp; result[len] = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Ditto, except input is char* */<br/></li>
<li></span><span class="Type">static</span> xmlChar *<br/></li>
<li><a id="L1354">&#x200c;</a><span class="linkable">pg_xmlCharStrndup</span>(<span class="Type">const</span> <span class="Type">char</span> *str, <span class="Type">size_t</span> len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; xmlChar&nbsp; &nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (xmlChar *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>((len + <span class="Constant">1</span>) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(xmlChar));<br/></li>
<li>&nbsp; &nbsp; memcpy(result, str, len);<br/></li>
<li>&nbsp; &nbsp; result[len] = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Copy xmlChar string to PostgreSQL-owned memory, freeing the input.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The input xmlChar is freed regardless of success of the copy.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L1371">&#x200c;</a><span class="linkable">xml_pstrdup_and_free</span>(xmlChar *str)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (str)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_TRY();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>((<span class="Type">char</span> *) str);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_FINALLY();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmlFree(str);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_END_TRY();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * str is the null-terminated input string.&nbsp; Remaining arguments are<br/></li>
<li></span><span class="Comment"> * output arguments; each can be NULL if value is not wanted.<br/></li>
<li></span><span class="Comment"> * version and encoding are returned as locally-<a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d strings.<br/></li>
<li></span><span class="Comment"> * Result is 0 if OK, an error code if not.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1400">&#x200c;</a></span><span class="linkable">parse_xml_decl</span>(<span class="Type">const</span> xmlChar *str, <span class="Type">size_t</span> *lenp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xmlChar **version, xmlChar **encoding, <span class="Type">int</span> *standalone)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> xmlChar *p;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> xmlChar *save_p;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; utf8char;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; utf8len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Only <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> libxml.&nbsp; We don't need error handling here, but we do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need to make sure libxml is initialized <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> calling <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.&nbsp; Note that this is safe (and a no-op) if caller has already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * done <a href="#L1178" title="utils/adt/xml.c:1178">pg_xml_init</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1132" title="utils/adt/xml.c:1132">pg_xml_init_library</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize output arguments to &quot;not present&quot; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (version)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *version = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (encoding)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *encoding = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (standalone)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *standalone = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; p = str;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xmlStrncmp(p, (xmlChar *) <span class="Constant">&quot;&lt;?xml&quot;</span>, <span class="Constant">5</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> finished;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> char is a name char, it's a PI like &lt;?xml-stylesheet ...?&gt;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rather than an XMLDecl, so we have done what we came to do and found no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * XMLDecl.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need an input length value for xmlGetUTF8Char, but there's no need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to count the whole document size, so use strnlen not strlen.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; utf8len = strnlen((<span class="Type">const</span> <span class="Type">char</span> *) (p + <span class="Constant">5</span>), MAX_MULTIBYTE_CHAR_LEN);<br/></li>
<li>&nbsp; &nbsp; utf8char = xmlGetUTF8Char(p + <span class="Constant">5</span>, &amp;utf8len);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1333" title="utils/adt/xml.c:1333">PG_XMLISNAMECHAR</a>(utf8char))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> finished;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; p += <span class="Constant">5</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* version */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1322" title="utils/adt/xml.c:1322">CHECK_XML_SPACE</a>(p);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1328" title="utils/adt/xml.c:1328">SKIP_XML_SPACE</a>(p);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xmlStrncmp(p, (xmlChar *) <span class="Constant">&quot;version&quot;</span>, <span class="Constant">7</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> XML_ERR_VERSION_MISSING;<br/></li>
<li>&nbsp; &nbsp; p += <span class="Constant">7</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L1328" title="utils/adt/xml.c:1328">SKIP_XML_SPACE</a>(p);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*p != <span class="Constant">'='</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> XML_ERR_VERSION_MISSING;<br/></li>
<li>&nbsp; &nbsp; p += <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L1328" title="utils/adt/xml.c:1328">SKIP_XML_SPACE</a>(p);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*p == <span class="Special">'\''</span> || *p == <span class="Constant">'&quot;'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> xmlChar *q;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; q = xmlStrchr(p + <span class="Constant">1</span>, *p);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!q)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> XML_ERR_VERSION_MISSING;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (version)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *version = <a href="#L1342" title="utils/adt/xml.c:1342">xml_pnstrdup</a>(p + <span class="Constant">1</span>, q - p - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; p = q + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> XML_ERR_VERSION_MISSING;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* encoding */<br/></li>
<li></span>&nbsp; &nbsp; save_p = p;<br/></li>
<li>&nbsp; &nbsp; <a href="#L1328" title="utils/adt/xml.c:1328">SKIP_XML_SPACE</a>(p);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xmlStrncmp(p, (xmlChar *) <span class="Constant">&quot;encoding&quot;</span>, <span class="Constant">8</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1322" title="utils/adt/xml.c:1322">CHECK_XML_SPACE</a>(save_p);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; p += <span class="Constant">8</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1328" title="utils/adt/xml.c:1328">SKIP_XML_SPACE</a>(p);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*p != <span class="Constant">'='</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> XML_ERR_MISSING_ENCODING;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; p += <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1328" title="utils/adt/xml.c:1328">SKIP_XML_SPACE</a>(p);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*p == <span class="Special">'\''</span> || *p == <span class="Constant">'&quot;'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> xmlChar *q;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; q = xmlStrchr(p + <span class="Constant">1</span>, *p);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!q)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> XML_ERR_MISSING_ENCODING;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (encoding)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *encoding = <a href="#L1342" title="utils/adt/xml.c:1342">xml_pnstrdup</a>(p + <span class="Constant">1</span>, q - p - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p = q + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> XML_ERR_MISSING_ENCODING;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; p = save_p;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* standalone */<br/></li>
<li></span>&nbsp; &nbsp; save_p = p;<br/></li>
<li>&nbsp; &nbsp; <a href="#L1328" title="utils/adt/xml.c:1328">SKIP_XML_SPACE</a>(p);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xmlStrncmp(p, (xmlChar *) <span class="Constant">&quot;standalone&quot;</span>, <span class="Constant">10</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1322" title="utils/adt/xml.c:1322">CHECK_XML_SPACE</a>(save_p);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; p += <span class="Constant">10</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1328" title="utils/adt/xml.c:1328">SKIP_XML_SPACE</a>(p);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*p != <span class="Constant">'='</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> XML_ERR_STANDALONE_VALUE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; p += <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1328" title="utils/adt/xml.c:1328">SKIP_XML_SPACE</a>(p);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xmlStrncmp(p, (xmlChar *) <span class="Constant">&quot;'yes'&quot;</span>, <span class="Constant">5</span>) == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmlStrncmp(p, (xmlChar *) <span class="Constant">&quot;</span><span class="Special">\&quot;</span><span class="Constant">yes</span><span class="Special">\&quot;</span><span class="Constant">&quot;</span>, <span class="Constant">5</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (standalone)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *standalone = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p += <span class="Constant">5</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (xmlStrncmp(p, (xmlChar *) <span class="Constant">&quot;'no'&quot;</span>, <span class="Constant">4</span>) == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xmlStrncmp(p, (xmlChar *) <span class="Constant">&quot;</span><span class="Special">\&quot;</span><span class="Constant">no</span><span class="Special">\&quot;</span><span class="Constant">&quot;</span>, <span class="Constant">4</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (standalone)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *standalone = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p += <span class="Constant">4</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> XML_ERR_STANDALONE_VALUE;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; p = save_p;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1328" title="utils/adt/xml.c:1328">SKIP_XML_SPACE</a>(p);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xmlStrncmp(p, (xmlChar *) <span class="Constant">&quot;?&gt;&quot;</span>, <span class="Constant">2</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> XML_ERR_XMLDECL_NOT_FINISHED;<br/></li>
<li>&nbsp; &nbsp; p += <span class="Constant">2</span>;<br/></li>
<li><br/></li>
<li><span class="Statement">finished</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; len = p - str;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (p = str; p &lt; str + len; p++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*p &gt; <span class="Constant">127</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> XML_ERR_INVALID_CHAR;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lenp)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *lenp = len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> XML_ERR_OK;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write an XML declaration.&nbsp; On output, we adjust the XML declaration<br/></li>
<li></span><span class="Comment"> * as follows.&nbsp; (These rules are the moral equivalent of the clause<br/></li>
<li></span><span class="Comment"> * &quot;Serialization of an XML value&quot; in the SQL standard.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We try to avoid generating an XML declaration if possible.&nbsp; This is<br/></li>
<li></span><span class="Comment"> * so that you don't get trivial things like xml '&lt;foo/&gt;' resulting in<br/></li>
<li></span><span class="Comment"> * '&lt;?xml version=&quot;1.0&quot;?&gt;&lt;foo/&gt;', which would surely be annoying.&nbsp; We<br/></li>
<li></span><span class="Comment"> * must provide a declaration if the standalone property is specified<br/></li>
<li></span><span class="Comment"> * or if we include an encoding declaration.&nbsp; If we have a<br/></li>
<li></span><span class="Comment"> * declaration, we must specify a version (XML requires this).<br/></li>
<li></span><span class="Comment"> * Otherwise we only make a declaration if the version is not &quot;1.0&quot;,<br/></li>
<li></span><span class="Comment"> * which is the default version specified in SQL:2003.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1573">&#x200c;</a></span><span class="linkable">print_xml_decl</span>(StringInfo buf, <span class="Type">const</span> xmlChar *version,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pg_enc encoding, <span class="Type">int</span> standalone)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((version &amp;&amp; strcmp((<span class="Type">const</span> <span class="Type">char</span> *) version, <a href="#L301" title="utils/adt/xml.c:301">PG_XML_DEFAULT_VERSION</a>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; || (encoding &amp;&amp; encoding != PG_UTF8)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; || standalone != -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(buf, <span class="Constant">&quot;&lt;?xml&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (version)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf, <span class="Constant">&quot; version=</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, version);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf, <span class="Constant">&quot; version=</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, <a href="#L301" title="utils/adt/xml.c:301">PG_XML_DEFAULT_VERSION</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (encoding &amp;&amp; encoding != PG_UTF8)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> might be useful to convert this to IANA names (ISO-8859-1<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * instead of LATIN1 etc.); needs field experience<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf, <span class="Constant">&quot; encoding=</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pg_encoding_to_char(encoding));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (standalone == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(buf, <span class="Constant">&quot; standalone=</span><span class="Special">\&quot;</span><span class="Constant">yes</span><span class="Special">\&quot;</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (standalone == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(buf, <span class="Constant">&quot; standalone=</span><span class="Special">\&quot;</span><span class="Constant">no</span><span class="Special">\&quot;</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(buf, <span class="Constant">&quot;?&gt;&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Test whether an input that is to be parsed as CONTENT contains a DTD.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The SQL/XML:2003 definition of CONTENT (&quot;XMLDecl? content&quot;) is not<br/></li>
<li></span><span class="Comment"> * satisfied by a document with a DTD, which is a <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> of a wart, as it means<br/></li>
<li></span><span class="Comment"> * the CONTENT type is not a proper superset of DOCUMENT.&nbsp; SQL/XML:2006 and<br/></li>
<li></span><span class="Comment"> * later fix that, by redefining content with reference to the &quot;more<br/></li>
<li></span><span class="Comment"> * permissive&quot; Document Node of the XQuery/XPath Data Model, such that <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * DOCUMENT value is indeed also a CONTENT value.&nbsp; That definition is more<br/></li>
<li></span><span class="Comment"> * useful, as CONTENT becomes usable for parsing input of unknown form (think<br/></li>
<li></span><span class="Comment"> * pg_restore).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As used below in parse_xml when parsing for CONTENT, libxml does not give<br/></li>
<li></span><span class="Comment"> * us the 2006+ behavior, but only the 2003; it will choke if the input has<br/></li>
<li></span><span class="Comment"> * a DTD.&nbsp; But we can provide the 2006+ definition of CONTENT easily enough,<br/></li>
<li></span><span class="Comment"> * by detecting this case first and simply doing the <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> as DOCUMENT.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A DTD can be found arbitrarily far in, but that would be a contrived case;<br/></li>
<li></span><span class="Comment"> * it will ordinarily start within a few dozen characters.&nbsp; The only things<br/></li>
<li></span><span class="Comment"> * that can precede it are an XMLDecl (here, the caller will have called<br/></li>
<li></span><span class="Comment"> * <a href="#L1400" title="utils/adt/xml.c:1400">parse_xml_decl</a> already), whitespace, comments, and processing instructions.<br/></li>
<li></span><span class="Comment"> * This function need only return true if it sees a valid sequence of such<br/></li>
<li></span><span class="Comment"> * things leading to &lt;!DOCTYPE.&nbsp; It can simply return false in <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other<br/></li>
<li></span><span class="Comment"> * cases, including malformed input; that will mean the input gets parsed as<br/></li>
<li></span><span class="Comment"> * CONTENT as originally planned, with libxml reporting <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> errors.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is only to be called from <a href="#L1715" title="utils/adt/xml.c:1715">xml_parse</a>, when <a href="#L1178" title="utils/adt/xml.c:1178">pg_xml_init</a> has already<br/></li>
<li></span><span class="Comment"> * been called.&nbsp; The input is already in UTF8 encoding.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1639">&#x200c;</a></span><span class="linkable">xml_doctype_in_content</span>(<span class="Type">const</span> xmlChar *str)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> xmlChar *p = str;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> xmlChar *e;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1328" title="utils/adt/xml.c:1328">SKIP_XML_SPACE</a>(p);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*p != <span class="Constant">'&lt;'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; p++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*p == <span class="Constant">'!'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if we see &lt;!DOCTYPE, we can return true */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xmlStrncmp(p, (xmlChar *) <span class="Constant">&quot;DOCTYPE&quot;</span>, <span class="Constant">7</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* otherwise, if it's not a comment, fail */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xmlStrncmp(p, (xmlChar *) <span class="Constant">&quot;--&quot;</span>, <span class="Constant">2</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> end of comment: <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> -- and a &gt; must follow */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p = xmlStrstr(p + <span class="Constant">2</span>, (xmlChar *) <span class="Constant">&quot;--&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!p || p[<span class="Constant">2</span>] != <span class="Constant">'&gt;'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* advance over comment, and keep scanning */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p += <span class="Constant">3</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* otherwise, if it's not a PI &lt;?target something?&gt;, fail */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*p != <span class="Constant">'?'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; p++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> end of PI (the string ?&gt; is forbidden within a PI) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; e = xmlStrstr(p, (xmlChar *) <span class="Constant">&quot;?&gt;&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!e)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* advance over PI, keep scanning */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; p = e + <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert a text object to XML <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> representation<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * data is the source data (must not be toasted!), encoding is its encoding,<br/></li>
<li></span><span class="Comment"> * and xmloption_arg and preserve_whitespace are options for the<br/></li>
<li></span><span class="Comment"> * transformation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If parsed_xmloptiontype isn't NULL, *parsed_xmloptiontype is set to the<br/></li>
<li></span><span class="Comment"> * XmlOptionType actually used to <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> the input (typically the same as<br/></li>
<li></span><span class="Comment"> * xmloption_arg, but a DOCTYPE node in the input can force DOCUMENT mode).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If parsed_nodes isn't NULL and the input is not an XML document, the list<br/></li>
<li></span><span class="Comment"> * of parsed nodes from the xmlParseBalancedChunkMemory call will be returned<br/></li>
<li></span><span class="Comment"> * to *parsed_nodes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Errors normally result in ereport(ERROR), but if escontext is an<br/></li>
<li></span><span class="Comment"> * ErrorSaveContext, then &quot;safe&quot; errors are reported there instead, and the<br/></li>
<li></span><span class="Comment"> * caller must check SOFT_ERROR_OCCURRED() to see whether that happened.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: it is caller's responsibility to xmlFreeDoc() the result,<br/></li>
<li></span><span class="Comment"> * else a permanent memory leak will ensue!&nbsp; But note the result could<br/></li>
<li></span><span class="Comment"> * be NULL after a soft error.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">TODO</span><span class="Comment"> maybe libxml2's xmlreader is better? (do not construct DOM,<br/></li>
<li></span><span class="Comment"> * yet do not use SAX - see xmlreader.c)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> xmlDocPtr<br/></li>
<li><a id="L1715">&#x200c;</a><span class="linkable">xml_parse</span>(text *data, XmlOptionType xmloption_arg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> preserve_whitespace, <span class="Type">int</span> encoding,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XmlOptionType *parsed_xmloptiontype, xmlNodePtr *parsed_nodes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node *escontext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; xmlChar&nbsp; &nbsp; *string;<br/></li>
<li>&nbsp; &nbsp; xmlChar&nbsp; &nbsp; *utf8string;<br/></li>
<li>&nbsp; &nbsp; <a href="#L117" title="utils/adt/xml.c:117">PgXmlErrorContext</a> *xmlerrcxt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">volatile</span> xmlParserCtxtPtr ctxt = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">volatile</span> xmlDocPtr doc = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This step looks annoyingly redundant, but we must do it to have a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * null-terminated string in case encoding conversion isn't required.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; len = VARSIZE_ANY_EXHDR(data);&nbsp; &nbsp; <span class="Comment">/* will be useful later */<br/></li>
<li></span>&nbsp; &nbsp; string = <a href="#L1881" title="utils/adt/xml.c:1881">xml_text2xmlChar</a>(data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the data isn't UTF8, we must <a href="oracle_compat.c.html#L797" title="utils/adt/oracle_compat.c:797">translate</a> <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> giving it to libxml.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> ideally, we'd catch <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> encoding conversion failure and return a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * soft error.&nbsp; However, failure to convert to UTF8 should be pretty darn<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rare, so for <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> this is left undone.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; utf8string = <a href="../mb/mbutils.c.html#L356" title="utils/mb/mbutils.c:356">pg_do_encoding_conversion</a>(string,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; encoding,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PG_UTF8);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Start up libxml and its parser */<br/></li>
<li></span>&nbsp; &nbsp; xmlerrcxt = <a href="#L1178" title="utils/adt/xml.c:1178">pg_xml_init</a>(PG_XML_STRICTNESS_WELLFORMED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Use a TRY block to ensure we clean up correctly */<br/></li>
<li></span>&nbsp; &nbsp; PG_TRY();<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; parse_as_document = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res_code;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xmlChar&nbsp; &nbsp; *version = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; standalone = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Any errors here are reported as hard ereport's */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; xmlInitParser();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ctxt = xmlNewParserCtxt();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ctxt == <span class="Constant">NULL</span> || xmlerrcxt-&gt;err_occurred)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1970" title="utils/adt/xml.c:1970">xml_ereport</a>(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;could not allocate parser context&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Decide whether to <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> as document or content */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xmloption_arg == XMLOPTION_DOCUMENT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parse_as_document = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Parse and <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> over the XML declaration, if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res_code = <a href="#L1400" title="utils/adt/xml.c:1400">parse_xml_decl</a>(utf8string,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;count, &amp;version, <span class="Constant">NULL</span>, &amp;standalone);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (res_code != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errsave(escontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_XML_CONTENT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;invalid XML content: invalid XML declaration&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2211" title="utils/adt/xml.c:2211">errdetail_for_xml_code</a>(res_code));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> fail;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Is there a DOCTYPE <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1639" title="utils/adt/xml.c:1639">xml_doctype_in_content</a>(utf8string + count))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parse_as_document = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> output parameters */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (parsed_xmloptiontype != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *parsed_xmloptiontype = parse_as_document ? XMLOPTION_DOCUMENT :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XMLOPTION_CONTENT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (parsed_nodes != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *parsed_nodes = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (parse_as_document)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note, that here we try to apply DTD defaults<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (XML_PARSE_DTDATTR) according to SQL/XML:2008 GR 10.16.7.d:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * 'Default <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> defined by <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> DTD are applied'. As for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * external DTDs, we try to support them too, (see SQL/XML:2008 GR<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * 10.16.7.e)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; doc = xmlCtxtReadDoc(ctxt, utf8string,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;UTF-8&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XML_PARSE_NOENT | XML_PARSE_DTDATTR<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; | (preserve_whitespace ? <span class="Constant">0</span> : XML_PARSE_NOBLANKS));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (doc == <span class="Constant">NULL</span> || xmlerrcxt-&gt;err_occurred)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Use original option to decide which error code to report */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xmloption_arg == XMLOPTION_DOCUMENT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2007" title="utils/adt/xml.c:2007">xml_errsave</a>(escontext, xmlerrcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ERRCODE_INVALID_XML_DOCUMENT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;invalid XML document&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2007" title="utils/adt/xml.c:2007">xml_errsave</a>(escontext, xmlerrcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ERRCODE_INVALID_XML_CONTENT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;invalid XML content&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> fail;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; doc = xmlNewDoc(version);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (doc == <span class="Constant">NULL</span> || xmlerrcxt-&gt;err_occurred)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1970" title="utils/adt/xml.c:1970">xml_ereport</a>(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;could not allocate XML document&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(doc-&gt;encoding == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; doc-&gt;encoding = xmlStrdup((<span class="Type">const</span> xmlChar *) <span class="Constant">&quot;UTF-8&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (doc-&gt;encoding == <span class="Constant">NULL</span> || xmlerrcxt-&gt;err_occurred)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1970" title="utils/adt/xml.c:1970">xml_ereport</a>(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;could not allocate XML document&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; doc-&gt;standalone = standalone;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* allow empty content */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*(utf8string + count))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res_code = xmlParseBalancedChunkMemory(doc, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; utf8string + count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; parsed_nodes);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (res_code != <span class="Constant">0</span> || xmlerrcxt-&gt;err_occurred)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2007" title="utils/adt/xml.c:2007">xml_errsave</a>(escontext, xmlerrcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ERRCODE_INVALID_XML_CONTENT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;invalid XML content&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> fail;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="Statement">fail</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_CATCH();<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (doc != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmlFreeDoc(doc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ctxt != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmlFreeParserCtxt(ctxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1259" title="utils/adt/xml.c:1259">pg_xml_done</a>(xmlerrcxt, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RE_THROW();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_END_TRY();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xmlFreeParserCtxt(ctxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1259" title="utils/adt/xml.c:1259">pg_xml_done</a>(xmlerrcxt, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> doc;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * xmlChar&lt;-&gt;text conversions<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> xmlChar *<br/></li>
<li><a id="L1881">&#x200c;</a><span class="linkable">xml_text2xmlChar</span>(text *in)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (xmlChar *) <a href="varlena.c.html#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>(in);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_LIBXMLCONTEXT<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Manage the special context used for all libxml allocations (but only<br/></li>
<li></span><span class="Comment"> * in special debug builds; see notes at top of file)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1894">&#x200c;</a></span><span class="linkable">xml_memory_init</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create memory context if not there already */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L143" title="utils/adt/xml.c:143">LibxmlContext</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L143" title="utils/adt/xml.c:143">LibxmlContext</a> = AllocSetContextCreate(<a href="../mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;Libxml context&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Re-establish the callbacks even if already set */<br/></li>
<li></span>&nbsp; &nbsp; xmlMemSetup(<a href="#L1924" title="utils/adt/xml.c:1924">xml_pfree</a>, <a href="#L1910" title="utils/adt/xml.c:1910">xml_palloc</a>, <a href="#L1917" title="utils/adt/xml.c:1917">xml_repalloc</a>, <a href="#L1933" title="utils/adt/xml.c:1933">xml_pstrdup</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Wrappers for memory management <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> *<br/></li>
<li><a id="L1910">&#x200c;</a><span class="linkable">xml_palloc</span>(<span class="Type">size_t</span> size)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(<a href="#L143" title="utils/adt/xml.c:143">LibxmlContext</a>, size);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> *<br/></li>
<li><a id="L1917">&#x200c;</a><span class="linkable">xml_repalloc</span>(<span class="Type">void</span> *ptr, <span class="Type">size_t</span> size)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(ptr, size);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1924">&#x200c;</a></span><span class="linkable">xml_pfree</span>(<span class="Type">void</span> *ptr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* At least some parts of libxml assume xmlFree(NULL) is allowed */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ptr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(ptr);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L1933">&#x200c;</a><span class="linkable">xml_pstrdup</span>(<span class="Type">const</span> <span class="Type">char</span> *string)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../mmgr/mcxt.c.html#L1682" title="utils/mmgr/mcxt.c:1682">MemoryContextStrdup</a>(<a href="#L143" title="utils/adt/xml.c:143">LibxmlContext</a>, string);<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* USE_LIBXMLCONTEXT */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1952" title="utils/adt/xml.c:1952">xmlPgEntityLoader</a> --- entity loader callback function<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Silently prevent <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> external entity URL from being loaded.&nbsp; We don't want<br/></li>
<li></span><span class="Comment"> * to throw an error, so instead make the entity appear to expand to an empty<br/></li>
<li></span><span class="Comment"> * string.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We would prefer to allow loading entities that exist in the system's<br/></li>
<li></span><span class="Comment"> * global XML catalog; but the available libxml2 APIs make that a complex<br/></li>
<li></span><span class="Comment"> * and fragile task.&nbsp; For <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, just shut down all external access.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> xmlParserInputPtr<br/></li>
<li><a id="L1952">&#x200c;</a><span class="linkable">xmlPgEntityLoader</span>(<span class="Type">const</span> <span class="Type">char</span> *URL, <span class="Type">const</span> <span class="Type">char</span> *ID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmlParserCtxtPtr ctxt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> xmlNewStringInputStream(ctxt, (<span class="Type">const</span> xmlChar *) <span class="Constant">&quot;&quot;</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1970" title="utils/adt/xml.c:1970">xml_ereport</a> --- report an XML-related error<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The &quot;msg&quot; is the SQL-level message; some can be adopted from the SQL/XML<br/></li>
<li></span><span class="Comment"> * standard.&nbsp; This function adds libxml's native error message, if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, as<br/></li>
<li></span><span class="Comment"> * detail.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is exported for modules that want to share the core libxml error<br/></li>
<li></span><span class="Comment"> * handler.&nbsp; Note that <a href="#L1178" title="utils/adt/xml.c:1178">pg_xml_init</a>() *must* have been called previously.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1970">&#x200c;</a></span><span class="linkable">xml_ereport</span>(<a href="#L117" title="utils/adt/xml.c:117">PgXmlErrorContext</a> *errcxt, <span class="Type">int</span> level, <span class="Type">int</span> sqlcode, <span class="Type">const</span> <span class="Type">char</span> *msg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *detail;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Defend against someone passing us a bogus context struct */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (errcxt-&gt;magic != <a href="#L115" title="utils/adt/xml.c:115">ERRCXT_MAGIC</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L1970" title="utils/adt/xml.c:1970">xml_ereport</a> called with invalid <a href="#L117" title="utils/adt/xml.c:117">PgXmlErrorContext</a>&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Flag that the current libxml error has been reported */<br/></li>
<li></span>&nbsp; &nbsp; errcxt-&gt;err_occurred = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Include detail only if we have some text from libxml */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (errcxt-&gt;err_buf.len &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; detail = errcxt-&gt;err_buf.data;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; detail = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereport(level,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(sqlcode),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>, msg),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; detail ? <a href="../error/elog.c.html#L1232" title="utils/error/elog.c:1232">errdetail_internal</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>, detail) : <span class="Constant">0</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2007" title="utils/adt/xml.c:2007">xml_errsave</a> --- save an XML-related error<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If escontext is an ErrorSaveContext, error details are saved into it,<br/></li>
<li></span><span class="Comment"> * and control returns normally.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Otherwise, the error is thrown, so that this is equivalent to<br/></li>
<li></span><span class="Comment"> * <a href="#L1970" title="utils/adt/xml.c:1970">xml_ereport</a>() with level == ERROR.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This should be used only for errors that we're sure we do not need<br/></li>
<li></span><span class="Comment"> * a transaction abort to clean up after.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2007">&#x200c;</a></span><span class="linkable">xml_errsave</span>(Node *escontext, <a href="#L117" title="utils/adt/xml.c:117">PgXmlErrorContext</a> *errcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> sqlcode, <span class="Type">const</span> <span class="Type">char</span> *msg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *detail;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Defend against someone passing us a bogus context struct */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (errcxt-&gt;magic != <a href="#L115" title="utils/adt/xml.c:115">ERRCXT_MAGIC</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L2007" title="utils/adt/xml.c:2007">xml_errsave</a> called with invalid <a href="#L117" title="utils/adt/xml.c:117">PgXmlErrorContext</a>&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Flag that the current libxml error has been reported */<br/></li>
<li></span>&nbsp; &nbsp; errcxt-&gt;err_occurred = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Include detail only if we have some text from libxml */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (errcxt-&gt;err_buf.len &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; detail = errcxt-&gt;err_buf.data;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; detail = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; errsave(escontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(sqlcode),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>, msg),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; detail ? <a href="../error/elog.c.html#L1232" title="utils/error/elog.c:1232">errdetail_internal</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>, detail) : <span class="Constant">0</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Error handler for libxml errors and warnings<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2036">&#x200c;</a></span><span class="linkable">xml_errorHandler</span>(<span class="Type">void</span> *data, <a href="#L75" title="utils/adt/xml.c:75">PgXmlErrorPtr</a> error)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L117" title="utils/adt/xml.c:117">PgXmlErrorContext</a> *xmlerrcxt = (<a href="#L117" title="utils/adt/xml.c:117">PgXmlErrorContext</a> *) data;<br/></li>
<li>&nbsp; &nbsp; xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) error-&gt;ctxt;<br/></li>
<li>&nbsp; &nbsp; xmlParserInputPtr input = (ctxt != <span class="Constant">NULL</span>) ? ctxt-&gt;input : <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; xmlNodePtr&nbsp; &nbsp; node = error-&gt;node;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> xmlChar *name = (node != <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;type == XML_ELEMENT_NODE) ? node-&gt;name : <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; domain = error-&gt;domain;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; level = error-&gt;level;<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; errorBuf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Defend against someone passing us a bogus context struct.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We force a backend exit if this check fails because longjmp'ing out of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * libxml would likely render it unsafe to use further.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (xmlerrcxt-&gt;magic != <a href="#L115" title="utils/adt/xml.c:115">ERRCXT_MAGIC</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;<a href="#L2036" title="utils/adt/xml.c:2036">xml_errorHandler</a> called with invalid <a href="#L117" title="utils/adt/xml.c:117">PgXmlErrorContext</a>&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Older libxml versions report some errors differently.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First, some errors were previously reported as coming from the parser<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * domain but are <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> reported as coming from the namespace domain.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Second, some warnings were upgraded to errors.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We attempt to compensate for that here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (error-&gt;code)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XML_WAR_NS_URI:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; level = XML_ERR_ERROR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; domain = XML_FROM_NAMESPACE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XML_ERR_NS_DECL_ERROR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XML_WAR_NS_URI_RELATIVE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XML_WAR_NS_COLUMN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XML_NS_ERR_XML_NAMESPACE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XML_NS_ERR_UNDEFINED_NAMESPACE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XML_NS_ERR_QNAME:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XML_NS_ERR_ATTRIBUTE_REDEFINED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XML_NS_ERR_EMPTY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; domain = XML_FROM_NAMESPACE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Decide whether to act on the error or not */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (domain)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XML_FROM_PARSER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XML_FROM_NONE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XML_FROM_MEMORY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XML_FROM_IO:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Suppress warnings about undeclared entities.&nbsp; We need to do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this to avoid problems due to not loading DTD definitions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (error-&gt;code == XML_WAR_UNDECLARED_ENTITY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Otherwise, <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> error regardless of the parsing purpose */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore error if only doing well-formedness check */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xmlerrcxt-&gt;strictness == PG_XML_STRICTNESS_WELLFORMED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Prepare error message in errorBuf */<br/></li>
<li></span>&nbsp; &nbsp; errorBuf = makeStringInfo();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (error-&gt;line &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(errorBuf, <span class="Constant">&quot;line </span><span class="Special">%d</span><span class="Constant">: &quot;</span>, error-&gt;line);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (name != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(errorBuf, <span class="Constant">&quot;<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> </span><span class="Special">%s</span><span class="Constant">: &quot;</span>, name);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (error-&gt;message != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(errorBuf, error-&gt;message);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(errorBuf, <span class="Constant">&quot;(no message provided)&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Append context information to errorBuf.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * xmlParserPrintFileContext() uses libxml's &quot;generic&quot; error handler to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * write the context.&nbsp; Since we don't want to duplicate libxml<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * functionality here, we set up a generic error handler temporarily.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We use appendStringInfo() directly as libxml's generic error handler.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This should work because it has essentially the same signature as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * libxml expects, namely (void *ptr, const char *msg, ...).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (input != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xmlGenericErrorFunc errFuncSaved = xmlGenericError;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *errCtxSaved = xmlGenericErrorContext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xmlSetGenericErrorFunc((<span class="Type">void</span> *) errorBuf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (xmlGenericErrorFunc) appendStringInfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Add context information to errorBuf */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2259" title="utils/adt/xml.c:2259">appendStringInfoLineSeparator</a>(errorBuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xmlParserPrintFileContext(input);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Restore generic error func */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; xmlSetGenericErrorFunc(errCtxSaved, errFuncSaved);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get rid of <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> trailing newlines in errorBuf */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2248" title="utils/adt/xml.c:2248">chopStringInfoNewlines</a>(errorBuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Legacy error handling mode.&nbsp; err_occurred is never set, we just add the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * message to err_buf.&nbsp; This mode exists because the xml2 contrib module<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * uses our error-handling infrastructure, but we don't want to change its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * behaviour since it's deprecated anyway.&nbsp; This is also why we don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * distinguish between notices, warnings and errors here --- the old-style<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * generic error handler wouldn't have done that either.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (xmlerrcxt-&gt;strictness == PG_XML_STRICTNESS_LEGACY)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2259" title="utils/adt/xml.c:2259">appendStringInfoLineSeparator</a>(&amp;xmlerrcxt-&gt;err_buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendBinaryStringInfo(&amp;xmlerrcxt-&gt;err_buf, errorBuf-&gt;data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; errorBuf-&gt;len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; destroyStringInfo(errorBuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't want to ereport() here because that'd probably leave libxml in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * an inconsistent state.&nbsp; Instead, we remember the error and ereport()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from <a href="#L1970" title="utils/adt/xml.c:1970">xml_ereport</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Warnings and notices can be reported immediately since they won't cause<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a longjmp() out of libxml.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (level &gt;= XML_ERR_ERROR)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2259" title="utils/adt/xml.c:2259">appendStringInfoLineSeparator</a>(&amp;xmlerrcxt-&gt;err_buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendBinaryStringInfo(&amp;xmlerrcxt-&gt;err_buf, errorBuf-&gt;data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; errorBuf-&gt;len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xmlerrcxt-&gt;err_occurred = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (level &gt;= XML_ERR_WARNING)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>, errorBuf-&gt;data)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(NOTICE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>, errorBuf-&gt;data)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; destroyStringInfo(errorBuf);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert libxml error codes into textual <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a> messages.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This should be called within an ereport or errsave invocation,<br/></li>
<li></span><span class="Comment"> * just as <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a> would be.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * At the moment, we only need to cover those codes that we<br/></li>
<li></span><span class="Comment"> * may raise in this file.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L2211">&#x200c;</a></span><span class="linkable">errdetail_for_xml_code</span>(<span class="Type">int</span> code)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *det;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (code)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XML_ERR_INVALID_CHAR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; det = gettext_noop(<span class="Constant">&quot;Invalid character value.&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XML_ERR_SPACE_REQUIRED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; det = gettext_noop(<span class="Constant">&quot;Space required.&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XML_ERR_STANDALONE_VALUE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; det = gettext_noop(<span class="Constant">&quot;standalone accepts only 'yes' or 'no'.&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XML_ERR_VERSION_MISSING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; det = gettext_noop(<span class="Constant">&quot;Malformed declaration: missing version.&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XML_ERR_MISSING_ENCODING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; det = gettext_noop(<span class="Constant">&quot;Missing encoding in text declaration.&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XML_ERR_XMLDECL_NOT_FINISHED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; det = gettext_noop(<span class="Constant">&quot;Parsing XML declaration: '?&gt;' expected.&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; det = gettext_noop(<span class="Constant">&quot;Unrecognized libxml error code: </span><span class="Special">%d</span><span class="Constant">.&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(det, code);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Remove all trailing newlines from a StringInfo string<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2248">&#x200c;</a></span><span class="linkable">chopStringInfoNewlines</span>(StringInfo str)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (str-&gt;len &gt; <span class="Constant">0</span> &amp;&amp; str-&gt;data[str-&gt;len - <span class="Constant">1</span>] == <span class="Special">'\n'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; str-&gt;data[--str-&gt;len] = <span class="Special">'\0'</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Append a <a href="../../regex/regc_lex.c.html#L1010" title="regex/regc_lex.c:1010">newline</a> after removing <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> existing trailing newlines<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2259">&#x200c;</a></span><span class="linkable">appendStringInfoLineSeparator</span>(StringInfo str)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L2248" title="utils/adt/xml.c:2248">chopStringInfoNewlines</a>(str);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (str-&gt;len &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(str, <span class="Special">'\n'</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert one char in the current server encoding to a Unicode codepoint.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> pg_wchar<br/></li>
<li><a id="L2271">&#x200c;</a><span class="linkable">sqlchar_to_unicode</span>(<span class="Type">const</span> <span class="Type">char</span> *s)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *utf8string;<br/></li>
<li>&nbsp; &nbsp; pg_wchar&nbsp; &nbsp; ret[<span class="Constant">2</span>];&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* need space for trailing zero */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* note we're not assuming s is null-terminated */<br/></li>
<li></span>&nbsp; &nbsp; utf8string = <a href="../mb/mbutils.c.html#L749" title="utils/mb/mbutils.c:749">pg_server_to_any</a>(s, <a href="../mb/mbutils.c.html#L1023" title="utils/mb/mbutils.c:1023">pg_mblen</a>(s), PG_UTF8);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mb/mbutils.c.html#L993" title="utils/mb/mbutils.c:993">pg_encoding_mb2wchar_with_len</a>(PG_UTF8, utf8string, ret,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_encoding_mblen(PG_UTF8, utf8string));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (utf8string != s)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(utf8string);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ret[<span class="Constant">0</span>];<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2290">&#x200c;</a></span><span class="linkable">is_valid_xml_namefirst</span>(pg_wchar c)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* (Letter | '<a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>' | ':') */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> (xmlIsBaseCharQ(c) || xmlIsIdeographicQ(c)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || c == <span class="Constant">'<a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>'</span> || c == <span class="Constant">':'</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2299">&#x200c;</a></span><span class="linkable">is_valid_xml_namechar</span>(pg_wchar c)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Letter | Digit | '.' | '-' | '<a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>' | ':' | CombiningChar | Extender */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> (xmlIsBaseCharQ(c) || xmlIsIdeographicQ(c)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || xmlIsDigitQ(c)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || c == <span class="Constant">'.'</span> || c == <span class="Constant">'-'</span> || c == <span class="Constant">'<a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>'</span> || c == <span class="Constant">':'<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || xmlIsCombiningQ(c)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || xmlIsExtenderQ(c));<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* USE_LIBXML */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Map SQL identifier to XML name; see SQL/XML:2008 section 9.1.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L2315">&#x200c;</a><span class="linkable">map_sql_identifier_to_xml_name</span>(<span class="Type">const</span> <span class="Type">char</span> *ident, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> fully_escaped,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> escape_period)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef USE_LIBXML<br/></li>
<li></span>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *p;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * SQL/XML doesn't make use of this case anywhere, so it's probably a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * mistake.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(fully_escaped || !escape_period);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (p = ident; *p; p += <a href="../mb/mbutils.c.html#L1023" title="utils/mb/mbutils.c:1023">pg_mblen</a>(p))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*p == <span class="Constant">':'</span> &amp;&amp; (p == ident || fully_escaped))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;buf, <span class="Constant">&quot;_x003A_&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*p == <span class="Constant">'<a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>'</span> &amp;&amp; *(p + <span class="Constant">1</span>) == <span class="Constant">'x'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;buf, <span class="Constant">&quot;_x005F_&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (fully_escaped &amp;&amp; p == ident &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pg_strncasecmp(p, <span class="Constant">&quot;xml&quot;</span>, <span class="Constant">3</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*p == <span class="Constant">'x'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;buf, <span class="Constant">&quot;_x0078_&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;buf, <span class="Constant">&quot;_x0058_&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (escape_period &amp;&amp; *p == <span class="Constant">'.'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;buf, <span class="Constant">&quot;_x002E_&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_wchar&nbsp; &nbsp; u = <a href="#L2271" title="utils/adt/xml.c:2271">sqlchar_to_unicode</a>(p);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((p == ident)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ? !<a href="#L2290" title="utils/adt/xml.c:2290">is_valid_xml_namefirst</a>(u)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : !<a href="#L2299" title="utils/adt/xml.c:2299">is_valid_xml_namechar</a>(u))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;buf, <span class="Constant">&quot;_x</span><span class="Special">%04X</span><span class="Constant"><a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>&quot;</span>, (<span class="Type">unsigned</span> <span class="Type">int</span>) u);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendBinaryStringInfo(&amp;buf, p, <a href="../mb/mbutils.c.html#L1023" title="utils/mb/mbutils.c:1023">pg_mblen</a>(p));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> buf.data;<br/></li>
<li><span class="PreProc">#else</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not USE_LIBXML */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L235" title="utils/adt/xml.c:235">NO_XML_SUPPORT</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not USE_LIBXML */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Map XML name to SQL identifier; see SQL/XML:2008 section 9.3.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L2371">&#x200c;</a><span class="linkable">map_xml_name_to_sql_identifier</span>(<span class="Type">const</span> <span class="Type">char</span> *name)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *p;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (p = name; *p; p += <a href="../mb/mbutils.c.html#L1023" title="utils/mb/mbutils.c:1023">pg_mblen</a>(p))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*p == <span class="Constant">'<a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>'</span> &amp;&amp; *(p + <span class="Constant">1</span>) == <span class="Constant">'x'<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; isxdigit((<span class="Type">unsigned</span> <span class="Type">char</span>) *(p + <span class="Constant">2</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; isxdigit((<span class="Type">unsigned</span> <span class="Type">char</span>) *(p + <span class="Constant">3</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; isxdigit((<span class="Type">unsigned</span> <span class="Type">char</span>) *(p + <span class="Constant">4</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; isxdigit((<span class="Type">unsigned</span> <span class="Type">char</span>) *(p + <span class="Constant">5</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; *(p + <span class="Constant">6</span>) == <span class="Constant">'<a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; cbuf[MAX_UNICODE_EQUIVALENT_STRING + <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> u;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sscanf(p + <span class="Constant">2</span>, <span class="Constant">&quot;</span><span class="Special">%X</span><span class="Constant">&quot;</span>, &amp;u);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mb/mbutils.c.html#L864" title="utils/mb/mbutils.c:864">pg_unicode_to_server</a>(u, (<span class="Type">unsigned</span> <span class="Type">char</span> *) cbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;buf, cbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p += <span class="Constant">6</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendBinaryStringInfo(&amp;buf, p, <a href="../mb/mbutils.c.html#L1023" title="utils/mb/mbutils.c:1023">pg_mblen</a>(p));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> buf.data;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Map SQL value to XML value; see SQL/XML:2008 section 9.8.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When xml_escape_strings is true, then certain characters in string<br/></li>
<li></span><span class="Comment"> * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are replaced by entity references (&amp;lt; etc.), as specified<br/></li>
<li></span><span class="Comment"> * in SQL/XML:2008 section 9.8 GR 9) a) iii).&nbsp;&nbsp; This is normally what is<br/></li>
<li></span><span class="Comment"> * wanted.&nbsp; The false case is mainly useful when the resulting value<br/></li>
<li></span><span class="Comment"> * is used with xmlTextWriterWriteAttribute() to write out an<br/></li>
<li></span><span class="Comment"> * attribute, because that function does the escaping itself.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L2413">&#x200c;</a><span class="linkable">map_sql_value_to_xml_value</span>(Datum value, Oid type, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> xml_escape_strings)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (type_is_array_domain(type))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ArrayType&nbsp; *array;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmtype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; elmlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; elmbyval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; elmalign;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_elems;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *elem_values;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *elem_nulls;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; StringInfoData buf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; array = DatumGetArrayTypeP(value);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elmtype = ARR_ELEMTYPE(array);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L2271" title="utils/cache/lsyscache.c:2271">get_typlenbyvalalign</a>(elmtype, &amp;elmlen, &amp;elmbyval, &amp;elmalign);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="arrayfuncs.c.html#L3612" title="utils/adt/arrayfuncs.c:3612">deconstruct_array</a>(array, elmtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmlen, elmbyval, elmalign,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;elem_values, &amp;elem_nulls,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;num_elems);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; initStringInfo(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; num_elems; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (elem_nulls[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;buf, <span class="Constant">&quot;&lt;<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>&gt;&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L2413" title="utils/adt/xml.c:2413">map_sql_value_to_xml_value</a>(elem_values[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmtype, <span class="Constant">true</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;buf, <span class="Constant">&quot;&lt;/<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>&gt;&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(elem_values);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(elem_nulls);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> buf.data;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typeOut;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isvarlena;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *str;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Flatten domains; the special-case treatments below should apply to,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * eg, domains over boolean not just boolean.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; type = <a href="../cache/lsyscache.c.html#L2521" title="utils/cache/lsyscache.c:2521">getBaseType</a>(type);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Special XSD formatting for some data types<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (type)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BOOLOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (DatumGetBool(value))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;true&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;false&quot;</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DATEOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; date;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> pg_tm tm;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; buf[MAXDATELEN + <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; date = DatumGetDateADT(value);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* XSD doesn't support infinite <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (DATE_NOT_FINITE(date))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;date out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;XML does not support infinite date <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="datetime.c.html#L311" title="utils/adt/datetime.c:311">j2date</a>(date + POSTGRES_EPOCH_JDATE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;(tm.tm_year), &amp;(tm.tm_mon), &amp;(tm.tm_mday));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="datetime.c.html#L4216" title="utils/adt/datetime.c:4216">EncodeDateOnly</a>(&amp;tm, USE_XSD_DATES, buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TIMESTAMPOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Timestamp&nbsp; &nbsp; timestamp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> pg_tm tm;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fsec_t&nbsp; &nbsp; &nbsp; &nbsp; fsec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; buf[MAXDATELEN + <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; timestamp = DatumGetTimestamp(value);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* XSD doesn't support infinite <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TIMESTAMP_NOT_FINITE(timestamp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;XML does not support infinite timestamp <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="timestamp.c.html#L1901" title="utils/adt/timestamp.c:1901">timestamp2tm</a>(timestamp, <span class="Constant">NULL</span>, &amp;tm, &amp;fsec, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="datetime.c.html#L4331" title="utils/adt/datetime.c:4331">EncodeDateTime</a>(&amp;tm, fsec, <span class="Constant">false</span>, <span class="Constant">0</span>, <span class="Constant">NULL</span>, USE_XSD_DATES, buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TIMESTAMPTZOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimestampTz timestamp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> pg_tm tm;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tz;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fsec_t&nbsp; &nbsp; &nbsp; &nbsp; fsec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *tzn = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; buf[MAXDATELEN + <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; timestamp = DatumGetTimestamp(value);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* XSD doesn't support infinite <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TIMESTAMP_NOT_FINITE(timestamp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;XML does not support infinite timestamp <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="timestamp.c.html#L1901" title="utils/adt/timestamp.c:1901">timestamp2tm</a>(timestamp, &amp;tz, &amp;tm, &amp;fsec, &amp;tzn, <span class="Constant">NULL</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="datetime.c.html#L4331" title="utils/adt/datetime.c:4331">EncodeDateTime</a>(&amp;tm, fsec, <span class="Constant">true</span>, tz, tzn, USE_XSD_DATES, buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_LIBXML<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BYTEAOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *bstr = DatumGetByteaPP(value);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L117" title="utils/adt/xml.c:117">PgXmlErrorContext</a> *xmlerrcxt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">volatile</span> xmlBufferPtr buf = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">volatile</span> xmlTextWriterPtr writer = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmlerrcxt = <a href="#L1178" title="utils/adt/xml.c:1178">pg_xml_init</a>(PG_XML_STRICTNESS_ALL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_TRY();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf = xmlBufferCreate();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (buf == <span class="Constant">NULL</span> || xmlerrcxt-&gt;err_occurred)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1970" title="utils/adt/xml.c:1970">xml_ereport</a>(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;could not allocate xmlBuffer&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; writer = xmlNewTextWriterMemory(buf, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (writer == <span class="Constant">NULL</span> || xmlerrcxt-&gt;err_occurred)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1970" title="utils/adt/xml.c:1970">xml_ereport</a>(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;could not allocate xmlTextWriter&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L109" title="utils/adt/xml.c:109">xmlbinary</a> == XMLBINARY_BASE64)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmlTextWriterWriteBase64(writer, VARDATA_ANY(bstr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>, VARSIZE_ANY_EXHDR(bstr));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmlTextWriterWriteBinHex(writer, VARDATA_ANY(bstr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>, VARSIZE_ANY_EXHDR(bstr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we MUST do this <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> to flush data out to the buffer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmlFreeTextWriter(writer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; writer = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>((<span class="Type">const</span> <span class="Type">char</span> *) xmlBufferContent(buf));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_CATCH();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (writer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmlFreeTextWriter(writer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (buf)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmlBufferFree(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1259" title="utils/adt/xml.c:1259">pg_xml_done</a>(xmlerrcxt, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RE_THROW();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_END_TRY();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmlBufferFree(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1259" title="utils/adt/xml.c:1259">pg_xml_done</a>(xmlerrcxt, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* USE_LIBXML */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * otherwise, just use the type's native text representation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L2907" title="utils/cache/lsyscache.c:2907">getTypeOutputInfo</a>(type, &amp;typeOut, &amp;isvarlena);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; str = <a href="../fmgr/fmgr.c.html#L1763" title="utils/fmgr/fmgr.c:1763">OidOutputFunctionCall</a>(typeOut, value);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ... exactly as-is for XML, and when escaping is not wanted */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (type == XMLOID || !xml_escape_strings)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> str;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* otherwise, <a href="oracle_compat.c.html#L797" title="utils/adt/oracle_compat.c:797">translate</a> special characters as needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2632" title="utils/adt/xml.c:2632">escape_xml</a>(str);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Escape characters in text that have special meanings in XML.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns a <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d string.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: this is intentionally not dependent on libxml.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L2632">&#x200c;</a><span class="linkable">escape_xml</span>(<span class="Type">const</span> <span class="Type">char</span> *str)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *p;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;buf);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (p = str; *p; p++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (*p)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'&amp;'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;buf, <span class="Constant">&quot;&amp;amp;&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'&lt;'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;buf, <span class="Constant">&quot;&amp;lt;&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'&gt;'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;buf, <span class="Constant">&quot;&amp;gt;&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Special">'\r'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;buf, <span class="Constant">&quot;&amp;#x0d;&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoCharMacro(&amp;buf, *p);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> buf.data;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L2664">&#x200c;</a><span class="linkable">_SPI_strdup</span>(<span class="Type">const</span> <span class="Type">char</span> *s)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; len = strlen(s) + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ret = <a href="../../executor/spi.c.html#L1335" title="executor/spi.c:1335">SPI_palloc</a>(len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memcpy(ret, s, len);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ret;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * SQL to XML mapping <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * What follows below was at one point intentionally organized so that<br/></li>
<li></span><span class="Comment"> * you can read along in the SQL/XML standard. The <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> are<br/></li>
<li></span><span class="Comment"> * mostly split up the way the clauses lay out in the standards<br/></li>
<li></span><span class="Comment"> * document, and the identifiers are also aligned with the standard<br/></li>
<li></span><span class="Comment"> * text.&nbsp; Unfortunately, SQL/XML:2006 reordered the clauses<br/></li>
<li></span><span class="Comment"> * differently than SQL/XML:2003, so the order below doesn't make much<br/></li>
<li></span><span class="Comment"> * sense anymore.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * There are many things going on there:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * There are two kinds of mappings: Mapping SQL data (table contents)<br/></li>
<li></span><span class="Comment"> * to XML documents, and mapping SQL structure (the &quot;schema&quot;) to XML<br/></li>
<li></span><span class="Comment"> * Schema.&nbsp; And there are <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> that do both at the same time.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Then you can map a database, a schema, or a table, each in both<br/></li>
<li></span><span class="Comment"> * ways.&nbsp; This breaks down recursively: Mapping a database invokes<br/></li>
<li></span><span class="Comment"> * mapping schemas, which invokes mapping tables, which invokes<br/></li>
<li></span><span class="Comment"> * mapping rows, which invokes mapping columns, although you can't<br/></li>
<li></span><span class="Comment"> * call the last two from the outside.&nbsp; Because of this, there are a<br/></li>
<li></span><span class="Comment"> * number of xyz_internal() <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> which are to be called both from<br/></li>
<li></span><span class="Comment"> * the function manager wrapper and from some <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> layer in a<br/></li>
<li></span><span class="Comment"> * recursive call.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See the documentation about what the common function arguments<br/></li>
<li></span><span class="Comment"> * nulls, tableforest, and targetns mean.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Some style guidelines for XML output: Use double quotes for quoting<br/></li>
<li></span><span class="Comment"> * XML attributes.&nbsp; Indent XML elements by two spaces, but remember<br/></li>
<li></span><span class="Comment"> * that a lot of code is called recursively at different levels, so<br/></li>
<li></span><span class="Comment"> * it's better not to indent rather than create output that indents<br/></li>
<li></span><span class="Comment"> * and outdents weirdly.&nbsp; Add newlines to make the output look nice.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Visibility of objects for XML mappings; see SQL/XML:2008 section<br/></li>
<li></span><span class="Comment"> * 4.10.8.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Given a query, which must return type oid as first column, produce<br/></li>
<li></span><span class="Comment"> * a list of Oids with the query results.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L2721">&#x200c;</a><span class="linkable">query_to_oid_list</span>(<span class="Type">const</span> <span class="Type">char</span> *query)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *list = NIL;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; spi_result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; spi_result = <a href="../../executor/spi.c.html#L593" title="executor/spi.c:593">SPI_execute</a>(query, <span class="Constant">true</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (spi_result != SPI_OK_SELECT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../../executor/spi.c.html#L593" title="executor/spi.c:593">SPI_execute</a> returned </span><span class="Special">%s</span><span class="Constant"> for </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../executor/spi.c.html#L1969" title="executor/spi.c:1969">SPI_result_code_string</a>(spi_result), query);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="../../executor/spi.c.html#L44" title="executor/spi.c:44">SPI_processed</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; oid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oid = <a href="../../executor/spi.c.html#L1249" title="executor/spi.c:1249">SPI_getbinval</a>(<a href="../../executor/spi.c.html#L45" title="executor/spi.c:45">SPI_tuptable</a>-&gt;vals[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/spi.c.html#L45" title="executor/spi.c:45">SPI_tuptable</a>-&gt;tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list = <a href="../../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(list, DatumGetObjectId(oid));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> list;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">static</span> List *<br/></li>
<li><a id="L2750">&#x200c;</a><span class="linkable">schema_get_xml_visible_tables</span>(Oid nspid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfoData query;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;query);<br/></li>
<li>&nbsp; &nbsp; appendStringInfo(&amp;query, <span class="Constant">&quot;SELECT oid FROM pg_catalog.pg_class&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot; WHERE relnamespace = </span><span class="Special">%u</span><span class="Constant"> AND relkind IN (&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; CppAsString2(RELKIND_RELATION) <span class="Constant">&quot;,&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; CppAsString2(RELKIND_MATVIEW) <span class="Constant">&quot;,&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; CppAsString2(RELKIND_VIEW) <span class="Constant">&quot;)&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot; AND pg_catalog.has_table_privilege (oid, 'SELECT')&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot; ORDER BY relname;&quot;</span>, nspid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2721" title="utils/adt/xml.c:2721">query_to_oid_list</a>(query.data);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Including the system schemas is probably not useful for a database<br/></li>
<li></span><span class="Comment"> * mapping.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L2771">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">XML_VISIBLE_SCHEMAS_EXCLUDE</span> </span><span class="Constant">&quot;(nspname ~ '^pg_' OR nspname = 'information_schema')&quot;<br/></li>
<li></span><br/></li>
<li><a id="L2773">&#x200c;</a><span class="PreProc">#define <span class="linkable">XML_VISIBLE_SCHEMAS</span> </span><span class="Constant">&quot;SELECT oid FROM pg_catalog.pg_namespace WHERE pg_catalog.has_schema_privilege (oid, 'USAGE') AND NOT &quot;</span><span class="PreProc"> <a href="#L2771" title="utils/adt/xml.c:2771">XML_VISIBLE_SCHEMAS_EXCLUDE</a><br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Type">static</span> List *<br/></li>
<li><a id="L2777">&#x200c;</a><span class="linkable">database_get_xml_visible_schemas</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2721" title="utils/adt/xml.c:2721">query_to_oid_list</a>(<a href="#L2773" title="utils/adt/xml.c:2773">XML_VISIBLE_SCHEMAS</a> <span class="Constant">&quot; ORDER BY nspname;&quot;</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">static</span> List *<br/></li>
<li><a id="L2784">&#x200c;</a><span class="linkable">database_get_xml_visible_tables</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* At the moment there is no order required here. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2721" title="utils/adt/xml.c:2721">query_to_oid_list</a>(<span class="Constant">&quot;SELECT oid FROM pg_catalog.pg_class&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot; WHERE relkind IN (&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; CppAsString2(RELKIND_RELATION) <span class="Constant">&quot;,&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; CppAsString2(RELKIND_MATVIEW) <span class="Constant">&quot;,&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; CppAsString2(RELKIND_VIEW) <span class="Constant">&quot;)&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot; AND pg_catalog.has_table_privilege(pg_class.oid, 'SELECT')&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot; AND relnamespace IN (&quot;</span> <a href="#L2773" title="utils/adt/xml.c:2773">XML_VISIBLE_SCHEMAS</a> <span class="Constant">&quot;);&quot;</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Map SQL table to XML and/or XML Schema document; see SQL/XML:2008<br/></li>
<li></span><span class="Comment"> * section 9.11.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> StringInfo<br/></li>
<li><a id="L2803">&#x200c;</a><span class="linkable">table_to_xml_internal</span>(Oid relid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *xmlschema, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nulls, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> tableforest,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *targetns, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> top_level)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfoData query;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;query);<br/></li>
<li>&nbsp; &nbsp; appendStringInfo(&amp;query, <span class="Constant">&quot;SELECT * FROM </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; DatumGetCString(DirectFunctionCall1(<a href="regproc.c.html#L943" title="utils/adt/regproc.c:943">regclassout</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectIdGetDatum(relid))));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2936" title="utils/adt/xml.c:2936">query_to_xml_internal</a>(query.data, <a href="../cache/lsyscache.c.html#L1928" title="utils/cache/lsyscache.c:1928">get_rel_name</a>(relid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xmlschema, nulls, tableforest,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; targetns, top_level);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2820">&#x200c;</a><span class="linkable">table_to_xml</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid = PG_GETARG_OID(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls = PG_GETARG_BOOL(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; tableforest = PG_GETARG_BOOL(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *targetns = <a href="varlena.c.html#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>(PG_GETARG_TEXT_PP(<span class="Constant">3</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_XML_P(<a href="#L467" title="utils/adt/xml.c:467">stringinfo_to_xmltype</a>(<a href="#L2803" title="utils/adt/xml.c:2803">table_to_xml_internal</a>(relid, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls, tableforest,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targetns, <span class="Constant">true</span>)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2834">&#x200c;</a><span class="linkable">query_to_xml</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *query = <a href="varlena.c.html#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>(PG_GETARG_TEXT_PP(<span class="Constant">0</span>));<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls = PG_GETARG_BOOL(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; tableforest = PG_GETARG_BOOL(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *targetns = <a href="varlena.c.html#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>(PG_GETARG_TEXT_PP(<span class="Constant">3</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_XML_P(<a href="#L467" title="utils/adt/xml.c:467">stringinfo_to_xmltype</a>(<a href="#L2936" title="utils/adt/xml.c:2936">query_to_xml_internal</a>(query, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, nulls, tableforest,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targetns, <span class="Constant">true</span>)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2848">&#x200c;</a><span class="linkable">cursor_to_xml</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *name = <a href="varlena.c.html#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>(PG_GETARG_TEXT_PP(<span class="Constant">0</span>));<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; count = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls = PG_GETARG_BOOL(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; tableforest = PG_GETARG_BOOL(<span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *targetns = <a href="varlena.c.html#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>(PG_GETARG_TEXT_PP(<span class="Constant">4</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; StringInfoData result;<br/></li>
<li>&nbsp; &nbsp; Portal&nbsp; &nbsp; &nbsp; &nbsp; portal;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!tableforest)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2902" title="utils/adt/xml.c:2902">xmldata_root_element_start</a>(&amp;result, <span class="Constant">&quot;table&quot;</span>, <span class="Constant">NULL</span>, targetns, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(&amp;result, <span class="Special">'\n'</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../executor/spi.c.html#L94" title="executor/spi.c:94">SPI_connect</a>();<br/></li>
<li>&nbsp; &nbsp; portal = <a href="../../executor/spi.c.html#L1791" title="executor/spi.c:1791">SPI_cursor_find</a>(name);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (portal == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_CURSOR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cursor </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>, name)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../executor/spi.c.html#L1803" title="executor/spi.c:1803">SPI_cursor_fetch</a>(portal, <span class="Constant">true</span>, count);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="../../executor/spi.c.html#L44" title="executor/spi.c:44">SPI_processed</a>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4021" title="utils/adt/xml.c:4021">SPI_sql_row_to_xmlelement</a>(i, &amp;result, <span class="Constant">NULL</span>, nulls,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tableforest, targetns, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../executor/spi.c.html#L182" title="executor/spi.c:182">SPI_finish</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!tableforest)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2929" title="utils/adt/xml.c:2929">xmldata_root_element_end</a>(&amp;result, <span class="Constant">&quot;table&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_XML_P(<a href="#L467" title="utils/adt/xml.c:467">stringinfo_to_xmltype</a>(&amp;result));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write the start tag of the root <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> of a data mapping.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * top_level means that this is the very top level of the eventual<br/></li>
<li></span><span class="Comment"> * output.&nbsp; For example, when the user calls <a href="#L2820" title="utils/adt/xml.c:2820">table_to_xml</a>, then a call<br/></li>
<li></span><span class="Comment"> * with a table name to this function is the top level.&nbsp; When the user<br/></li>
<li></span><span class="Comment"> * calls <a href="#L3334" title="utils/adt/xml.c:3334">database_to_xml</a>, then a call with a schema name to this<br/></li>
<li></span><span class="Comment"> * function is not the top level.&nbsp; If top_level is false, then the XML<br/></li>
<li></span><span class="Comment"> * namespace declarations are omitted, because they supposedly already<br/></li>
<li></span><span class="Comment"> * appeared earlier in the output.&nbsp; Repeating them is not wrong, but<br/></li>
<li></span><span class="Comment"> * it looks ugly.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2902">&#x200c;</a></span><span class="linkable">xmldata_root_element_start</span>(StringInfo result, <span class="Type">const</span> <span class="Type">char</span> *eltname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *xmlschema, <span class="Type">const</span> <span class="Type">char</span> *targetns,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> top_level)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This isn't really wrong but currently makes no sense. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(top_level || !xmlschema);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfo(result, <span class="Constant">&quot;&lt;</span><span class="Special">%s</span><span class="Constant">&quot;</span>, eltname);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (top_level)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(result, <span class="Constant">&quot; xmlns:xsi=</span><span class="Special">\&quot;</span><span class="Constant">&quot;</span> <a href="#L244" title="utils/adt/xml.c:244">NAMESPACE_XSI</a> <span class="Constant">&quot;</span><span class="Special">\&quot;</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strlen(targetns) &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(result, <span class="Constant">&quot; xmlns=</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, targetns);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xmlschema)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">FIXME</span><span class="Comment">: better targets */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strlen(targetns) &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(result, <span class="Constant">&quot; xsi:schemaLocation=</span><span class="Special">\&quot;%s</span><span class="Constant"> #</span><span class="Special">\&quot;</span><span class="Constant">&quot;</span>, targetns);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(result, <span class="Constant">&quot; xsi:noNamespaceSchemaLocation=</span><span class="Special">\&quot;</span><span class="Constant">#</span><span class="Special">\&quot;</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; appendStringInfoString(result, <span class="Constant">&quot;&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2929">&#x200c;</a></span><span class="linkable">xmldata_root_element_end</span>(StringInfo result, <span class="Type">const</span> <span class="Type">char</span> *eltname)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; appendStringInfo(result, <span class="Constant">&quot;&lt;/</span><span class="Special">%s</span><span class="Constant">&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>, eltname);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">static</span> StringInfo<br/></li>
<li><a id="L2936">&#x200c;</a><span class="linkable">query_to_xml_internal</span>(<span class="Type">const</span> <span class="Type">char</span> *query, <span class="Type">char</span> *tablename,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *xmlschema, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nulls, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> tableforest,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *targetns, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> top_level)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *xmltn;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tablename)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xmltn = <a href="#L2315" title="utils/adt/xml.c:2315">map_sql_identifier_to_xml_name</a>(tablename, <span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; xmltn = <span class="Constant">&quot;table&quot;</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = makeStringInfo();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../executor/spi.c.html#L94" title="executor/spi.c:94">SPI_connect</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../executor/spi.c.html#L593" title="executor/spi.c:593">SPI_execute</a>(query, <span class="Constant">true</span>, <span class="Constant">0</span>) != SPI_OK_SELECT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_EXCEPTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid query&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!tableforest)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2902" title="utils/adt/xml.c:2902">xmldata_root_element_start</a>(result, xmltn, xmlschema,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; targetns, top_level);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(result, <span class="Special">'\n'</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xmlschema)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(result, <span class="Constant">&quot;</span><span class="Special">%s\n\n</span><span class="Constant">&quot;</span>, xmlschema);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="../../executor/spi.c.html#L44" title="executor/spi.c:44">SPI_processed</a>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4021" title="utils/adt/xml.c:4021">SPI_sql_row_to_xmlelement</a>(i, result, tablename, nulls,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tableforest, targetns, top_level);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!tableforest)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2929" title="utils/adt/xml.c:2929">xmldata_root_element_end</a>(result, xmltn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../executor/spi.c.html#L182" title="executor/spi.c:182">SPI_finish</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2981">&#x200c;</a><span class="linkable">table_to_xmlschema</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid = PG_GETARG_OID(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls = PG_GETARG_BOOL(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; tableforest = PG_GETARG_BOOL(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *targetns = <a href="varlena.c.html#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>(PG_GETARG_TEXT_PP(<span class="Constant">3</span>));<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *result;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rel = <a href="../../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(relid, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; result = <a href="#L3451" title="utils/adt/xml.c:3451">map_sql_table_to_xmlschema</a>(rel-&gt;rd_att, relid, nulls,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tableforest, targetns);<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(rel, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_XML_P(<a href="#L474" title="utils/adt/xml.c:474">cstring_to_xmltype</a>(result));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3000">&#x200c;</a><span class="linkable">query_to_xmlschema</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *query = <a href="varlena.c.html#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>(PG_GETARG_TEXT_PP(<span class="Constant">0</span>));<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls = PG_GETARG_BOOL(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; tableforest = PG_GETARG_BOOL(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *targetns = <a href="varlena.c.html#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>(PG_GETARG_TEXT_PP(<span class="Constant">3</span>));<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *result;<br/></li>
<li>&nbsp; &nbsp; SPIPlanPtr&nbsp; &nbsp; plan;<br/></li>
<li>&nbsp; &nbsp; Portal&nbsp; &nbsp; &nbsp; &nbsp; portal;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../executor/spi.c.html#L94" title="executor/spi.c:94">SPI_connect</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((plan = <a href="../../executor/spi.c.html#L857" title="executor/spi.c:857">SPI_prepare</a>(query, <span class="Constant">0</span>, <span class="Constant">NULL</span>)) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../../executor/spi.c.html#L857" title="executor/spi.c:857">SPI_prepare</a>(</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">) failed&quot;</span>, query);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((portal = <a href="../../executor/spi.c.html#L1442" title="executor/spi.c:1442">SPI_cursor_open</a>(<span class="Constant">NULL</span>, plan, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>, <span class="Constant">true</span>)) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../../executor/spi.c.html#L1442" title="executor/spi.c:1442">SPI_cursor_open</a>(</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">) failed&quot;</span>, query);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L2664" title="utils/adt/xml.c:2664">_SPI_strdup</a>(<a href="#L3451" title="utils/adt/xml.c:3451">map_sql_table_to_xmlschema</a>(portal-&gt;tupDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidOid, nulls,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tableforest, targetns));<br/></li>
<li>&nbsp; &nbsp; <a href="../../executor/spi.c.html#L1859" title="executor/spi.c:1859">SPI_cursor_close</a>(portal);<br/></li>
<li>&nbsp; &nbsp; <a href="../../executor/spi.c.html#L182" title="executor/spi.c:182">SPI_finish</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_XML_P(<a href="#L474" title="utils/adt/xml.c:474">cstring_to_xmltype</a>(result));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3029">&#x200c;</a><span class="linkable">cursor_to_xmlschema</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *name = <a href="varlena.c.html#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>(PG_GETARG_TEXT_PP(<span class="Constant">0</span>));<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls = PG_GETARG_BOOL(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; tableforest = PG_GETARG_BOOL(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *targetns = <a href="varlena.c.html#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>(PG_GETARG_TEXT_PP(<span class="Constant">3</span>));<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *xmlschema;<br/></li>
<li>&nbsp; &nbsp; Portal&nbsp; &nbsp; &nbsp; &nbsp; portal;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../executor/spi.c.html#L94" title="executor/spi.c:94">SPI_connect</a>();<br/></li>
<li>&nbsp; &nbsp; portal = <a href="../../executor/spi.c.html#L1791" title="executor/spi.c:1791">SPI_cursor_find</a>(name);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (portal == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_CURSOR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cursor </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>, name)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;tupDesc == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_CURSOR_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;portal </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not return tuples&quot;</span>, name)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xmlschema = <a href="#L2664" title="utils/adt/xml.c:2664">_SPI_strdup</a>(<a href="#L3451" title="utils/adt/xml.c:3451">map_sql_table_to_xmlschema</a>(portal-&gt;tupDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid, nulls,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tableforest, targetns));<br/></li>
<li>&nbsp; &nbsp; <a href="../../executor/spi.c.html#L182" title="executor/spi.c:182">SPI_finish</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_XML_P(<a href="#L474" title="utils/adt/xml.c:474">cstring_to_xmltype</a>(xmlschema));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3059">&#x200c;</a><span class="linkable">table_to_xml_and_xmlschema</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid = PG_GETARG_OID(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls = PG_GETARG_BOOL(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; tableforest = PG_GETARG_BOOL(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *targetns = <a href="varlena.c.html#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>(PG_GETARG_TEXT_PP(<span class="Constant">3</span>));<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *xmlschema;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rel = <a href="../../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(relid, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; xmlschema = <a href="#L3451" title="utils/adt/xml.c:3451">map_sql_table_to_xmlschema</a>(rel-&gt;rd_att, relid, nulls,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tableforest, targetns);<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(rel, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_XML_P(<a href="#L467" title="utils/adt/xml.c:467">stringinfo_to_xmltype</a>(<a href="#L2803" title="utils/adt/xml.c:2803">table_to_xml_internal</a>(relid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmlschema, nulls, tableforest,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targetns, <span class="Constant">true</span>)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3080">&#x200c;</a><span class="linkable">query_to_xml_and_xmlschema</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *query = <a href="varlena.c.html#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>(PG_GETARG_TEXT_PP(<span class="Constant">0</span>));<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls = PG_GETARG_BOOL(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; tableforest = PG_GETARG_BOOL(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *targetns = <a href="varlena.c.html#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>(PG_GETARG_TEXT_PP(<span class="Constant">3</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *xmlschema;<br/></li>
<li>&nbsp; &nbsp; SPIPlanPtr&nbsp; &nbsp; plan;<br/></li>
<li>&nbsp; &nbsp; Portal&nbsp; &nbsp; &nbsp; &nbsp; portal;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../executor/spi.c.html#L94" title="executor/spi.c:94">SPI_connect</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((plan = <a href="../../executor/spi.c.html#L857" title="executor/spi.c:857">SPI_prepare</a>(query, <span class="Constant">0</span>, <span class="Constant">NULL</span>)) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../../executor/spi.c.html#L857" title="executor/spi.c:857">SPI_prepare</a>(</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">) failed&quot;</span>, query);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((portal = <a href="../../executor/spi.c.html#L1442" title="executor/spi.c:1442">SPI_cursor_open</a>(<span class="Constant">NULL</span>, plan, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>, <span class="Constant">true</span>)) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../../executor/spi.c.html#L1442" title="executor/spi.c:1442">SPI_cursor_open</a>(</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">) failed&quot;</span>, query);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xmlschema = <a href="#L2664" title="utils/adt/xml.c:2664">_SPI_strdup</a>(<a href="#L3451" title="utils/adt/xml.c:3451">map_sql_table_to_xmlschema</a>(portal-&gt;tupDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid, nulls, tableforest, targetns));<br/></li>
<li>&nbsp; &nbsp; <a href="../../executor/spi.c.html#L1859" title="executor/spi.c:1859">SPI_cursor_close</a>(portal);<br/></li>
<li>&nbsp; &nbsp; <a href="../../executor/spi.c.html#L182" title="executor/spi.c:182">SPI_finish</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_XML_P(<a href="#L467" title="utils/adt/xml.c:467">stringinfo_to_xmltype</a>(<a href="#L2936" title="utils/adt/xml.c:2936">query_to_xml_internal</a>(query, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmlschema, nulls, tableforest,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targetns, <span class="Constant">true</span>)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Map SQL schema to XML and/or XML Schema document; see SQL/XML:2008<br/></li>
<li></span><span class="Comment"> * sections 9.13, 9.14.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> StringInfo<br/></li>
<li><a id="L3116">&#x200c;</a><span class="linkable">schema_to_xml_internal</span>(Oid nspid, <span class="Type">const</span> <span class="Type">char</span> *xmlschema, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nulls,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> tableforest, <span class="Type">const</span> <span class="Type">char</span> *targetns, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> top_level)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *xmlsn;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *relid_list;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *cell;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xmlsn = <a href="#L2315" title="utils/adt/xml.c:2315">map_sql_identifier_to_xml_name</a>(<a href="../cache/lsyscache.c.html#L3366" title="utils/cache/lsyscache.c:3366">get_namespace_name</a>(nspid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; result = makeStringInfo();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2902" title="utils/adt/xml.c:2902">xmldata_root_element_start</a>(result, xmlsn, xmlschema, targetns, top_level);<br/></li>
<li>&nbsp; &nbsp; appendStringInfoChar(result, <span class="Special">'\n'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xmlschema)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(result, <span class="Constant">&quot;</span><span class="Special">%s\n\n</span><span class="Constant">&quot;</span>, xmlschema);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../executor/spi.c.html#L94" title="executor/spi.c:94">SPI_connect</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; relid_list = <a href="#L2750" title="utils/adt/xml.c:2750">schema_get_xml_visible_tables</a>(nspid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(cell, relid_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid = lfirst_oid(cell);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; StringInfo&nbsp; &nbsp; subres;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; subres = <a href="#L2803" title="utils/adt/xml.c:2803">table_to_xml_internal</a>(relid, <span class="Constant">NULL</span>, nulls, tableforest,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; targetns, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendBinaryStringInfo(result, subres-&gt;data, subres-&gt;len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(result, <span class="Special">'\n'</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../executor/spi.c.html#L182" title="executor/spi.c:182">SPI_finish</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2929" title="utils/adt/xml.c:2929">xmldata_root_element_end</a>(result, xmlsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3159">&#x200c;</a><span class="linkable">schema_to_xml</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Name&nbsp; &nbsp; &nbsp; &nbsp; name = PG_GETARG_NAME(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls = PG_GETARG_BOOL(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; tableforest = PG_GETARG_BOOL(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *targetns = <a href="varlena.c.html#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>(PG_GETARG_TEXT_PP(<span class="Constant">3</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *schemaname;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nspid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; schemaname = NameStr(*name);<br/></li>
<li>&nbsp; &nbsp; nspid = <a href="../../catalog/namespace.c.html#L3370" title="catalog/namespace.c:3370">LookupExplicitNamespace</a>(schemaname, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_XML_P(<a href="#L467" title="utils/adt/xml.c:467">stringinfo_to_xmltype</a>(<a href="#L3116" title="utils/adt/xml.c:3116">schema_to_xml_internal</a>(nspid, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nulls, tableforest, targetns, <span class="Constant">true</span>)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write the start <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> of the root <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> of an XML Schema mapping.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3181">&#x200c;</a></span><span class="linkable">xsd_schema_element_start</span>(StringInfo result, <span class="Type">const</span> <span class="Type">char</span> *targetns)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; appendStringInfoString(result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&lt;xsd:schema</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &nbsp; xmlns:xsd=</span><span class="Special">\&quot;</span><span class="Constant">&quot;</span> <a href="#L243" title="utils/adt/xml.c:243">NAMESPACE_XSD</a> <span class="Constant">&quot;</span><span class="Special">\&quot;</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (strlen(targetns) &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &nbsp; targetNamespace=</span><span class="Special">\&quot;%s\&quot;\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &nbsp; elementFormDefault=</span><span class="Special">\&quot;</span><span class="Constant">qualified</span><span class="Special">\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; targetns);<br/></li>
<li>&nbsp; &nbsp; appendStringInfoString(result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&gt;</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3198">&#x200c;</a></span><span class="linkable">xsd_schema_element_end</span>(StringInfo result)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; appendStringInfoString(result, <span class="Constant">&quot;&lt;/xsd:schema&gt;&quot;</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">static</span> StringInfo<br/></li>
<li><a id="L3205">&#x200c;</a><span class="linkable">schema_to_xmlschema_internal</span>(<span class="Type">const</span> <span class="Type">char</span> *schemaname, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nulls,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> tableforest, <span class="Type">const</span> <span class="Type">char</span> *targetns)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nspid;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *relid_list;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *tupdesc_list;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *cell;<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = makeStringInfo();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nspid = <a href="../../catalog/namespace.c.html#L3370" title="catalog/namespace.c:3370">LookupExplicitNamespace</a>(schemaname, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L3181" title="utils/adt/xml.c:3181">xsd_schema_element_start</a>(result, targetns);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../executor/spi.c.html#L94" title="executor/spi.c:94">SPI_connect</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; relid_list = <a href="#L2750" title="utils/adt/xml.c:2750">schema_get_xml_visible_tables</a>(nspid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tupdesc_list = NIL;<br/></li>
<li>&nbsp; &nbsp; foreach(cell, relid_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; rel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel = <a href="../../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(lfirst_oid(cell), AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tupdesc_list = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(tupdesc_list, <a href="../../access/common/tupdesc.c.html#L133" title="access/common/tupdesc.c:133">CreateTupleDescCopy</a>(rel-&gt;rd_att));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(rel, NoLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfoString(result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L3791" title="utils/adt/xml.c:3791">map_sql_typecoll_to_xmlschema_types</a>(tupdesc_list));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfoString(result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L3556" title="utils/adt/xml.c:3556">map_sql_schema_to_xmlschema_types</a>(nspid, relid_list,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nulls, tableforest, targetns));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L3198" title="utils/adt/xml.c:3198">xsd_schema_element_end</a>(result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../executor/spi.c.html#L182" title="executor/spi.c:182">SPI_finish</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3250">&#x200c;</a><span class="linkable">schema_to_xmlschema</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Name&nbsp; &nbsp; &nbsp; &nbsp; name = PG_GETARG_NAME(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls = PG_GETARG_BOOL(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; tableforest = PG_GETARG_BOOL(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *targetns = <a href="varlena.c.html#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>(PG_GETARG_TEXT_PP(<span class="Constant">3</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_XML_P(<a href="#L467" title="utils/adt/xml.c:467">stringinfo_to_xmltype</a>(<a href="#L3205" title="utils/adt/xml.c:3205">schema_to_xmlschema_internal</a>(NameStr(*name),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nulls, tableforest, targetns)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3263">&#x200c;</a><span class="linkable">schema_to_xml_and_xmlschema</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Name&nbsp; &nbsp; &nbsp; &nbsp; name = PG_GETARG_NAME(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls = PG_GETARG_BOOL(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; tableforest = PG_GETARG_BOOL(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *targetns = <a href="varlena.c.html#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>(PG_GETARG_TEXT_PP(<span class="Constant">3</span>));<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *schemaname;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nspid;<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; xmlschema;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; schemaname = NameStr(*name);<br/></li>
<li>&nbsp; &nbsp; nspid = <a href="../../catalog/namespace.c.html#L3370" title="catalog/namespace.c:3370">LookupExplicitNamespace</a>(schemaname, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xmlschema = <a href="#L3205" title="utils/adt/xml.c:3205">schema_to_xmlschema_internal</a>(schemaname, nulls,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tableforest, targetns);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_XML_P(<a href="#L467" title="utils/adt/xml.c:467">stringinfo_to_xmltype</a>(<a href="#L3116" title="utils/adt/xml.c:3116">schema_to_xml_internal</a>(nspid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xmlschema-&gt;data, nulls,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tableforest, targetns, <span class="Constant">true</span>)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Map SQL database to XML and/or XML Schema document; see SQL/XML:2008<br/></li>
<li></span><span class="Comment"> * sections 9.16, 9.17.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> StringInfo<br/></li>
<li><a id="L3291">&#x200c;</a><span class="linkable">database_to_xml_internal</span>(<span class="Type">const</span> <span class="Type">char</span> *xmlschema, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nulls,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> tableforest, <span class="Type">const</span> <span class="Type">char</span> *targetns)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *nspid_list;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *cell;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *xmlcn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xmlcn = <a href="#L2315" title="utils/adt/xml.c:2315">map_sql_identifier_to_xml_name</a>(<a href="../../commands/dbcommands.c.html#L3153" title="commands/dbcommands.c:3153">get_database_name</a>(<a href="../init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; result = makeStringInfo();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2902" title="utils/adt/xml.c:2902">xmldata_root_element_start</a>(result, xmlcn, xmlschema, targetns, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; appendStringInfoChar(result, <span class="Special">'\n'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xmlschema)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(result, <span class="Constant">&quot;</span><span class="Special">%s\n\n</span><span class="Constant">&quot;</span>, xmlschema);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../executor/spi.c.html#L94" title="executor/spi.c:94">SPI_connect</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nspid_list = <a href="#L2777" title="utils/adt/xml.c:2777">database_get_xml_visible_schemas</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(cell, nspid_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nspid = lfirst_oid(cell);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; StringInfo&nbsp; &nbsp; subres;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; subres = <a href="#L3116" title="utils/adt/xml.c:3116">schema_to_xml_internal</a>(nspid, <span class="Constant">NULL</span>, nulls,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tableforest, targetns, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendBinaryStringInfo(result, subres-&gt;data, subres-&gt;len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(result, <span class="Special">'\n'</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../executor/spi.c.html#L182" title="executor/spi.c:182">SPI_finish</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2929" title="utils/adt/xml.c:2929">xmldata_root_element_end</a>(result, xmlcn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3334">&#x200c;</a><span class="linkable">database_to_xml</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls = PG_GETARG_BOOL(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; tableforest = PG_GETARG_BOOL(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *targetns = <a href="varlena.c.html#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>(PG_GETARG_TEXT_PP(<span class="Constant">2</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_XML_P(<a href="#L467" title="utils/adt/xml.c:467">stringinfo_to_xmltype</a>(<a href="#L3291" title="utils/adt/xml.c:3291">database_to_xml_internal</a>(<span class="Constant">NULL</span>, nulls,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tableforest, targetns)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">static</span> StringInfo<br/></li>
<li><a id="L3346">&#x200c;</a><span class="linkable">database_to_xmlschema_internal</span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nulls, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> tableforest,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *targetns)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *relid_list;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *nspid_list;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *tupdesc_list;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *cell;<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = makeStringInfo();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L3181" title="utils/adt/xml.c:3181">xsd_schema_element_start</a>(result, targetns);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../executor/spi.c.html#L94" title="executor/spi.c:94">SPI_connect</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; relid_list = <a href="#L2784" title="utils/adt/xml.c:2784">database_get_xml_visible_tables</a>();<br/></li>
<li>&nbsp; &nbsp; nspid_list = <a href="#L2777" title="utils/adt/xml.c:2777">database_get_xml_visible_schemas</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tupdesc_list = NIL;<br/></li>
<li>&nbsp; &nbsp; foreach(cell, relid_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; rel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel = <a href="../../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(lfirst_oid(cell), AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tupdesc_list = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(tupdesc_list, <a href="../../access/common/tupdesc.c.html#L133" title="access/common/tupdesc.c:133">CreateTupleDescCopy</a>(rel-&gt;rd_att));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(rel, NoLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfoString(result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L3791" title="utils/adt/xml.c:3791">map_sql_typecoll_to_xmlschema_types</a>(tupdesc_list));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfoString(result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L3629" title="utils/adt/xml.c:3629">map_sql_catalog_to_xmlschema_types</a>(nspid_list, nulls, tableforest, targetns));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L3198" title="utils/adt/xml.c:3198">xsd_schema_element_end</a>(result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../executor/spi.c.html#L182" title="executor/spi.c:182">SPI_finish</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3389">&#x200c;</a><span class="linkable">database_to_xmlschema</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls = PG_GETARG_BOOL(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; tableforest = PG_GETARG_BOOL(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *targetns = <a href="varlena.c.html#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>(PG_GETARG_TEXT_PP(<span class="Constant">2</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_XML_P(<a href="#L467" title="utils/adt/xml.c:467">stringinfo_to_xmltype</a>(<a href="#L3346" title="utils/adt/xml.c:3346">database_to_xmlschema_internal</a>(nulls,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tableforest, targetns)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3401">&#x200c;</a><span class="linkable">database_to_xml_and_xmlschema</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls = PG_GETARG_BOOL(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; tableforest = PG_GETARG_BOOL(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *targetns = <a href="varlena.c.html#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>(PG_GETARG_TEXT_PP(<span class="Constant">2</span>));<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; xmlschema;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xmlschema = <a href="#L3346" title="utils/adt/xml.c:3346">database_to_xmlschema_internal</a>(nulls, tableforest, targetns);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_XML_P(<a href="#L467" title="utils/adt/xml.c:467">stringinfo_to_xmltype</a>(<a href="#L3291" title="utils/adt/xml.c:3291">database_to_xml_internal</a>(xmlschema-&gt;data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nulls, tableforest, targetns)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Map a multi-part SQL name to an XML name; see SQL/XML:2008 section<br/></li>
<li></span><span class="Comment"> * 9.2.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L3420">&#x200c;</a><span class="linkable">map_multipart_sql_identifier_to_xml_name</span>(<span class="Type">const</span> <span class="Type">char</span> *a, <span class="Type">const</span> <span class="Type">char</span> *b, <span class="Type">const</span> <span class="Type">char</span> *c, <span class="Type">const</span> <span class="Type">char</span> *d)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfoData result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (a)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L2315" title="utils/adt/xml.c:2315">map_sql_identifier_to_xml_name</a>(a, <span class="Constant">true</span>, <span class="Constant">true</span>));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (b)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;result, <span class="Constant">&quot;.</span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L2315" title="utils/adt/xml.c:2315">map_sql_identifier_to_xml_name</a>(b, <span class="Constant">true</span>, <span class="Constant">true</span>));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (c)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;result, <span class="Constant">&quot;.</span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L2315" title="utils/adt/xml.c:2315">map_sql_identifier_to_xml_name</a>(c, <span class="Constant">true</span>, <span class="Constant">true</span>));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (d)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;result, <span class="Constant">&quot;.</span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L2315" title="utils/adt/xml.c:2315">map_sql_identifier_to_xml_name</a>(d, <span class="Constant">true</span>, <span class="Constant">true</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result.data;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Map an SQL table to an XML Schema document; see SQL/XML:2008<br/></li>
<li></span><span class="Comment"> * section 9.11.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Map an SQL table to XML Schema data types; see SQL/XML:2008 section<br/></li>
<li></span><span class="Comment"> * 9.9.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">const</span> <span class="Type">char</span> *<br/></li>
<li><a id="L3451">&#x200c;</a><span class="linkable">map_sql_table_to_xmlschema</span>(TupleDesc tupdesc, Oid relid, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nulls,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> tableforest, <span class="Type">const</span> <span class="Type">char</span> *targetns)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *xmltn;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *tabletypename;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *rowtypename;<br/></li>
<li>&nbsp; &nbsp; StringInfoData result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(relid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_class reltuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple = <a href="../cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(RELOID, ObjectIdGetDatum(relid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for relation </span><span class="Special">%u</span><span class="Constant">&quot;</span>, relid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; reltuple = (Form_pg_class) GETSTRUCT(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xmltn = <a href="#L2315" title="utils/adt/xml.c:2315">map_sql_identifier_to_xml_name</a>(NameStr(reltuple-&gt;relname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tabletypename = <a href="#L3420" title="utils/adt/xml.c:3420">map_multipart_sql_identifier_to_xml_name</a>(<span class="Constant">&quot;TableType&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../commands/dbcommands.c.html#L3153" title="commands/dbcommands.c:3153">get_database_name</a>(<a href="../init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../cache/lsyscache.c.html#L3366" title="utils/cache/lsyscache.c:3366">get_namespace_name</a>(reltuple-&gt;relnamespace),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NameStr(reltuple-&gt;relname));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rowtypename = <a href="#L3420" title="utils/adt/xml.c:3420">map_multipart_sql_identifier_to_xml_name</a>(<span class="Constant">&quot;RowType&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../commands/dbcommands.c.html#L3153" title="commands/dbcommands.c:3153">get_database_name</a>(<a href="../init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../cache/lsyscache.c.html#L3366" title="utils/cache/lsyscache.c:3366">get_namespace_name</a>(reltuple-&gt;relnamespace),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NameStr(reltuple-&gt;relname));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tableforest)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmltn = <span class="Constant">&quot;row&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmltn = <span class="Constant">&quot;table&quot;</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tabletypename = <span class="Constant">&quot;TableType&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rowtypename = <span class="Constant">&quot;RowType&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L3181" title="utils/adt/xml.c:3181">xsd_schema_element_start</a>(&amp;result, targetns);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfoString(&amp;result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L3791" title="utils/adt/xml.c:3791">map_sql_typecoll_to_xmlschema_types</a>(list_make1(tupdesc)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfo(&amp;result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&lt;xsd:complexType name=</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&gt;</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &lt;xsd:sequence&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rowtypename);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; tupdesc-&gt;natts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att = TupleDescAttr(tupdesc, i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (att-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &nbsp; &lt;xsd:<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> name=</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> type=</span><span class="Special">\&quot;%s\&quot;%s</span><span class="Constant">&gt;&lt;/xsd:<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L2315" title="utils/adt/xml.c:2315">map_sql_identifier_to_xml_name</a>(NameStr(att-&gt;attname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>, <span class="Constant">false</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L3686" title="utils/adt/xml.c:3686">map_sql_type_to_xml_name</a>(att-&gt;atttypid, -<span class="Constant">1</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nulls ? <span class="Constant">&quot; nillable=</span><span class="Special">\&quot;</span><span class="Constant">true</span><span class="Special">\&quot;</span><span class="Constant">&quot;</span> : <span class="Constant">&quot; minOccurs=</span><span class="Special">\&quot;</span><span class="Constant">0</span><span class="Special">\&quot;</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfoString(&amp;result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &lt;/xsd:sequence&gt;</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&lt;/xsd:complexType&gt;</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!tableforest)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&lt;xsd:complexType name=</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&gt;</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &lt;xsd:sequence&gt;</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &nbsp; &lt;xsd:<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> name=</span><span class="Special">\&quot;</span><span class="Constant">row</span><span class="Special">\&quot;</span><span class="Constant"> type=</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> minOccurs=</span><span class="Special">\&quot;</span><span class="Constant">0</span><span class="Special">\&quot;</span><span class="Constant"> maxOccurs=</span><span class="Special">\&quot;</span><span class="Constant">unbounded</span><span class="Special">\&quot;</span><span class="Constant">/&gt;</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &lt;/xsd:sequence&gt;</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&lt;/xsd:complexType&gt;</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tabletypename, rowtypename);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&lt;xsd:<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> name=</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> type=</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">/&gt;</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xmltn, tabletypename);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&lt;xsd:<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> name=</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> type=</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">/&gt;</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xmltn, rowtypename);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L3198" title="utils/adt/xml.c:3198">xsd_schema_element_end</a>(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result.data;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Map an SQL schema to XML Schema data types; see SQL/XML:2008<br/></li>
<li></span><span class="Comment"> * section 9.12.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">const</span> <span class="Type">char</span> *<br/></li>
<li><a id="L3556">&#x200c;</a><span class="linkable">map_sql_schema_to_xmlschema_types</span>(Oid nspid, List *relid_list, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nulls,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> tableforest, <span class="Type">const</span> <span class="Type">char</span> *targetns)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *dbname;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *nspname;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *xmlsn;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *schematypename;<br/></li>
<li>&nbsp; &nbsp; StringInfoData result;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *cell;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dbname = <a href="../../commands/dbcommands.c.html#L3153" title="commands/dbcommands.c:3153">get_database_name</a>(<a href="../init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>);<br/></li>
<li>&nbsp; &nbsp; nspname = <a href="../cache/lsyscache.c.html#L3366" title="utils/cache/lsyscache.c:3366">get_namespace_name</a>(nspid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xmlsn = <a href="#L2315" title="utils/adt/xml.c:2315">map_sql_identifier_to_xml_name</a>(nspname, <span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; schematypename = <a href="#L3420" title="utils/adt/xml.c:3420">map_multipart_sql_identifier_to_xml_name</a>(<span class="Constant">&quot;SchemaType&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dbname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nspname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfo(&amp;result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&lt;xsd:complexType name=</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>, schematypename);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!tableforest)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &lt;xsd:all&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &lt;xsd:sequence&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(cell, relid_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid = lfirst_oid(cell);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *relname = <a href="../cache/lsyscache.c.html#L1928" title="utils/cache/lsyscache.c:1928">get_rel_name</a>(relid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *xmltn = <a href="#L2315" title="utils/adt/xml.c:2315">map_sql_identifier_to_xml_name</a>(relname, <span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *tabletypename = <a href="#L3420" title="utils/adt/xml.c:3420">map_multipart_sql_identifier_to_xml_name</a>(tableforest ? <span class="Constant">&quot;RowType&quot;</span> : <span class="Constant">&quot;TableType&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; dbname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nspname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!tableforest)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &nbsp; &lt;xsd:<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> name=</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> type=</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">/&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xmltn, tabletypename);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &nbsp; &lt;xsd:<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> name=</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> type=</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> minOccurs=</span><span class="Special">\&quot;</span><span class="Constant">0</span><span class="Special">\&quot;</span><span class="Constant"> maxOccurs=</span><span class="Special">\&quot;</span><span class="Constant">unbounded</span><span class="Special">\&quot;</span><span class="Constant">/&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xmltn, tabletypename);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!tableforest)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &lt;/xsd:all&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &lt;/xsd:sequence&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; appendStringInfoString(&amp;result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&lt;/xsd:complexType&gt;</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfo(&amp;result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&lt;xsd:<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> name=</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> type=</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">/&gt;</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xmlsn, schematypename);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result.data;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Map an SQL catalog to XML Schema data types; see SQL/XML:2008<br/></li>
<li></span><span class="Comment"> * section 9.15.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">const</span> <span class="Type">char</span> *<br/></li>
<li><a id="L3629">&#x200c;</a><span class="linkable">map_sql_catalog_to_xmlschema_types</span>(List *nspid_list, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nulls,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> tableforest, <span class="Type">const</span> <span class="Type">char</span> *targetns)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *dbname;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *xmlcn;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *catalogtypename;<br/></li>
<li>&nbsp; &nbsp; StringInfoData result;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *cell;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dbname = <a href="../../commands/dbcommands.c.html#L3153" title="commands/dbcommands.c:3153">get_database_name</a>(<a href="../init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xmlcn = <a href="#L2315" title="utils/adt/xml.c:2315">map_sql_identifier_to_xml_name</a>(dbname, <span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; catalogtypename = <a href="#L3420" title="utils/adt/xml.c:3420">map_multipart_sql_identifier_to_xml_name</a>(<span class="Constant">&quot;CatalogType&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; dbname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfo(&amp;result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&lt;xsd:complexType name=</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>, catalogtypename);<br/></li>
<li>&nbsp; &nbsp; appendStringInfoString(&amp;result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &lt;xsd:all&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(cell, nspid_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nspid = lfirst_oid(cell);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *nspname = <a href="../cache/lsyscache.c.html#L3366" title="utils/cache/lsyscache.c:3366">get_namespace_name</a>(nspid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *xmlsn = <a href="#L2315" title="utils/adt/xml.c:2315">map_sql_identifier_to_xml_name</a>(nspname, <span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *schematypename = <a href="#L3420" title="utils/adt/xml.c:3420">map_multipart_sql_identifier_to_xml_name</a>(<span class="Constant">&quot;SchemaType&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dbname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nspname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &nbsp; &lt;xsd:<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> name=</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> type=</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">/&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xmlsn, schematypename);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfoString(&amp;result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &lt;/xsd:all&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; appendStringInfoString(&amp;result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&lt;/xsd:complexType&gt;</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfo(&amp;result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&lt;xsd:<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> name=</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> type=</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">/&gt;</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xmlcn, catalogtypename);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result.data;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Map an SQL data type to an XML name; see SQL/XML:2008 section 9.4.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">const</span> <span class="Type">char</span> *<br/></li>
<li><a id="L3686">&#x200c;</a><span class="linkable">map_sql_type_to_xml_name</span>(Oid typeoid, <span class="Type">int</span> typmod)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfoData result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (typeoid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BPCHAROID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typmod == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;result, <span class="Constant">&quot;CHAR&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;result, <span class="Constant">&quot;CHAR_</span><span class="Special">%d</span><span class="Constant">&quot;</span>, typmod - VARHDRSZ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> VARCHAROID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typmod == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;result, <span class="Constant">&quot;VARCHAR&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;result, <span class="Constant">&quot;VARCHAR_</span><span class="Special">%d</span><span class="Constant">&quot;</span>, typmod - VARHDRSZ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> NUMERICOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typmod == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;result, <span class="Constant">&quot;NUMERIC&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;result, <span class="Constant">&quot;NUMERIC_</span><span class="Special">%d</span><span class="Constant"><a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a></span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ((typmod - VARHDRSZ) &gt;&gt; <span class="Constant">16</span>) &amp; <span class="Constant">0xffff</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (typmod - VARHDRSZ) &amp; <span class="Constant">0xffff</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INT4OID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;result, <span class="Constant">&quot;INTEGER&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INT2OID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;result, <span class="Constant">&quot;SMALLINT&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INT8OID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;result, <span class="Constant">&quot;BIGINT&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> FLOAT4OID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;result, <span class="Constant">&quot;REAL&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> FLOAT8OID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;result, <span class="Constant">&quot;DOUBLE&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BOOLOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;result, <span class="Constant">&quot;BOOLEAN&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TIMEOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typmod == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;result, <span class="Constant">&quot;TIME&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;result, <span class="Constant">&quot;TIME_</span><span class="Special">%d</span><span class="Constant">&quot;</span>, typmod);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TIMETZOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typmod == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;result, <span class="Constant">&quot;TIME_WTZ&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;result, <span class="Constant">&quot;TIME_WTZ_</span><span class="Special">%d</span><span class="Constant">&quot;</span>, typmod);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TIMESTAMPOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typmod == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;result, <span class="Constant">&quot;TIMESTAMP&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;result, <span class="Constant">&quot;TIMESTAMP_</span><span class="Special">%d</span><span class="Constant">&quot;</span>, typmod);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TIMESTAMPTZOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typmod == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;result, <span class="Constant">&quot;TIMESTAMP_WTZ&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;result, <span class="Constant">&quot;TIMESTAMP_WTZ_</span><span class="Special">%d</span><span class="Constant">&quot;</span>, typmod);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DATEOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;result, <span class="Constant">&quot;DATE&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XMLOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;result, <span class="Constant">&quot;XML&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_type typtuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple = <a href="../cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(TYPEOID, ObjectIdGetDatum(typeoid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for type </span><span class="Special">%u</span><span class="Constant">&quot;</span>, typeoid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typtuple = (Form_pg_type) GETSTRUCT(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L3420" title="utils/adt/xml.c:3420">map_multipart_sql_identifier_to_xml_name</a>((typtuple-&gt;typtype == TYPTYPE_DOMAIN) ? <span class="Constant">&quot;Domain&quot;</span> : <span class="Constant">&quot;UDT&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../commands/dbcommands.c.html#L3153" title="commands/dbcommands.c:3153">get_database_name</a>(<a href="../init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L3366" title="utils/cache/lsyscache.c:3366">get_namespace_name</a>(typtuple-&gt;typnamespace),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(typtuple-&gt;typname)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result.data;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Map a collection of SQL data types to XML Schema data types; see<br/></li>
<li></span><span class="Comment"> * SQL/XML:2008 section 9.7.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">const</span> <span class="Type">char</span> *<br/></li>
<li><a id="L3791">&#x200c;</a><span class="linkable">map_sql_typecoll_to_xmlschema_types</span>(List *tupdesc_list)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *uniquetypes = NIL;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; StringInfoData result;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *cell0;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* extract all column types used in the set of TupleDescs */<br/></li>
<li></span>&nbsp; &nbsp; foreach(cell0, tupdesc_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc = (TupleDesc) lfirst(cell0);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; tupdesc-&gt;natts; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att = TupleDescAttr(tupdesc, i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (att-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uniquetypes = <a href="../../nodes/list.c.html#L1380" title="nodes/list.c:1380">list_append_unique_oid</a>(uniquetypes, att-&gt;atttypid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* add base types of domains */<br/></li>
<li></span>&nbsp; &nbsp; foreach(cell0, uniquetypes)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typid = lfirst_oid(cell0);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; basetypid = <a href="../cache/lsyscache.c.html#L2521" title="utils/cache/lsyscache.c:2521">getBaseType</a>(typid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (basetypid != typid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uniquetypes = <a href="../../nodes/list.c.html#L1380" title="nodes/list.c:1380">list_append_unique_oid</a>(uniquetypes, basetypid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Convert to textual form */<br/></li>
<li></span>&nbsp; &nbsp; initStringInfo(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(cell0, uniquetypes)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;result, <span class="Constant">&quot;</span><span class="Special">%s\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L3846" title="utils/adt/xml.c:3846">map_sql_type_to_xmlschema_type</a>(lfirst_oid(cell0),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -<span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result.data;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Map an SQL data type to a named XML Schema data type; see<br/></li>
<li></span><span class="Comment"> * SQL/XML:2008 sections 9.5 and 9.6.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * (The distinction between 9.5 and 9.6 is basically that 9.6 adds<br/></li>
<li></span><span class="Comment"> * a name attribute, which this function does.&nbsp; The name-less version<br/></li>
<li></span><span class="Comment"> * 9.5 doesn't appear to be required anywhere.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">const</span> <span class="Type">char</span> *<br/></li>
<li><a id="L3846">&#x200c;</a><span class="linkable">map_sql_type_to_xmlschema_type</span>(Oid typeoid, <span class="Type">int</span> typmod)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfoData result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *typename = <a href="#L3686" title="utils/adt/xml.c:3686">map_sql_type_to_xml_name</a>(typeoid, typmod);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (typeoid == XMLOID)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&lt;xsd:complexType mixed=</span><span class="Special">\&quot;</span><span class="Constant">true</span><span class="Special">\&quot;</span><span class="Constant">&gt;</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &lt;xsd:sequence&gt;</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &nbsp; &lt;xsd:<a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> name=</span><span class="Special">\&quot;</span><span class="Constant"><a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a></span><span class="Special">\&quot;</span><span class="Constant"> minOccurs=</span><span class="Special">\&quot;</span><span class="Constant">0</span><span class="Special">\&quot;</span><span class="Constant"> maxOccurs=</span><span class="Special">\&quot;</span><span class="Constant">unbounded</span><span class="Special">\&quot;</span><span class="Constant"> processContents=</span><span class="Special">\&quot;</span><span class="Constant"><a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a></span><span class="Special">\&quot;</span><span class="Constant">/&gt;</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &lt;/xsd:sequence&gt;</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&lt;/xsd:complexType&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&lt;xsd:simpleType name=</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>, typename);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (typeoid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BPCHAROID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> VARCHAROID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TEXTOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &lt;xsd:restriction base=</span><span class="Special">\&quot;</span><span class="Constant">xsd:string</span><span class="Special">\&quot;</span><span class="Constant">&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typmod != -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &nbsp; &lt;xsd:maxLength value=</span><span class="Special">\&quot;%d\&quot;</span><span class="Constant">/&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typmod - VARHDRSZ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;result, <span class="Constant">&quot;&nbsp; &lt;/xsd:restriction&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BYTEAOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &lt;xsd:restriction base=</span><span class="Special">\&quot;</span><span class="Constant">xsd:</span><span class="Special">%s\&quot;</span><span class="Constant">&gt;</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &lt;/xsd:restriction&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L109" title="utils/adt/xml.c:109">xmlbinary</a> == XMLBINARY_BASE64 ? <span class="Constant">&quot;base64Binary&quot;</span> : <span class="Constant">&quot;hexBinary&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> NUMERICOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typmod != -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &lt;xsd:restriction base=</span><span class="Special">\&quot;</span><span class="Constant">xsd:decimal</span><span class="Special">\&quot;</span><span class="Constant">&gt;</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &nbsp; &lt;xsd:totalDigits value=</span><span class="Special">\&quot;%d\&quot;</span><span class="Constant">/&gt;</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &nbsp; &lt;xsd:fractionDigits value=</span><span class="Special">\&quot;%d\&quot;</span><span class="Constant">/&gt;</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &lt;/xsd:restriction&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ((typmod - VARHDRSZ) &gt;&gt; <span class="Constant">16</span>) &amp; <span class="Constant">0xffff</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (typmod - VARHDRSZ) &amp; <span class="Constant">0xffff</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INT2OID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &lt;xsd:restriction base=</span><span class="Special">\&quot;</span><span class="Constant">xsd:short</span><span class="Special">\&quot;</span><span class="Constant">&gt;</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &nbsp; &lt;xsd:maxInclusive value=</span><span class="Special">\&quot;%d\&quot;</span><span class="Constant">/&gt;</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &nbsp; &lt;xsd:minInclusive value=</span><span class="Special">\&quot;%d\&quot;</span><span class="Constant">/&gt;</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &lt;/xsd:restriction&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">SHRT_MAX</span>, <span class="Constant">SHRT_MIN</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INT4OID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &lt;xsd:restriction base=</span><span class="Special">\&quot;</span><span class="Constant">xsd:int</span><span class="Special">\&quot;</span><span class="Constant">&gt;</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &nbsp; &lt;xsd:maxInclusive value=</span><span class="Special">\&quot;%d\&quot;</span><span class="Constant">/&gt;</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &nbsp; &lt;xsd:minInclusive value=</span><span class="Special">\&quot;%d\&quot;</span><span class="Constant">/&gt;</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &lt;/xsd:restriction&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">INT_MAX</span>, <span class="Constant">INT_MIN</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INT8OID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &lt;xsd:restriction base=</span><span class="Special">\&quot;</span><span class="Constant">xsd:long</span><span class="Special">\&quot;</span><span class="Constant">&gt;</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &nbsp; &lt;xsd:maxInclusive value=</span><span class="Special">\&quot;</span><span class="Constant">&quot;</span> INT64_FORMAT <span class="Constant">&quot;</span><span class="Special">\&quot;</span><span class="Constant">/&gt;</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &nbsp; &lt;xsd:minInclusive value=</span><span class="Special">\&quot;</span><span class="Constant">&quot;</span> INT64_FORMAT <span class="Constant">&quot;</span><span class="Special">\&quot;</span><span class="Constant">/&gt;</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &lt;/xsd:restriction&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PG_INT64_MAX,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PG_INT64_MIN);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> FLOAT4OID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &lt;xsd:restriction base=</span><span class="Special">\&quot;</span><span class="Constant">xsd:float</span><span class="Special">\&quot;</span><span class="Constant">&gt;&lt;/xsd:restriction&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> FLOAT8OID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &lt;xsd:restriction base=</span><span class="Special">\&quot;</span><span class="Constant">xsd:double</span><span class="Special">\&quot;</span><span class="Constant">&gt;&lt;/xsd:restriction&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BOOLOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &lt;xsd:restriction base=</span><span class="Special">\&quot;</span><span class="Constant">xsd:boolean</span><span class="Special">\&quot;</span><span class="Constant">&gt;&lt;/xsd:restriction&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TIMEOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TIMETZOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *tz = (typeoid == TIMETZOID ? <span class="Constant">&quot;(</span><span class="Special">\\</span><span class="Constant">+|-)</span><span class="Special">\\</span><span class="Constant">p{Nd}{2}:</span><span class="Special">\\</span><span class="Constant">p{Nd}{2}&quot;</span> : <span class="Constant">&quot;&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typmod == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &lt;xsd:restriction base=</span><span class="Special">\&quot;</span><span class="Constant">xsd:time</span><span class="Special">\&quot;</span><span class="Constant">&gt;</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &nbsp; &lt;xsd:pattern value=</span><span class="Special">\&quot;\\</span><span class="Constant">p{Nd}{2}:</span><span class="Special">\\</span><span class="Constant">p{Nd}{2}:</span><span class="Special">\\</span><span class="Constant">p{Nd}{2}(.</span><span class="Special">\\</span><span class="Constant">p{Nd}+)?</span><span class="Special">%s\&quot;</span><span class="Constant">/&gt;</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &lt;/xsd:restriction&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>, tz);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (typmod == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &lt;xsd:restriction base=</span><span class="Special">\&quot;</span><span class="Constant">xsd:time</span><span class="Special">\&quot;</span><span class="Constant">&gt;</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &nbsp; &lt;xsd:pattern value=</span><span class="Special">\&quot;\\</span><span class="Constant">p{Nd}{2}:</span><span class="Special">\\</span><span class="Constant">p{Nd}{2}:</span><span class="Special">\\</span><span class="Constant">p{Nd}{2}</span><span class="Special">%s\&quot;</span><span class="Constant">/&gt;</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &lt;/xsd:restriction&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>, tz);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &lt;xsd:restriction base=</span><span class="Special">\&quot;</span><span class="Constant">xsd:time</span><span class="Special">\&quot;</span><span class="Constant">&gt;</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &nbsp; &lt;xsd:pattern value=</span><span class="Special">\&quot;\\</span><span class="Constant">p{Nd}{2}:</span><span class="Special">\\</span><span class="Constant">p{Nd}{2}:</span><span class="Special">\\</span><span class="Constant">p{Nd}{2}.</span><span class="Special">\\</span><span class="Constant">p{Nd}{</span><span class="Special">%d</span><span class="Constant">}</span><span class="Special">%s\&quot;</span><span class="Constant">/&gt;</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &lt;/xsd:restriction&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>, typmod - VARHDRSZ, tz);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TIMESTAMPOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TIMESTAMPTZOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *tz = (typeoid == TIMESTAMPTZOID ? <span class="Constant">&quot;(</span><span class="Special">\\</span><span class="Constant">+|-)</span><span class="Special">\\</span><span class="Constant">p{Nd}{2}:</span><span class="Special">\\</span><span class="Constant">p{Nd}{2}&quot;</span> : <span class="Constant">&quot;&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typmod == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &lt;xsd:restriction base=</span><span class="Special">\&quot;</span><span class="Constant">xsd:dateTime</span><span class="Special">\&quot;</span><span class="Constant">&gt;</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &nbsp; &lt;xsd:pattern value=</span><span class="Special">\&quot;\\</span><span class="Constant">p{Nd}{4}-</span><span class="Special">\\</span><span class="Constant">p{Nd}{2}-</span><span class="Special">\\</span><span class="Constant">p{Nd}{2}T</span><span class="Special">\\</span><span class="Constant">p{Nd}{2}:</span><span class="Special">\\</span><span class="Constant">p{Nd}{2}:</span><span class="Special">\\</span><span class="Constant">p{Nd}{2}(.</span><span class="Special">\\</span><span class="Constant">p{Nd}+)?</span><span class="Special">%s\&quot;</span><span class="Constant">/&gt;</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &lt;/xsd:restriction&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>, tz);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (typmod == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &lt;xsd:restriction base=</span><span class="Special">\&quot;</span><span class="Constant">xsd:dateTime</span><span class="Special">\&quot;</span><span class="Constant">&gt;</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &nbsp; &lt;xsd:pattern value=</span><span class="Special">\&quot;\\</span><span class="Constant">p{Nd}{4}-</span><span class="Special">\\</span><span class="Constant">p{Nd}{2}-</span><span class="Special">\\</span><span class="Constant">p{Nd}{2}T</span><span class="Special">\\</span><span class="Constant">p{Nd}{2}:</span><span class="Special">\\</span><span class="Constant">p{Nd}{2}:</span><span class="Special">\\</span><span class="Constant">p{Nd}{2}</span><span class="Special">%s\&quot;</span><span class="Constant">/&gt;</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &lt;/xsd:restriction&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>, tz);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &lt;xsd:restriction base=</span><span class="Special">\&quot;</span><span class="Constant">xsd:dateTime</span><span class="Special">\&quot;</span><span class="Constant">&gt;</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &nbsp; &lt;xsd:pattern value=</span><span class="Special">\&quot;\\</span><span class="Constant">p{Nd}{4}-</span><span class="Special">\\</span><span class="Constant">p{Nd}{2}-</span><span class="Special">\\</span><span class="Constant">p{Nd}{2}T</span><span class="Special">\\</span><span class="Constant">p{Nd}{2}:</span><span class="Special">\\</span><span class="Constant">p{Nd}{2}:</span><span class="Special">\\</span><span class="Constant">p{Nd}{2}.</span><span class="Special">\\</span><span class="Constant">p{Nd}{</span><span class="Special">%d</span><span class="Constant">}</span><span class="Special">%s\&quot;</span><span class="Constant">/&gt;</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &lt;/xsd:restriction&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>, typmod - VARHDRSZ, tz);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DATEOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &lt;xsd:restriction base=</span><span class="Special">\&quot;</span><span class="Constant">xsd:date</span><span class="Special">\&quot;</span><span class="Constant">&gt;</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &nbsp; &lt;xsd:pattern value=</span><span class="Special">\&quot;\\</span><span class="Constant">p{Nd}{4}-</span><span class="Special">\\</span><span class="Constant">p{Nd}{2}-</span><span class="Special">\\</span><span class="Constant">p{Nd}{2}</span><span class="Special">\&quot;</span><span class="Constant">/&gt;</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &lt;/xsd:restriction&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../cache/lsyscache.c.html#L2629" title="utils/cache/lsyscache.c:2629">get_typtype</a>(typeoid) == TYPTYPE_DOMAIN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; base_typeoid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; base_typmod = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; base_typeoid = <a href="../cache/lsyscache.c.html#L2538" title="utils/cache/lsyscache.c:2538">getBaseTypeAndTypmod</a>(typeoid, &amp;base_typmod);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;&nbsp; &lt;xsd:restriction base=</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">/&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L3686" title="utils/adt/xml.c:3686">map_sql_type_to_xml_name</a>(base_typeoid, base_typmod));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;result, <span class="Constant">&quot;&lt;/xsd:simpleType&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result.data;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Map an SQL row to an XML <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>, taking the row from the active<br/></li>
<li></span><span class="Comment"> * SPI cursor.&nbsp; See also SQL/XML:2008 section 9.10.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4021">&#x200c;</a></span><span class="linkable">SPI_sql_row_to_xmlelement</span>(uint64 rownum, StringInfo result, <span class="Type">char</span> *tablename,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nulls, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> tableforest,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *targetns, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> top_level)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *xmltn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tablename)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xmltn = <a href="#L2315" title="utils/adt/xml.c:2315">map_sql_identifier_to_xml_name</a>(tablename, <span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tableforest)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmltn = <span class="Constant">&quot;row&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmltn = <span class="Constant">&quot;table&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tableforest)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2902" title="utils/adt/xml.c:2902">xmldata_root_element_start</a>(result, xmltn, <span class="Constant">NULL</span>, targetns, top_level);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(result, <span class="Constant">&quot;&lt;row&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt;= <a href="../../executor/spi.c.html#L45" title="executor/spi.c:45">SPI_tuptable</a>-&gt;tupdesc-&gt;natts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *colname;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; colval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; colname = <a href="#L2315" title="utils/adt/xml.c:2315">map_sql_identifier_to_xml_name</a>(<a href="../../executor/spi.c.html#L1195" title="executor/spi.c:1195">SPI_fname</a>(<a href="../../executor/spi.c.html#L45" title="executor/spi.c:45">SPI_tuptable</a>-&gt;tupdesc, i),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; colval = <a href="../../executor/spi.c.html#L1249" title="executor/spi.c:1249">SPI_getbinval</a>(<a href="../../executor/spi.c.html#L45" title="executor/spi.c:45">SPI_tuptable</a>-&gt;vals[rownum],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../executor/spi.c.html#L45" title="executor/spi.c:45">SPI_tuptable</a>-&gt;tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nulls)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(result, <span class="Constant">&quot;&nbsp; &lt;</span><span class="Special">%s</span><span class="Constant"> xsi:nil=</span><span class="Special">\&quot;</span><span class="Constant">true</span><span class="Special">\&quot;</span><span class="Constant">/&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>, colname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(result, <span class="Constant">&quot;&nbsp; &lt;</span><span class="Special">%s</span><span class="Constant">&gt;</span><span class="Special">%s</span><span class="Constant">&lt;/</span><span class="Special">%s</span><span class="Constant">&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; colname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L2413" title="utils/adt/xml.c:2413">map_sql_value_to_xml_value</a>(colval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/spi.c.html#L1305" title="executor/spi.c:1305">SPI_gettypeid</a>(<a href="../../executor/spi.c.html#L45" title="executor/spi.c:45">SPI_tuptable</a>-&gt;tupdesc, i), <span class="Constant">true</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; colname);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tableforest)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2929" title="utils/adt/xml.c:2929">xmldata_root_element_end</a>(result, xmltn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(result, <span class="Special">'\n'</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(result, <span class="Constant">&quot;&lt;/row&gt;</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * XPath related <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef USE_LIBXML<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert XML node to text.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For attribute and text nodes, return the escaped text.&nbsp; For anything else,<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a> the whole subtree.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> text *<br/></li>
<li><a id="L4091">&#x200c;</a><span class="linkable">xml_xmlnodetoxmltype</span>(xmlNodePtr cur, <a href="#L117" title="utils/adt/xml.c:117">PgXmlErrorContext</a> *xmlerrcxt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; xmltype&nbsp; &nbsp; *result = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cur-&gt;type != XML_ATTRIBUTE_NODE &amp;&amp; cur-&gt;type != XML_TEXT_NODE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp; &nbsp; (*<span class="Type">volatile</span> nodefree) (xmlNodePtr) = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">volatile</span> xmlBufferPtr buf = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">volatile</span> xmlNodePtr cur_copy = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_TRY();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bytes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf = xmlBufferCreate();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (buf == <span class="Constant">NULL</span> || xmlerrcxt-&gt;err_occurred)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1970" title="utils/adt/xml.c:1970">xml_ereport</a>(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;could not allocate xmlBuffer&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Produce a <a href="../../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a> of the node that we can serialize.&nbsp; xmlNodeDump<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * does that, but the result of that function won't contain<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * namespace definitions from ancestor nodes, so we first do a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * xmlCopyNode() which duplicates the node along with its required<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * namespace definitions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Some old libxml2 versions such as 2.7.6 produce partially<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * broken XML_DOCUMENT_NODE nodes (unset content field) when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * copying them.&nbsp; xmlNodeDump of such a node works fine, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * xmlFreeNode crashes; set us up to call xmlFreeDoc instead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cur_copy = xmlCopyNode(cur, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cur_copy == <span class="Constant">NULL</span> || xmlerrcxt-&gt;err_occurred)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1970" title="utils/adt/xml.c:1970">xml_ereport</a>(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;could not copy node&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nodefree = (cur_copy-&gt;type == XML_DOCUMENT_NODE) ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span> (*) (xmlNodePtr)) xmlFreeDoc : xmlFreeNode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bytes = xmlNodeDump(buf, <span class="Constant">NULL</span>, cur_copy, <span class="Constant">0</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bytes == -<span class="Constant">1</span> || xmlerrcxt-&gt;err_occurred)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1970" title="utils/adt/xml.c:1970">xml_ereport</a>(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;could not <a href="../../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a> node&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L482" title="utils/adt/xml.c:482">xmlBuffer_to_xmltype</a>(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_FINALLY();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nodefree)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nodefree(cur_copy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (buf)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmlBufferFree(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_END_TRY();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xmlChar&nbsp; &nbsp; *str;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; str = xmlXPathCastNodeToString(cur);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_TRY();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Here we rely on XML having the same representation as TEXT */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *escaped = <a href="#L2632" title="utils/adt/xml.c:2632">escape_xml</a>((<span class="Type">char</span> *) str);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = (xmltype *) <a href="varlena.c.html#L184" title="utils/adt/varlena.c:184">cstring_to_text</a>(escaped);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(escaped);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_FINALLY();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmlFree(str);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_END_TRY();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert an XML XPath object (the result of evaluating an XPath expression)<br/></li>
<li></span><span class="Comment"> * to an array of xml <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, which are appended to astate.&nbsp; The function<br/></li>
<li></span><span class="Comment"> * result value is the number of elements in the array.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If &quot;astate&quot; is NULL then we don't generate the array value, but we still<br/></li>
<li></span><span class="Comment"> * return the number of elements it would have had.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Nodesets are converted to an array containing the nodes' textual<br/></li>
<li></span><span class="Comment"> * representations.&nbsp; Primitive <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> (float, double, string) are converted<br/></li>
<li></span><span class="Comment"> * to a single-<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> array containing the value's string representation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L4181">&#x200c;</a></span><span class="linkable">xml_xpathobjtoxmlarray</span>(xmlXPathObjectPtr xpathobj,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ArrayBuildState *astate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L117" title="utils/adt/xml.c:117">PgXmlErrorContext</a> *xmlerrcxt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; datum;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datumtype;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *result_str;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (xpathobj-&gt;type)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XPATH_NODESET:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xpathobj-&gt;nodesetval != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = xpathobj-&gt;nodesetval-&gt;nodeNr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (astate != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; result; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datum = PointerGetDatum(<a href="#L4091" title="utils/adt/xml.c:4091">xml_xmlnodetoxmltype</a>(xpathobj-&gt;nodesetval-&gt;nodeTab[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xmlerrcxt));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="arrayfuncs.c.html#L5331" title="utils/adt/arrayfuncs.c:5331">accumArrayResult</a>(astate, datum, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XMLOID, <a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XPATH_BOOLEAN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (astate == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datum = BoolGetDatum(xpathobj-&gt;boolval);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datumtype = BOOLOID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XPATH_NUMBER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (astate == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datum = <a href="../fmgr/fmgr.c.html#L1816" title="utils/fmgr/fmgr.c:1816">Float8GetDatum</a>(xpathobj-&gt;floatval);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datumtype = FLOAT8OID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XPATH_STRING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (astate == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datum = CStringGetDatum((<span class="Type">char</span> *) xpathobj-&gt;stringval);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datumtype = CSTRINGOID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L4450" title="utils/adt/xml.c:4450">xpath</a> expression result type </span><span class="Special">%d</span><span class="Constant"> is unsupported&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xpathobj-&gt;type);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Common code for scalar-value cases */<br/></li>
<li></span>&nbsp; &nbsp; result_str = <a href="#L2413" title="utils/adt/xml.c:2413">map_sql_value_to_xml_value</a>(datum, datumtype, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; datum = PointerGetDatum(<a href="#L474" title="utils/adt/xml.c:474">cstring_to_xmltype</a>(result_str));<br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="arrayfuncs.c.html#L5331" title="utils/adt/arrayfuncs.c:5331">accumArrayResult</a>(astate, datum, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XMLOID, <a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Common code for <a href="#L4450" title="utils/adt/xml.c:4450">xpath</a>() and <a href="#L4473" title="utils/adt/xml.c:4473">xmlexists</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Evaluate XPath expression and return number of nodes in res_nitems<br/></li>
<li></span><span class="Comment"> * and array of XML <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in astate.&nbsp; Either of those pointers can be<br/></li>
<li></span><span class="Comment"> * NULL if the corresponding result isn't wanted.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It is up to the user to ensure that the XML passed is in fact<br/></li>
<li></span><span class="Comment"> * an XML document - XPath doesn't work easily on fragments without<br/></li>
<li></span><span class="Comment"> * a context node being known.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4259">&#x200c;</a></span><span class="linkable">xpath_internal</span>(text *xpath_expr_text, xmltype *data, ArrayType *namespaces,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> *res_nitems, ArrayBuildState *astate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L117" title="utils/adt/xml.c:117">PgXmlErrorContext</a> *xmlerrcxt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">volatile</span> xmlParserCtxtPtr ctxt = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">volatile</span> xmlDocPtr doc = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">volatile</span> xmlXPathContextPtr xpathctx = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">volatile</span> xmlXPathCompExprPtr xpathcomp = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">volatile</span> xmlXPathObjectPtr xpathobj = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *datastr;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; xpath_len;<br/></li>
<li>&nbsp; &nbsp; xmlChar&nbsp; &nbsp; *string;<br/></li>
<li>&nbsp; &nbsp; xmlChar&nbsp; &nbsp; *xpath_expr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; xmldecl_len = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndim;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *ns_names_uris;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *ns_names_uris_nulls;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ns_count;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Namespace mappings are passed as text[].&nbsp; If an empty array is passed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (ndim = 0, &quot;0-dimensional&quot;), then there are no namespace mappings.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Else, a 2-dimensional array with length of the second axis being <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to 2 should be passed, i.e., every subarray contains 2 elements, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * first <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> defining the name, the second one the URI.&nbsp; Example:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ARRAY[ARRAY['myns', 'http://example.com'], ARRAY['myns2',<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 'http://example2.com']].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ndim = namespaces ? ARR_NDIM(namespaces) : <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ndim != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *dims;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dims = ARR_DIMS(namespaces);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ndim != <span class="Constant">2</span> || dims[<span class="Constant">1</span>] != <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_EXCEPTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid array for XML namespace mapping&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;The array must be two-dimensional with length of the second axis <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to 2.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(ARR_ELEMTYPE(namespaces) == TEXTOID);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="arrayfuncs.c.html#L3678" title="utils/adt/arrayfuncs.c:3678">deconstruct_array_builtin</a>(namespaces, TEXTOID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;ns_names_uris, &amp;ns_names_uris_nulls,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;ns_count);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert((ns_count % <span class="Constant">2</span>) == <span class="Constant">0</span>);&nbsp; &nbsp; <span class="Comment">/* checked above */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ns_count /= <span class="Constant">2</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* count pairs only */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ns_names_uris = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ns_names_uris_nulls = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ns_count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; datastr = VARDATA(data);<br/></li>
<li>&nbsp; &nbsp; len = VARSIZE(data) - VARHDRSZ;<br/></li>
<li>&nbsp; &nbsp; xpath_len = VARSIZE_ANY_EXHDR(xpath_expr_text);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xpath_len == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_EXCEPTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;empty XPath expression&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; string = <a href="#L1354" title="utils/adt/xml.c:1354">pg_xmlCharStrndup</a>(datastr, len);<br/></li>
<li>&nbsp; &nbsp; xpath_expr = <a href="#L1354" title="utils/adt/xml.c:1354">pg_xmlCharStrndup</a>(VARDATA_ANY(xpath_expr_text), xpath_len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In a UTF8 database, <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> xml declaration, which might assert<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * another encoding.&nbsp; Ignore <a href="#L1400" title="utils/adt/xml.c:1400">parse_xml_decl</a>() failure, letting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * xmlCtxtReadMemory() report <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> errors.&nbsp; Documentation disclaims<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L4450" title="utils/adt/xml.c:4450">xpath</a>() support for non-ASCII data in non-UTF8 databases, so leave<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * those scenarios bug-compatible with historical behavior.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../mb/mbutils.c.html#L1261" title="utils/mb/mbutils.c:1261">GetDatabaseEncoding</a>() == PG_UTF8)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1400" title="utils/adt/xml.c:1400">parse_xml_decl</a>(string, &amp;xmldecl_len, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xmlerrcxt = <a href="#L1178" title="utils/adt/xml.c:1178">pg_xml_init</a>(PG_XML_STRICTNESS_ALL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_TRY();<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xmlInitParser();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * redundant XML parsing (two parsings for the same value during one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * command execution are possible)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ctxt = xmlNewParserCtxt();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ctxt == <span class="Constant">NULL</span> || xmlerrcxt-&gt;err_occurred)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1970" title="utils/adt/xml.c:1970">xml_ereport</a>(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;could not allocate parser context&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; doc = xmlCtxtReadMemory(ctxt, (<span class="Type">char</span> *) string + xmldecl_len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len - xmldecl_len, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (doc == <span class="Constant">NULL</span> || xmlerrcxt-&gt;err_occurred)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1970" title="utils/adt/xml.c:1970">xml_ereport</a>(xmlerrcxt, ERROR, ERRCODE_INVALID_XML_DOCUMENT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;could not <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> XML document&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xpathctx = xmlXPathNewContext(doc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xpathctx == <span class="Constant">NULL</span> || xmlerrcxt-&gt;err_occurred)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1970" title="utils/adt/xml.c:1970">xml_ereport</a>(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;could not allocate XPath context&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xpathctx-&gt;node = (xmlNodePtr) doc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* register namespaces, if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ns_count &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; ns_count; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ns_name;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ns_uri;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ns_names_uris_nulls[i * <span class="Constant">2</span>] ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ns_names_uris_nulls[i * <span class="Constant">2</span> + <span class="Constant">1</span>])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NULL_VALUE_NOT_ALLOWED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;neither namespace name nor URI may be null&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ns_name = TextDatumGetCString(ns_names_uris[i * <span class="Constant">2</span>]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ns_uri = TextDatumGetCString(ns_names_uris[i * <span class="Constant">2</span> + <span class="Constant">1</span>]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xmlXPathRegisterNs(xpathctx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (xmlChar *) ns_name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (xmlChar *) ns_uri) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,&nbsp; &nbsp; <span class="Comment">/* is this an <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> error??? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not register XML namespace with name </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> and URI </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ns_name, ns_uri)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xpathcomp = xmlXPathCompile(xpath_expr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xpathcomp == <span class="Constant">NULL</span> || xmlerrcxt-&gt;err_occurred)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1970" title="utils/adt/xml.c:1970">xml_ereport</a>(xmlerrcxt, ERROR, ERRCODE_INTERNAL_ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;invalid XPath expression&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Version 2.6.27 introduces a function named<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * xmlXPathCompiledEvalToBoolean, which would be enough for <a href="#L4473" title="utils/adt/xml.c:4473">xmlexists</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but we can derive the existence by whether <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> nodes are returned,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * thereby preventing a library version upgrade and keeping the code<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the same.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; xpathobj = xmlXPathCompiledEval(xpathcomp, xpathctx);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xpathobj == <span class="Constant">NULL</span> || xmlerrcxt-&gt;err_occurred)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1970" title="utils/adt/xml.c:1970">xml_ereport</a>(xmlerrcxt, ERROR, ERRCODE_INTERNAL_ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;could not create XPath object&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Extract the results as requested.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (res_nitems != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *res_nitems = <a href="#L4181" title="utils/adt/xml.c:4181">xml_xpathobjtoxmlarray</a>(xpathobj, astate, xmlerrcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L4181" title="utils/adt/xml.c:4181">xml_xpathobjtoxmlarray</a>(xpathobj, astate, xmlerrcxt);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_CATCH();<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xpathobj)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmlXPathFreeObject(xpathobj);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xpathcomp)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmlXPathFreeCompExpr(xpathcomp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xpathctx)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmlXPathFreeContext(xpathctx);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (doc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmlFreeDoc(doc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ctxt)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmlFreeParserCtxt(ctxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1259" title="utils/adt/xml.c:1259">pg_xml_done</a>(xmlerrcxt, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RE_THROW();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_END_TRY();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xmlXPathFreeObject(xpathobj);<br/></li>
<li>&nbsp; &nbsp; xmlXPathFreeCompExpr(xpathcomp);<br/></li>
<li>&nbsp; &nbsp; xmlXPathFreeContext(xpathctx);<br/></li>
<li>&nbsp; &nbsp; xmlFreeDoc(doc);<br/></li>
<li>&nbsp; &nbsp; xmlFreeParserCtxt(ctxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1259" title="utils/adt/xml.c:1259">pg_xml_done</a>(xmlerrcxt, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* USE_LIBXML */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Evaluate XPath expression and return array of XML <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As we have no support of XQuery sequences yet, this function seems<br/></li>
<li></span><span class="Comment"> * to be the most useful one (array of XML <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> plays a role of<br/></li>
<li></span><span class="Comment"> * some kind of substitution for XQuery sequences).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4450">&#x200c;</a><span class="linkable">xpath</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef USE_LIBXML<br/></li>
<li></span>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *xpath_expr_text = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; xmltype&nbsp; &nbsp; *data = PG_GETARG_XML_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *namespaces = PG_GETARG_ARRAYTYPE_P(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; ArrayBuildState *astate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; astate = <a href="arrayfuncs.c.html#L5274" title="utils/adt/arrayfuncs.c:5274">initArrayResult</a>(XMLOID, <a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L4259" title="utils/adt/xml.c:4259">xpath_internal</a>(xpath_expr_text, data, namespaces,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>, astate);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_DATUM(<a href="arrayfuncs.c.html#L5401" title="utils/adt/arrayfuncs.c:5401">makeArrayResult</a>(astate, <a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>));<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L235" title="utils/adt/xml.c:235">NO_XML_SUPPORT</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Determines if the node specified by the supplied XPath exists<br/></li>
<li></span><span class="Comment"> * in a given XML document, returning a boolean.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4473">&#x200c;</a><span class="linkable">xmlexists</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef USE_LIBXML<br/></li>
<li></span>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *xpath_expr_text = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; xmltype&nbsp; &nbsp; *data = PG_GETARG_XML_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res_nitems;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L4259" title="utils/adt/xml.c:4259">xpath_internal</a>(xpath_expr_text, data, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;res_nitems, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(res_nitems &gt; <span class="Constant">0</span>);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L235" title="utils/adt/xml.c:235">NO_XML_SUPPORT</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Determines if the node specified by the supplied XPath exists<br/></li>
<li></span><span class="Comment"> * in a given XML document, returning a boolean. Differs from<br/></li>
<li></span><span class="Comment"> * <a href="#L4473" title="utils/adt/xml.c:4473">xmlexists</a> as it supports namespaces and is not defined in SQL/XML.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4496">&#x200c;</a><span class="linkable">xpath_exists</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef USE_LIBXML<br/></li>
<li></span>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *xpath_expr_text = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; xmltype&nbsp; &nbsp; *data = PG_GETARG_XML_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *namespaces = PG_GETARG_ARRAYTYPE_P(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res_nitems;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L4259" title="utils/adt/xml.c:4259">xpath_internal</a>(xpath_expr_text, data, namespaces,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;res_nitems, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(res_nitems &gt; <span class="Constant">0</span>);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L235" title="utils/adt/xml.c:235">NO_XML_SUPPORT</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Functions for checking well-formed-ness<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef USE_LIBXML<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L4520">&#x200c;</a></span><span class="linkable">wellformed_xml</span>(text *data, XmlOptionType xmloption_arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; xmlDocPtr&nbsp; &nbsp; doc;<br/></li>
<li>&nbsp; &nbsp; ErrorSaveContext escontext = {T_ErrorSaveContext};<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We'll report &quot;true&quot; if no soft error is reported by <a href="#L1715" title="utils/adt/xml.c:1715">xml_parse</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; doc = <a href="#L1715" title="utils/adt/xml.c:1715">xml_parse</a>(data, xmloption_arg, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mb/mbutils.c.html#L1261" title="utils/mb/mbutils.c:1261">GetDatabaseEncoding</a>(), <span class="Constant">NULL</span>, <span class="Constant">NULL</span>, (Node *) &amp;escontext);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (doc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xmlFreeDoc(doc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> !escontext.error_occurred;<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L4538">&#x200c;</a><span class="linkable">xml_is_well_formed</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef USE_LIBXML<br/></li>
<li></span>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *data = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L4520" title="utils/adt/xml.c:4520">wellformed_xml</a>(data, <a href="#L110" title="utils/adt/xml.c:110">xmloption</a>));<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L235" title="utils/adt/xml.c:235">NO_XML_SUPPORT</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not USE_LIBXML */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L4551">&#x200c;</a><span class="linkable">xml_is_well_formed_document</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef USE_LIBXML<br/></li>
<li></span>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *data = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L4520" title="utils/adt/xml.c:4520">wellformed_xml</a>(data, XMLOPTION_DOCUMENT));<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L235" title="utils/adt/xml.c:235">NO_XML_SUPPORT</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not USE_LIBXML */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L4564">&#x200c;</a><span class="linkable">xml_is_well_formed_content</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef USE_LIBXML<br/></li>
<li></span>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *data = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L4520" title="utils/adt/xml.c:4520">wellformed_xml</a>(data, XMLOPTION_CONTENT));<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L235" title="utils/adt/xml.c:235">NO_XML_SUPPORT</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not USE_LIBXML */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * support <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for XMLTABLE<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#ifdef USE_LIBXML<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns private data from executor state. Ensure validity by check with<br/></li>
<li></span><span class="Comment"> * MAGIC number.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <a href="#L196" title="utils/adt/xml.c:196">XmlTableBuilderData</a> *<br/></li>
<li><a id="L4587">&#x200c;</a><span class="linkable">GetXmlTableBuilderPrivateData</span>(TableFuncScanState *state, <span class="Type">const</span> <span class="Type">char</span> *fname)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L196" title="utils/adt/xml.c:196">XmlTableBuilderData</a> *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!IsA(state, TableFuncScanState))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> called with invalid TableFuncScanState&quot;</span>, fname);<br/></li>
<li>&nbsp; &nbsp; result = (<a href="#L196" title="utils/adt/xml.c:196">XmlTableBuilderData</a> *) state-&gt;opaque;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result-&gt;magic != <a href="#L195" title="utils/adt/xml.c:195">XMLTABLE_CONTEXT_MAGIC</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> called with invalid TableFuncScanState&quot;</span>, fname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4613" title="utils/adt/xml.c:4613">XmlTableInitOpaque</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Fill in TableFuncScanState-&gt;opaque for XmlTable processor; <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; the XML parser.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: Because we call <a href="#L1178" title="utils/adt/xml.c:1178">pg_xml_init</a>() here and <a href="#L1259" title="utils/adt/xml.c:1259">pg_xml_done</a>() in<br/></li>
<li></span><span class="Comment"> * <a href="#L5002" title="utils/adt/xml.c:5002">XmlTableDestroyOpaque</a>, it is critical for robustness that no other<br/></li>
<li></span><span class="Comment"> * executor nodes run until this node is processed to completion.&nbsp; Caller<br/></li>
<li></span><span class="Comment"> * must execute this to completion (probably filling a tuplestore to exhaust<br/></li>
<li></span><span class="Comment"> * this node in a single pass) instead of using row-per-call mode.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4613">&#x200c;</a></span><span class="linkable">XmlTableInitOpaque</span>(TableFuncScanState *state, <span class="Type">int</span> natts)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef USE_LIBXML<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">volatile</span> xmlParserCtxtPtr ctxt = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L196" title="utils/adt/xml.c:196">XmlTableBuilderData</a> *xtCxt;<br/></li>
<li>&nbsp; &nbsp; <a href="#L117" title="utils/adt/xml.c:117">PgXmlErrorContext</a> *xmlerrcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xtCxt = <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L196" title="utils/adt/xml.c:196">XmlTableBuilderData</a>));<br/></li>
<li>&nbsp; &nbsp; xtCxt-&gt;magic = <a href="#L195" title="utils/adt/xml.c:195">XMLTABLE_CONTEXT_MAGIC</a>;<br/></li>
<li>&nbsp; &nbsp; xtCxt-&gt;natts = natts;<br/></li>
<li>&nbsp; &nbsp; xtCxt-&gt;xpathscomp = <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(xmlXPathCompExprPtr) * natts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xmlerrcxt = <a href="#L1178" title="utils/adt/xml.c:1178">pg_xml_init</a>(PG_XML_STRICTNESS_ALL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_TRY();<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xmlInitParser();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ctxt = xmlNewParserCtxt();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ctxt == <span class="Constant">NULL</span> || xmlerrcxt-&gt;err_occurred)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1970" title="utils/adt/xml.c:1970">xml_ereport</a>(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;could not allocate parser context&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_CATCH();<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ctxt != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmlFreeParserCtxt(ctxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1259" title="utils/adt/xml.c:1259">pg_xml_done</a>(xmlerrcxt, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RE_THROW();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_END_TRY();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xtCxt-&gt;xmlerrcxt = xmlerrcxt;<br/></li>
<li>&nbsp; &nbsp; xtCxt-&gt;ctxt = ctxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;opaque = xtCxt;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L235" title="utils/adt/xml.c:235">NO_XML_SUPPORT</a>();<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not USE_LIBXML */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4661" title="utils/adt/xml.c:4661">XmlTableSetDocument</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Install the input document<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4661">&#x200c;</a></span><span class="linkable">XmlTableSetDocument</span>(TableFuncScanState *state, Datum value)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef USE_LIBXML<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L196" title="utils/adt/xml.c:196">XmlTableBuilderData</a> *xtCxt;<br/></li>
<li>&nbsp; &nbsp; xmltype&nbsp; &nbsp; *xmlval = DatumGetXmlP(value);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *str;<br/></li>
<li>&nbsp; &nbsp; xmlChar&nbsp; &nbsp; *xstr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; length;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">volatile</span> xmlDocPtr doc = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">volatile</span> xmlXPathContextPtr xpathcxt = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xtCxt = <a href="#L4587" title="utils/adt/xml.c:4587">GetXmlTableBuilderPrivateData</a>(state, <span class="Constant">&quot;<a href="#L4661" title="utils/adt/xml.c:4661">XmlTableSetDocument</a>&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Use out function for casting to string (remove encoding property). See<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * comment in <a href="#L356" title="utils/adt/xml.c:356">xml_out</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; str = <a href="#L312" title="utils/adt/xml.c:312">xml_out_internal</a>(xmlval, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; length = strlen(str);<br/></li>
<li>&nbsp; &nbsp; xstr = <a href="#L1354" title="utils/adt/xml.c:1354">pg_xmlCharStrndup</a>(str, length);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_TRY();<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; doc = xmlCtxtReadMemory(xtCxt-&gt;ctxt, (<span class="Type">char</span> *) xstr, length, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (doc == <span class="Constant">NULL</span> || xtCxt-&gt;xmlerrcxt-&gt;err_occurred)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1970" title="utils/adt/xml.c:1970">xml_ereport</a>(xtCxt-&gt;xmlerrcxt, ERROR, ERRCODE_INVALID_XML_DOCUMENT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;could not <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> XML document&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xpathcxt = xmlXPathNewContext(doc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xpathcxt == <span class="Constant">NULL</span> || xtCxt-&gt;xmlerrcxt-&gt;err_occurred)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1970" title="utils/adt/xml.c:1970">xml_ereport</a>(xtCxt-&gt;xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;could not allocate XPath context&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xpathcxt-&gt;node = (xmlNodePtr) doc;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_CATCH();<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xpathcxt != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmlXPathFreeContext(xpathcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (doc != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmlFreeDoc(doc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RE_THROW();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_END_TRY();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xtCxt-&gt;doc = doc;<br/></li>
<li>&nbsp; &nbsp; xtCxt-&gt;xpathcxt = xpathcxt;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L235" title="utils/adt/xml.c:235">NO_XML_SUPPORT</a>();<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not USE_LIBXML */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4718" title="utils/adt/xml.c:4718">XmlTableSetNamespace</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Add a namespace declaration<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4718">&#x200c;</a></span><span class="linkable">XmlTableSetNamespace</span>(TableFuncScanState *state, <span class="Type">const</span> <span class="Type">char</span> *name, <span class="Type">const</span> <span class="Type">char</span> *uri)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef USE_LIBXML<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L196" title="utils/adt/xml.c:196">XmlTableBuilderData</a> *xtCxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (name == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;DEFAULT namespace is not supported&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; xtCxt = <a href="#L4587" title="utils/adt/xml.c:4587">GetXmlTableBuilderPrivateData</a>(state, <span class="Constant">&quot;<a href="#L4718" title="utils/adt/xml.c:4718">XmlTableSetNamespace</a>&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xmlXPathRegisterNs(xtCxt-&gt;xpathcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L1354" title="utils/adt/xml.c:1354">pg_xmlCharStrndup</a>(name, strlen(name)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L1354" title="utils/adt/xml.c:1354">pg_xmlCharStrndup</a>(uri, strlen(uri))))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1970" title="utils/adt/xml.c:1970">xml_ereport</a>(xtCxt-&gt;xmlerrcxt, ERROR, ERRCODE_DATA_EXCEPTION,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;could not set XML namespace&quot;</span>);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L235" title="utils/adt/xml.c:235">NO_XML_SUPPORT</a>();<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not USE_LIBXML */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4744" title="utils/adt/xml.c:4744">XmlTableSetRowFilter</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Install the row-filter Xpath expression.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4744">&#x200c;</a></span><span class="linkable">XmlTableSetRowFilter</span>(TableFuncScanState *state, <span class="Type">const</span> <span class="Type">char</span> *path)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef USE_LIBXML<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L196" title="utils/adt/xml.c:196">XmlTableBuilderData</a> *xtCxt;<br/></li>
<li>&nbsp; &nbsp; xmlChar&nbsp; &nbsp; *xstr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xtCxt = <a href="#L4587" title="utils/adt/xml.c:4587">GetXmlTableBuilderPrivateData</a>(state, <span class="Constant">&quot;<a href="#L4744" title="utils/adt/xml.c:4744">XmlTableSetRowFilter</a>&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*path == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_EXCEPTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;row path filter must not be empty string&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xstr = <a href="#L1354" title="utils/adt/xml.c:1354">pg_xmlCharStrndup</a>(path, strlen(path));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xtCxt-&gt;xpathcomp = xmlXPathCompile(xstr);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xtCxt-&gt;xpathcomp == <span class="Constant">NULL</span> || xtCxt-&gt;xmlerrcxt-&gt;err_occurred)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1970" title="utils/adt/xml.c:1970">xml_ereport</a>(xtCxt-&gt;xmlerrcxt, ERROR, ERRCODE_SYNTAX_ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;invalid XPath expression&quot;</span>);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L235" title="utils/adt/xml.c:235">NO_XML_SUPPORT</a>();<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not USE_LIBXML */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4773" title="utils/adt/xml.c:4773">XmlTableSetColumnFilter</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Install the column-filter Xpath expression, for the given column.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4773">&#x200c;</a></span><span class="linkable">XmlTableSetColumnFilter</span>(TableFuncScanState *state, <span class="Type">const</span> <span class="Type">char</span> *path, <span class="Type">int</span> colnum)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef USE_LIBXML<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L196" title="utils/adt/xml.c:196">XmlTableBuilderData</a> *xtCxt;<br/></li>
<li>&nbsp; &nbsp; xmlChar&nbsp; &nbsp; *xstr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(PointerIsValid(path));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xtCxt = <a href="#L4587" title="utils/adt/xml.c:4587">GetXmlTableBuilderPrivateData</a>(state, <span class="Constant">&quot;<a href="#L4773" title="utils/adt/xml.c:4773">XmlTableSetColumnFilter</a>&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*path == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_EXCEPTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column path filter must not be empty string&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xstr = <a href="#L1354" title="utils/adt/xml.c:1354">pg_xmlCharStrndup</a>(path, strlen(path));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xtCxt-&gt;xpathscomp[colnum] = xmlXPathCompile(xstr);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xtCxt-&gt;xpathscomp[colnum] == <span class="Constant">NULL</span> || xtCxt-&gt;xmlerrcxt-&gt;err_occurred)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1970" title="utils/adt/xml.c:1970">xml_ereport</a>(xtCxt-&gt;xmlerrcxt, ERROR, ERRCODE_DATA_EXCEPTION,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;invalid XPath expression&quot;</span>);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L235" title="utils/adt/xml.c:235">NO_XML_SUPPORT</a>();<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not USE_LIBXML */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4805" title="utils/adt/xml.c:4805">XmlTableFetchRow</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Prepare the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> &quot;current&quot; tuple for upcoming GetValue calls.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns false if the row-filter expression returned no more rows.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L4805">&#x200c;</a></span><span class="linkable">XmlTableFetchRow</span>(TableFuncScanState *state)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef USE_LIBXML<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L196" title="utils/adt/xml.c:196">XmlTableBuilderData</a> *xtCxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xtCxt = <a href="#L4587" title="utils/adt/xml.c:4587">GetXmlTableBuilderPrivateData</a>(state, <span class="Constant">&quot;<a href="#L4805" title="utils/adt/xml.c:4805">XmlTableFetchRow</a>&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Propagate our own error context to libxml2 */<br/></li>
<li></span>&nbsp; &nbsp; xmlSetStructuredErrorFunc((<span class="Type">void</span> *) xtCxt-&gt;xmlerrcxt, <a href="#L2036" title="utils/adt/xml.c:2036">xml_errorHandler</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xtCxt-&gt;xpathobj == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xtCxt-&gt;xpathobj = xmlXPathCompiledEval(xtCxt-&gt;xpathcomp, xtCxt-&gt;xpathcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xtCxt-&gt;xpathobj == <span class="Constant">NULL</span> || xtCxt-&gt;xmlerrcxt-&gt;err_occurred)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1970" title="utils/adt/xml.c:1970">xml_ereport</a>(xtCxt-&gt;xmlerrcxt, ERROR, ERRCODE_INTERNAL_ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;could not create XPath object&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xtCxt-&gt;row_count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xtCxt-&gt;xpathobj-&gt;type == XPATH_NODESET)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xtCxt-&gt;xpathobj-&gt;nodesetval != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xtCxt-&gt;row_count++ &lt; xtCxt-&gt;xpathobj-&gt;nodesetval-&gt;nodeNr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L235" title="utils/adt/xml.c:235">NO_XML_SUPPORT</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not USE_LIBXML */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4850" title="utils/adt/xml.c:4850">XmlTableGetValue</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Return the value for column number 'colnum' for the current row.&nbsp; If<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; column -1 is requested, return representation of the whole row.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This leaks memory, so be sure to reset often the context in which it's<br/></li>
<li></span><span class="Comment"> * called.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Datum<br/></li>
<li><a id="L4850">&#x200c;</a><span class="linkable">XmlTableGetValue</span>(TableFuncScanState *state, <span class="Type">int</span> colnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid typid, int32 typmod, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef USE_LIBXML<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L196" title="utils/adt/xml.c:196">XmlTableBuilderData</a> *xtCxt;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; xmlNodePtr&nbsp; &nbsp; cur;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *cstr = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">volatile</span> xmlXPathObjectPtr xpathobj = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xtCxt = <a href="#L4587" title="utils/adt/xml.c:4587">GetXmlTableBuilderPrivateData</a>(state, <span class="Constant">&quot;<a href="#L4850" title="utils/adt/xml.c:4850">XmlTableGetValue</a>&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(xtCxt-&gt;xpathobj &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xtCxt-&gt;xpathobj-&gt;type == XPATH_NODESET &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xtCxt-&gt;xpathobj-&gt;nodesetval != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Propagate our own error context to libxml2 */<br/></li>
<li></span>&nbsp; &nbsp; xmlSetStructuredErrorFunc((<span class="Type">void</span> *) xtCxt-&gt;xmlerrcxt, <a href="#L2036" title="utils/adt/xml.c:2036">xml_errorHandler</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *isnull = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cur = xtCxt-&gt;xpathobj-&gt;nodesetval-&gt;nodeTab[xtCxt-&gt;row_count - <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(xtCxt-&gt;xpathscomp[colnum] != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_TRY();<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set current node as entry point for XPath evaluation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; xtCxt-&gt;xpathcxt-&gt;node = cur;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Evaluate column path */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; xpathobj = xmlXPathCompiledEval(xtCxt-&gt;xpathscomp[colnum], xtCxt-&gt;xpathcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xpathobj == <span class="Constant">NULL</span> || xtCxt-&gt;xmlerrcxt-&gt;err_occurred)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1970" title="utils/adt/xml.c:1970">xml_ereport</a>(xtCxt-&gt;xmlerrcxt, ERROR, ERRCODE_INTERNAL_ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;could not create XPath object&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There are four possible cases, depending on the number of nodes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * returned by the XPath expression and the type of the target column:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a) XPath returns no nodes.&nbsp; b) The target type is XML (return all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * as XML).&nbsp; For non-XML return types:&nbsp; c) One node (return content).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * d) Multiple nodes (error).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xpathobj-&gt;type == XPATH_NODESET)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xpathobj-&gt;nodesetval != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count = xpathobj-&gt;nodesetval-&gt;nodeNr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xpathobj-&gt;nodesetval == <span class="Constant">NULL</span> || count == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *isnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typid == XMLOID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *textstr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StringInfoData str;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Concatenate serialized <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; initStringInfo(&amp;str);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; count; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; textstr =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4091" title="utils/adt/xml.c:4091">xml_xmlnodetoxmltype</a>(xpathobj-&gt;nodesetval-&gt;nodeTab[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xtCxt-&gt;xmlerrcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L459" title="utils/adt/xml.c:459">appendStringInfoText</a>(&amp;str, textstr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cstr = str.data;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmlChar&nbsp; &nbsp; *str;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (count &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_CARDINALITY_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;more than one value returned by column XPath expression&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = xmlXPathCastNodeSetToString(xpathobj-&gt;nodesetval);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cstr = str ? <a href="#L1371" title="utils/adt/xml.c:1371">xml_pstrdup_and_free</a>(str) : <span class="Constant">&quot;&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (xpathobj-&gt;type == XPATH_STRING)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Content should be escaped when target will be XML */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typid == XMLOID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cstr = <a href="#L2632" title="utils/adt/xml.c:2632">escape_xml</a>((<span class="Type">char</span> *) xpathobj-&gt;stringval);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cstr = (<span class="Type">char</span> *) xpathobj-&gt;stringval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (xpathobj-&gt;type == XPATH_BOOLEAN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; typcategory;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; typispreferred;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmlChar&nbsp; &nbsp; *str;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Allow implicit casting from boolean to numbers */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L2710" title="utils/cache/lsyscache.c:2710">get_type_category_preferred</a>(typid, &amp;typcategory, &amp;typispreferred);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typcategory != TYPCATEGORY_NUMERIC)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = xmlXPathCastBooleanToString(xpathobj-&gt;boolval);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = xmlXPathCastNumberToString(xmlXPathCastBooleanToNumber(xpathobj-&gt;boolval));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cstr = <a href="#L1371" title="utils/adt/xml.c:1371">xml_pstrdup_and_free</a>(str);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (xpathobj-&gt;type == XPATH_NUMBER)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmlChar&nbsp; &nbsp; *str;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = xmlXPathCastNumberToString(xpathobj-&gt;floatval);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cstr = <a href="#L1371" title="utils/adt/xml.c:1371">xml_pstrdup_and_free</a>(str);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected XPath object type </span><span class="Special">%u</span><span class="Constant">&quot;</span>, xpathobj-&gt;type);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * By here, either cstr contains the result value, or the isnull flag<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * has been set.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(cstr || *isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!*isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../fmgr/fmgr.c.html#L1530" title="utils/fmgr/fmgr.c:1530">InputFunctionCall</a>(&amp;state-&gt;in_functions[colnum],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cstr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;typioparams[colnum],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typmod);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_FINALLY();<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xpathobj != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmlXPathFreeObject(xpathobj);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_END_TRY();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L235" title="utils/adt/xml.c:235">NO_XML_SUPPORT</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not USE_LIBXML */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5002" title="utils/adt/xml.c:5002">XmlTableDestroyOpaque</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Release all libxml2 resources<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L5002">&#x200c;</a></span><span class="linkable">XmlTableDestroyOpaque</span>(TableFuncScanState *state)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef USE_LIBXML<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L196" title="utils/adt/xml.c:196">XmlTableBuilderData</a> *xtCxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xtCxt = <a href="#L4587" title="utils/adt/xml.c:4587">GetXmlTableBuilderPrivateData</a>(state, <span class="Constant">&quot;<a href="#L5002" title="utils/adt/xml.c:5002">XmlTableDestroyOpaque</a>&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Propagate our own error context to libxml2 */<br/></li>
<li></span>&nbsp; &nbsp; xmlSetStructuredErrorFunc((<span class="Type">void</span> *) xtCxt-&gt;xmlerrcxt, <a href="#L2036" title="utils/adt/xml.c:2036">xml_errorHandler</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xtCxt-&gt;xpathscomp != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; xtCxt-&gt;natts; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xtCxt-&gt;xpathscomp[i] != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmlXPathFreeCompExpr(xtCxt-&gt;xpathscomp[i]);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xtCxt-&gt;xpathobj != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xmlXPathFreeObject(xtCxt-&gt;xpathobj);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xtCxt-&gt;xpathcomp != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xmlXPathFreeCompExpr(xtCxt-&gt;xpathcomp);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xtCxt-&gt;xpathcxt != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xmlXPathFreeContext(xtCxt-&gt;xpathcxt);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xtCxt-&gt;doc != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xmlFreeDoc(xtCxt-&gt;doc);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xtCxt-&gt;ctxt != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xmlFreeParserCtxt(xtCxt-&gt;ctxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1259" title="utils/adt/xml.c:1259">pg_xml_done</a>(xtCxt-&gt;xmlerrcxt, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* not valid anymore */<br/></li>
<li></span>&nbsp; &nbsp; xtCxt-&gt;magic = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;opaque = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L235" title="utils/adt/xml.c:235">NO_XML_SUPPORT</a>();<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not USE_LIBXML */<br/></li>
<li></span>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
