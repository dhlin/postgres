<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/adt/levenshtein.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/adt/levenshtein.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L68">varstr_levenshtein_less_equal</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L26">MAX_LEVENSHTEIN_STRLEN</a></li>
<li><a href="#L96">START_COLUMN</a></li>
<li><a href="#L98">START_COLUMN</a></li>
<li><a href="#L97">STOP_COLUMN</a></li>
<li><a href="#L99">STOP_COLUMN</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * levenshtein.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Levenshtein distance implementation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Original author:&nbsp; Joe Conway &lt;mail@joeconway.com&gt;<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This file is included by varlena.c twice, to provide matching code for (1)<br/></li>
<li></span><span class="Comment"> * Levenshtein distance with custom costings, and (2) Levenshtein distance with<br/></li>
<li></span><span class="Comment"> * custom costings and a &quot;max&quot; value above which exact distances are not<br/></li>
<li></span><span class="Comment"> * interesting.&nbsp; Before the inclusion, we rely on the presence of the inline<br/></li>
<li></span><span class="Comment"> * function <a href="varlena.c.html#L6152" title="utils/adt/varlena.c:6152">rest_of_char_same</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Written based on a description of the algorithm by Michael Gilleland found<br/></li>
<li></span><span class="Comment"> * at http://www.merriampark.com/ld.htm.&nbsp; Also looked at levenshtein.c in the<br/></li>
<li></span><span class="Comment"> * PHP 4.0.6 distribution for inspiration.&nbsp; Configurable penalty costs<br/></li>
<li></span><span class="Comment"> * extension is introduced by Volkan YAZICI &lt;volkan.yazici@gmail.com.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Copyright (c) 2001-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; src/backend/utils/adt/levenshtein.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L26">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MAX_LEVENSHTEIN_STRLEN</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">255<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Calculates Levenshtein distance metric between supplied strings, which are<br/></li>
<li></span><span class="Comment"> * not necessarily null-terminated.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * source: source string, of length slen bytes.<br/></li>
<li></span><span class="Comment"> * target: target string, of length tlen bytes.<br/></li>
<li></span><span class="Comment"> * ins_c, del_c, sub_c: costs to <a href="char.c.html#L172" title="utils/adt/char.c:172">charge</a> for character insertion, deletion,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; and substitution respectively; (1, 1, 1) costs suffice for common<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; cases, but your mileage may vary.<br/></li>
<li></span><span class="Comment"> * max_d: if provided and &gt;= 0, maximum distance we care about; see below.<br/></li>
<li></span><span class="Comment"> * trusted: caller is trusted and need not obey <a href="#L26" title="utils/adt/levenshtein.c:26">MAX_LEVENSHTEIN_STRLEN</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * One way to compute Levenshtein distance is to incrementally construct<br/></li>
<li></span><span class="Comment"> * an (m+1)x(n+1) matrix where cell (i, j) represents the minimum number<br/></li>
<li></span><span class="Comment"> * of operations required to transform the first i characters of s into<br/></li>
<li></span><span class="Comment"> * the first j characters of t.&nbsp; The last column of the final row is the<br/></li>
<li></span><span class="Comment"> * answer.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We use that algorithm here with some modification.&nbsp; In lieu of holding<br/></li>
<li></span><span class="Comment"> * the entire array in memory at once, we'll just use two arrays of size<br/></li>
<li></span><span class="Comment"> * m+1 for storing accumulated <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>. At each step one array represents<br/></li>
<li></span><span class="Comment"> * the &quot;previous&quot; row and one is the &quot;current&quot; row of the notional large<br/></li>
<li></span><span class="Comment"> * array.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If max_d &gt;= 0, we only need to provide an accurate answer when that answer<br/></li>
<li></span><span class="Comment"> * is less than or <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to max_d.&nbsp; From <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> cell in the matrix, there is<br/></li>
<li></span><span class="Comment"> * theoretical &quot;minimum residual distance&quot; from that cell to the last column<br/></li>
<li></span><span class="Comment"> * of the final row.&nbsp; This minimum residual distance is zero when the<br/></li>
<li></span><span class="Comment"> * untransformed portions of the strings are of <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> length (because we might<br/></li>
<li></span><span class="Comment"> * get lucky and <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> all the remaining characters matching) and is otherwise<br/></li>
<li></span><span class="Comment"> * based on the minimum number of insertions or deletions needed to make them<br/></li>
<li></span><span class="Comment"> * <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> length.&nbsp; The residual distance grows as we move toward the <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a><br/></li>
<li></span><span class="Comment"> * right or <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> left corners of the matrix.&nbsp; When the max_d bound is<br/></li>
<li></span><span class="Comment"> * usefully tight, we can use this property to avoid computing the entirety<br/></li>
<li></span><span class="Comment"> * of each row; instead, we maintain a start_column and stop_column that<br/></li>
<li></span><span class="Comment"> * identify the portion of the matrix close to the diagonal which can still<br/></li>
<li></span><span class="Comment"> * affect the final answer.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li></span><span class="PreProc">#ifdef <a href="varlena.c.html#L6165" title="utils/adt/varlena.c:6165">LEVENSHTEIN_LESS_EQUAL</a><br/></li>
<li><a id="L68">&#x200c;</a></span><span class="linkable">varstr_levenshtein_less_equal</span>(<span class="Type">const</span> <span class="Type">char</span> *source, <span class="Type">int</span> slen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *target, <span class="Type">int</span> tlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> ins_c, <span class="Type">int</span> del_c, <span class="Type">int</span> sub_c,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> max_d, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> trusted)<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>varstr_levenshtein(<span class="Type">const</span> <span class="Type">char</span> *source, <span class="Type">int</span> slen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *target, <span class="Type">int</span> tlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> ins_c, <span class="Type">int</span> del_c, <span class="Type">int</span> sub_c,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> trusted)<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; m,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *prev;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *curr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *s_char_len = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *y;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For <a href="#L68" title="utils/adt/levenshtein.c:68">varstr_levenshtein_less_equal</a>, we have real variables called<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * start_column and stop_column; otherwise it's just short-hand for 0 and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * m.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef <a href="varlena.c.html#L6165" title="utils/adt/varlena.c:6165">LEVENSHTEIN_LESS_EQUAL</a><br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; start_column,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stop_column;<br/></li>
<li><br/></li>
<li><a id="L96">&#x200c;</a><span class="PreProc">#undef <span class="linkable">START_COLUMN</span><br/></li>
<li><a id="L97">&#x200c;</a></span><span class="PreProc">#undef <span class="linkable">STOP_COLUMN</span><br/></li>
<li><a id="L98">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">START_COLUMN</span> start_column<br/></li>
<li><a id="L99">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">STOP_COLUMN</span> stop_column<br/></li>
<li></span><span class="PreProc">#else<br/></li>
<li></span><span class="PreProc">#undef <a href="#L96" title="utils/adt/levenshtein.c:96">START_COLUMN</a><br/></li>
<li></span><span class="PreProc">#undef <a href="#L97" title="utils/adt/levenshtein.c:97">STOP_COLUMN</a><br/></li>
<li></span><span class="PreProc">#define <a href="#L96" title="utils/adt/levenshtein.c:96">START_COLUMN</a> </span><span class="Constant">0<br/></li>
<li></span><span class="PreProc">#define <a href="#L97" title="utils/adt/levenshtein.c:97">STOP_COLUMN</a> m<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Convert string lengths (in bytes) to lengths in characters */<br/></li>
<li></span>&nbsp; &nbsp; m = <a href="../mb/mbutils.c.html#L1057" title="utils/mb/mbutils.c:1057">pg_mbstrlen_with_len</a>(source, slen);<br/></li>
<li>&nbsp; &nbsp; n = <a href="../mb/mbutils.c.html#L1057" title="utils/mb/mbutils.c:1057">pg_mbstrlen_with_len</a>(target, tlen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can transform an empty s into t with n insertions, or a non-empty t<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * into an empty s with m deletions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!m)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> n * ins_c;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!n)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> m * del_c;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For security concerns, restrict excessive CPU+RAM usage. (This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * implementation uses O(m) memory and has O(mn) complexity.)&nbsp; If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &quot;trusted&quot; is true, caller is responsible for not making excessive<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * requests, typically by using a small max_d along with strings that are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bounded, though not necessarily to <a href="#L26" title="utils/adt/levenshtein.c:26">MAX_LEVENSHTEIN_STRLEN</a> exactly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!trusted &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (m &gt; <a href="#L26" title="utils/adt/levenshtein.c:26">MAX_LEVENSHTEIN_STRLEN</a> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; n &gt; <a href="#L26" title="utils/adt/levenshtein.c:26">MAX_LEVENSHTEIN_STRLEN</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;levenshtein argument exceeds maximum length of </span><span class="Special">%d</span><span class="Constant"> characters&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L26" title="utils/adt/levenshtein.c:26">MAX_LEVENSHTEIN_STRLEN</a>)));<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef <a href="varlena.c.html#L6165" title="utils/adt/varlena.c:6165">LEVENSHTEIN_LESS_EQUAL</a><br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Initialize start and stop columns. */<br/></li>
<li></span>&nbsp; &nbsp; start_column = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; stop_column = m + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If max_d &gt;= 0, determine whether the bound is impossibly tight.&nbsp; If so,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * return max_d + 1 immediately.&nbsp; Otherwise, determine whether it's tight<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * enough to limit the computation we must perform.&nbsp; If so, figure out<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * initial stop column.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (max_d &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min_theo_d; <span class="Comment">/* Theoretical minimum distance. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max_theo_d; <span class="Comment">/* Theoretical maximum distance. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; net_inserts = n - m;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; min_theo_d = net_inserts &lt; <span class="Constant">0</span> ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -net_inserts * del_c : net_inserts * ins_c;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (min_theo_d &gt; max_d)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> max_d + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ins_c + del_c &lt; sub_c)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sub_c = ins_c + del_c;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; max_theo_d = min_theo_d + sub_c * <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(m, n);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (max_d &gt;= max_theo_d)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max_d = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (ins_c + del_c &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Figure out how much of the first row of the notional matrix we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * need to fill in.&nbsp; If the string is growing, the theoretical<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * minimum distance already incorporates the cost of deleting the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * number of characters necessary to make the two strings <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * length.&nbsp; Each additional deletion forces another insertion, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the best-case total cost increases by ins_c + del_c. If the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * string is shrinking, the minimum theoretical cost assumes no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * excess deletions; that is, we're starting no further right than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * column n - m.&nbsp; If we do start further right, the best-case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * total cost increases by ins_c + del_c for each move right.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slack_d = max_d - min_theo_d;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_column = net_inserts &lt; <span class="Constant">0</span> ? -net_inserts : <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stop_column = best_column + (slack_d / (ins_c + del_c)) + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (stop_column &gt; m)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stop_column = m + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In order to avoid calling <a href="../mb/mbutils.c.html#L1023" title="utils/mb/mbutils.c:1023">pg_mblen</a>() repeatedly on each character in s,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we cache all the lengths <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> starting the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> loop -- but if all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the characters in both strings are single byte, then we <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> this and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * use a fast-path in the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> loop.&nbsp; If only one string contains<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * multi-byte characters, we still build the array, so that the fast-path<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * needn't deal with the case where the array hasn't been initialized.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (m != slen || n != tlen)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *cp = source;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s_char_len = (<span class="Type">int</span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>((m + <span class="Constant">1</span>) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; m; ++i)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s_char_len[i] = <a href="../mb/mbutils.c.html#L1023" title="utils/mb/mbutils.c:1023">pg_mblen</a>(cp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cp += s_char_len[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s_char_len[i] = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* One more cell for initialization column and row. */<br/></li>
<li></span>&nbsp; &nbsp; ++m;<br/></li>
<li>&nbsp; &nbsp; ++n;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Previous and current rows of notional array. */<br/></li>
<li></span>&nbsp; &nbsp; prev = (<span class="Type">int</span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Constant">2</span> * m * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; curr = prev + m;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * To transform the first i characters of s into the first 0 characters of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * t, we must perform i deletions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <a href="#L96" title="utils/adt/levenshtein.c:96">START_COLUMN</a>; i &lt; <a href="#L97" title="utils/adt/levenshtein.c:97">STOP_COLUMN</a>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prev[i] = i * del_c;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Loop through rows of the notional array */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (y = target, j = <span class="Constant">1</span>; j &lt; n; j++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *temp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *x = source;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; y_char_len = n != tlen + <span class="Constant">1</span> ? <a href="../mb/mbutils.c.html#L1023" title="utils/mb/mbutils.c:1023">pg_mblen</a>(y) : <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef <a href="varlena.c.html#L6165" title="utils/adt/varlena.c:6165">LEVENSHTEIN_LESS_EQUAL</a><br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In the best case, <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> percolate down the diagonal unchanged, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we must increment stop_column unless it's already on the right end<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of the array.&nbsp; The inner loop will read prev[stop_column], so we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have to <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> it even though it shouldn't affect the result.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (stop_column &lt; m)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prev[stop_column] = max_d + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ++stop_column;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> loop fills in curr, but curr[0] needs a special case: to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transform the first 0 characters of s into the first j characters<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of t, we must perform j insertions.&nbsp; However, if start_column &gt; 0,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this special case does not apply.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (start_column == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curr[<span class="Constant">0</span>] = j * ins_c;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = start_column;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; curr[<span class="Constant">0</span>] = j * ins_c;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i = <span class="Constant">1</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This inner loop is critical to performance, so we include a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fast-path to handle the (fairly common) case where no multibyte<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * characters are in the mix.&nbsp; The fast-path is entitled to assume<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that if s_char_len is not initialized then BOTH strings contain<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * only single-byte characters.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s_char_len != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (; i &lt; <a href="#L97" title="utils/adt/levenshtein.c:97">STOP_COLUMN</a>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ins;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; del;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sub;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x_char_len = s_char_len[i - <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Calculate costs for insertion, deletion, and substitution.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When calculating cost for substitution, we <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> the last<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * character of each possibly-multibyte character first,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because that's enough to rule out most mis-matches.&nbsp; If we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * get past that test, then we <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> the lengths and the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * remaining bytes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ins = prev[i] + ins_c;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; del = curr[i - <span class="Constant">1</span>] + del_c;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (x[x_char_len - <span class="Constant">1</span>] == y[y_char_len - <span class="Constant">1</span>]<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; x_char_len == y_char_len &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (x_char_len == <span class="Constant">1</span> || <a href="varlena.c.html#L6152" title="utils/adt/varlena.c:6152">rest_of_char_same</a>(x, y, x_char_len)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sub = prev[i - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sub = prev[i - <span class="Constant">1</span>] + sub_c;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Take the one with minimum cost. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curr[i] = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(ins, del);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curr[i] = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(curr[i], sub);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Point to <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> character. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x += x_char_len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (; i &lt; <a href="#L97" title="utils/adt/levenshtein.c:97">STOP_COLUMN</a>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ins;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; del;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sub;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Calculate costs for insertion, deletion, and substitution. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ins = prev[i] + ins_c;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; del = curr[i - <span class="Constant">1</span>] + del_c;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sub = prev[i - <span class="Constant">1</span>] + ((*x == *y) ? <span class="Constant">0</span> : sub_c);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Take the one with minimum cost. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curr[i] = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(ins, del);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curr[i] = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(curr[i], sub);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Point to <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> character. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Swap current row with previous row. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; temp = curr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; curr = prev;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prev = temp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Point to <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> character. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; y += y_char_len;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef <a href="varlena.c.html#L6165" title="utils/adt/varlena.c:6165">LEVENSHTEIN_LESS_EQUAL</a><br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This chunk of code represents a significant performance hit if used<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in the case where there is no max_d bound.&nbsp; This is probably not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because the max_d &gt;= 0 test itself is expensive, but rather because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the possibility of needing to execute this code prevents tight<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * optimization of the loop as a whole.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (max_d &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The &quot;zero point&quot; is the column of the current row where the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * remaining portions of the strings are of <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> length.&nbsp; There<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * are (n - 1) characters in the target string, of which j have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * been transformed.&nbsp; There are (m - 1) characters in the source<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * string, so we want to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the value for zp where (n - 1) - j =<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (m - 1) - zp.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; zp = j - (n - m);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check whether the stop column can slide left. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (stop_column &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ii = stop_column - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; net_inserts = ii - zp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (prev[ii] + (net_inserts &gt; <span class="Constant">0</span> ? net_inserts * ins_c :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -net_inserts * del_c) &lt;= max_d)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stop_column--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check whether the start column can slide right. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (start_column &lt; stop_column)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; net_inserts = start_column - zp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (prev[start_column] +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (net_inserts &gt; <span class="Constant">0</span> ? net_inserts * ins_c :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; -net_inserts * del_c) &lt;= max_d)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We'll never again update these <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, so we must make sure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there's nothing here that could confuse <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> future<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * iteration of the outer loop.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prev[start_column] = max_d + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curr[start_column] = max_d + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (start_column != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; source += (s_char_len != <span class="Constant">NULL</span>) ? s_char_len[start_column - <span class="Constant">1</span>] : <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; start_column++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If they cross, we're going to exceed the bound. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (start_column &gt;= stop_column)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> max_d + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Because the final value was swapped from the previous row to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * current row, that's where we'll <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> prev[m - <span class="Constant">1</span>];<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
