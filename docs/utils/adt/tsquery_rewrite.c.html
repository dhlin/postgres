<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/adt/tsquery_rewrite.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/adt/tsquery_rewrite.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L206">dofindsubquery</a></li>
<li><a href="#L35">findeq</a></li>
<li><a href="#L267">findsubquery</a></li>
<li><a href="#L410">tsquery_rewrite</a></li>
<li><a href="#L280">tsquery_rewrite_query</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L410" title="utils/adt/tsquery_rewrite.c:410">tsquery_rewrite</a>.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Utilities for reconstructing tsquery<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/adt/<a href="#L410" title="utils/adt/tsquery_rewrite.c:410">tsquery_rewrite</a>.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/spi.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;tsearch/ts_utils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * If &quot;node&quot; is <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to &quot;ex&quot;, return a copy of &quot;subs&quot; instead.<br/></li>
<li></span><span class="Comment"> * If &quot;ex&quot; matches a <a href="../../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> of node's children, return a modified version<br/></li>
<li></span><span class="Comment"> * of &quot;node&quot; in which those children are replaced with a copy of &quot;subs&quot;.<br/></li>
<li></span><span class="Comment"> * Otherwise return &quot;node&quot; unmodified.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The QTN_NOCHANGE <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> is set in successfully modified nodes, so that<br/></li>
<li></span><span class="Comment"> * we won't uselessly recurse into them.<br/></li>
<li></span><span class="Comment"> * Also, set *isfind true if we make a replacement.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> QTNode *<br/></li>
<li><a id="L35">&#x200c;</a><span class="linkable">findeq</span>(QTNode *node, QTNode *ex, QTNode *subs, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isfind)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Can't match unless signature matches and node type matches. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((node-&gt;sign &amp; ex-&gt;sign) != ex-&gt;sign ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; node-&gt;valnode-&gt;type != ex-&gt;valnode-&gt;type)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Ignore nodes marked NOCHANGE, too. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;flags &amp; QTN_NOCHANGE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;valnode-&gt;type == QI_OPR)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must be same operator. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;valnode-&gt;qoperator.<a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a> != ex-&gt;valnode-&gt;qoperator.<a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;nchild == ex-&gt;nchild)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Simple case: when same number of children, match if <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (This is reliable when the children were sorted earlier.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="tsquery_util.c.html#L183" title="utils/adt/tsquery_util.c:183">QTNEq</a>(node, ex))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Match; delete node and return a copy of subs instead. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="tsquery_util.c.html#L64" title="utils/adt/tsquery_util.c:64">QTNFree</a>(node);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node = <a href="tsquery_util.c.html#L396" title="utils/adt/tsquery_util.c:396">QTNCopy</a>(subs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;flags |= QTN_NOCHANGE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *isfind = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (node-&gt;nchild &gt; ex-&gt;nchild &amp;&amp; ex-&gt;nchild &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * AND and OR are commutative/associative, so we should check if a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> of the children match.&nbsp; For example, if node is A|B|C,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and ex is B|C, we have a match after we notionally convert node<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to A|(B|C).&nbsp; This does not work for NOT or PHRASE nodes, but we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can't get here for those node types because they have a fixed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * number of children.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Because we expect that the children are sorted, it suffices to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * make one pass through the two lists to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the matches.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *matched;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nmatched;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Assert that the <a href="../../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> rule is OK */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(node-&gt;valnode-&gt;qoperator.<a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a> == OP_AND ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;valnode-&gt;qoperator.<a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a> == OP_OR);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* matched[] will record which children of node matched */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matched = (<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(node-&gt;nchild * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nmatched = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = j = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (i &lt; node-&gt;nchild &amp;&amp; j &lt; ex-&gt;nchild)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = <a href="tsquery_util.c.html#L97" title="utils/adt/tsquery_util.c:97">QTNodeCompare</a>(node-&gt;child[i], ex-&gt;child[j]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* match! */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matched[i] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nmatched++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i++, j++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* node-&gt;child[i] has no match, ignore it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ex-&gt;child[j] has no match; we can give up immediately */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nmatched == ex-&gt;nchild)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* collapse out the matched children of node */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; node-&gt;nchild; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (matched[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="tsquery_util.c.html#L64" title="utils/adt/tsquery_util.c:64">QTNFree</a>(node-&gt;child[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;child[j++] = node-&gt;child[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* and instead insert a copy of subs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subs = <a href="tsquery_util.c.html#L396" title="utils/adt/tsquery_util.c:396">QTNCopy</a>(subs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subs-&gt;flags |= QTN_NOCHANGE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;child[j++] = subs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;nchild = j;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * At this point we might have a node with zero or one child,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * which should be simplified.&nbsp; But we leave it to our caller<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (<a href="#L206" title="utils/adt/tsquery_rewrite.c:206">dofindsubquery</a>) to take care of that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Re-sort the node to put new child in the right place.&nbsp; This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is a <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> bogus, because it won't matter for <a href="#L267" title="utils/adt/tsquery_rewrite.c:267">findsubquery</a>'s<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * remaining processing, and it's insufficient to prepare the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tree for another search (we would need to re-flatten as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * well, and we don't want to do that because we'd lose the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * QTN_NOCHANGE marking on the new child).&nbsp; But it's needed to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * keep the results the same as the regression tests expect.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="tsquery_util.c.html#L163" title="utils/adt/tsquery_util.c:163">QTNSort</a>(node);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *isfind = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(matched);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(node-&gt;valnode-&gt;type == QI_VAL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;valnode-&gt;qoperand.valcrc != ex-&gt;valnode-&gt;qoperand.valcrc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> node;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="tsquery_util.c.html#L183" title="utils/adt/tsquery_util.c:183">QTNEq</a>(node, ex))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="tsquery_util.c.html#L64" title="utils/adt/tsquery_util.c:64">QTNFree</a>(node);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node = <a href="tsquery_util.c.html#L396" title="utils/adt/tsquery_util.c:396">QTNCopy</a>(subs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;flags |= QTN_NOCHANGE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *isfind = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> node;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Recursive guts of <a href="#L267" title="utils/adt/tsquery_rewrite.c:267">findsubquery</a>(): attempt to replace &quot;ex&quot; with &quot;subs&quot;<br/></li>
<li></span><span class="Comment"> * at the root node, and if we failed to do so, recursively match against<br/></li>
<li></span><span class="Comment"> * child nodes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> void subtrees resulting from the replacement.<br/></li>
<li></span><span class="Comment"> * In the following example '5' is replaced by empty operand:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; AND&nbsp; &nbsp; &nbsp; &nbsp; -&gt;&nbsp; &nbsp; &nbsp; 6<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; /&nbsp; &nbsp;&nbsp; \<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; 5&nbsp; &nbsp;&nbsp; OR<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; /&nbsp; \<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; 6&nbsp; &nbsp; 5<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> QTNode *<br/></li>
<li><a id="L206">&#x200c;</a><span class="linkable">dofindsubquery</span>(QTNode *root, QTNode *ex, QTNode *subs, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isfind)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* since this function recurses, it could be driven to stack overflow. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* also, since it's a <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> expensive, let's check for query cancel. */<br/></li>
<li></span>&nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* match at the node itself */<br/></li>
<li></span>&nbsp; &nbsp; root = <a href="#L35" title="utils/adt/tsquery_rewrite.c:35">findeq</a>(root, ex, subs, isfind);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* unless we matched here, consider matches at child nodes */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (root &amp;&amp; (root-&gt;flags &amp; QTN_NOCHANGE) == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;valnode-&gt;type == QI_OPR)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Any subtrees that are replaced by NULL must be dropped from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tree.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; root-&gt;nchild; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;child[j] = <a href="#L206" title="utils/adt/tsquery_rewrite.c:206">dofindsubquery</a>(root-&gt;child[i], ex, subs, isfind);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (root-&gt;child[j])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;nchild = j;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we have just zero or one remaining child node, simplify out this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * operator node.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (root-&gt;nchild == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="tsquery_util.c.html#L64" title="utils/adt/tsquery_util.c:64">QTNFree</a>(root);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (root-&gt;nchild == <span class="Constant">1</span> &amp;&amp; root-&gt;valnode-&gt;qoperator.<a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a> != OP_NOT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QTNode&nbsp; &nbsp; &nbsp;&nbsp; *nroot = root-&gt;child[<span class="Constant">0</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(root);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root = nroot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> root;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Substitute &quot;subs&quot; for &quot;ex&quot; throughout the QTNode tree at root.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If isfind isn't NULL, set *isfind to show whether we made <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> substitution.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Both &quot;root&quot; and &quot;ex&quot; must have been through <a href="tsquery_util.c.html#L201" title="utils/adt/tsquery_util.c:201">QTNTernary</a> and <a href="tsquery_util.c.html#L163" title="utils/adt/tsquery_util.c:163">QTNSort</a><br/></li>
<li></span><span class="Comment"> * to ensure reliable matching.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>QTNode *<br/></li>
<li><a id="L267">&#x200c;</a><span class="linkable">findsubquery</span>(QTNode *root, QTNode *ex, QTNode *subs, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isfind)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; DidFind = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; root = <a href="#L206" title="utils/adt/tsquery_rewrite.c:206">dofindsubquery</a>(root, ex, subs, &amp;DidFind);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isfind)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *isfind = DidFind;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> root;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L280">&#x200c;</a><span class="linkable">tsquery_rewrite_query</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TSQuery&nbsp; &nbsp; &nbsp; &nbsp; query = PG_GETARG_TSQUERY_COPY(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *in = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TSQuery&nbsp; &nbsp; &nbsp; &nbsp; rewritten = query;<br/></li>
<li>&nbsp; &nbsp; MemoryContext outercontext = <a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li>&nbsp; &nbsp; QTNode&nbsp; &nbsp; &nbsp;&nbsp; *tree;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *buf;<br/></li>
<li>&nbsp; &nbsp; SPIPlanPtr&nbsp; &nbsp; plan;<br/></li>
<li>&nbsp; &nbsp; Portal&nbsp; &nbsp; &nbsp; &nbsp; portal;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (query-&gt;size == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_FREE_IF_COPY(in, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_POINTER(rewritten);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tree = <a href="tsquery_util.c.html#L25" title="utils/adt/tsquery_util.c:25">QT2QTN</a>(GETQUERY(query), GETOPERAND(query));<br/></li>
<li>&nbsp; &nbsp; <a href="tsquery_util.c.html#L201" title="utils/adt/tsquery_util.c:201">QTNTernary</a>(tree);<br/></li>
<li>&nbsp; &nbsp; <a href="tsquery_util.c.html#L163" title="utils/adt/tsquery_util.c:163">QTNSort</a>(tree);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; buf = <a href="varlena.c.html#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>(in);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../executor/spi.c.html#L94" title="executor/spi.c:94">SPI_connect</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((plan = <a href="../../executor/spi.c.html#L857" title="executor/spi.c:857">SPI_prepare</a>(buf, <span class="Constant">0</span>, <span class="Constant">NULL</span>)) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../../executor/spi.c.html#L857" title="executor/spi.c:857">SPI_prepare</a>(</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">) failed&quot;</span>, buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((portal = <a href="../../executor/spi.c.html#L1442" title="executor/spi.c:1442">SPI_cursor_open</a>(<span class="Constant">NULL</span>, plan, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>, <span class="Constant">true</span>)) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../../executor/spi.c.html#L1442" title="executor/spi.c:1442">SPI_cursor_open</a>(</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">) failed&quot;</span>, buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../executor/spi.c.html#L1803" title="executor/spi.c:1803">SPI_cursor_fetch</a>(portal, <span class="Constant">true</span>, <span class="Constant">100</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../executor/spi.c.html#L45" title="executor/spi.c:45">SPI_tuptable</a> == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/spi.c.html#L45" title="executor/spi.c:45">SPI_tuptable</a>-&gt;tupdesc-&gt;natts != <span class="Constant">2</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/spi.c.html#L1305" title="executor/spi.c:1305">SPI_gettypeid</a>(<a href="../../executor/spi.c.html#L45" title="executor/spi.c:45">SPI_tuptable</a>-&gt;tupdesc, <span class="Constant">1</span>) != TSQUERYOID ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/spi.c.html#L1305" title="executor/spi.c:1305">SPI_gettypeid</a>(<a href="../../executor/spi.c.html#L45" title="executor/spi.c:45">SPI_tuptable</a>-&gt;tupdesc, <span class="Constant">2</span>) != TSQUERYOID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;ts_rewrite query must return two tsquery columns&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="../../executor/spi.c.html#L44" title="executor/spi.c:44">SPI_processed</a> &gt; <span class="Constant">0</span> &amp;&amp; tree)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="../../executor/spi.c.html#L44" title="executor/spi.c:44">SPI_processed</a> &amp;&amp; tree; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; qdata = <a href="../../executor/spi.c.html#L1249" title="executor/spi.c:1249">SPI_getbinval</a>(<a href="../../executor/spi.c.html#L45" title="executor/spi.c:45">SPI_tuptable</a>-&gt;vals[i], <a href="../../executor/spi.c.html#L45" title="executor/spi.c:45">SPI_tuptable</a>-&gt;tupdesc, <span class="Constant">1</span>, &amp;isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; sdata;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sdata = <a href="../../executor/spi.c.html#L1249" title="executor/spi.c:1249">SPI_getbinval</a>(<a href="../../executor/spi.c.html#L45" title="executor/spi.c:45">SPI_tuptable</a>-&gt;vals[i], <a href="../../executor/spi.c.html#L45" title="executor/spi.c:45">SPI_tuptable</a>-&gt;tupdesc, <span class="Constant">2</span>, &amp;isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TSQuery&nbsp; &nbsp; &nbsp; &nbsp; qtex = DatumGetTSQuery(qdata);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TSQuery&nbsp; &nbsp; &nbsp; &nbsp; qtsubs = DatumGetTSQuery(sdata);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QTNode&nbsp; &nbsp; &nbsp;&nbsp; *qex,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *qsubs = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (qtex-&gt;size == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (qtex != (TSQuery) DatumGetPointer(qdata))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(qtex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (qtsubs != (TSQuery) DatumGetPointer(sdata))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(qtsubs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qex = <a href="tsquery_util.c.html#L25" title="utils/adt/tsquery_util.c:25">QT2QTN</a>(GETQUERY(qtex), GETOPERAND(qtex));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="tsquery_util.c.html#L201" title="utils/adt/tsquery_util.c:201">QTNTernary</a>(qex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="tsquery_util.c.html#L163" title="utils/adt/tsquery_util.c:163">QTNSort</a>(qex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (qtsubs-&gt;size)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qsubs = <a href="tsquery_util.c.html#L25" title="utils/adt/tsquery_util.c:25">QT2QTN</a>(GETQUERY(qtsubs), GETOPERAND(qtsubs));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(outercontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tree = <a href="#L267" title="utils/adt/tsquery_rewrite.c:267">findsubquery</a>(tree, qex, qsubs, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="tsquery_util.c.html#L64" title="utils/adt/tsquery_util.c:64">QTNFree</a>(qex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (qtex != (TSQuery) DatumGetPointer(qdata))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(qtex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="tsquery_util.c.html#L64" title="utils/adt/tsquery_util.c:64">QTNFree</a>(qsubs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (qtsubs != (TSQuery) DatumGetPointer(sdata))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(qtsubs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tree)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ready the tree for another pass */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="tsquery_util.c.html#L434" title="utils/adt/tsquery_util.c:434">QTNClearFlags</a>(tree, QTN_NOCHANGE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="tsquery_util.c.html#L201" title="utils/adt/tsquery_util.c:201">QTNTernary</a>(tree);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="tsquery_util.c.html#L163" title="utils/adt/tsquery_util.c:163">QTNSort</a>(tree);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/spi.c.html#L1383" title="executor/spi.c:1383">SPI_freetuptable</a>(<a href="../../executor/spi.c.html#L45" title="executor/spi.c:45">SPI_tuptable</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/spi.c.html#L1803" title="executor/spi.c:1803">SPI_cursor_fetch</a>(portal, <span class="Constant">true</span>, <span class="Constant">100</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../executor/spi.c.html#L1383" title="executor/spi.c:1383">SPI_freetuptable</a>(<a href="../../executor/spi.c.html#L45" title="executor/spi.c:45">SPI_tuptable</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../executor/spi.c.html#L1859" title="executor/spi.c:1859">SPI_cursor_close</a>(portal);<br/></li>
<li>&nbsp; &nbsp; <a href="../../executor/spi.c.html#L1022" title="executor/spi.c:1022">SPI_freeplan</a>(plan);<br/></li>
<li>&nbsp; &nbsp; <a href="../../executor/spi.c.html#L182" title="executor/spi.c:182">SPI_finish</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tree)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="tsquery_util.c.html#L250" title="utils/adt/tsquery_util.c:250">QTNBinary</a>(tree);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rewritten = <a href="tsquery_util.c.html#L363" title="utils/adt/tsquery_util.c:363">QTN2QT</a>(tree);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="tsquery_util.c.html#L64" title="utils/adt/tsquery_util.c:64">QTNFree</a>(tree);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_FREE_IF_COPY(query, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SET_VARSIZE(rewritten, HDRSIZETQ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rewritten-&gt;size = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(buf);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(in, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(rewritten);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L410">&#x200c;</a><span class="linkable">tsquery_rewrite</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TSQuery&nbsp; &nbsp; &nbsp; &nbsp; query = PG_GETARG_TSQUERY_COPY(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TSQuery&nbsp; &nbsp; &nbsp; &nbsp; ex = PG_GETARG_TSQUERY(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TSQuery&nbsp; &nbsp; &nbsp; &nbsp; subst = PG_GETARG_TSQUERY(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; TSQuery&nbsp; &nbsp; &nbsp; &nbsp; rewritten = query;<br/></li>
<li>&nbsp; &nbsp; QTNode&nbsp; &nbsp; &nbsp;&nbsp; *tree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *qex,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *subs = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (query-&gt;size == <span class="Constant">0</span> || ex-&gt;size == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_FREE_IF_COPY(ex, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_FREE_IF_COPY(subst, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_POINTER(rewritten);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tree = <a href="tsquery_util.c.html#L25" title="utils/adt/tsquery_util.c:25">QT2QTN</a>(GETQUERY(query), GETOPERAND(query));<br/></li>
<li>&nbsp; &nbsp; <a href="tsquery_util.c.html#L201" title="utils/adt/tsquery_util.c:201">QTNTernary</a>(tree);<br/></li>
<li>&nbsp; &nbsp; <a href="tsquery_util.c.html#L163" title="utils/adt/tsquery_util.c:163">QTNSort</a>(tree);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; qex = <a href="tsquery_util.c.html#L25" title="utils/adt/tsquery_util.c:25">QT2QTN</a>(GETQUERY(ex), GETOPERAND(ex));<br/></li>
<li>&nbsp; &nbsp; <a href="tsquery_util.c.html#L201" title="utils/adt/tsquery_util.c:201">QTNTernary</a>(qex);<br/></li>
<li>&nbsp; &nbsp; <a href="tsquery_util.c.html#L163" title="utils/adt/tsquery_util.c:163">QTNSort</a>(qex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (subst-&gt;size)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; subs = <a href="tsquery_util.c.html#L25" title="utils/adt/tsquery_util.c:25">QT2QTN</a>(GETQUERY(subst), GETOPERAND(subst));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tree = <a href="#L267" title="utils/adt/tsquery_rewrite.c:267">findsubquery</a>(tree, qex, subs, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="tsquery_util.c.html#L64" title="utils/adt/tsquery_util.c:64">QTNFree</a>(qex);<br/></li>
<li>&nbsp; &nbsp; <a href="tsquery_util.c.html#L64" title="utils/adt/tsquery_util.c:64">QTNFree</a>(subs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!tree)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SET_VARSIZE(rewritten, HDRSIZETQ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rewritten-&gt;size = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_FREE_IF_COPY(ex, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_FREE_IF_COPY(subst, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_POINTER(rewritten);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="tsquery_util.c.html#L250" title="utils/adt/tsquery_util.c:250">QTNBinary</a>(tree);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rewritten = <a href="tsquery_util.c.html#L363" title="utils/adt/tsquery_util.c:363">QTN2QT</a>(tree);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="tsquery_util.c.html#L64" title="utils/adt/tsquery_util.c:64">QTNFree</a>(tree);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(query, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(ex, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(subst, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(rewritten);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
