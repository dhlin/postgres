<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/adt/date.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/adt/date.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L1645">AdjustTimeForTypmod</a></li>
<li><a href="#L294">EncodeSpecialDate</a></li>
<li><a href="#L309">GetSQLCurrentDate</a></li>
<li><a href="#L342">GetSQLCurrentTime</a></li>
<li><a href="#L362">GetSQLLocalTime</a></li>
<li><a href="#L71">anytime_typmod_check</a></li>
<li><a href="#L50">anytime_typmodin</a></li>
<li><a href="#L93">anytime_typmodout</a></li>
<li><a href="#L608">date2timestamp</a></li>
<li><a href="#L720">date2timestamp_no_overflow</a></li>
<li><a href="#L564">date2timestamp_opt_overflow</a></li>
<li><a href="#L704">date2timestamptz</a></li>
<li><a href="#L624">date2timestamptz_opt_overflow</a></li>
<li><a href="#L437">date_cmp</a></li>
<li><a href="#L814">date_cmp_timestamp</a></li>
<li><a href="#L743">date_cmp_timestamp_internal</a></li>
<li><a href="#L898">date_cmp_timestamptz</a></li>
<li><a href="#L823">date_cmp_timestamptz_internal</a></li>
<li><a href="#L383">date_eq</a></li>
<li><a href="#L760">date_eq_timestamp</a></li>
<li><a href="#L844">date_eq_timestamptz</a></li>
<li><a href="#L459">date_finite</a></li>
<li><a href="#L428">date_ge</a></li>
<li><a href="#L805">date_ge_timestamp</a></li>
<li><a href="#L889">date_ge_timestamptz</a></li>
<li><a href="#L419">date_gt</a></li>
<li><a href="#L787">date_gt_timestamp</a></li>
<li><a href="#L871">date_gt_timestamptz</a></li>
<li><a href="#L113">date_in</a></li>
<li><a href="#L467">date_larger</a></li>
<li><a href="#L410">date_le</a></li>
<li><a href="#L796">date_le_timestamp</a></li>
<li><a href="#L880">date_le_timestamptz</a></li>
<li><a href="#L401">date_lt</a></li>
<li><a href="#L778">date_lt_timestamp</a></li>
<li><a href="#L862">date_lt_timestamptz</a></li>
<li><a href="#L487">date_mi</a></li>
<li><a href="#L1266">date_mi_interval</a></li>
<li><a href="#L528">date_mii</a></li>
<li><a href="#L392">date_ne</a></li>
<li><a href="#L769">date_ne_timestamp</a></li>
<li><a href="#L853">date_ne_timestamptz</a></li>
<li><a href="#L184">date_out</a></li>
<li><a href="#L1246">date_pl_interval</a></li>
<li><a href="#L504">date_pli</a></li>
<li><a href="#L209">date_recv</a></li>
<li><a href="#L231">date_send</a></li>
<li><a href="#L476">date_smaller</a></li>
<li><a href="#L450">date_sortsupport</a></li>
<li><a href="#L1283">date_timestamp</a></li>
<li><a href="#L1327">date_timestamptz</a></li>
<li><a href="#L1966">datetime_timestamp</a></li>
<li><a href="#L2886">datetimetz_timestamptz</a></li>
<li><a href="#L1066">extract_date</a></li>
<li><a href="#L2249">extract_time</a></li>
<li><a href="#L3050">extract_timetz</a></li>
<li><a href="#L1451">float_time_overflows</a></li>
<li><a href="#L1039">in_range_date_interval</a></li>
<li><a href="#L2098">in_range_time_interval</a></li>
<li><a href="#L2650">in_range_timetz_interval</a></li>
<li><a href="#L2012">interval_time</a></li>
<li><a href="#L245">make_date</a></li>
<li><a href="#L1577">make_time</a></li>
<li><a href="#L1783">overlaps_time</a></li>
<li><a href="#L2695">overlaps_timetz</a></li>
<li><a href="#L1488">time2tm</a></li>
<li><a href="#L1734">time_cmp</a></li>
<li><a href="#L1680">time_eq</a></li>
<li><a href="#L1725">time_ge</a></li>
<li><a href="#L1716">time_gt</a></li>
<li><a href="#L1747">time_hash</a></li>
<li><a href="#L1753">time_hash_extended</a></li>
<li><a href="#L1374">time_in</a></li>
<li><a href="#L1989">time_interval</a></li>
<li><a href="#L1759">time_larger</a></li>
<li><a href="#L1707">time_le</a></li>
<li><a href="#L1698">time_lt</a></li>
<li><a href="#L2075">time_mi_interval</a></li>
<li><a href="#L2033">time_mi_time</a></li>
<li><a href="#L1689">time_ne</a></li>
<li><a href="#L1501">time_out</a></li>
<li><a href="#L1427">time_overflows</a></li>
<li><a href="#L2243">time_part</a></li>
<li><a href="#L2140">time_part_common</a></li>
<li><a href="#L2052">time_pl_interval</a></li>
<li><a href="#L1521">time_recv</a></li>
<li><a href="#L1625">time_scale</a></li>
<li><a href="#L1547">time_send</a></li>
<li><a href="#L1768">time_smaller</a></li>
<li><a href="#L1605">time_support</a></li>
<li><a href="#L2828">time_timetz</a></li>
<li><a href="#L961">timestamp_cmp_date</a></li>
<li><a href="#L1297">timestamp_date</a></li>
<li><a href="#L907">timestamp_eq_date</a></li>
<li><a href="#L952">timestamp_ge_date</a></li>
<li><a href="#L934">timestamp_gt_date</a></li>
<li><a href="#L943">timestamp_le_date</a></li>
<li><a href="#L925">timestamp_lt_date</a></li>
<li><a href="#L916">timestamp_ne_date</a></li>
<li><a href="#L1905">timestamp_time</a></li>
<li><a href="#L1024">timestamptz_cmp_date</a></li>
<li><a href="#L1342">timestamptz_date</a></li>
<li><a href="#L970">timestamptz_eq_date</a></li>
<li><a href="#L1015">timestamptz_ge_date</a></li>
<li><a href="#L997">timestamptz_gt_date</a></li>
<li><a href="#L1006">timestamptz_le_date</a></li>
<li><a href="#L988">timestamptz_lt_date</a></li>
<li><a href="#L979">timestamptz_ne_date</a></li>
<li><a href="#L1935">timestamptz_time</a></li>
<li><a href="#L2854">timestamptz_timetz</a></li>
<li><a href="#L1558">timetypmodin</a></li>
<li><a href="#L1566">timetypmodout</a></li>
<li><a href="#L2403">timetz2tm</a></li>
<li><a href="#L3165">timetz_at_local</a></li>
<li><a href="#L2524">timetz_cmp</a></li>
<li><a href="#L2443">timetz_cmp_internal</a></li>
<li><a href="#L2470">timetz_eq</a></li>
<li><a href="#L2515">timetz_ge</a></li>
<li><a href="#L2506">timetz_gt</a></li>
<li><a href="#L2533">timetz_hash</a></li>
<li><a href="#L2549">timetz_hash_extended</a></li>
<li><a href="#L2273">timetz_in</a></li>
<li><a href="#L3122">timetz_izone</a></li>
<li><a href="#L2565">timetz_larger</a></li>
<li><a href="#L2497">timetz_le</a></li>
<li><a href="#L2488">timetz_lt</a></li>
<li><a href="#L2623">timetz_mi_interval</a></li>
<li><a href="#L2479">timetz_ne</a></li>
<li><a href="#L2314">timetz_out</a></li>
<li><a href="#L3044">timetz_part</a></li>
<li><a href="#L2927">timetz_part_common</a></li>
<li><a href="#L2596">timetz_pl_interval</a></li>
<li><a href="#L2335">timetz_recv</a></li>
<li><a href="#L2425">timetz_scale</a></li>
<li><a href="#L2371">timetz_send</a></li>
<li><a href="#L2579">timetz_smaller</a></li>
<li><a href="#L2815">timetz_time</a></li>
<li><a href="#L3060">timetz_zone</a></li>
<li><a href="#L2383">timetztypmodin</a></li>
<li><a href="#L2391">timetztypmodout</a></li>
<li><a href="#L1416">tm2time</a></li>
<li><a href="#L2263">tm2timetz</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L1798">TIMEADT_GT</a></li>
<li><a href="#L1897">TIMEADT_GT</a></li>
<li><a href="#L1800">TIMEADT_LT</a></li>
<li><a href="#L1898">TIMEADT_LT</a></li>
<li><a href="#L2710">TIMETZ_GT</a></li>
<li><a href="#L2809">TIMETZ_GT</a></li>
<li><a href="#L2712">TIMETZ_LT</a></li>
<li><a href="#L2810">TIMETZ_LT</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * date.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; implements DATE and TIME data types specified in SQL standard<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994-5, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/adt/date.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;ctype.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;limits.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;float.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;math.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;time.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/hashfn.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/int.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/pqformat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/supportnodes.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/scansup.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/array.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/date.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/datetime.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/<a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/sortsupport.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * gcc's -ffast-math switch breaks routines that expect exact results from<br/></li>
<li></span><span class="Comment"> * expressions like timeval / SECS_PER_HOUR, where timeval is double.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#ifdef __FAST_MATH__<br/></li>
<li></span><span class="PreProc">#error -ffast-math is known to </span><span class="Statement">break</span><span class="PreProc"> this code<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* common code for <a href="#L1558" title="utils/adt/date.c:1558">timetypmodin</a> and <a href="#L2383" title="utils/adt/date.c:2383">timetztypmodin</a> */<br/></li>
<li></span><span class="Type">static</span> int32<br/></li>
<li><a id="L50">&#x200c;</a><span class="linkable">anytime_typmodin</span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> istz, ArrayType *ta)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp;&nbsp; *tl;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tl = <a href="arrayutils.c.html#L233" title="utils/adt/arrayutils.c:233">ArrayGetIntegerTypmods</a>(ta, &amp;n);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we're not too tense about good error message here because grammar<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * shouldn't allow wrong number of modifiers for TIME<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (n != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid type modifier&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L71" title="utils/adt/date.c:71">anytime_typmod_check</a>(istz, tl[<span class="Constant">0</span>]);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* exported so parse_expr.c can use it */<br/></li>
<li></span>int32<br/></li>
<li><a id="L71">&#x200c;</a><span class="linkable">anytime_typmod_check</span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> istz, int32 typmod)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (typmod &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;TIME(</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">%s</span><span class="Constant"> precision must not be negative&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typmod, (istz ? <span class="Constant">&quot; WITH TIME ZONE&quot;</span> : <span class="Constant">&quot;&quot;</span>))));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (typmod &gt; MAX_TIME_PRECISION)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;TIME(</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">%s</span><span class="Constant"> precision reduced to maximum allowed, </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typmod, (istz ? <span class="Constant">&quot; WITH TIME ZONE&quot;</span> : <span class="Constant">&quot;&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MAX_TIME_PRECISION)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typmod = MAX_TIME_PRECISION;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> typmod;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* common code for <a href="#L1566" title="utils/adt/date.c:1566">timetypmodout</a> and <a href="#L2391" title="utils/adt/date.c:2391">timetztypmodout</a> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L93">&#x200c;</a><span class="linkable">anytime_typmodout</span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> istz, int32 typmod)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *tz = istz ? <span class="Constant">&quot; with time zone&quot;</span> : <span class="Constant">&quot; without time zone&quot;</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (typmod &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> psprintf(<span class="Constant">&quot;(</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">%s</span><span class="Constant">&quot;</span>, (<span class="Type">int</span>) typmod, tz);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(tz);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*****************************************************************************<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; Date ADT<br/></li>
<li></span><span class="Comment"> *****************************************************************************/<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L113" title="utils/adt/date.c:113">date_in</a>()<br/></li>
<li></span><span class="Comment"> * Given date text string, convert to <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> date format.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L113">&#x200c;</a><span class="linkable">date_in</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *str = PG_GETARG_CSTRING(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *escontext = fcinfo-&gt;context;<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; date;<br/></li>
<li>&nbsp; &nbsp; fsec_t&nbsp; &nbsp; &nbsp; &nbsp; fsec;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> pg_tm tt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *tm = &amp;tt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tzp;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dtype;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dterr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *field[MAXDATEFIELDS];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ftype[MAXDATEFIELDS];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; workbuf[MAXDATELEN + <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; DateTimeErrorExtra extra;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dterr = <a href="datetime.c.html#L754" title="utils/adt/datetime.c:754">ParseDateTime</a>(str, workbuf, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(workbuf),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; field, ftype, MAXDATEFIELDS, &amp;nf);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dterr == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dterr = <a href="datetime.c.html#L978" title="utils/adt/datetime.c:978">DecodeDateTime</a>(field, ftype, nf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;dtype, tm, &amp;fsec, &amp;tzp, &amp;extra);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dterr != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="datetime.c.html#L4081" title="utils/adt/datetime.c:4081">DateTimeParseError</a>(dterr, &amp;extra, str, <span class="Constant">&quot;date&quot;</span>, escontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (dtype)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_DATE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_EPOCH:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="timestamp.c.html#L2168" title="utils/adt/timestamp.c:2168">GetEpochTime</a>(tm);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_LATE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DATE_NOEND(date);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_DATEADT(date);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_EARLY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DATE_NOBEGIN(date);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_DATEADT(date);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="datetime.c.html#L4081" title="utils/adt/datetime.c:4081">DateTimeParseError</a>(DTERR_BAD_FORMAT, &amp;extra, str, <span class="Constant">&quot;date&quot;</span>, escontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Prevent overflow in Julian-day routines */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!IS_VALID_JULIAN(tm-&gt;tm_year, tm-&gt;tm_mon, tm-&gt;tm_mday))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;date out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, str)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; date = <a href="datetime.c.html#L286" title="utils/adt/datetime.c:286">date2j</a>(tm-&gt;tm_year, tm-&gt;tm_mon, tm-&gt;tm_mday) - POSTGRES_EPOCH_JDATE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now check for just-out-of-<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> dates */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!IS_VALID_DATE(date))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;date out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, str)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_DATEADT(date);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L184" title="utils/adt/date.c:184">date_out</a>()<br/></li>
<li></span><span class="Comment"> * Given <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> format date, convert to text string.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L184">&#x200c;</a><span class="linkable">date_out</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; date = PG_GETARG_DATEADT(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> pg_tm tt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *tm = &amp;tt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; buf[MAXDATELEN + <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (DATE_NOT_FINITE(date))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L294" title="utils/adt/date.c:294">EncodeSpecialDate</a>(date, buf);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="datetime.c.html#L311" title="utils/adt/datetime.c:311">j2date</a>(date + POSTGRES_EPOCH_JDATE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;(tm-&gt;tm_year), &amp;(tm-&gt;tm_mon), &amp;(tm-&gt;tm_mday));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="datetime.c.html#L4216" title="utils/adt/datetime.c:4216">EncodeDateOnly</a>(tm, <a href="../init/globals.c.html#L122" title="utils/init/globals.c:122">DateStyle</a>, buf);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(buf);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CSTRING(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L209" title="utils/adt/date.c:209">date_recv</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts external binary format to date<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L209">&#x200c;</a><span class="linkable">date_recv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; buf = (StringInfo) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (DateADT) <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(buf, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(DateADT));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Limit to the same <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> that <a href="#L113" title="utils/adt/date.c:113">date_in</a>() accepts. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (DATE_NOT_FINITE(result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Comment">/* ok */</span> ;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!IS_VALID_DATE(result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;date out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_DATEADT(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L231" title="utils/adt/date.c:231">date_send</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts date to binary format<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L231">&#x200c;</a><span class="linkable">date_send</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; date = PG_GETARG_DATEADT(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L326" title="libpq/pqformat.c:326">pq_begintypsend</a>(&amp;buf);<br/></li>
<li>&nbsp; &nbsp; pq_sendint32(&amp;buf, date);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BYTEA_P(<a href="../../libpq/pqformat.c.html#L346" title="libpq/pqformat.c:346">pq_endtypsend</a>(&amp;buf));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L245" title="utils/adt/date.c:245">make_date</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - date constructor<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L245">&#x200c;</a><span class="linkable">make_date</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> pg_tm tm;<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; date;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dterr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; bc = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tm.tm_year = PG_GETARG_INT32(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; tm.tm_mon = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; tm.tm_mday = PG_GETARG_INT32(<span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Handle negative years as BC */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tm.tm_year &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bc = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tm.tm_year = -tm.tm_year;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dterr = <a href="datetime.c.html#L2497" title="utils/adt/datetime.c:2497">ValidateDate</a>(DTK_DATE_M, <span class="Constant">false</span>, <span class="Constant">false</span>, bc, &amp;tm);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dterr != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_FIELD_OVERFLOW),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;date field value out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>: </span><span class="Special">%d</span><span class="Constant">-</span><span class="Special">%02d</span><span class="Constant">-</span><span class="Special">%02d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm.tm_year, tm.tm_mon, tm.tm_mday)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Prevent overflow in Julian-day routines */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!IS_VALID_JULIAN(tm.tm_year, tm.tm_mon, tm.tm_mday))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;date out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>: </span><span class="Special">%d</span><span class="Constant">-</span><span class="Special">%02d</span><span class="Constant">-</span><span class="Special">%02d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm.tm_year, tm.tm_mon, tm.tm_mday)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; date = <a href="datetime.c.html#L286" title="utils/adt/datetime.c:286">date2j</a>(tm.tm_year, tm.tm_mon, tm.tm_mday) - POSTGRES_EPOCH_JDATE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now check for just-out-of-<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> dates */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!IS_VALID_DATE(date))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;date out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>: </span><span class="Special">%d</span><span class="Constant">-</span><span class="Special">%02d</span><span class="Constant">-</span><span class="Special">%02d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm.tm_year, tm.tm_mon, tm.tm_mday)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_DATEADT(date);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert reserved date <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to string.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L294">&#x200c;</a></span><span class="linkable">EncodeSpecialDate</span>(DateADT dt, <span class="Type">char</span> *str)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (DATE_IS_NOBEGIN(dt))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; strcpy(str, EARLY);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (DATE_IS_NOEND(dt))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; strcpy(str, LATE);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* shouldn't happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid argument for <a href="#L294" title="utils/adt/date.c:294">EncodeSpecialDate</a>&quot;</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L309" title="utils/adt/date.c:309">GetSQLCurrentDate</a> -- implements CURRENT_DATE<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>DateADT<br/></li>
<li><a id="L309">&#x200c;</a><span class="linkable">GetSQLCurrentDate</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> pg_tm tm;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; cache_year = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; cache_mon = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; cache_mday = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> DateADT cache_date;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="datetime.c.html#L366" title="utils/adt/datetime.c:366">GetCurrentDateTime</a>(&amp;tm);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="datetime.c.html#L286" title="utils/adt/datetime.c:286">date2j</a> involves several integer divisions; moreover, unless our session<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lives across local midnight, we don't really have to do it more than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * once.&nbsp; So it seems worth having a separate cache here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tm.tm_year != cache_year ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tm.tm_mon != cache_mon ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tm.tm_mday != cache_mday)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cache_date = <a href="datetime.c.html#L286" title="utils/adt/datetime.c:286">date2j</a>(tm.tm_year, tm.tm_mon, tm.tm_mday) - POSTGRES_EPOCH_JDATE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cache_year = tm.tm_year;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cache_mon = tm.tm_mon;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cache_mday = tm.tm_mday;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> cache_date;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L342" title="utils/adt/date.c:342">GetSQLCurrentTime</a> -- implements CURRENT_TIME, CURRENT_TIME(n)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TimeTzADT *<br/></li>
<li><a id="L342">&#x200c;</a><span class="linkable">GetSQLCurrentTime</span>(int32 typmod)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimeTzADT&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> pg_tm tt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *tm = &amp;tt;<br/></li>
<li>&nbsp; &nbsp; fsec_t&nbsp; &nbsp; &nbsp; &nbsp; fsec;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="datetime.c.html#L387" title="utils/adt/datetime.c:387">GetCurrentTimeUsec</a>(tm, &amp;fsec, &amp;tz);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (TimeTzADT *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TimeTzADT));<br/></li>
<li>&nbsp; &nbsp; <a href="#L2263" title="utils/adt/date.c:2263">tm2timetz</a>(tm, fsec, tz, result);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1645" title="utils/adt/date.c:1645">AdjustTimeForTypmod</a>(&amp;(result-&gt;time), typmod);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L362" title="utils/adt/date.c:362">GetSQLLocalTime</a> -- implements LOCALTIME, LOCALTIME(n)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TimeADT<br/></li>
<li><a id="L362">&#x200c;</a><span class="linkable">GetSQLLocalTime</span>(int32 typmod)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimeADT&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> pg_tm tt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *tm = &amp;tt;<br/></li>
<li>&nbsp; &nbsp; fsec_t&nbsp; &nbsp; &nbsp; &nbsp; fsec;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="datetime.c.html#L387" title="utils/adt/datetime.c:387">GetCurrentTimeUsec</a>(tm, &amp;fsec, &amp;tz);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1416" title="utils/adt/date.c:1416">tm2time</a>(tm, fsec, &amp;result);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1645" title="utils/adt/date.c:1645">AdjustTimeForTypmod</a>(&amp;result, typmod);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Comparison <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for dates<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L383">&#x200c;</a><span class="linkable">date_eq</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; dateVal1 = PG_GETARG_DATEADT(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; dateVal2 = PG_GETARG_DATEADT(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(dateVal1 == dateVal2);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L392">&#x200c;</a><span class="linkable">date_ne</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; dateVal1 = PG_GETARG_DATEADT(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; dateVal2 = PG_GETARG_DATEADT(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(dateVal1 != dateVal2);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L401">&#x200c;</a><span class="linkable">date_lt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; dateVal1 = PG_GETARG_DATEADT(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; dateVal2 = PG_GETARG_DATEADT(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(dateVal1 &lt; dateVal2);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L410">&#x200c;</a><span class="linkable">date_le</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; dateVal1 = PG_GETARG_DATEADT(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; dateVal2 = PG_GETARG_DATEADT(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(dateVal1 &lt;= dateVal2);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L419">&#x200c;</a><span class="linkable">date_gt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; dateVal1 = PG_GETARG_DATEADT(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; dateVal2 = PG_GETARG_DATEADT(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(dateVal1 &gt; dateVal2);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L428">&#x200c;</a><span class="linkable">date_ge</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; dateVal1 = PG_GETARG_DATEADT(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; dateVal2 = PG_GETARG_DATEADT(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(dateVal1 &gt;= dateVal2);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L437">&#x200c;</a><span class="linkable">date_cmp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; dateVal1 = PG_GETARG_DATEADT(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; dateVal2 = PG_GETARG_DATEADT(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dateVal1 &lt; dateVal2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_INT32(-<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (dateVal1 &gt; dateVal2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(<span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L450">&#x200c;</a><span class="linkable">date_sortsupport</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SortSupport ssup = (SortSupport) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ssup-&gt;comparator = <a href="../sort/tuplesort.c.html#L3204" title="utils/sort/tuplesort.c:3204">ssup_datum_int32_cmp</a>;<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VOID();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L459">&#x200c;</a><span class="linkable">date_finite</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; date = PG_GETARG_DATEADT(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(!DATE_NOT_FINITE(date));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L467">&#x200c;</a><span class="linkable">date_larger</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; dateVal1 = PG_GETARG_DATEADT(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; dateVal2 = PG_GETARG_DATEADT(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_DATEADT((dateVal1 &gt; dateVal2) ? dateVal1 : dateVal2);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L476">&#x200c;</a><span class="linkable">date_smaller</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; dateVal1 = PG_GETARG_DATEADT(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; dateVal2 = PG_GETARG_DATEADT(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_DATEADT((dateVal1 &lt; dateVal2) ? dateVal1 : dateVal2);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Compute difference between two dates in <a href="datetime.c.html#L84" title="utils/adt/datetime.c:84">days</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L487">&#x200c;</a><span class="linkable">date_mi</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; dateVal1 = PG_GETARG_DATEADT(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; dateVal2 = PG_GETARG_DATEADT(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (DATE_NOT_FINITE(dateVal1) || DATE_NOT_FINITE(dateVal2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot subtract infinite dates&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32((int32) (dateVal1 - dateVal2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Add a number of <a href="datetime.c.html#L84" title="utils/adt/datetime.c:84">days</a> to a date, giving a new date.<br/></li>
<li></span><span class="Comment"> * Must handle both positive and negative numbers of <a href="datetime.c.html#L84" title="utils/adt/datetime.c:84">days</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L504">&#x200c;</a><span class="linkable">date_pli</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; dateVal = PG_GETARG_DATEADT(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; <a href="datetime.c.html#L84" title="utils/adt/datetime.c:84">days</a> = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (DATE_NOT_FINITE(dateVal))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_DATEADT(dateVal); <span class="Comment">/* can't change infinity */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; result = dateVal + <a href="datetime.c.html#L84" title="utils/adt/datetime.c:84">days</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for integer overflow and out-of-allowed-<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((<a href="datetime.c.html#L84" title="utils/adt/datetime.c:84">days</a> &gt;= <span class="Constant">0</span> ? (result &lt; dateVal) : (result &gt; dateVal)) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !IS_VALID_DATE(result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;date out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_DATEADT(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Subtract a number of <a href="datetime.c.html#L84" title="utils/adt/datetime.c:84">days</a> from a date, giving a new date.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L528">&#x200c;</a><span class="linkable">date_mii</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; dateVal = PG_GETARG_DATEADT(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; <a href="datetime.c.html#L84" title="utils/adt/datetime.c:84">days</a> = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (DATE_NOT_FINITE(dateVal))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_DATEADT(dateVal); <span class="Comment">/* can't change infinity */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; result = dateVal - <a href="datetime.c.html#L84" title="utils/adt/datetime.c:84">days</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for integer overflow and out-of-allowed-<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((<a href="datetime.c.html#L84" title="utils/adt/datetime.c:84">days</a> &gt;= <span class="Constant">0</span> ? (result &gt; dateVal) : (result &lt; dateVal)) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !IS_VALID_DATE(result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;date out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_DATEADT(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Promote date to timestamp.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On successful conversion, *overflow is set to zero if it's not NULL.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the date is finite but out of the valid <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> for timestamp, then:<br/></li>
<li></span><span class="Comment"> * if overflow is NULL, we throw an out-of-<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> error.<br/></li>
<li></span><span class="Comment"> * if overflow is not NULL, we store +1 or -1 there to indicate the sign<br/></li>
<li></span><span class="Comment"> * of the overflow, and return the appropriate timestamp infinity.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: *overflow = -1 is actually not possible currently, since both<br/></li>
<li></span><span class="Comment"> * datatypes have the same <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound, Julian day zero.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Timestamp<br/></li>
<li><a id="L564">&#x200c;</a><span class="linkable">date2timestamp_opt_overflow</span>(DateADT dateVal, <span class="Type">int</span> *overflow)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (overflow)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *overflow = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (DATE_IS_NOBEGIN(dateVal))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TIMESTAMP_NOBEGIN(result);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (DATE_IS_NOEND(dateVal))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TIMESTAMP_NOEND(result);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since dates have the same minimum <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> as timestamps, only <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * boundary need be checked for overflow.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dateVal &gt;= (TIMESTAMP_END_JULIAN - POSTGRES_EPOCH_JDATE))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (overflow)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *overflow = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TIMESTAMP_NOEND(result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;date out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> for timestamp&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* date is <a href="datetime.c.html#L84" title="utils/adt/datetime.c:84">days</a> since 2000, timestamp is microseconds since same... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = dateVal * USECS_PER_DAY;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Promote date to timestamp, throwing error for overflow.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> TimestampTz<br/></li>
<li><a id="L608">&#x200c;</a><span class="linkable">date2timestamp</span>(DateADT dateVal)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L564" title="utils/adt/date.c:564">date2timestamp_opt_overflow</a>(dateVal, <span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Promote date to timestamp with time zone.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On successful conversion, *overflow is set to zero if it's not NULL.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the date is finite but out of the valid <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> for timestamptz, then:<br/></li>
<li></span><span class="Comment"> * if overflow is NULL, we throw an out-of-<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> error.<br/></li>
<li></span><span class="Comment"> * if overflow is not NULL, we store +1 or -1 there to indicate the sign<br/></li>
<li></span><span class="Comment"> * of the overflow, and return the appropriate timestamptz infinity.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TimestampTz<br/></li>
<li><a id="L624">&#x200c;</a><span class="linkable">date2timestamptz_opt_overflow</span>(DateADT dateVal, <span class="Type">int</span> *overflow)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> pg_tm tt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *tm = &amp;tt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (overflow)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *overflow = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (DATE_IS_NOBEGIN(dateVal))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TIMESTAMP_NOBEGIN(result);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (DATE_IS_NOEND(dateVal))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TIMESTAMP_NOEND(result);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since dates have the same minimum <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> as timestamps, only <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * boundary need be checked for overflow.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dateVal &gt;= (TIMESTAMP_END_JULIAN - POSTGRES_EPOCH_JDATE))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (overflow)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *overflow = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TIMESTAMP_NOEND(result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;date out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> for timestamp&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="datetime.c.html#L311" title="utils/adt/datetime.c:311">j2date</a>(dateVal + POSTGRES_EPOCH_JDATE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;(tm-&gt;tm_year), &amp;(tm-&gt;tm_mon), &amp;(tm-&gt;tm_mday));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_hour = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_min = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_sec = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tz = <a href="datetime.c.html#L1585" title="utils/adt/datetime.c:1585">DetermineTimeZoneOffset</a>(tm, session_timezone);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = dateVal * USECS_PER_DAY + tz * USECS_PER_SEC;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since it is possible to go beyond allowed timestamptz <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of time zone, check for allowed timestamp <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> after adding tz.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!IS_VALID_TIMESTAMP(result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (overflow)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result &lt; MIN_TIMESTAMP)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *overflow = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TIMESTAMP_NOBEGIN(result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *overflow = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TIMESTAMP_NOEND(result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;date out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> for timestamp&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Promote date to timestamptz, throwing error for overflow.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> TimestampTz<br/></li>
<li><a id="L704">&#x200c;</a><span class="linkable">date2timestamptz</span>(DateADT dateVal)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L624" title="utils/adt/date.c:624">date2timestamptz_opt_overflow</a>(dateVal, <span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L720" title="utils/adt/date.c:720">date2timestamp_no_overflow</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is chartered to produce a double value that is numerically<br/></li>
<li></span><span class="Comment"> * equivalent to the corresponding Timestamp value, if the date is in the<br/></li>
<li></span><span class="Comment"> * valid <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of Timestamps, but in <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case not throw an overflow error.<br/></li>
<li></span><span class="Comment"> * We can do this since the numerical <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of double is greater than<br/></li>
<li></span><span class="Comment"> * that of non-erroneous timestamps.&nbsp; The results are currently only<br/></li>
<li></span><span class="Comment"> * used for statistical estimation purposes.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">double<br/></li>
<li><a id="L720">&#x200c;</a></span><span class="linkable">date2timestamp_no_overflow</span>(DateADT dateVal)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (DATE_IS_NOBEGIN(dateVal))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = -<span class="Constant">DBL_MAX</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (DATE_IS_NOEND(dateVal))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">DBL_MAX</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* date is <a href="datetime.c.html#L84" title="utils/adt/datetime.c:84">days</a> since 2000, timestamp is microseconds since same... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = dateVal * (<span class="Type">double</span>) USECS_PER_DAY;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Crosstype comparison <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for dates<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li>int32<br/></li>
<li><a id="L743">&#x200c;</a><span class="linkable">date_cmp_timestamp_internal</span>(DateADT dateVal, Timestamp dt2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; dt1;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; overflow;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dt1 = <a href="#L564" title="utils/adt/date.c:564">date2timestamp_opt_overflow</a>(dateVal, &amp;overflow);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (overflow &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* dt1 is larger than <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> finite timestamp, but less than infinity */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> TIMESTAMP_IS_NOEND(dt2) ? -<span class="Constant">1</span> : +<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; Assert(overflow == <span class="Constant">0</span>);&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* -1 case cannot occur */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="timestamp.c.html#L2210" title="utils/adt/timestamp.c:2210">timestamp_cmp_internal</a>(dt1, dt2);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L760">&#x200c;</a><span class="linkable">date_eq_timestamp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; dateVal = PG_GETARG_DATEADT(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; dt2 = PG_GETARG_TIMESTAMP(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L743" title="utils/adt/date.c:743">date_cmp_timestamp_internal</a>(dateVal, dt2) == <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L769">&#x200c;</a><span class="linkable">date_ne_timestamp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; dateVal = PG_GETARG_DATEADT(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; dt2 = PG_GETARG_TIMESTAMP(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L743" title="utils/adt/date.c:743">date_cmp_timestamp_internal</a>(dateVal, dt2) != <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L778">&#x200c;</a><span class="linkable">date_lt_timestamp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; dateVal = PG_GETARG_DATEADT(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; dt2 = PG_GETARG_TIMESTAMP(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L743" title="utils/adt/date.c:743">date_cmp_timestamp_internal</a>(dateVal, dt2) &lt; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L787">&#x200c;</a><span class="linkable">date_gt_timestamp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; dateVal = PG_GETARG_DATEADT(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; dt2 = PG_GETARG_TIMESTAMP(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L743" title="utils/adt/date.c:743">date_cmp_timestamp_internal</a>(dateVal, dt2) &gt; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L796">&#x200c;</a><span class="linkable">date_le_timestamp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; dateVal = PG_GETARG_DATEADT(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; dt2 = PG_GETARG_TIMESTAMP(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L743" title="utils/adt/date.c:743">date_cmp_timestamp_internal</a>(dateVal, dt2) &lt;= <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L805">&#x200c;</a><span class="linkable">date_ge_timestamp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; dateVal = PG_GETARG_DATEADT(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; dt2 = PG_GETARG_TIMESTAMP(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L743" title="utils/adt/date.c:743">date_cmp_timestamp_internal</a>(dateVal, dt2) &gt;= <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L814">&#x200c;</a><span class="linkable">date_cmp_timestamp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; dateVal = PG_GETARG_DATEADT(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; dt2 = PG_GETARG_TIMESTAMP(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(<a href="#L743" title="utils/adt/date.c:743">date_cmp_timestamp_internal</a>(dateVal, dt2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>int32<br/></li>
<li><a id="L823">&#x200c;</a><span class="linkable">date_cmp_timestamptz_internal</span>(DateADT dateVal, TimestampTz dt2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz dt1;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; overflow;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dt1 = <a href="#L624" title="utils/adt/date.c:624">date2timestamptz_opt_overflow</a>(dateVal, &amp;overflow);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (overflow &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* dt1 is larger than <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> finite timestamp, but less than infinity */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> TIMESTAMP_IS_NOEND(dt2) ? -<span class="Constant">1</span> : +<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (overflow &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* dt1 is less than <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> finite timestamp, but more than -infinity */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> TIMESTAMP_IS_NOBEGIN(dt2) ? +<span class="Constant">1</span> : -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> timestamptz_cmp_internal(dt1, dt2);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L844">&#x200c;</a><span class="linkable">date_eq_timestamptz</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; dateVal = PG_GETARG_DATEADT(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimestampTz dt2 = PG_GETARG_TIMESTAMPTZ(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L823" title="utils/adt/date.c:823">date_cmp_timestamptz_internal</a>(dateVal, dt2) == <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L853">&#x200c;</a><span class="linkable">date_ne_timestamptz</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; dateVal = PG_GETARG_DATEADT(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimestampTz dt2 = PG_GETARG_TIMESTAMPTZ(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L823" title="utils/adt/date.c:823">date_cmp_timestamptz_internal</a>(dateVal, dt2) != <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L862">&#x200c;</a><span class="linkable">date_lt_timestamptz</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; dateVal = PG_GETARG_DATEADT(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimestampTz dt2 = PG_GETARG_TIMESTAMPTZ(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L823" title="utils/adt/date.c:823">date_cmp_timestamptz_internal</a>(dateVal, dt2) &lt; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L871">&#x200c;</a><span class="linkable">date_gt_timestamptz</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; dateVal = PG_GETARG_DATEADT(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimestampTz dt2 = PG_GETARG_TIMESTAMPTZ(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L823" title="utils/adt/date.c:823">date_cmp_timestamptz_internal</a>(dateVal, dt2) &gt; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L880">&#x200c;</a><span class="linkable">date_le_timestamptz</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; dateVal = PG_GETARG_DATEADT(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimestampTz dt2 = PG_GETARG_TIMESTAMPTZ(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L823" title="utils/adt/date.c:823">date_cmp_timestamptz_internal</a>(dateVal, dt2) &lt;= <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L889">&#x200c;</a><span class="linkable">date_ge_timestamptz</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; dateVal = PG_GETARG_DATEADT(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimestampTz dt2 = PG_GETARG_TIMESTAMPTZ(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L823" title="utils/adt/date.c:823">date_cmp_timestamptz_internal</a>(dateVal, dt2) &gt;= <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L898">&#x200c;</a><span class="linkable">date_cmp_timestamptz</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; dateVal = PG_GETARG_DATEADT(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimestampTz dt2 = PG_GETARG_TIMESTAMPTZ(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(<a href="#L823" title="utils/adt/date.c:823">date_cmp_timestamptz_internal</a>(dateVal, dt2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L907">&#x200c;</a><span class="linkable">timestamp_eq_date</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; dt1 = PG_GETARG_TIMESTAMP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; dateVal = PG_GETARG_DATEADT(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L743" title="utils/adt/date.c:743">date_cmp_timestamp_internal</a>(dateVal, dt1) == <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L916">&#x200c;</a><span class="linkable">timestamp_ne_date</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; dt1 = PG_GETARG_TIMESTAMP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; dateVal = PG_GETARG_DATEADT(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L743" title="utils/adt/date.c:743">date_cmp_timestamp_internal</a>(dateVal, dt1) != <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L925">&#x200c;</a><span class="linkable">timestamp_lt_date</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; dt1 = PG_GETARG_TIMESTAMP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; dateVal = PG_GETARG_DATEADT(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L743" title="utils/adt/date.c:743">date_cmp_timestamp_internal</a>(dateVal, dt1) &gt; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L934">&#x200c;</a><span class="linkable">timestamp_gt_date</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; dt1 = PG_GETARG_TIMESTAMP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; dateVal = PG_GETARG_DATEADT(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L743" title="utils/adt/date.c:743">date_cmp_timestamp_internal</a>(dateVal, dt1) &lt; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L943">&#x200c;</a><span class="linkable">timestamp_le_date</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; dt1 = PG_GETARG_TIMESTAMP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; dateVal = PG_GETARG_DATEADT(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L743" title="utils/adt/date.c:743">date_cmp_timestamp_internal</a>(dateVal, dt1) &gt;= <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L952">&#x200c;</a><span class="linkable">timestamp_ge_date</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; dt1 = PG_GETARG_TIMESTAMP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; dateVal = PG_GETARG_DATEADT(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L743" title="utils/adt/date.c:743">date_cmp_timestamp_internal</a>(dateVal, dt1) &lt;= <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L961">&#x200c;</a><span class="linkable">timestamp_cmp_date</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; dt1 = PG_GETARG_TIMESTAMP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; dateVal = PG_GETARG_DATEADT(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(-<a href="#L743" title="utils/adt/date.c:743">date_cmp_timestamp_internal</a>(dateVal, dt1));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L970">&#x200c;</a><span class="linkable">timestamptz_eq_date</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz dt1 = PG_GETARG_TIMESTAMPTZ(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; dateVal = PG_GETARG_DATEADT(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L823" title="utils/adt/date.c:823">date_cmp_timestamptz_internal</a>(dateVal, dt1) == <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L979">&#x200c;</a><span class="linkable">timestamptz_ne_date</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz dt1 = PG_GETARG_TIMESTAMPTZ(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; dateVal = PG_GETARG_DATEADT(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L823" title="utils/adt/date.c:823">date_cmp_timestamptz_internal</a>(dateVal, dt1) != <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L988">&#x200c;</a><span class="linkable">timestamptz_lt_date</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz dt1 = PG_GETARG_TIMESTAMPTZ(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; dateVal = PG_GETARG_DATEADT(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L823" title="utils/adt/date.c:823">date_cmp_timestamptz_internal</a>(dateVal, dt1) &gt; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L997">&#x200c;</a><span class="linkable">timestamptz_gt_date</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz dt1 = PG_GETARG_TIMESTAMPTZ(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; dateVal = PG_GETARG_DATEADT(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L823" title="utils/adt/date.c:823">date_cmp_timestamptz_internal</a>(dateVal, dt1) &lt; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1006">&#x200c;</a><span class="linkable">timestamptz_le_date</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz dt1 = PG_GETARG_TIMESTAMPTZ(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; dateVal = PG_GETARG_DATEADT(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L823" title="utils/adt/date.c:823">date_cmp_timestamptz_internal</a>(dateVal, dt1) &gt;= <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1015">&#x200c;</a><span class="linkable">timestamptz_ge_date</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz dt1 = PG_GETARG_TIMESTAMPTZ(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; dateVal = PG_GETARG_DATEADT(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L823" title="utils/adt/date.c:823">date_cmp_timestamptz_internal</a>(dateVal, dt1) &lt;= <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1024">&#x200c;</a><span class="linkable">timestamptz_cmp_date</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz dt1 = PG_GETARG_TIMESTAMPTZ(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; dateVal = PG_GETARG_DATEADT(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(-<a href="#L823" title="utils/adt/date.c:823">date_cmp_timestamptz_internal</a>(dateVal, dt1));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * in_range support function for date.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We implement this by promoting the dates to timestamp (without time zone)<br/></li>
<li></span><span class="Comment"> * and then using the timestamp-and-interval in_range function.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1039">&#x200c;</a><span class="linkable">in_range_date_interval</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; val = PG_GETARG_DATEADT(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; base = PG_GETARG_DATEADT(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *offset = PG_GETARG_INTERVAL_P(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; sub = PG_GETARG_BOOL(<span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; less = PG_GETARG_BOOL(<span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; valStamp;<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; baseStamp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">XXX</span><span class="Comment"> we could support out-of-<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> cases here, perhaps */<br/></li>
<li></span>&nbsp; &nbsp; valStamp = <a href="#L608" title="utils/adt/date.c:608">date2timestamp</a>(val);<br/></li>
<li>&nbsp; &nbsp; baseStamp = <a href="#L608" title="utils/adt/date.c:608">date2timestamp</a>(base);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> DirectFunctionCall5(<a href="timestamp.c.html#L3823" title="utils/adt/timestamp.c:3823">in_range_timestamp_interval</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TimestampGetDatum(valStamp),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TimestampGetDatum(baseStamp),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IntervalPGetDatum(offset),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BoolGetDatum(sub),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BoolGetDatum(less));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L1066" title="utils/adt/date.c:1066">extract_date</a>()<br/></li>
<li></span><span class="Comment"> * Extract specified field from date type.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1066">&#x200c;</a><span class="linkable">extract_date</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *units = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; date = PG_GETARG_DATEADT(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; intresult;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *lowunits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; year,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mon,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mday;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; lowunits = <a href="../../parser/scansup.c.html#L37" title="parser/scansup.c:37">downcase_truncate_identifier</a>(VARDATA_ANY(units),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VARSIZE_ANY_EXHDR(units),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; type = <a href="datetime.c.html#L4036" title="utils/adt/datetime.c:4036">DecodeUnits</a>(<span class="Constant">0</span>, lowunits, &amp;val);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (type == UNKNOWN_FIELD)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; type = <a href="datetime.c.html#L3137" title="utils/adt/datetime.c:3137">DecodeSpecial</a>(<span class="Constant">0</span>, lowunits, &amp;val);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (DATE_NOT_FINITE(date) &amp;&amp; (type == UNITS || type == RESERV))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (val)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Oscillating units */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_DAY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MONTH:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_QUARTER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_WEEK:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_DOW:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_ISODOW:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_DOY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Monotonically-increasing units */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_YEAR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_DECADE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_CENTURY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MILLENNIUM:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_JULIAN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_ISOYEAR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_EPOCH:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (DATE_IS_NOBEGIN(date))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(DatumGetNumeric(DirectFunctionCall3(<a href="numeric.c.html#L628" title="utils/adt/numeric.c:628">numeric_in</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CStringGetDatum(<span class="Constant">&quot;-Infinity&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(InvalidOid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Int32GetDatum(-<span class="Constant">1</span>))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(DatumGetNumeric(DirectFunctionCall3(<a href="numeric.c.html#L628" title="utils/adt/numeric.c:628">numeric_in</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CStringGetDatum(<span class="Constant">&quot;Infinity&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(InvalidOid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Int32GetDatum(-<span class="Constant">1</span>))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unit </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> not supported for type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lowunits, <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(DATEOID))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (type == UNITS)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="datetime.c.html#L311" title="utils/adt/datetime.c:311">j2date</a>(date + POSTGRES_EPOCH_JDATE, &amp;year, &amp;mon, &amp;mday);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (val)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_DAY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = mday;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MONTH:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = mon;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_QUARTER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = (mon - <span class="Constant">1</span>) / <span class="Constant">3</span> + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_WEEK:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = <a href="timestamp.c.html#L5155" title="utils/adt/timestamp.c:5155">date2isoweek</a>(year, mon, mday);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_YEAR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (year &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = year;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* there is no year 0, just 1 BC and 1 AD */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = year - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_DECADE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* see comments in <a href="timestamp.c.html#L5599" title="utils/adt/timestamp.c:5599">timestamp_part</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (year &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = year / <span class="Constant">10</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = -((<span class="Constant">8</span> - (year - <span class="Constant">1</span>)) / <span class="Constant">10</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_CENTURY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* see comments in <a href="timestamp.c.html#L5599" title="utils/adt/timestamp.c:5599">timestamp_part</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (year &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = (year + <span class="Constant">99</span>) / <span class="Constant">100</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = -((<span class="Constant">99</span> - (year - <span class="Constant">1</span>)) / <span class="Constant">100</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MILLENNIUM:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* see comments in <a href="timestamp.c.html#L5599" title="utils/adt/timestamp.c:5599">timestamp_part</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (year &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = (year + <span class="Constant">999</span>) / <span class="Constant">1000</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = -((<span class="Constant">999</span> - (year - <span class="Constant">1</span>)) / <span class="Constant">1000</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_JULIAN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = date + POSTGRES_EPOCH_JDATE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_ISOYEAR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = <a href="timestamp.c.html#L5210" title="utils/adt/timestamp.c:5210">date2isoyear</a>(year, mon, mday);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Adjust BC years */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (intresult &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult -= <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_DOW:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_ISODOW:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = <a href="datetime.c.html#L344" title="utils/adt/datetime.c:344">j2day</a>(date + POSTGRES_EPOCH_JDATE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (val == DTK_ISODOW &amp;&amp; intresult == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = <span class="Constant">7</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_DOY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = <a href="datetime.c.html#L286" title="utils/adt/datetime.c:286">date2j</a>(year, mon, mday) - <a href="datetime.c.html#L286" title="utils/adt/datetime.c:286">date2j</a>(year, <span class="Constant">1</span>, <span class="Constant">1</span>) + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unit </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> not supported for type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lowunits, <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(DATEOID))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (type == RESERV)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (val)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_EPOCH:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = ((int64) date + POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unit </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> not supported for type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lowunits, <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(DATEOID))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unit </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> not recognized for type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lowunits, <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(DATEOID))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; intresult = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="numeric.c.html#L4283" title="utils/adt/numeric.c:4283">int64_to_numeric</a>(intresult));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* Add an interval to a date, giving a new date.<br/></li>
<li></span><span class="Comment"> * Must handle both positive and negative intervals.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We implement this by promoting the date to timestamp (without time zone)<br/></li>
<li></span><span class="Comment"> * and then using the timestamp plus interval function.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1246">&#x200c;</a><span class="linkable">date_pl_interval</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; dateVal = PG_GETARG_DATEADT(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *span = PG_GETARG_INTERVAL_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; dateStamp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dateStamp = <a href="#L608" title="utils/adt/date.c:608">date2timestamp</a>(dateVal);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> DirectFunctionCall2(<a href="timestamp.c.html#L3049" title="utils/adt/timestamp.c:3049">timestamp_pl_interval</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TimestampGetDatum(dateStamp),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PointerGetDatum(span));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Subtract an interval from a date, giving a new date.<br/></li>
<li></span><span class="Comment"> * Must handle both positive and negative intervals.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We implement this by promoting the date to timestamp (without time zone)<br/></li>
<li></span><span class="Comment"> * and then using the timestamp minus interval function.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1266">&#x200c;</a><span class="linkable">date_mi_interval</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; dateVal = PG_GETARG_DATEADT(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *span = PG_GETARG_INTERVAL_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; dateStamp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dateStamp = <a href="#L608" title="utils/adt/date.c:608">date2timestamp</a>(dateVal);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> DirectFunctionCall2(<a href="timestamp.c.html#L3160" title="utils/adt/timestamp.c:3160">timestamp_mi_interval</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TimestampGetDatum(dateStamp),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PointerGetDatum(span));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L1283" title="utils/adt/date.c:1283">date_timestamp</a>()<br/></li>
<li></span><span class="Comment"> * Convert date to timestamp data type.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1283">&#x200c;</a><span class="linkable">date_timestamp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; dateVal = PG_GETARG_DATEADT(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L608" title="utils/adt/date.c:608">date2timestamp</a>(dateVal);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMESTAMP(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L1297" title="utils/adt/date.c:1297">timestamp_date</a>()<br/></li>
<li></span><span class="Comment"> * Convert timestamp to date data type.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1297">&#x200c;</a><span class="linkable">timestamp_date</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; timestamp = PG_GETARG_TIMESTAMP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> pg_tm tt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *tm = &amp;tt;<br/></li>
<li>&nbsp; &nbsp; fsec_t&nbsp; &nbsp; &nbsp; &nbsp; fsec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (TIMESTAMP_IS_NOBEGIN(timestamp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; DATE_NOBEGIN(result);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (TIMESTAMP_IS_NOEND(timestamp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; DATE_NOEND(result);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="timestamp.c.html#L1901" title="utils/adt/timestamp.c:1901">timestamp2tm</a>(timestamp, <span class="Constant">NULL</span>, tm, &amp;fsec, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="datetime.c.html#L286" title="utils/adt/datetime.c:286">date2j</a>(tm-&gt;tm_year, tm-&gt;tm_mon, tm-&gt;tm_mday) - POSTGRES_EPOCH_JDATE;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_DATEADT(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L1327" title="utils/adt/date.c:1327">date_timestamptz</a>()<br/></li>
<li></span><span class="Comment"> * Convert date to timestamp with time zone data type.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1327">&#x200c;</a><span class="linkable">date_timestamptz</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; dateVal = PG_GETARG_DATEADT(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimestampTz result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L704" title="utils/adt/date.c:704">date2timestamptz</a>(dateVal);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMESTAMP(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L1342" title="utils/adt/date.c:1342">timestamptz_date</a>()<br/></li>
<li></span><span class="Comment"> * Convert timestamp with time zone to date data type.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1342">&#x200c;</a><span class="linkable">timestamptz_date</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz timestamp = PG_GETARG_TIMESTAMP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> pg_tm tt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *tm = &amp;tt;<br/></li>
<li>&nbsp; &nbsp; fsec_t&nbsp; &nbsp; &nbsp; &nbsp; fsec;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (TIMESTAMP_IS_NOBEGIN(timestamp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; DATE_NOBEGIN(result);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (TIMESTAMP_IS_NOEND(timestamp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; DATE_NOEND(result);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="timestamp.c.html#L1901" title="utils/adt/timestamp.c:1901">timestamp2tm</a>(timestamp, &amp;tz, tm, &amp;fsec, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="datetime.c.html#L286" title="utils/adt/datetime.c:286">date2j</a>(tm-&gt;tm_year, tm-&gt;tm_mon, tm-&gt;tm_mday) - POSTGRES_EPOCH_JDATE;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_DATEADT(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*****************************************************************************<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; Time ADT<br/></li>
<li></span><span class="Comment"> *****************************************************************************/<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L1374">&#x200c;</a><span class="linkable">time_in</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *str = PG_GETARG_CSTRING(<span class="Constant">0</span>);<br/></li>
<li><span class="PreProc">#ifdef NOT_USED<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typelem = PG_GETARG_OID(<span class="Constant">1</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; typmod = PG_GETARG_INT32(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *escontext = fcinfo-&gt;context;<br/></li>
<li>&nbsp; &nbsp; TimeADT&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; fsec_t&nbsp; &nbsp; &nbsp; &nbsp; fsec;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> pg_tm tt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *tm = &amp;tt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tz;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dterr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; workbuf[MAXDATELEN + <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *field[MAXDATEFIELDS];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dtype;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ftype[MAXDATEFIELDS];<br/></li>
<li>&nbsp; &nbsp; DateTimeErrorExtra extra;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dterr = <a href="datetime.c.html#L754" title="utils/adt/datetime.c:754">ParseDateTime</a>(str, workbuf, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(workbuf),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; field, ftype, MAXDATEFIELDS, &amp;nf);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dterr == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dterr = <a href="datetime.c.html#L1864" title="utils/adt/datetime.c:1864">DecodeTimeOnly</a>(field, ftype, nf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;dtype, tm, &amp;fsec, &amp;tz, &amp;extra);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dterr != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="datetime.c.html#L4081" title="utils/adt/datetime.c:4081">DateTimeParseError</a>(dterr, &amp;extra, str, <span class="Constant">&quot;time&quot;</span>, escontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1416" title="utils/adt/date.c:1416">tm2time</a>(tm, fsec, &amp;result);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1645" title="utils/adt/date.c:1645">AdjustTimeForTypmod</a>(&amp;result, typmod);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMEADT(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L1416" title="utils/adt/date.c:1416">tm2time</a>()<br/></li>
<li></span><span class="Comment"> * Convert a tm structure to a time data type.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1416">&#x200c;</a></span><span class="linkable">tm2time</span>(<span class="Type">struct</span> pg_tm *tm, fsec_t fsec, TimeADT *result)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; *result = ((((tm-&gt;tm_hour * MINS_PER_HOUR + tm-&gt;tm_min) * SECS_PER_MINUTE) + tm-&gt;tm_sec)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * USECS_PER_SEC) + fsec;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L1427" title="utils/adt/date.c:1427">time_overflows</a>()<br/></li>
<li></span><span class="Comment"> * Check to see if a broken-down time-of-day is out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1427">&#x200c;</a></span><span class="linkable">time_overflows</span>(<span class="Type">int</span> hour, <span class="Type">int</span> min, <span class="Type">int</span> sec, fsec_t fsec)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="geo_spgist.c.html#L107" title="utils/adt/geo_spgist.c:107">Range</a>-check the fields individually. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (hour &lt; <span class="Constant">0</span> || hour &gt; HOURS_PER_DAY ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; min &lt; <span class="Constant">0</span> || min &gt;= MINS_PER_HOUR ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sec &lt; <span class="Constant">0</span> || sec &gt; SECS_PER_MINUTE ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fsec &lt; <span class="Constant">0</span> || fsec &gt; USECS_PER_SEC)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Because we allow, eg, hour = 24 or sec = 60, we must check separately<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that the total time value doesn't exceed 24:00:00.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((((((hour * MINS_PER_HOUR + min) * SECS_PER_MINUTE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; + sec) * USECS_PER_SEC) + fsec) &gt; USECS_PER_DAY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L1451" title="utils/adt/date.c:1451">float_time_overflows</a>()<br/></li>
<li></span><span class="Comment"> * Same, when we have seconds + fractional seconds as one &quot;double&quot; value.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1451">&#x200c;</a></span><span class="linkable">float_time_overflows</span>(<span class="Type">int</span> hour, <span class="Type">int</span> min, <span class="Type">double</span> sec)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="geo_spgist.c.html#L107" title="utils/adt/geo_spgist.c:107">Range</a>-check the fields individually. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (hour &lt; <span class="Constant">0</span> || hour &gt; HOURS_PER_DAY ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; min &lt; <span class="Constant">0</span> || min &gt;= MINS_PER_HOUR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &quot;sec&quot;, being double, requires extra care.&nbsp; Cope with NaN, and round off<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> applying the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> check to avoid unexpected errors due to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * imprecise input.&nbsp; (We assume rint() behaves sanely with infinities.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isnan(sec))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; sec = rint(sec * USECS_PER_SEC);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (sec &lt; <span class="Constant">0</span> || sec &gt; SECS_PER_MINUTE * USECS_PER_SEC)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Because we allow, eg, hour = 24 or sec = 60, we must check separately<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that the total time value doesn't exceed 24:00:00.&nbsp; This must match the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * way that callers will convert the fields to a time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (((((hour * MINS_PER_HOUR + min) * SECS_PER_MINUTE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * USECS_PER_SEC) + (int64) sec) &gt; USECS_PER_DAY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L1488" title="utils/adt/date.c:1488">time2tm</a>()<br/></li>
<li></span><span class="Comment"> * Convert time data type to POSIX time structure.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that only the hour/min/sec/fractional-sec fields are filled in.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1488">&#x200c;</a></span><span class="linkable">time2tm</span>(TimeADT time, <span class="Type">struct</span> pg_tm *tm, fsec_t *fsec)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; tm-&gt;tm_hour = time / USECS_PER_HOUR;<br/></li>
<li>&nbsp; &nbsp; time -= tm-&gt;tm_hour * USECS_PER_HOUR;<br/></li>
<li>&nbsp; &nbsp; tm-&gt;tm_min = time / USECS_PER_MINUTE;<br/></li>
<li>&nbsp; &nbsp; time -= tm-&gt;tm_min * USECS_PER_MINUTE;<br/></li>
<li>&nbsp; &nbsp; tm-&gt;tm_sec = time / USECS_PER_SEC;<br/></li>
<li>&nbsp; &nbsp; time -= tm-&gt;tm_sec * USECS_PER_SEC;<br/></li>
<li>&nbsp; &nbsp; *fsec = time;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1501">&#x200c;</a><span class="linkable">time_out</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimeADT&nbsp; &nbsp; &nbsp; &nbsp; time = PG_GETARG_TIMEADT(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> pg_tm tt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *tm = &amp;tt;<br/></li>
<li>&nbsp; &nbsp; fsec_t&nbsp; &nbsp; &nbsp; &nbsp; fsec;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; buf[MAXDATELEN + <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1488" title="utils/adt/date.c:1488">time2tm</a>(time, tm, &amp;fsec);<br/></li>
<li>&nbsp; &nbsp; <a href="datetime.c.html#L4301" title="utils/adt/datetime.c:4301">EncodeTimeOnly</a>(tm, fsec, <span class="Constant">false</span>, <span class="Constant">0</span>, <a href="../init/globals.c.html#L122" title="utils/init/globals.c:122">DateStyle</a>, buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(buf);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CSTRING(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1521" title="utils/adt/date.c:1521">time_recv</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts external binary format to time<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1521">&#x200c;</a><span class="linkable">time_recv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; buf = (StringInfo) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef NOT_USED<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typelem = PG_GETARG_OID(<span class="Constant">1</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; typmod = PG_GETARG_INT32(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; TimeADT&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="../../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result &lt; INT64CONST(<span class="Constant">0</span>) || result &gt; USECS_PER_DAY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;time out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1645" title="utils/adt/date.c:1645">AdjustTimeForTypmod</a>(&amp;result, typmod);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMEADT(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1547" title="utils/adt/date.c:1547">time_send</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts time to binary format<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1547">&#x200c;</a><span class="linkable">time_send</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimeADT&nbsp; &nbsp; &nbsp; &nbsp; time = PG_GETARG_TIMEADT(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L326" title="libpq/pqformat.c:326">pq_begintypsend</a>(&amp;buf);<br/></li>
<li>&nbsp; &nbsp; pq_sendint64(&amp;buf, time);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BYTEA_P(<a href="../../libpq/pqformat.c.html#L346" title="libpq/pqformat.c:346">pq_endtypsend</a>(&amp;buf));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1558">&#x200c;</a><span class="linkable">timetypmodin</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *ta = PG_GETARG_ARRAYTYPE_P(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(<a href="#L50" title="utils/adt/date.c:50">anytime_typmodin</a>(<span class="Constant">false</span>, ta));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1566">&#x200c;</a><span class="linkable">timetypmodout</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; typmod = PG_GETARG_INT32(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CSTRING(<a href="#L93" title="utils/adt/date.c:93">anytime_typmodout</a>(<span class="Constant">false</span>, typmod));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1577" title="utils/adt/date.c:1577">make_time</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - time constructor<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1577">&#x200c;</a><span class="linkable">make_time</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm_hour = PG_GETARG_INT32(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm_min = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; sec = PG_GETARG_FLOAT8(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; TimeADT&nbsp; &nbsp; &nbsp; &nbsp; time;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for time overflow */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1451" title="utils/adt/date.c:1451">float_time_overflows</a>(tm_hour, tm_min, sec))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_FIELD_OVERFLOW),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;time field value out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>: </span><span class="Special">%d</span><span class="Constant">:</span><span class="Special">%02d</span><span class="Constant">:</span><span class="Special">%02g</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm_hour, tm_min, sec)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This should match <a href="#L1416" title="utils/adt/date.c:1416">tm2time</a> */<br/></li>
<li></span>&nbsp; &nbsp; time = (((tm_hour * MINS_PER_HOUR + tm_min) * SECS_PER_MINUTE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * USECS_PER_SEC) + (int64) rint(sec * USECS_PER_SEC);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMEADT(time);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L1605" title="utils/adt/date.c:1605">time_support</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Planner support function for the <a href="#L1625" title="utils/adt/date.c:1625">time_scale</a>() and <a href="#L2425" title="utils/adt/date.c:2425">timetz_scale</a>()<br/></li>
<li></span><span class="Comment"> * length coercion <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> (we need not distinguish them here).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1605">&#x200c;</a><span class="linkable">time_support</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *rawreq = (Node *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *ret = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(rawreq, SupportRequestSimplify))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SupportRequestSimplify *req = (SupportRequestSimplify *) rawreq;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ret = <a href="datetime.c.html#L4829" title="utils/adt/datetime.c:4829">TemporalSimplify</a>(MAX_TIME_PRECISION, (Node *) req-&gt;fcall);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(ret);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L1625" title="utils/adt/date.c:1625">time_scale</a>()<br/></li>
<li></span><span class="Comment"> * Adjust time type for specified scale factor.<br/></li>
<li></span><span class="Comment"> * Used by PostgreSQL type system to stuff columns.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1625">&#x200c;</a><span class="linkable">time_scale</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimeADT&nbsp; &nbsp; &nbsp; &nbsp; time = PG_GETARG_TIMEADT(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; typmod = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TimeADT&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = time;<br/></li>
<li>&nbsp; &nbsp; <a href="#L1645" title="utils/adt/date.c:1645">AdjustTimeForTypmod</a>(&amp;result, typmod);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMEADT(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L1645" title="utils/adt/date.c:1645">AdjustTimeForTypmod</a>()<br/></li>
<li></span><span class="Comment"> * Force the precision of the time value to a specified value.<br/></li>
<li></span><span class="Comment"> * Uses *exactly* the same code as in <a href="timestamp.c.html#L366" title="utils/adt/timestamp.c:366">AdjustTimestampForTypmod</a>()<br/></li>
<li></span><span class="Comment"> * but we make a separate copy because those types do not<br/></li>
<li></span><span class="Comment"> * have a fundamental tie together but rather a coincidence of<br/></li>
<li></span><span class="Comment"> * implementation. - thomas<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1645">&#x200c;</a></span><span class="linkable">AdjustTimeForTypmod</span>(TimeADT *time, int32 typmod)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">const</span> int64 TimeScales[MAX_TIME_PRECISION + <span class="Constant">1</span>] = {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INT64CONST(<span class="Constant">1000000</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INT64CONST(<span class="Constant">100000</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INT64CONST(<span class="Constant">10000</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INT64CONST(<span class="Constant">1000</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INT64CONST(<span class="Constant">100</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INT64CONST(<span class="Constant">10</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INT64CONST(<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; };<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">const</span> int64 TimeOffsets[MAX_TIME_PRECISION + <span class="Constant">1</span>] = {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INT64CONST(<span class="Constant">500000</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INT64CONST(<span class="Constant">50000</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INT64CONST(<span class="Constant">5000</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INT64CONST(<span class="Constant">500</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INT64CONST(<span class="Constant">50</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INT64CONST(<span class="Constant">5</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INT64CONST(<span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; };<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (typmod &gt;= <span class="Constant">0</span> &amp;&amp; typmod &lt;= MAX_TIME_PRECISION)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*time &gt;= INT64CONST(<span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *time = ((*time + TimeOffsets[typmod]) / TimeScales[typmod]) *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimeScales[typmod];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *time = -((((-*time) + TimeOffsets[typmod]) / TimeScales[typmod]) *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimeScales[typmod]);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1680">&#x200c;</a><span class="linkable">time_eq</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimeADT&nbsp; &nbsp; &nbsp; &nbsp; time1 = PG_GETARG_TIMEADT(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimeADT&nbsp; &nbsp; &nbsp; &nbsp; time2 = PG_GETARG_TIMEADT(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(time1 == time2);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1689">&#x200c;</a><span class="linkable">time_ne</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimeADT&nbsp; &nbsp; &nbsp; &nbsp; time1 = PG_GETARG_TIMEADT(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimeADT&nbsp; &nbsp; &nbsp; &nbsp; time2 = PG_GETARG_TIMEADT(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(time1 != time2);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1698">&#x200c;</a><span class="linkable">time_lt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimeADT&nbsp; &nbsp; &nbsp; &nbsp; time1 = PG_GETARG_TIMEADT(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimeADT&nbsp; &nbsp; &nbsp; &nbsp; time2 = PG_GETARG_TIMEADT(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(time1 &lt; time2);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1707">&#x200c;</a><span class="linkable">time_le</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimeADT&nbsp; &nbsp; &nbsp; &nbsp; time1 = PG_GETARG_TIMEADT(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimeADT&nbsp; &nbsp; &nbsp; &nbsp; time2 = PG_GETARG_TIMEADT(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(time1 &lt;= time2);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1716">&#x200c;</a><span class="linkable">time_gt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimeADT&nbsp; &nbsp; &nbsp; &nbsp; time1 = PG_GETARG_TIMEADT(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimeADT&nbsp; &nbsp; &nbsp; &nbsp; time2 = PG_GETARG_TIMEADT(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(time1 &gt; time2);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1725">&#x200c;</a><span class="linkable">time_ge</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimeADT&nbsp; &nbsp; &nbsp; &nbsp; time1 = PG_GETARG_TIMEADT(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimeADT&nbsp; &nbsp; &nbsp; &nbsp; time2 = PG_GETARG_TIMEADT(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(time1 &gt;= time2);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1734">&#x200c;</a><span class="linkable">time_cmp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimeADT&nbsp; &nbsp; &nbsp; &nbsp; time1 = PG_GETARG_TIMEADT(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimeADT&nbsp; &nbsp; &nbsp; &nbsp; time2 = PG_GETARG_TIMEADT(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (time1 &lt; time2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_INT32(-<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (time1 &gt; time2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(<span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1747">&#x200c;</a><span class="linkable">time_hash</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../access/hash/hashfunc.c.html#L83" title="access/hash/hashfunc.c:83">hashint8</a>(fcinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1753">&#x200c;</a><span class="linkable">time_hash_extended</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../access/hash/hashfunc.c.html#L103" title="access/hash/hashfunc.c:103">hashint8extended</a>(fcinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1759">&#x200c;</a><span class="linkable">time_larger</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimeADT&nbsp; &nbsp; &nbsp; &nbsp; time1 = PG_GETARG_TIMEADT(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimeADT&nbsp; &nbsp; &nbsp; &nbsp; time2 = PG_GETARG_TIMEADT(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMEADT((time1 &gt; time2) ? time1 : time2);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1768">&#x200c;</a><span class="linkable">time_smaller</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimeADT&nbsp; &nbsp; &nbsp; &nbsp; time1 = PG_GETARG_TIMEADT(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimeADT&nbsp; &nbsp; &nbsp; &nbsp; time2 = PG_GETARG_TIMEADT(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMEADT((time1 &lt; time2) ? time1 : time2);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L1783" title="utils/adt/date.c:1783">overlaps_time</a>() --- implements the SQL OVERLAPS operator.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Algorithm is per SQL spec.&nbsp; This is much harder than you'd think<br/></li>
<li></span><span class="Comment"> * because the spec requires us to deliver a non-null answer in some cases<br/></li>
<li></span><span class="Comment"> * where some of the inputs are null.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1783">&#x200c;</a><span class="linkable">overlaps_time</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The arguments are TimeADT, but we leave them as generic Datums to avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * dereferencing nulls (TimeADT is pass-by-reference!)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; ts1 = PG_GETARG_DATUM(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; te1 = PG_GETARG_DATUM(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; ts2 = PG_GETARG_DATUM(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; te2 = PG_GETARG_DATUM(<span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; ts1IsNull = PG_ARGISNULL(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; te1IsNull = PG_ARGISNULL(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; ts2IsNull = PG_ARGISNULL(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; te2IsNull = PG_ARGISNULL(<span class="Constant">3</span>);<br/></li>
<li><br/></li>
<li><a id="L1798">&#x200c;</a><span class="PreProc">#define <span class="linkable">TIMEADT_GT</span>(t1,t2) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (DatumGetTimeADT(t1) &gt; DatumGetTimeADT(t2))<br/></li>
<li><a id="L1800">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">TIMEADT_LT</span>(t1,t2) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (DatumGetTimeADT(t1) &lt; DatumGetTimeADT(t2))<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If both endpoints of interval 1 are null, the result is null (unknown).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If just one endpoint is null, take ts1 as the non-null one. Otherwise,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * take ts1 as the lesser endpoint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ts1IsNull)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (te1IsNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* swap null for non-null */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ts1 = te1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; te1IsNull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!te1IsNull)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1798" title="utils/adt/date.c:1798">TIMEADT_GT</a>(ts1, te1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; tt = ts1;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ts1 = te1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; te1 = tt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Likewise for interval 2. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ts2IsNull)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (te2IsNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* swap null for non-null */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ts2 = te2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; te2IsNull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!te2IsNull)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1798" title="utils/adt/date.c:1798">TIMEADT_GT</a>(ts2, te2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; tt = ts2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ts2 = te2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; te2 = tt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * At this point neither ts1 nor ts2 is null, so we can consider three<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cases: ts1 &gt; ts2, ts1 &lt; ts2, ts1 = ts2<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1798" title="utils/adt/date.c:1798">TIMEADT_GT</a>(ts1, ts2))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This case is ts1 &lt; te2 OR te1 &lt; te2, which may look redundant but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in the presence of nulls it's not quite completely so.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (te2IsNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1800" title="utils/adt/date.c:1800">TIMEADT_LT</a>(ts1, te2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (te1IsNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If te1 is not null then we had ts1 &lt;= te1 above, and we just found<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ts1 &gt;= te2, hence te1 &gt;= te2.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L1800" title="utils/adt/date.c:1800">TIMEADT_LT</a>(ts1, ts2))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This case is ts2 &lt; te1 OR te2 &lt; te1 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (te1IsNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1800" title="utils/adt/date.c:1800">TIMEADT_LT</a>(ts2, te1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (te2IsNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If te2 is not null then we had ts2 &lt;= te2 above, and we just found<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ts2 &gt;= te1, hence te2 &gt;= te1.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For ts1 = ts2 the spec says te1 &lt;&gt; te2 OR te1 = te2, which is a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rather silly way of saying &quot;true if both are nonnull, else null&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (te1IsNull || te2IsNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><a id="L1897">&#x200c;</a><span class="PreProc">#undef <span class="linkable">TIMEADT_GT</span><br/></li>
<li><a id="L1898">&#x200c;</a></span><span class="PreProc">#undef <span class="linkable">TIMEADT_LT</span><br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L1905" title="utils/adt/date.c:1905">timestamp_time</a>()<br/></li>
<li></span><span class="Comment"> * Convert timestamp to time data type.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1905">&#x200c;</a><span class="linkable">timestamp_time</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; timestamp = PG_GETARG_TIMESTAMP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimeADT&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> pg_tm tt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *tm = &amp;tt;<br/></li>
<li>&nbsp; &nbsp; fsec_t&nbsp; &nbsp; &nbsp; &nbsp; fsec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (TIMESTAMP_NOT_FINITE(timestamp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="timestamp.c.html#L1901" title="utils/adt/timestamp.c:1901">timestamp2tm</a>(timestamp, <span class="Constant">NULL</span>, tm, &amp;fsec, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Could also do this with time = (timestamp / USECS_PER_DAY *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * USECS_PER_DAY) - timestamp;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; result = ((((tm-&gt;tm_hour * MINS_PER_HOUR + tm-&gt;tm_min) * SECS_PER_MINUTE) + tm-&gt;tm_sec) *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; USECS_PER_SEC) + fsec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMEADT(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L1935" title="utils/adt/date.c:1935">timestamptz_time</a>()<br/></li>
<li></span><span class="Comment"> * Convert timestamptz to time data type.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1935">&#x200c;</a><span class="linkable">timestamptz_time</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz timestamp = PG_GETARG_TIMESTAMP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimeADT&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> pg_tm tt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *tm = &amp;tt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tz;<br/></li>
<li>&nbsp; &nbsp; fsec_t&nbsp; &nbsp; &nbsp; &nbsp; fsec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (TIMESTAMP_NOT_FINITE(timestamp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="timestamp.c.html#L1901" title="utils/adt/timestamp.c:1901">timestamp2tm</a>(timestamp, &amp;tz, tm, &amp;fsec, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Could also do this with time = (timestamp / USECS_PER_DAY *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * USECS_PER_DAY) - timestamp;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; result = ((((tm-&gt;tm_hour * MINS_PER_HOUR + tm-&gt;tm_min) * SECS_PER_MINUTE) + tm-&gt;tm_sec) *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; USECS_PER_SEC) + fsec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMEADT(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L1966" title="utils/adt/date.c:1966">datetime_timestamp</a>()<br/></li>
<li></span><span class="Comment"> * Convert date and time to timestamp data type.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1966">&#x200c;</a><span class="linkable">datetime_timestamp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; date = PG_GETARG_DATEADT(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimeADT&nbsp; &nbsp; &nbsp; &nbsp; time = PG_GETARG_TIMEADT(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L608" title="utils/adt/date.c:608">date2timestamp</a>(date);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!TIMESTAMP_NOT_FINITE(result))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result += time;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!IS_VALID_TIMESTAMP(result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMESTAMP(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L1989" title="utils/adt/date.c:1989">time_interval</a>()<br/></li>
<li></span><span class="Comment"> * Convert time to interval data type.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1989">&#x200c;</a><span class="linkable">time_interval</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimeADT&nbsp; &nbsp; &nbsp; &nbsp; time = PG_GETARG_TIMEADT(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (Interval *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Interval));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result-&gt;time = time;<br/></li>
<li>&nbsp; &nbsp; result-&gt;day = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; result-&gt;month = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INTERVAL_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L2012" title="utils/adt/date.c:2012">interval_time</a>()<br/></li>
<li></span><span class="Comment"> * Convert interval to time data type.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is defined as producing the fractional-day portion of the interval.<br/></li>
<li></span><span class="Comment"> * Therefore, we can just ignore the <a href="datetime.c.html#L81" title="utils/adt/datetime.c:81">months</a> field.&nbsp; It is not real clear<br/></li>
<li></span><span class="Comment"> * what to do with negative intervals, but we choose to subtract the floor,<br/></li>
<li></span><span class="Comment"> * so that, say, '-2 hours' becomes '22:00:00'.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2012">&#x200c;</a><span class="linkable">interval_time</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *span = PG_GETARG_INTERVAL_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimeADT&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (INTERVAL_NOT_FINITE(span))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot convert infinite interval to time&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = span-&gt;time % USECS_PER_DAY;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result += USECS_PER_DAY;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMEADT(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L2033" title="utils/adt/date.c:2033">time_mi_time</a>()<br/></li>
<li></span><span class="Comment"> * Subtract two times to produce an interval.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2033">&#x200c;</a><span class="linkable">time_mi_time</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimeADT&nbsp; &nbsp; &nbsp; &nbsp; time1 = PG_GETARG_TIMEADT(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimeADT&nbsp; &nbsp; &nbsp; &nbsp; time2 = PG_GETARG_TIMEADT(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (Interval *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Interval));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result-&gt;month = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; result-&gt;day = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; result-&gt;time = time1 - time2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INTERVAL_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L2052" title="utils/adt/date.c:2052">time_pl_interval</a>()<br/></li>
<li></span><span class="Comment"> * Add interval to time.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2052">&#x200c;</a><span class="linkable">time_pl_interval</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimeADT&nbsp; &nbsp; &nbsp; &nbsp; time = PG_GETARG_TIMEADT(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *span = PG_GETARG_INTERVAL_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TimeADT&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (INTERVAL_NOT_FINITE(span))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot add infinite interval to time&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = time + span-&gt;time;<br/></li>
<li>&nbsp; &nbsp; result -= result / USECS_PER_DAY * USECS_PER_DAY;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result &lt; INT64CONST(<span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result += USECS_PER_DAY;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMEADT(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L2075" title="utils/adt/date.c:2075">time_mi_interval</a>()<br/></li>
<li></span><span class="Comment"> * Subtract interval from time.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2075">&#x200c;</a><span class="linkable">time_mi_interval</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimeADT&nbsp; &nbsp; &nbsp; &nbsp; time = PG_GETARG_TIMEADT(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *span = PG_GETARG_INTERVAL_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TimeADT&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (INTERVAL_NOT_FINITE(span))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot subtract infinite interval from time&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = time - span-&gt;time;<br/></li>
<li>&nbsp; &nbsp; result -= result / USECS_PER_DAY * USECS_PER_DAY;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result &lt; INT64CONST(<span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result += USECS_PER_DAY;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMEADT(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * in_range support function for time.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2098">&#x200c;</a><span class="linkable">in_range_time_interval</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimeADT&nbsp; &nbsp; &nbsp; &nbsp; val = PG_GETARG_TIMEADT(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimeADT&nbsp; &nbsp; &nbsp; &nbsp; base = PG_GETARG_TIMEADT(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *offset = PG_GETARG_INTERVAL_P(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; sub = PG_GETARG_BOOL(<span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; less = PG_GETARG_BOOL(<span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; TimeADT&nbsp; &nbsp; &nbsp; &nbsp; sum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Like <a href="#L2052" title="utils/adt/date.c:2052">time_pl_interval</a>/<a href="#L2075" title="utils/adt/date.c:2075">time_mi_interval</a>, we disregard the month and day<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fields of the offset.&nbsp; So our test for negative should too.&nbsp; This also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * catches -infinity, so we only need worry about +infinity below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (offset-&gt;time &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid preceding or following size in window function&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can't use <a href="#L2052" title="utils/adt/date.c:2052">time_pl_interval</a>/<a href="#L2075" title="utils/adt/date.c:2075">time_mi_interval</a> here, because their<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * wraparound behavior would give wrong (or at least undesirable) answers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fortunately the equivalent non-wrapping behavior is trivial, except<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that adding an infinite (or very large) interval might cause integer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * overflow.&nbsp; Subtraction cannot overflow here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (sub)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sum = base - offset-&gt;time;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (pg_add_s64_overflow(base, offset-&gt;time, &amp;sum))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(less);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (less)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(val &lt;= sum);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(val &gt;= sum);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L2243" title="utils/adt/date.c:2243">time_part</a>() and <a href="#L2249" title="utils/adt/date.c:2249">extract_time</a>()<br/></li>
<li></span><span class="Comment"> * Extract specified field from time type.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Datum<br/></li>
<li><a id="L2140">&#x200c;</a><span class="linkable">time_part_common</span>(PG_FUNCTION_ARGS, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> retnumeric)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *units = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimeADT&nbsp; &nbsp; &nbsp; &nbsp; time = PG_GETARG_TIMEADT(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; intresult;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *lowunits;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; lowunits = <a href="../../parser/scansup.c.html#L37" title="parser/scansup.c:37">downcase_truncate_identifier</a>(VARDATA_ANY(units),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VARSIZE_ANY_EXHDR(units),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; type = <a href="datetime.c.html#L4036" title="utils/adt/datetime.c:4036">DecodeUnits</a>(<span class="Constant">0</span>, lowunits, &amp;val);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (type == UNKNOWN_FIELD)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; type = <a href="datetime.c.html#L3137" title="utils/adt/datetime.c:3137">DecodeSpecial</a>(<span class="Constant">0</span>, lowunits, &amp;val);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (type == UNITS)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fsec_t&nbsp; &nbsp; &nbsp; &nbsp; fsec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> pg_tm tt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *tm = &amp;tt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1488" title="utils/adt/date.c:1488">time2tm</a>(time, tm, &amp;fsec);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (val)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MICROSEC:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = tm-&gt;tm_sec * INT64CONST(<span class="Constant">1000000</span>) + fsec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MILLISEC:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (retnumeric)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*---<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tm-&gt;tm_sec * 1000 + fsec / 1000<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * = (tm-&gt;tm_sec * 1'000'000 + fsec) / 1000<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="numeric.c.html#L4304" title="utils/adt/numeric.c:4304">int64_div_fast_to_numeric</a>(tm-&gt;tm_sec * INT64CONST(<span class="Constant">1000000</span>) + fsec, <span class="Constant">3</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(tm-&gt;tm_sec * <span class="Constant">1000.0</span> + fsec / <span class="Constant">1000.0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_SECOND:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (retnumeric)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*---<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tm-&gt;tm_sec + fsec / 1'000'000<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * = (tm-&gt;tm_sec * 1'000'000 + fsec) / 1'000'000<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="numeric.c.html#L4304" title="utils/adt/numeric.c:4304">int64_div_fast_to_numeric</a>(tm-&gt;tm_sec * INT64CONST(<span class="Constant">1000000</span>) + fsec, <span class="Constant">6</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(tm-&gt;tm_sec + fsec / <span class="Constant">1000000.0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MINUTE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = tm-&gt;tm_min;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_HOUR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = tm-&gt;tm_hour;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_TZ:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_TZ_MINUTE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_TZ_HOUR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_DAY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MONTH:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_QUARTER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_YEAR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_DECADE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_CENTURY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MILLENNIUM:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_ISOYEAR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unit </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> not supported for type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lowunits, <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(TIMEOID))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (type == RESERV &amp;&amp; val == DTK_EPOCH)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (retnumeric)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="numeric.c.html#L4304" title="utils/adt/numeric.c:4304">int64_div_fast_to_numeric</a>(time, <span class="Constant">6</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(time / <span class="Constant">1000000.0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unit </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> not recognized for type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lowunits, <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(TIMEOID))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; intresult = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (retnumeric)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="numeric.c.html#L4283" title="utils/adt/numeric.c:4283">int64_to_numeric</a>(intresult));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(intresult);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2243">&#x200c;</a><span class="linkable">time_part</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2140" title="utils/adt/date.c:2140">time_part_common</a>(fcinfo, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2249">&#x200c;</a><span class="linkable">extract_time</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2140" title="utils/adt/date.c:2140">time_part_common</a>(fcinfo, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*****************************************************************************<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; Time With Time Zone ADT<br/></li>
<li></span><span class="Comment"> *****************************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* <a href="#L2263" title="utils/adt/date.c:2263">tm2timetz</a>()<br/></li>
<li></span><span class="Comment"> * Convert a tm structure to a time data type.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L2263">&#x200c;</a></span><span class="linkable">tm2timetz</span>(<span class="Type">struct</span> pg_tm *tm, fsec_t fsec, <span class="Type">int</span> tz, TimeTzADT *result)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; result-&gt;time = ((((tm-&gt;tm_hour * MINS_PER_HOUR + tm-&gt;tm_min) * SECS_PER_MINUTE) + tm-&gt;tm_sec) *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; USECS_PER_SEC) + fsec;<br/></li>
<li>&nbsp; &nbsp; result-&gt;zone = tz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2273">&#x200c;</a><span class="linkable">timetz_in</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *str = PG_GETARG_CSTRING(<span class="Constant">0</span>);<br/></li>
<li><span class="PreProc">#ifdef NOT_USED<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typelem = PG_GETARG_OID(<span class="Constant">1</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; typmod = PG_GETARG_INT32(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *escontext = fcinfo-&gt;context;<br/></li>
<li>&nbsp; &nbsp; TimeTzADT&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; fsec_t&nbsp; &nbsp; &nbsp; &nbsp; fsec;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> pg_tm tt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *tm = &amp;tt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tz;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dterr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; workbuf[MAXDATELEN + <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *field[MAXDATEFIELDS];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dtype;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ftype[MAXDATEFIELDS];<br/></li>
<li>&nbsp; &nbsp; DateTimeErrorExtra extra;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dterr = <a href="datetime.c.html#L754" title="utils/adt/datetime.c:754">ParseDateTime</a>(str, workbuf, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(workbuf),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; field, ftype, MAXDATEFIELDS, &amp;nf);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dterr == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dterr = <a href="datetime.c.html#L1864" title="utils/adt/datetime.c:1864">DecodeTimeOnly</a>(field, ftype, nf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;dtype, tm, &amp;fsec, &amp;tz, &amp;extra);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dterr != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="datetime.c.html#L4081" title="utils/adt/datetime.c:4081">DateTimeParseError</a>(dterr, &amp;extra, str, <span class="Constant">&quot;time with time zone&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; escontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (TimeTzADT *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TimeTzADT));<br/></li>
<li>&nbsp; &nbsp; <a href="#L2263" title="utils/adt/date.c:2263">tm2timetz</a>(tm, fsec, tz, result);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1645" title="utils/adt/date.c:1645">AdjustTimeForTypmod</a>(&amp;(result-&gt;time), typmod);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMETZADT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2314">&#x200c;</a><span class="linkable">timetz_out</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimeTzADT&nbsp; *time = PG_GETARG_TIMETZADT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> pg_tm tt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *tm = &amp;tt;<br/></li>
<li>&nbsp; &nbsp; fsec_t&nbsp; &nbsp; &nbsp; &nbsp; fsec;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tz;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; buf[MAXDATELEN + <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2403" title="utils/adt/date.c:2403">timetz2tm</a>(time, tm, &amp;fsec, &amp;tz);<br/></li>
<li>&nbsp; &nbsp; <a href="datetime.c.html#L4301" title="utils/adt/datetime.c:4301">EncodeTimeOnly</a>(tm, fsec, <span class="Constant">true</span>, tz, <a href="../init/globals.c.html#L122" title="utils/init/globals.c:122">DateStyle</a>, buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(buf);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CSTRING(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2335" title="utils/adt/date.c:2335">timetz_recv</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts external binary format to timetz<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2335">&#x200c;</a><span class="linkable">timetz_recv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; buf = (StringInfo) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef NOT_USED<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typelem = PG_GETARG_OID(<span class="Constant">1</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; typmod = PG_GETARG_INT32(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; TimeTzADT&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (TimeTzADT *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TimeTzADT));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result-&gt;time = <a href="../../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result-&gt;time &lt; INT64CONST(<span class="Constant">0</span>) || result-&gt;time &gt; USECS_PER_DAY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;time out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result-&gt;zone = <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(buf, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(result-&gt;zone));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for sane GMT displacement; see notes in datatype/timestamp.h */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (result-&gt;zone &lt;= -TZDISP_LIMIT || result-&gt;zone &gt;= TZDISP_LIMIT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TIME_ZONE_DISPLACEMENT_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;time zone displacement out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1645" title="utils/adt/date.c:1645">AdjustTimeForTypmod</a>(&amp;(result-&gt;time), typmod);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMETZADT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2371" title="utils/adt/date.c:2371">timetz_send</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts timetz to binary format<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2371">&#x200c;</a><span class="linkable">timetz_send</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimeTzADT&nbsp; *time = PG_GETARG_TIMETZADT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L326" title="libpq/pqformat.c:326">pq_begintypsend</a>(&amp;buf);<br/></li>
<li>&nbsp; &nbsp; pq_sendint64(&amp;buf, time-&gt;time);<br/></li>
<li>&nbsp; &nbsp; pq_sendint32(&amp;buf, time-&gt;zone);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BYTEA_P(<a href="../../libpq/pqformat.c.html#L346" title="libpq/pqformat.c:346">pq_endtypsend</a>(&amp;buf));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2383">&#x200c;</a><span class="linkable">timetztypmodin</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *ta = PG_GETARG_ARRAYTYPE_P(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(<a href="#L50" title="utils/adt/date.c:50">anytime_typmodin</a>(<span class="Constant">true</span>, ta));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2391">&#x200c;</a><span class="linkable">timetztypmodout</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; typmod = PG_GETARG_INT32(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CSTRING(<a href="#L93" title="utils/adt/date.c:93">anytime_typmodout</a>(<span class="Constant">true</span>, typmod));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L2403" title="utils/adt/date.c:2403">timetz2tm</a>()<br/></li>
<li></span><span class="Comment"> * Convert TIME WITH TIME ZONE data type to POSIX time structure.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L2403">&#x200c;</a></span><span class="linkable">timetz2tm</span>(TimeTzADT *time, <span class="Type">struct</span> pg_tm *tm, fsec_t *fsec, <span class="Type">int</span> *tzp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimeOffset&nbsp; &nbsp; trem = time-&gt;time;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tm-&gt;tm_hour = trem / USECS_PER_HOUR;<br/></li>
<li>&nbsp; &nbsp; trem -= tm-&gt;tm_hour * USECS_PER_HOUR;<br/></li>
<li>&nbsp; &nbsp; tm-&gt;tm_min = trem / USECS_PER_MINUTE;<br/></li>
<li>&nbsp; &nbsp; trem -= tm-&gt;tm_min * USECS_PER_MINUTE;<br/></li>
<li>&nbsp; &nbsp; tm-&gt;tm_sec = trem / USECS_PER_SEC;<br/></li>
<li>&nbsp; &nbsp; *fsec = trem - tm-&gt;tm_sec * USECS_PER_SEC;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tzp != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *tzp = time-&gt;zone;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L2425" title="utils/adt/date.c:2425">timetz_scale</a>()<br/></li>
<li></span><span class="Comment"> * Adjust time type for specified scale factor.<br/></li>
<li></span><span class="Comment"> * Used by PostgreSQL type system to stuff columns.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2425">&#x200c;</a><span class="linkable">timetz_scale</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimeTzADT&nbsp; *time = PG_GETARG_TIMETZADT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; typmod = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TimeTzADT&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (TimeTzADT *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TimeTzADT));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result-&gt;time = time-&gt;time;<br/></li>
<li>&nbsp; &nbsp; result-&gt;zone = time-&gt;zone;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1645" title="utils/adt/date.c:1645">AdjustTimeForTypmod</a>(&amp;(result-&gt;time), typmod);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMETZADT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L2443">&#x200c;</a></span><span class="linkable">timetz_cmp_internal</span>(TimeTzADT *time1, TimeTzADT *time2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimeOffset&nbsp; &nbsp; t1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Primary sort is by true (GMT-equivalent) time */<br/></li>
<li></span>&nbsp; &nbsp; t1 = time1-&gt;time + (time1-&gt;zone * USECS_PER_SEC);<br/></li>
<li>&nbsp; &nbsp; t2 = time2-&gt;time + (time2-&gt;zone * USECS_PER_SEC);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (t1 &gt; t2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (t1 &lt; t2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If same GMT time, sort by timezone; we only want to say that two<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * timetz's are <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> if both the time and zone parts are <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (time1-&gt;zone &gt; time2-&gt;zone)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (time1-&gt;zone &lt; time2-&gt;zone)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2470">&#x200c;</a><span class="linkable">timetz_eq</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimeTzADT&nbsp; *time1 = PG_GETARG_TIMETZADT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimeTzADT&nbsp; *time2 = PG_GETARG_TIMETZADT_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2443" title="utils/adt/date.c:2443">timetz_cmp_internal</a>(time1, time2) == <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2479">&#x200c;</a><span class="linkable">timetz_ne</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimeTzADT&nbsp; *time1 = PG_GETARG_TIMETZADT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimeTzADT&nbsp; *time2 = PG_GETARG_TIMETZADT_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2443" title="utils/adt/date.c:2443">timetz_cmp_internal</a>(time1, time2) != <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2488">&#x200c;</a><span class="linkable">timetz_lt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimeTzADT&nbsp; *time1 = PG_GETARG_TIMETZADT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimeTzADT&nbsp; *time2 = PG_GETARG_TIMETZADT_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2443" title="utils/adt/date.c:2443">timetz_cmp_internal</a>(time1, time2) &lt; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2497">&#x200c;</a><span class="linkable">timetz_le</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimeTzADT&nbsp; *time1 = PG_GETARG_TIMETZADT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimeTzADT&nbsp; *time2 = PG_GETARG_TIMETZADT_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2443" title="utils/adt/date.c:2443">timetz_cmp_internal</a>(time1, time2) &lt;= <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2506">&#x200c;</a><span class="linkable">timetz_gt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimeTzADT&nbsp; *time1 = PG_GETARG_TIMETZADT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimeTzADT&nbsp; *time2 = PG_GETARG_TIMETZADT_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2443" title="utils/adt/date.c:2443">timetz_cmp_internal</a>(time1, time2) &gt; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2515">&#x200c;</a><span class="linkable">timetz_ge</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimeTzADT&nbsp; *time1 = PG_GETARG_TIMETZADT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimeTzADT&nbsp; *time2 = PG_GETARG_TIMETZADT_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2443" title="utils/adt/date.c:2443">timetz_cmp_internal</a>(time1, time2) &gt;= <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2524">&#x200c;</a><span class="linkable">timetz_cmp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimeTzADT&nbsp; *time1 = PG_GETARG_TIMETZADT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimeTzADT&nbsp; *time2 = PG_GETARG_TIMETZADT_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(<a href="#L2443" title="utils/adt/date.c:2443">timetz_cmp_internal</a>(time1, time2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2533">&#x200c;</a><span class="linkable">timetz_hash</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimeTzADT&nbsp; *key = PG_GETARG_TIMETZADT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; thash;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * To avoid <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> problems with padding bytes in the struct, we figure the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * field hashes separately and XOR them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; thash = DatumGetUInt32(DirectFunctionCall1(<a href="../../access/hash/hashfunc.c.html#L83" title="access/hash/hashfunc.c:83">hashint8</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Int64GetDatumFast(key-&gt;time)));<br/></li>
<li>&nbsp; &nbsp; thash ^= DatumGetUInt32(hash_uint32(key-&gt;zone));<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_UINT32(thash);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2549">&#x200c;</a><span class="linkable">timetz_hash_extended</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimeTzADT&nbsp; *key = PG_GETARG_TIMETZADT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; seed = PG_GETARG_DATUM(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; thash;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Same approach as <a href="#L2533" title="utils/adt/date.c:2533">timetz_hash</a> */<br/></li>
<li></span>&nbsp; &nbsp; thash = DatumGetUInt64(DirectFunctionCall2(<a href="../../access/hash/hashfunc.c.html#L103" title="access/hash/hashfunc.c:103">hashint8extended</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Int64GetDatumFast(key-&gt;time),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; seed));<br/></li>
<li>&nbsp; &nbsp; thash ^= DatumGetUInt64(hash_uint32_extended(key-&gt;zone,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; DatumGetInt64(seed)));<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_UINT64(thash);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2565">&#x200c;</a><span class="linkable">timetz_larger</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimeTzADT&nbsp; *time1 = PG_GETARG_TIMETZADT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimeTzADT&nbsp; *time2 = PG_GETARG_TIMETZADT_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TimeTzADT&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2443" title="utils/adt/date.c:2443">timetz_cmp_internal</a>(time1, time2) &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = time1;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = time2;<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMETZADT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2579">&#x200c;</a><span class="linkable">timetz_smaller</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimeTzADT&nbsp; *time1 = PG_GETARG_TIMETZADT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimeTzADT&nbsp; *time2 = PG_GETARG_TIMETZADT_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TimeTzADT&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2443" title="utils/adt/date.c:2443">timetz_cmp_internal</a>(time1, time2) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = time1;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = time2;<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMETZADT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L2596" title="utils/adt/date.c:2596">timetz_pl_interval</a>()<br/></li>
<li></span><span class="Comment"> * Add interval to timetz.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2596">&#x200c;</a><span class="linkable">timetz_pl_interval</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimeTzADT&nbsp; *time = PG_GETARG_TIMETZADT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *span = PG_GETARG_INTERVAL_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TimeTzADT&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (INTERVAL_NOT_FINITE(span))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot add infinite interval to time&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (TimeTzADT *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TimeTzADT));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result-&gt;time = time-&gt;time + span-&gt;time;<br/></li>
<li>&nbsp; &nbsp; result-&gt;time -= result-&gt;time / USECS_PER_DAY * USECS_PER_DAY;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result-&gt;time &lt; INT64CONST(<span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;time += USECS_PER_DAY;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result-&gt;zone = time-&gt;zone;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMETZADT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L2623" title="utils/adt/date.c:2623">timetz_mi_interval</a>()<br/></li>
<li></span><span class="Comment"> * Subtract interval from timetz.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2623">&#x200c;</a><span class="linkable">timetz_mi_interval</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimeTzADT&nbsp; *time = PG_GETARG_TIMETZADT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *span = PG_GETARG_INTERVAL_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TimeTzADT&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (INTERVAL_NOT_FINITE(span))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot subtract infinite interval from time&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (TimeTzADT *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TimeTzADT));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result-&gt;time = time-&gt;time - span-&gt;time;<br/></li>
<li>&nbsp; &nbsp; result-&gt;time -= result-&gt;time / USECS_PER_DAY * USECS_PER_DAY;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result-&gt;time &lt; INT64CONST(<span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;time += USECS_PER_DAY;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result-&gt;zone = time-&gt;zone;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMETZADT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * in_range support function for timetz.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2650">&#x200c;</a><span class="linkable">in_range_timetz_interval</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimeTzADT&nbsp; *val = PG_GETARG_TIMETZADT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimeTzADT&nbsp; *base = PG_GETARG_TIMETZADT_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *offset = PG_GETARG_INTERVAL_P(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; sub = PG_GETARG_BOOL(<span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; less = PG_GETARG_BOOL(<span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; TimeTzADT&nbsp; &nbsp; sum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Like <a href="#L2596" title="utils/adt/date.c:2596">timetz_pl_interval</a>/<a href="#L2623" title="utils/adt/date.c:2623">timetz_mi_interval</a>, we disregard the month and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * day fields of the offset.&nbsp; So our test for negative should too. This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * also catches -infinity, so we only need worry about +infinity below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (offset-&gt;time &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid preceding or following size in window function&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can't use <a href="#L2596" title="utils/adt/date.c:2596">timetz_pl_interval</a>/<a href="#L2623" title="utils/adt/date.c:2623">timetz_mi_interval</a> here, because their<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * wraparound behavior would give wrong (or at least undesirable) answers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fortunately the equivalent non-wrapping behavior is trivial, except<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that adding an infinite (or very large) interval might cause integer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * overflow.&nbsp; Subtraction cannot overflow here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (sub)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sum.time = base-&gt;time - offset-&gt;time;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (pg_add_s64_overflow(base-&gt;time, offset-&gt;time, &amp;sum.time))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(less);<br/></li>
<li>&nbsp; &nbsp; sum.zone = base-&gt;zone;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (less)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2443" title="utils/adt/date.c:2443">timetz_cmp_internal</a>(val, &amp;sum) &lt;= <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2443" title="utils/adt/date.c:2443">timetz_cmp_internal</a>(val, &amp;sum) &gt;= <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L2695" title="utils/adt/date.c:2695">overlaps_timetz</a>() --- implements the SQL OVERLAPS operator.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Algorithm is per SQL spec.&nbsp; This is much harder than you'd think<br/></li>
<li></span><span class="Comment"> * because the spec requires us to deliver a non-null answer in some cases<br/></li>
<li></span><span class="Comment"> * where some of the inputs are null.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2695">&#x200c;</a><span class="linkable">overlaps_timetz</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The arguments are TimeTzADT *, but we leave them as generic Datums for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * convenience of notation --- and to avoid dereferencing nulls.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; ts1 = PG_GETARG_DATUM(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; te1 = PG_GETARG_DATUM(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; ts2 = PG_GETARG_DATUM(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; te2 = PG_GETARG_DATUM(<span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; ts1IsNull = PG_ARGISNULL(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; te1IsNull = PG_ARGISNULL(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; ts2IsNull = PG_ARGISNULL(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; te2IsNull = PG_ARGISNULL(<span class="Constant">3</span>);<br/></li>
<li><br/></li>
<li><a id="L2710">&#x200c;</a><span class="PreProc">#define <span class="linkable">TIMETZ_GT</span>(t1,t2) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; DatumGetBool(DirectFunctionCall2(<a href="#L2506" title="utils/adt/date.c:2506">timetz_gt</a>,t1,t2))<br/></li>
<li><a id="L2712">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">TIMETZ_LT</span>(t1,t2) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; DatumGetBool(DirectFunctionCall2(<a href="#L2488" title="utils/adt/date.c:2488">timetz_lt</a>,t1,t2))<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If both endpoints of interval 1 are null, the result is null (unknown).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If just one endpoint is null, take ts1 as the non-null one. Otherwise,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * take ts1 as the lesser endpoint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ts1IsNull)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (te1IsNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* swap null for non-null */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ts1 = te1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; te1IsNull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!te1IsNull)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2710" title="utils/adt/date.c:2710">TIMETZ_GT</a>(ts1, te1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; tt = ts1;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ts1 = te1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; te1 = tt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Likewise for interval 2. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ts2IsNull)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (te2IsNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* swap null for non-null */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ts2 = te2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; te2IsNull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!te2IsNull)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2710" title="utils/adt/date.c:2710">TIMETZ_GT</a>(ts2, te2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; tt = ts2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ts2 = te2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; te2 = tt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * At this point neither ts1 nor ts2 is null, so we can consider three<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cases: ts1 &gt; ts2, ts1 &lt; ts2, ts1 = ts2<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2710" title="utils/adt/date.c:2710">TIMETZ_GT</a>(ts1, ts2))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This case is ts1 &lt; te2 OR te1 &lt; te2, which may look redundant but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in the presence of nulls it's not quite completely so.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (te2IsNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2712" title="utils/adt/date.c:2712">TIMETZ_LT</a>(ts1, te2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (te1IsNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If te1 is not null then we had ts1 &lt;= te1 above, and we just found<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ts1 &gt;= te2, hence te1 &gt;= te2.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L2712" title="utils/adt/date.c:2712">TIMETZ_LT</a>(ts1, ts2))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This case is ts2 &lt; te1 OR te2 &lt; te1 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (te1IsNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2712" title="utils/adt/date.c:2712">TIMETZ_LT</a>(ts2, te1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (te2IsNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If te2 is not null then we had ts2 &lt;= te2 above, and we just found<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ts2 &gt;= te1, hence te2 &gt;= te1.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For ts1 = ts2 the spec says te1 &lt;&gt; te2 OR te1 = te2, which is a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rather silly way of saying &quot;true if both are nonnull, else null&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (te1IsNull || te2IsNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><a id="L2809">&#x200c;</a><span class="PreProc">#undef <span class="linkable">TIMETZ_GT</span><br/></li>
<li><a id="L2810">&#x200c;</a></span><span class="PreProc">#undef <span class="linkable">TIMETZ_LT</span><br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2815">&#x200c;</a><span class="linkable">timetz_time</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimeTzADT&nbsp; *timetz = PG_GETARG_TIMETZADT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimeADT&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* swallow the time zone and just return the time */<br/></li>
<li></span>&nbsp; &nbsp; result = timetz-&gt;time;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMEADT(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2828">&#x200c;</a><span class="linkable">time_timetz</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimeADT&nbsp; &nbsp; &nbsp; &nbsp; time = PG_GETARG_TIMEADT(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimeTzADT&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> pg_tm tt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *tm = &amp;tt;<br/></li>
<li>&nbsp; &nbsp; fsec_t&nbsp; &nbsp; &nbsp; &nbsp; fsec;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="datetime.c.html#L366" title="utils/adt/datetime.c:366">GetCurrentDateTime</a>(tm);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1488" title="utils/adt/date.c:1488">time2tm</a>(time, tm, &amp;fsec);<br/></li>
<li>&nbsp; &nbsp; tz = <a href="datetime.c.html#L1585" title="utils/adt/datetime.c:1585">DetermineTimeZoneOffset</a>(tm, session_timezone);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (TimeTzADT *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TimeTzADT));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result-&gt;time = time;<br/></li>
<li>&nbsp; &nbsp; result-&gt;zone = tz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMETZADT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L2854" title="utils/adt/date.c:2854">timestamptz_timetz</a>()<br/></li>
<li></span><span class="Comment"> * Convert timestamp to timetz data type.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2854">&#x200c;</a><span class="linkable">timestamptz_timetz</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz timestamp = PG_GETARG_TIMESTAMP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimeTzADT&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> pg_tm tt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *tm = &amp;tt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tz;<br/></li>
<li>&nbsp; &nbsp; fsec_t&nbsp; &nbsp; &nbsp; &nbsp; fsec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (TIMESTAMP_NOT_FINITE(timestamp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="timestamp.c.html#L1901" title="utils/adt/timestamp.c:1901">timestamp2tm</a>(timestamp, &amp;tz, tm, &amp;fsec, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (TimeTzADT *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TimeTzADT));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2263" title="utils/adt/date.c:2263">tm2timetz</a>(tm, fsec, tz, result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMETZADT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L2886" title="utils/adt/date.c:2886">datetimetz_timestamptz</a>()<br/></li>
<li></span><span class="Comment"> * Convert date and timetz to timestamp with time zone data type.<br/></li>
<li></span><span class="Comment"> * Timestamp is stored in GMT, so add the time zone<br/></li>
<li></span><span class="Comment"> * stored with the timetz to the result.<br/></li>
<li></span><span class="Comment"> * - thomas 2000-03-10<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2886">&#x200c;</a><span class="linkable">datetimetz_timestamptz</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; date = PG_GETARG_DATEADT(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimeTzADT&nbsp; *time = PG_GETARG_TIMETZADT_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TimestampTz result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (DATE_IS_NOBEGIN(date))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TIMESTAMP_NOBEGIN(result);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (DATE_IS_NOEND(date))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TIMESTAMP_NOEND(result);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Date's <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> is wider than timestamp's, so check for boundaries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since dates have the same minimum <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> as timestamps, only <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * boundary need be checked for overflow.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (date &gt;= (TIMESTAMP_END_JULIAN - POSTGRES_EPOCH_JDATE))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;date out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> for timestamp&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = date * USECS_PER_DAY + time-&gt;time + time-&gt;zone * USECS_PER_SEC;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since it is possible to go beyond allowed timestamptz <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of time zone, check for allowed timestamp <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> after adding tz.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!IS_VALID_TIMESTAMP(result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;date out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> for timestamp&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMESTAMP(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L3044" title="utils/adt/date.c:3044">timetz_part</a>() and <a href="#L3050" title="utils/adt/date.c:3050">extract_timetz</a>()<br/></li>
<li></span><span class="Comment"> * Extract specified field from time type.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Datum<br/></li>
<li><a id="L2927">&#x200c;</a><span class="linkable">timetz_part_common</span>(PG_FUNCTION_ARGS, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> retnumeric)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *units = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimeTzADT&nbsp; *time = PG_GETARG_TIMETZADT_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; intresult;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *lowunits;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; lowunits = <a href="../../parser/scansup.c.html#L37" title="parser/scansup.c:37">downcase_truncate_identifier</a>(VARDATA_ANY(units),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VARSIZE_ANY_EXHDR(units),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; type = <a href="datetime.c.html#L4036" title="utils/adt/datetime.c:4036">DecodeUnits</a>(<span class="Constant">0</span>, lowunits, &amp;val);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (type == UNKNOWN_FIELD)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; type = <a href="datetime.c.html#L3137" title="utils/adt/datetime.c:3137">DecodeSpecial</a>(<span class="Constant">0</span>, lowunits, &amp;val);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (type == UNITS)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tz;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fsec_t&nbsp; &nbsp; &nbsp; &nbsp; fsec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> pg_tm tt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *tm = &amp;tt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2403" title="utils/adt/date.c:2403">timetz2tm</a>(time, tm, &amp;fsec, &amp;tz);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (val)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_TZ:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = -tz;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_TZ_MINUTE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = (-tz / SECS_PER_MINUTE) % MINS_PER_HOUR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_TZ_HOUR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = -tz / SECS_PER_HOUR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MICROSEC:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = tm-&gt;tm_sec * INT64CONST(<span class="Constant">1000000</span>) + fsec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MILLISEC:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (retnumeric)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*---<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tm-&gt;tm_sec * 1000 + fsec / 1000<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * = (tm-&gt;tm_sec * 1'000'000 + fsec) / 1000<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="numeric.c.html#L4304" title="utils/adt/numeric.c:4304">int64_div_fast_to_numeric</a>(tm-&gt;tm_sec * INT64CONST(<span class="Constant">1000000</span>) + fsec, <span class="Constant">3</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(tm-&gt;tm_sec * <span class="Constant">1000.0</span> + fsec / <span class="Constant">1000.0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_SECOND:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (retnumeric)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*---<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tm-&gt;tm_sec + fsec / 1'000'000<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * = (tm-&gt;tm_sec * 1'000'000 + fsec) / 1'000'000<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="numeric.c.html#L4304" title="utils/adt/numeric.c:4304">int64_div_fast_to_numeric</a>(tm-&gt;tm_sec * INT64CONST(<span class="Constant">1000000</span>) + fsec, <span class="Constant">6</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(tm-&gt;tm_sec + fsec / <span class="Constant">1000000.0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MINUTE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = tm-&gt;tm_min;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_HOUR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = tm-&gt;tm_hour;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_DAY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MONTH:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_QUARTER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_YEAR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_DECADE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_CENTURY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MILLENNIUM:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unit </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> not supported for type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lowunits, <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(TIMETZOID))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (type == RESERV &amp;&amp; val == DTK_EPOCH)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (retnumeric)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*---<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * time-&gt;time / 1'000'000 + time-&gt;zone<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * = (time-&gt;time + time-&gt;zone * 1'000'000) / 1'000'000<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="numeric.c.html#L4304" title="utils/adt/numeric.c:4304">int64_div_fast_to_numeric</a>(time-&gt;time + time-&gt;zone * INT64CONST(<span class="Constant">1000000</span>), <span class="Constant">6</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(time-&gt;time / <span class="Constant">1000000.0</span> + time-&gt;zone);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unit </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> not recognized for type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lowunits, <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(TIMETZOID))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; intresult = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (retnumeric)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="numeric.c.html#L4283" title="utils/adt/numeric.c:4283">int64_to_numeric</a>(intresult));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(intresult);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3044">&#x200c;</a><span class="linkable">timetz_part</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2927" title="utils/adt/date.c:2927">timetz_part_common</a>(fcinfo, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3050">&#x200c;</a><span class="linkable">extract_timetz</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2927" title="utils/adt/date.c:2927">timetz_part_common</a>(fcinfo, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L3060" title="utils/adt/date.c:3060">timetz_zone</a>()<br/></li>
<li></span><span class="Comment"> * Encode time with time zone type with specified time zone.<br/></li>
<li></span><span class="Comment"> * Applies DST rules as of the transaction start time.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3060">&#x200c;</a><span class="linkable">timetz_zone</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *zone = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimeTzADT&nbsp; *t = PG_GETARG_TIMETZADT_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TimeTzADT&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tz;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; tzname[TZ_STRLEN_MAX + <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li>&nbsp; &nbsp; pg_tz&nbsp; &nbsp; &nbsp;&nbsp; *tzp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Look up the requested timezone.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="varlena.c.html#L248" title="utils/adt/varlena.c:248">text_to_cstring_buffer</a>(zone, tzname, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(tzname));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; type = <a href="datetime.c.html#L3179" title="utils/adt/datetime.c:3179">DecodeTimezoneName</a>(tzname, &amp;val, &amp;tzp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (type == TZNAME_FIXED_OFFSET)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fixed-offset abbreviation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tz = -val;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (type == TZNAME_DYNTZ)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* dynamic-offset abbreviation, resolve using transaction start time */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; TimestampTz <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> = <a href="../../access/transam/xact.c.html#L867" title="access/transam/xact.c:867">GetCurrentTransactionStartTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isdst;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tz = <a href="datetime.c.html#L1784" title="utils/adt/datetime.c:1784">DetermineTimeZoneAbbrevOffsetTS</a>(<a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, tzname, tzp, &amp;isdst);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get the offset-from-GMT that is valid <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> for the zone name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; TimestampTz <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> = <a href="../../access/transam/xact.c.html#L867" title="access/transam/xact.c:867">GetCurrentTransactionStartTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> pg_tm tm;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fsec_t&nbsp; &nbsp; &nbsp; &nbsp; fsec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="timestamp.c.html#L1901" title="utils/adt/timestamp.c:1901">timestamp2tm</a>(<a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, &amp;tz, &amp;tm, &amp;fsec, <span class="Constant">NULL</span>, tzp) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (TimeTzADT *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TimeTzADT));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result-&gt;time = t-&gt;time + (t-&gt;zone - tz) * USECS_PER_SEC;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* C99 modulo has the wrong sign convention for negative input */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (result-&gt;time &lt; INT64CONST(<span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;time += USECS_PER_DAY;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result-&gt;time &gt;= USECS_PER_DAY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;time %= USECS_PER_DAY;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result-&gt;zone = tz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMETZADT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L3122" title="utils/adt/date.c:3122">timetz_izone</a>()<br/></li>
<li></span><span class="Comment"> * Encode time with time zone type with specified time interval as time zone.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3122">&#x200c;</a><span class="linkable">timetz_izone</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *zone = PG_GETARG_INTERVAL_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimeTzADT&nbsp; *time = PG_GETARG_TIMETZADT_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TimeTzADT&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (INTERVAL_NOT_FINITE(zone))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;interval time zone </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> must be finite&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DatumGetCString(DirectFunctionCall1(<a href="timestamp.c.html#L982" title="utils/adt/timestamp.c:982">interval_out</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(zone))))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (zone-&gt;month != <span class="Constant">0</span> || zone-&gt;day != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;interval time zone </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> must not include <a href="datetime.c.html#L81" title="utils/adt/datetime.c:81">months</a> or <a href="datetime.c.html#L84" title="utils/adt/datetime.c:84">days</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DatumGetCString(DirectFunctionCall1(<a href="timestamp.c.html#L982" title="utils/adt/timestamp.c:982">interval_out</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(zone))))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tz = -(zone-&gt;time / USECS_PER_SEC);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (TimeTzADT *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TimeTzADT));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result-&gt;time = time-&gt;time + (time-&gt;zone - tz) * USECS_PER_SEC;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* C99 modulo has the wrong sign convention for negative input */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (result-&gt;time &lt; INT64CONST(<span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;time += USECS_PER_DAY;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result-&gt;time &gt;= USECS_PER_DAY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;time %= USECS_PER_DAY;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result-&gt;zone = tz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMETZADT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L3165" title="utils/adt/date.c:3165">timetz_at_local</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Unlike for timestamp[tz]_at_local, the type for timetz does not flip between<br/></li>
<li></span><span class="Comment"> * time with/without time zone, so we cannot just call the conversion function.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3165">&#x200c;</a><span class="linkable">timetz_at_local</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; time = PG_GETARG_DATUM(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *tzn = pg_get_timezone_name(session_timezone);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; zone = PointerGetDatum(<a href="varlena.c.html#L184" title="utils/adt/varlena.c:184">cstring_to_text</a>(tzn));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> DirectFunctionCall2(<a href="#L3060" title="utils/adt/date.c:3060">timetz_zone</a>, zone, time);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
