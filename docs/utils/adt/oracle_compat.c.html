<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/adt/oracle_compat.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/adt/oracle_compat.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L925">ascii</a></li>
<li><a href="#L342">btrim</a></li>
<li><a href="#L362">btrim1</a></li>
<li><a href="#L644">bytealtrim</a></li>
<li><a href="#L671">byteartrim</a></li>
<li><a href="#L617">byteatrim</a></li>
<li><a href="#L1006">chr</a></li>
<li><a href="#L534">dobyteatrim</a></li>
<li><a href="#L378">dotrim</a></li>
<li><a href="#L114">initcap</a></li>
<li><a href="#L49">lower</a></li>
<li><a href="#L147">lpad</a></li>
<li><a href="#L698">ltrim</a></li>
<li><a href="#L718">ltrim1</a></li>
<li><a href="#L1121">repeat</a></li>
<li><a href="#L245">rpad</a></li>
<li><a href="#L746">rtrim</a></li>
<li><a href="#L766">rtrim1</a></li>
<li><a href="#L797">translate</a></li>
<li><a href="#L80">upper</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * oracle_compat.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Oracle compatible <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Author: Edmund Mergl &lt;E.Mergl@bawue.de&gt;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Multibyte enhancement: Tatsuo Ishii &lt;ishii@postgresql.org&gt;<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; src/backend/utils/adt/oracle_compat.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;common/int.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;mb/pg_wchar.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/formatting.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;varatt.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Type">static</span> text *<a href="#L378" title="utils/adt/oracle_compat.c:378">dotrim</a>(<span class="Type">const</span> <span class="Type">char</span> *string, <span class="Type">int</span> stringlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *set, <span class="Type">int</span> setlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> doltrim, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> dortrim);<br/></li>
<li><span class="Type">static</span> bytea *<a href="#L534" title="utils/adt/oracle_compat.c:534">dobyteatrim</a>(bytea *string, bytea *set,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> doltrim, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> dortrim);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/********************************************************************<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L49" title="utils/adt/oracle_compat.c:49">lower</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Syntax:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; text <a href="#L49" title="utils/adt/oracle_compat.c:49">lower</a>(text string)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Purpose:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; Returns string, with all letters forced to lowercase.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> ********************************************************************/<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L49">&#x200c;</a><span class="linkable">lower</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *in_string = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *out_string;<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; out_string = <a href="formatting.c.html#L1636" title="utils/adt/formatting.c:1636">str_tolower</a>(VARDATA_ANY(in_string),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VARSIZE_ANY_EXHDR(in_string),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PG_GET_COLLATION());<br/></li>
<li>&nbsp; &nbsp; result = <a href="varlena.c.html#L184" title="utils/adt/varlena.c:184">cstring_to_text</a>(out_string);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(out_string);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/********************************************************************<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L80" title="utils/adt/oracle_compat.c:80">upper</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Syntax:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; text <a href="#L80" title="utils/adt/oracle_compat.c:80">upper</a>(text string)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Purpose:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; Returns string, with all letters forced to uppercase.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> ********************************************************************/<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L80">&#x200c;</a><span class="linkable">upper</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *in_string = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *out_string;<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; out_string = <a href="formatting.c.html#L1784" title="utils/adt/formatting.c:1784">str_toupper</a>(VARDATA_ANY(in_string),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VARSIZE_ANY_EXHDR(in_string),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PG_GET_COLLATION());<br/></li>
<li>&nbsp; &nbsp; result = <a href="varlena.c.html#L184" title="utils/adt/varlena.c:184">cstring_to_text</a>(out_string);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(out_string);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/********************************************************************<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L114" title="utils/adt/oracle_compat.c:114">initcap</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Syntax:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; text <a href="#L114" title="utils/adt/oracle_compat.c:114">initcap</a>(text string)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Purpose:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; Returns string, with first letter of each <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> in uppercase, all<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; other letters in lowercase. A <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> is defined as a sequence of<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; alphanumeric characters, delimited by non-alphanumeric<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; characters.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> ********************************************************************/<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L114">&#x200c;</a><span class="linkable">initcap</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *in_string = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *out_string;<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; out_string = <a href="formatting.c.html#L1973" title="utils/adt/formatting.c:1973">str_initcap</a>(VARDATA_ANY(in_string),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VARSIZE_ANY_EXHDR(in_string),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PG_GET_COLLATION());<br/></li>
<li>&nbsp; &nbsp; result = <a href="varlena.c.html#L184" title="utils/adt/varlena.c:184">cstring_to_text</a>(out_string);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(out_string);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/********************************************************************<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L147" title="utils/adt/oracle_compat.c:147">lpad</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Syntax:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; text <a href="#L147" title="utils/adt/oracle_compat.c:147">lpad</a>(text string1, int4 len, text string2)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Purpose:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; Returns string1, left-padded to length len with the sequence of<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; characters in string2.&nbsp; If len is less than the length of string1,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; instead truncate (on the right) to len.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> ********************************************************************/<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L147">&#x200c;</a><span class="linkable">lpad</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *string1 = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; len = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *string2 = PG_GETARG_TEXT_PP(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *ret;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ptr1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *ptr2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *ptr2start,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *ptr2end,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *ptr_ret;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; m,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s1len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s2len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bytelen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Negative len is silently taken as zero */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (len &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; s1len = VARSIZE_ANY_EXHDR(string1);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (s1len &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s1len = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* shouldn't happen */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; s2len = VARSIZE_ANY_EXHDR(string2);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (s2len &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s2len = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* shouldn't happen */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; s1len = <a href="../mb/mbutils.c.html#L1057" title="utils/mb/mbutils.c:1057">pg_mbstrlen_with_len</a>(VARDATA_ANY(string1), s1len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (s1len &gt; len)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s1len = len;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* truncate string1 to len chars */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (s2len &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len = s1len;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nothing to pad with, so don't pad */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* compute worst-case output length */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(pg_mul_s32_overflow(<a href="../mb/mbutils.c.html#L1546" title="utils/mb/mbutils.c:1546">pg_database_encoding_max_length</a>(), len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;bytelen)) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; unlikely(pg_add_s32_overflow(bytelen, VARHDRSZ, &amp;bytelen)) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; unlikely(!AllocSizeIsValid(bytelen)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;requested length too large&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ret = (text *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(bytelen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; m = len - s1len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ptr2 = ptr2start = VARDATA_ANY(string2);<br/></li>
<li>&nbsp; &nbsp; ptr2end = ptr2 + s2len;<br/></li>
<li>&nbsp; &nbsp; ptr_ret = VARDATA(ret);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (m--)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mlen = <a href="../mb/mbutils.c.html#L1023" title="utils/mb/mbutils.c:1023">pg_mblen</a>(ptr2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(ptr_ret, ptr2, mlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr_ret += mlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr2 += mlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ptr2 == ptr2end)&nbsp; &nbsp; <span class="Comment">/* wrap around at end of s2 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr2 = ptr2start;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ptr1 = VARDATA_ANY(string1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (s1len--)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mlen = <a href="../mb/mbutils.c.html#L1023" title="utils/mb/mbutils.c:1023">pg_mblen</a>(ptr1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(ptr_ret, ptr1, mlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr_ret += mlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr1 += mlen;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(ret, ptr_ret - (<span class="Type">char</span> *) ret);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(ret);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/********************************************************************<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L245" title="utils/adt/oracle_compat.c:245">rpad</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Syntax:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; text <a href="#L245" title="utils/adt/oracle_compat.c:245">rpad</a>(text string1, int4 len, text string2)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Purpose:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; Returns string1, right-padded to length len with the sequence of<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; characters in string2.&nbsp; If len is less than the length of string1,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; instead truncate (on the right) to len.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> ********************************************************************/<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L245">&#x200c;</a><span class="linkable">rpad</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *string1 = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; len = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *string2 = PG_GETARG_TEXT_PP(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *ret;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ptr1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *ptr2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *ptr2start,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *ptr2end,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *ptr_ret;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; m,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s1len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s2len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bytelen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Negative len is silently taken as zero */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (len &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; s1len = VARSIZE_ANY_EXHDR(string1);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (s1len &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s1len = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* shouldn't happen */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; s2len = VARSIZE_ANY_EXHDR(string2);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (s2len &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s2len = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* shouldn't happen */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; s1len = <a href="../mb/mbutils.c.html#L1057" title="utils/mb/mbutils.c:1057">pg_mbstrlen_with_len</a>(VARDATA_ANY(string1), s1len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (s1len &gt; len)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s1len = len;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* truncate string1 to len chars */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (s2len &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len = s1len;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nothing to pad with, so don't pad */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* compute worst-case output length */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(pg_mul_s32_overflow(<a href="../mb/mbutils.c.html#L1546" title="utils/mb/mbutils.c:1546">pg_database_encoding_max_length</a>(), len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;bytelen)) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; unlikely(pg_add_s32_overflow(bytelen, VARHDRSZ, &amp;bytelen)) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; unlikely(!AllocSizeIsValid(bytelen)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;requested length too large&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ret = (text *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(bytelen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; m = len - s1len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ptr1 = VARDATA_ANY(string1);<br/></li>
<li>&nbsp; &nbsp; ptr_ret = VARDATA(ret);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (s1len--)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mlen = <a href="../mb/mbutils.c.html#L1023" title="utils/mb/mbutils.c:1023">pg_mblen</a>(ptr1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(ptr_ret, ptr1, mlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr_ret += mlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr1 += mlen;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ptr2 = ptr2start = VARDATA_ANY(string2);<br/></li>
<li>&nbsp; &nbsp; ptr2end = ptr2 + s2len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (m--)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mlen = <a href="../mb/mbutils.c.html#L1023" title="utils/mb/mbutils.c:1023">pg_mblen</a>(ptr2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(ptr_ret, ptr2, mlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr_ret += mlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr2 += mlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ptr2 == ptr2end)&nbsp; &nbsp; <span class="Comment">/* wrap around at end of s2 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr2 = ptr2start;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(ret, ptr_ret - (<span class="Type">char</span> *) ret);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(ret);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/********************************************************************<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L342" title="utils/adt/oracle_compat.c:342">btrim</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Syntax:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; text <a href="#L342" title="utils/adt/oracle_compat.c:342">btrim</a>(text string, text set)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Purpose:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; Returns string with characters removed from the front and back<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; up to the first character not in set.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> ********************************************************************/<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L342">&#x200c;</a><span class="linkable">btrim</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *string = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *set = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *ret;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ret = <a href="#L378" title="utils/adt/oracle_compat.c:378">dotrim</a>(VARDATA_ANY(string), VARSIZE_ANY_EXHDR(string),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VARDATA_ANY(set), VARSIZE_ANY_EXHDR(set),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(ret);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/********************************************************************<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L362" title="utils/adt/oracle_compat.c:362">btrim1</a> --- <a href="#L342" title="utils/adt/oracle_compat.c:342">btrim</a> with set fixed as ' '<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> ********************************************************************/<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L362">&#x200c;</a><span class="linkable">btrim1</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *string = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *ret;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ret = <a href="#L378" title="utils/adt/oracle_compat.c:378">dotrim</a>(VARDATA_ANY(string), VARSIZE_ANY_EXHDR(string),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot; &quot;</span>, <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(ret);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Common implementation for <a href="#L342" title="utils/adt/oracle_compat.c:342">btrim</a>, <a href="#L698" title="utils/adt/oracle_compat.c:698">ltrim</a>, <a href="#L746" title="utils/adt/oracle_compat.c:746">rtrim</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> text *<br/></li>
<li><a id="L378">&#x200c;</a><span class="linkable">dotrim</span>(<span class="Type">const</span> <span class="Type">char</span> *string, <span class="Type">int</span> stringlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *set, <span class="Type">int</span> setlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> doltrim, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> dortrim)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Nothing to do if either string or set is empty */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stringlen &gt; <span class="Constant">0</span> &amp;&amp; setlen &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../mb/mbutils.c.html#L1546" title="utils/mb/mbutils.c:1546">pg_database_encoding_max_length</a>() &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In the multibyte-encoding case, build arrays of pointers to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * character starts, so that we can avoid inefficient checks in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the inner loops.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> **stringchars;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> **setchars;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *stringmblen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *setmblen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stringnchars;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; setnchars;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resultndx;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resultnchars;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *p;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mblen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *str_pos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str_len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stringchars = (<span class="Type">const</span> <span class="Type">char</span> **) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(stringlen * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">char</span> *));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stringmblen = (<span class="Type">int</span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(stringlen * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stringnchars = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p = string;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len = stringlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (len &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stringchars[stringnchars] = p;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stringmblen[stringnchars] = mblen = <a href="../mb/mbutils.c.html#L1023" title="utils/mb/mbutils.c:1023">pg_mblen</a>(p);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stringnchars++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p += mblen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len -= mblen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; setchars = (<span class="Type">const</span> <span class="Type">char</span> **) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(setlen * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">char</span> *));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; setmblen = (<span class="Type">int</span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(setlen * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; setnchars = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p = set;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len = setlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (len &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; setchars[setnchars] = p;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; setmblen[setnchars] = mblen = <a href="../mb/mbutils.c.html#L1023" title="utils/mb/mbutils.c:1023">pg_mblen</a>(p);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; setnchars++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p += mblen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len -= mblen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resultndx = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* index in stringchars[] */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resultnchars = stringnchars;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (doltrim)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (resultnchars &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str_pos = stringchars[resultndx];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str_len = stringmblen[resultndx];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; setnchars; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (str_len == setmblen[i] &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcmp(str_pos, setchars[i], str_len) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &gt;= setnchars)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; <span class="Comment">/* no match here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; string += str_len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stringlen -= str_len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resultndx++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resultnchars--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dortrim)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (resultnchars &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str_pos = stringchars[resultndx + resultnchars - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str_len = stringmblen[resultndx + resultnchars - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; setnchars; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (str_len == setmblen[i] &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcmp(str_pos, setchars[i], str_len) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &gt;= setnchars)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; <span class="Comment">/* no match here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stringlen -= str_len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resultnchars--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(stringchars);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(stringmblen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(setchars);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(setmblen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In the single-byte-encoding case, we don't need such overhead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (doltrim)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (stringlen &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; str_ch = *string;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; setlen; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (str_ch == set[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &gt;= setlen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; <span class="Comment">/* no match here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; string++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stringlen--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dortrim)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (stringlen &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; str_ch = string[stringlen - <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; setlen; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (str_ch == set[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &gt;= setlen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; <span class="Comment">/* no match here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stringlen--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Return selected portion of string */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="varlena.c.html#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(string, stringlen);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Common implementation for bytea versions of <a href="#L342" title="utils/adt/oracle_compat.c:342">btrim</a>, <a href="#L698" title="utils/adt/oracle_compat.c:698">ltrim</a>, <a href="#L746" title="utils/adt/oracle_compat.c:746">rtrim</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>bytea *<br/></li>
<li><a id="L534">&#x200c;</a><span class="linkable">dobyteatrim</span>(bytea *string, bytea *set, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> doltrim, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> dortrim)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *ret;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ptr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *end,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *ptr2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *ptr2start,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *end2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; m,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stringlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; setlen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; stringlen = VARSIZE_ANY_EXHDR(string);<br/></li>
<li>&nbsp; &nbsp; setlen = VARSIZE_ANY_EXHDR(set);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (stringlen &lt;= <span class="Constant">0</span> || setlen &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> string;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; m = stringlen;<br/></li>
<li>&nbsp; &nbsp; ptr = VARDATA_ANY(string);<br/></li>
<li>&nbsp; &nbsp; end = ptr + stringlen - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; ptr2start = VARDATA_ANY(set);<br/></li>
<li>&nbsp; &nbsp; end2 = ptr2start + setlen - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (doltrim)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (m &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr2 = ptr2start;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (ptr2 &lt;= end2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*ptr == *ptr2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ++ptr2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ptr2 &gt; end2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; m--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dortrim)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (m &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr2 = ptr2start;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (ptr2 &lt;= end2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*end == *ptr2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ++ptr2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ptr2 &gt; end2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; m--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ret = (bytea *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(VARHDRSZ + m);<br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(ret, VARHDRSZ + m);<br/></li>
<li>&nbsp; &nbsp; memcpy(VARDATA(ret), ptr, m);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ret;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/********************************************************************<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L617" title="utils/adt/oracle_compat.c:617">byteatrim</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Syntax:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; bytea <a href="#L617" title="utils/adt/oracle_compat.c:617">byteatrim</a>(bytea string, bytea set)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Purpose:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; Returns string with characters removed from the front and back<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; up to the first character not in set.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Cloned from <a href="#L342" title="utils/adt/oracle_compat.c:342">btrim</a> and modified as required.<br/></li>
<li></span><span class="Comment"> ********************************************************************/<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L617">&#x200c;</a><span class="linkable">byteatrim</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *string = PG_GETARG_BYTEA_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *set = PG_GETARG_BYTEA_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *ret;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ret = <a href="#L534" title="utils/adt/oracle_compat.c:534">dobyteatrim</a>(string, set, <span class="Constant">true</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BYTEA_P(ret);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/********************************************************************<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L644" title="utils/adt/oracle_compat.c:644">bytealtrim</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Syntax:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; bytea <a href="#L644" title="utils/adt/oracle_compat.c:644">bytealtrim</a>(bytea string, bytea set)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Purpose:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; Returns string with initial characters removed up to the first<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; character not in set.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> ********************************************************************/<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L644">&#x200c;</a><span class="linkable">bytealtrim</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *string = PG_GETARG_BYTEA_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *set = PG_GETARG_BYTEA_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *ret;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ret = <a href="#L534" title="utils/adt/oracle_compat.c:534">dobyteatrim</a>(string, set, <span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BYTEA_P(ret);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/********************************************************************<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L671" title="utils/adt/oracle_compat.c:671">byteartrim</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Syntax:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; bytea <a href="#L671" title="utils/adt/oracle_compat.c:671">byteartrim</a>(bytea string, bytea set)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Purpose:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; Returns string with final characters removed after the last<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; character not in set.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> ********************************************************************/<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L671">&#x200c;</a><span class="linkable">byteartrim</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *string = PG_GETARG_BYTEA_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *set = PG_GETARG_BYTEA_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *ret;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ret = <a href="#L534" title="utils/adt/oracle_compat.c:534">dobyteatrim</a>(string, set, <span class="Constant">false</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BYTEA_P(ret);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/********************************************************************<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L698" title="utils/adt/oracle_compat.c:698">ltrim</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Syntax:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; text <a href="#L698" title="utils/adt/oracle_compat.c:698">ltrim</a>(text string, text set)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Purpose:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; Returns string with initial characters removed up to the first<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; character not in set.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> ********************************************************************/<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L698">&#x200c;</a><span class="linkable">ltrim</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *string = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *set = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *ret;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ret = <a href="#L378" title="utils/adt/oracle_compat.c:378">dotrim</a>(VARDATA_ANY(string), VARSIZE_ANY_EXHDR(string),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VARDATA_ANY(set), VARSIZE_ANY_EXHDR(set),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(ret);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/********************************************************************<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L718" title="utils/adt/oracle_compat.c:718">ltrim1</a> --- <a href="#L698" title="utils/adt/oracle_compat.c:698">ltrim</a> with set fixed as ' '<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> ********************************************************************/<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L718">&#x200c;</a><span class="linkable">ltrim1</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *string = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *ret;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ret = <a href="#L378" title="utils/adt/oracle_compat.c:378">dotrim</a>(VARDATA_ANY(string), VARSIZE_ANY_EXHDR(string),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot; &quot;</span>, <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(ret);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/********************************************************************<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L746" title="utils/adt/oracle_compat.c:746">rtrim</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Syntax:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; text <a href="#L746" title="utils/adt/oracle_compat.c:746">rtrim</a>(text string, text set)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Purpose:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; Returns string with final characters removed after the last<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; character not in set.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> ********************************************************************/<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L746">&#x200c;</a><span class="linkable">rtrim</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *string = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *set = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *ret;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ret = <a href="#L378" title="utils/adt/oracle_compat.c:378">dotrim</a>(VARDATA_ANY(string), VARSIZE_ANY_EXHDR(string),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VARDATA_ANY(set), VARSIZE_ANY_EXHDR(set),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(ret);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/********************************************************************<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L766" title="utils/adt/oracle_compat.c:766">rtrim1</a> --- <a href="#L746" title="utils/adt/oracle_compat.c:746">rtrim</a> with set fixed as ' '<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> ********************************************************************/<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L766">&#x200c;</a><span class="linkable">rtrim1</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *string = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *ret;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ret = <a href="#L378" title="utils/adt/oracle_compat.c:378">dotrim</a>(VARDATA_ANY(string), VARSIZE_ANY_EXHDR(string),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot; &quot;</span>, <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(ret);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/********************************************************************<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L797" title="utils/adt/oracle_compat.c:797">translate</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Syntax:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; text <a href="#L797" title="utils/adt/oracle_compat.c:797">translate</a>(text string, text from, text to)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Purpose:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; Returns string after replacing all occurrences of characters in from<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; with the corresponding character in to.&nbsp; If from is longer than to,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; occurrences of the extra characters in from are deleted.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; Improved by Edwin Ramirez &lt;ramirez@doc.mssm.edu&gt;.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> ********************************************************************/<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L797">&#x200c;</a><span class="linkable">translate</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *string = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *from = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *to = PG_GETARG_TEXT_PP(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *from_ptr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *to_ptr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *to_end;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *source,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *target;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; m,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fromlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tolen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; retlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bytelen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; source_len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; from_index;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; m = VARSIZE_ANY_EXHDR(string);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (m &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_TEXT_P(string);<br/></li>
<li>&nbsp; &nbsp; source = VARDATA_ANY(string);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fromlen = VARSIZE_ANY_EXHDR(from);<br/></li>
<li>&nbsp; &nbsp; from_ptr = VARDATA_ANY(from);<br/></li>
<li>&nbsp; &nbsp; tolen = VARSIZE_ANY_EXHDR(to);<br/></li>
<li>&nbsp; &nbsp; to_ptr = VARDATA_ANY(to);<br/></li>
<li>&nbsp; &nbsp; to_end = to_ptr + tolen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The worst-case expansion is to substitute a max-length character for a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * single-byte character at each position of the string.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(pg_mul_s32_overflow(<a href="../mb/mbutils.c.html#L1546" title="utils/mb/mbutils.c:1546">pg_database_encoding_max_length</a>(), m,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;bytelen)) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; unlikely(pg_add_s32_overflow(bytelen, VARHDRSZ, &amp;bytelen)) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; unlikely(!AllocSizeIsValid(bytelen)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;requested length too large&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (text *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(bytelen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; target = VARDATA(result);<br/></li>
<li>&nbsp; &nbsp; retlen = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (m &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; source_len = <a href="../mb/mbutils.c.html#L1023" title="utils/mb/mbutils.c:1023">pg_mblen</a>(source);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; from_index = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; fromlen; i += len)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len = <a href="../mb/mbutils.c.html#L1023" title="utils/mb/mbutils.c:1023">pg_mblen</a>(&amp;from_ptr[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (len == source_len &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcmp(source, &amp;from_ptr[i], len) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; from_index++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &lt; fromlen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* substitute, or delete if no corresponding &quot;to&quot; character */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *p = to_ptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; from_index; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (p &gt;= to_end)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p += <a href="../mb/mbutils.c.html#L1023" title="utils/mb/mbutils.c:1023">pg_mblen</a>(p);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (p &lt; to_end)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len = <a href="../mb/mbutils.c.html#L1023" title="utils/mb/mbutils.c:1023">pg_mblen</a>(p);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(target, p, len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; target += len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; retlen += len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no match, so copy */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(target, source, source_len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; target += source_len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; retlen += source_len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; source += source_len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; m -= source_len;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(result, retlen + VARHDRSZ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The function result is probably much bigger than needed, if we're using<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a multibyte encoding, but it's not worth reallocating it; the result<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * probably won't live long anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/********************************************************************<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L925" title="utils/adt/oracle_compat.c:925">ascii</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Syntax:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; int <a href="#L925" title="utils/adt/oracle_compat.c:925">ascii</a>(text string)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Purpose:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; Returns the decimal representation of the first character from<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; string.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; If the string is empty we return 0.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; If the database encoding is UTF8, we return the Unicode codepoint.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; If the database encoding is <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other multi-byte encoding, we<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; return the value of the first byte if it is an ASCII character<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; (<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> 1 .. 127), or raise an error.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; For all other encodings we return the value of the first byte,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; (<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> 1..255).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> ********************************************************************/<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L925">&#x200c;</a><span class="linkable">ascii</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *string = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; encoding = <a href="../mb/mbutils.c.html#L1261" title="utils/mb/mbutils.c:1261">GetDatabaseEncoding</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> *data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (VARSIZE_ANY_EXHDR(string) &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_INT32(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; data = (<span class="Type">unsigned</span> <span class="Type">char</span> *) VARDATA_ANY(string);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (encoding == PG_UTF8 &amp;&amp; *data &gt; <span class="Constant">127</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* return the code point for Unicode */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tbytes = <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*data &gt;= <span class="Constant">0xF0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = *data &amp; <span class="Constant">0x07</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tbytes = <span class="Constant">3</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*data &gt;= <span class="Constant">0xE0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = *data &amp; <span class="Constant">0x0F</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tbytes = <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(*data &gt; <span class="Constant">0xC0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = *data &amp; <span class="Constant">0x1f</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tbytes = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(tbytes &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt;= tbytes; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert((data[i] &amp; <span class="Constant">0xC0</span>) == <span class="Constant">0x80</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = (result &lt;&lt; <span class="Constant">6</span>) + (data[i] &amp; <span class="Constant">0x3f</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_INT32(result);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pg_encoding_max_length(encoding) &gt; <span class="Constant">1</span> &amp;&amp; *data &gt; <span class="Constant">127</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;requested character too large&quot;</span>)));<br/></li>
<li><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_INT32((int32) *data);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/********************************************************************<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L1006" title="utils/adt/oracle_compat.c:1006">chr</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Syntax:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; text <a href="#L1006" title="utils/adt/oracle_compat.c:1006">chr</a>(int val)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Purpose:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Returns the character having the binary equivalent to val.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For UTF8 we treat the argument as a Unicode code point.<br/></li>
<li></span><span class="Comment"> * For other multi-byte encodings we raise an error for arguments<br/></li>
<li></span><span class="Comment"> * outside the strict ASCII <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> (1..127).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It's important that we don't ever return a value that is not valid<br/></li>
<li></span><span class="Comment"> * in the database encoding, so that this doesn't become a way for<br/></li>
<li></span><span class="Comment"> * invalid data to enter the database.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> ********************************************************************/<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L1006">&#x200c;</a><span class="linkable">chr</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; arg = PG_GETARG_INT32(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; cvalue;<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; encoding = <a href="../mb/mbutils.c.html#L1261" title="utils/mb/mbutils.c:1261">GetDatabaseEncoding</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Error out on arguments that make no sense or that we can't validly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * represent in the encoding.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (arg &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;character number must be positive&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (arg == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;null character not permitted&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cvalue = arg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (encoding == PG_UTF8 &amp;&amp; cvalue &gt; <span class="Constant">127</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* for Unicode we treat the argument as a code point */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bytes;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> *wch;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We only allow valid Unicode code points; per RFC3629 that stops at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * U+10FFFF, even though 4-byte UTF8 sequences can hold <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> up to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * U+1FFFFF.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cvalue &gt; <span class="Constant">0x0010ffff</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;requested character too large for encoding: </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cvalue)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cvalue &gt; <span class="Constant">0xffff</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bytes = <span class="Constant">4</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (cvalue &gt; <span class="Constant">0x07ff</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bytes = <span class="Constant">3</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bytes = <span class="Constant">2</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = (text *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(VARHDRSZ + bytes);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SET_VARSIZE(result, VARHDRSZ + bytes);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; wch = (<span class="Type">unsigned</span> <span class="Type">char</span> *) VARDATA(result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bytes == <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wch[<span class="Constant">0</span>] = <span class="Constant">0xC0</span> | ((cvalue &gt;&gt; <span class="Constant">6</span>) &amp; <span class="Constant">0x1F</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wch[<span class="Constant">1</span>] = <span class="Constant">0x80</span> | (cvalue &amp; <span class="Constant">0x3F</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (bytes == <span class="Constant">3</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wch[<span class="Constant">0</span>] = <span class="Constant">0xE0</span> | ((cvalue &gt;&gt; <span class="Constant">12</span>) &amp; <span class="Constant">0x0F</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wch[<span class="Constant">1</span>] = <span class="Constant">0x80</span> | ((cvalue &gt;&gt; <span class="Constant">6</span>) &amp; <span class="Constant">0x3F</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wch[<span class="Constant">2</span>] = <span class="Constant">0x80</span> | (cvalue &amp; <span class="Constant">0x3F</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wch[<span class="Constant">0</span>] = <span class="Constant">0xF0</span> | ((cvalue &gt;&gt; <span class="Constant">18</span>) &amp; <span class="Constant">0x07</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wch[<span class="Constant">1</span>] = <span class="Constant">0x80</span> | ((cvalue &gt;&gt; <span class="Constant">12</span>) &amp; <span class="Constant">0x3F</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wch[<span class="Constant">2</span>] = <span class="Constant">0x80</span> | ((cvalue &gt;&gt; <span class="Constant">6</span>) &amp; <span class="Constant">0x3F</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wch[<span class="Constant">3</span>] = <span class="Constant">0x80</span> | (cvalue &amp; <span class="Constant">0x3F</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The preceding <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> check isn't sufficient, because UTF8 excludes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Unicode &quot;surrogate pair&quot; codes.&nbsp; Make sure what we created is valid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * UTF8.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!pg_utf8_islegal(wch, bytes))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;requested character not valid for encoding: </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cvalue)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_mb;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; is_mb = pg_encoding_max_length(encoding) &gt; <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((is_mb &amp;&amp; (cvalue &gt; <span class="Constant">127</span>)) || (!is_mb &amp;&amp; (cvalue &gt; <span class="Constant">255</span>)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;requested character too large for encoding: </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cvalue)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = (text *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(VARHDRSZ + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SET_VARSIZE(result, VARHDRSZ + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *VARDATA(result) = (<span class="Type">char</span>) cvalue;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/********************************************************************<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L1584" title="regex/regcomp.c:1584">repeat</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Syntax:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; text <a href="../../regex/regcomp.c.html#L1584" title="regex/regcomp.c:1584">repeat</a>(text string, int val)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Purpose:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Repeat string by val.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> ********************************************************************/<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L1121">&#x200c;</a><span class="linkable">repeat</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *string = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; count = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *cp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *sp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (count &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; count = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; slen = VARSIZE_ANY_EXHDR(string);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(pg_mul_s32_overflow(count, slen, &amp;tlen)) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; unlikely(pg_add_s32_overflow(tlen, VARHDRSZ, &amp;tlen)) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; unlikely(!AllocSizeIsValid(tlen)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;requested length too large&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (text *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(tlen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(result, tlen);<br/></li>
<li>&nbsp; &nbsp; cp = VARDATA(result);<br/></li>
<li>&nbsp; &nbsp; sp = VARDATA_ANY(string);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; count; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(cp, sp, slen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cp += slen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(result);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
