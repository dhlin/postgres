<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/adt/selfuncs.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/adt/selfuncs.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L148">get_index_stats_hook</a></li>
<li><a href="#L147">get_relation_stats_hook</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L7295">GinQualCounts</a></li>
<li><a href="#L3293">GroupVarInfo</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L4971">ReleaseDummy</a></li>
<li><a href="#L6767">add_predicate_to_index_quals</a></li>
<li><a href="#L3296">add_unique_group_var</a></li>
<li><a href="#L1540">booltestsel</a></li>
<li><a href="#L1512">boolvarsel</a></li>
<li><a href="#L7973">brincostestimate</a></li>
<li><a href="#L6788">btcostestimate</a></li>
<li><a href="#L4726">convert_bytea_to_scalar</a></li>
<li><a href="#L4452">convert_numeric_to_scalar</a></li>
<li><a href="#L4774">convert_one_bytea_to_scalar</a></li>
<li><a href="#L4594">convert_one_string_to_scalar</a></li>
<li><a href="#L4645">convert_string_datum</a></li>
<li><a href="#L4514">convert_string_to_scalar</a></li>
<li><a href="#L4817">convert_timevalue_to_scalar</a></li>
<li><a href="#L4305">convert_to_scalar</a></li>
<li><a href="#L2269">eqjoinsel</a></li>
<li><a href="#L2434">eqjoinsel_inner</a></li>
<li><a href="#L2631">eqjoinsel_semi</a></li>
<li><a href="#L227">eqsel</a></li>
<li><a href="#L236">eqsel_internal</a></li>
<li><a href="#L2136">estimate_array_length</a></li>
<li><a href="#L3798">estimate_hash_bucket_stats</a></li>
<li><a href="#L3917">estimate_hashagg_tablesize</a></li>
<li><a href="#L3954">estimate_multivariate_ndistinct</a></li>
<li><a href="#L3416">estimate_num_groups</a></li>
<li><a href="#L5406">examine_simple_variable</a></li>
<li><a href="#L5012">examine_variable</a></li>
<li><a href="#L6428">find_join_input_rel</a></li>
<li><a href="#L914">generic_restriction_selectivity</a></li>
<li><a href="#L6544">genericcostestimate</a></li>
<li><a href="#L6267">get_actual_variable_endpoint</a></li>
<li><a href="#L6087">get_actual_variable_range</a></li>
<li><a href="#L4943">get_join_variables</a></li>
<li><a href="#L6460">get_quals_from_indexclauses</a></li>
<li><a href="#L4883">get_restriction_variable</a></li>
<li><a href="#L6024">get_stats_slot_range</a></li>
<li><a href="#L5764">get_variable_numdistinct</a></li>
<li><a href="#L5897">get_variable_range</a></li>
<li><a href="#L7417">gincost_opexpr</a></li>
<li><a href="#L7303">gincost_pattern</a></li>
<li><a href="#L7467">gincost_scalararrayopexpr</a></li>
<li><a href="#L7583">gincostestimate</a></li>
<li><a href="#L7173">gistcostestimate</a></li>
<li><a href="#L7131">hashcostestimate</a></li>
<li><a href="#L823">histogram_selectivity</a></li>
<li><a href="#L6490">index_other_operands_eval_cost</a></li>
<li><a href="#L1041">ineq_histogram_selectivity</a></li>
<li><a href="#L3275">matchingjoinsel</a></li>
<li><a href="#L3257">matchingsel</a></li>
<li><a href="#L732">mcv_selectivity</a></li>
<li><a href="#L2952">mergejoinscansel</a></li>
<li><a href="#L2819">neqjoinsel</a></li>
<li><a href="#L557">neqsel</a></li>
<li><a href="#L1698">nulltestsel</a></li>
<li><a href="#L2202">rowcomparesel</a></li>
<li><a href="#L1816">scalararraysel</a></li>
<li><a href="#L2924">scalargejoinsel</a></li>
<li><a href="#L1498">scalargesel</a></li>
<li><a href="#L2915">scalargtjoinsel</a></li>
<li><a href="#L1489">scalargtsel</a></li>
<li><a href="#L580">scalarineqsel</a></li>
<li><a href="#L1400">scalarineqsel_wrapper</a></li>
<li><a href="#L2906">scalarlejoinsel</a></li>
<li><a href="#L1480">scalarlesel</a></li>
<li><a href="#L2897">scalarltjoinsel</a></li>
<li><a href="#L1471">scalarltsel</a></li>
<li><a href="#L7228">spgcostestimate</a></li>
<li><a href="#L5735">statistic_proc_security_check</a></li>
<li><a href="#L1783">strip_array_coercion</a></li>
<li><a href="#L295">var_eq_const</a></li>
<li><a href="#L466">var_eq_non_const</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L144">DEFAULT_PAGE_CPU_MULTIPLIER</a></li>
<li><a href="#L6364">VISITED_PAGES_LIMIT</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * selfuncs.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Selectivity <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> and index cost estimation <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; standard operators and index access methods.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Selectivity routines are registered in the pg_operator catalog<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; in the &quot;oprrest&quot; and &quot;oprjoin&quot; attributes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Index cost <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> are located via the index AM's API struct,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; which is obtained from the handler function registered in pg_am.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/adt/selfuncs.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*----------<br/></li>
<li></span><span class="Comment"> * Operator selectivity estimation <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> are called to estimate the<br/></li>
<li></span><span class="Comment"> * selectivity of WHERE clauses whose top-level operator is their operator.<br/></li>
<li></span><span class="Comment"> * We divide the problem into two cases:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Restriction clause estimation: the clause involves <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> of just<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; one relation.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Join clause estimation: the clause involves <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> of multiple rels.<br/></li>
<li></span><span class="Comment"> * Join selectivity estimation is far more difficult and usually less accurate<br/></li>
<li></span><span class="Comment"> * than restriction estimation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When dealing with the inner scan of a nestloop join, we consider the<br/></li>
<li></span><span class="Comment"> * join's joinclauses as restriction clauses for the inner relation, and<br/></li>
<li></span><span class="Comment"> * treat <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> of the outer relation as parameters (a/k/a constants of unknown<br/></li>
<li></span><span class="Comment"> * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>).&nbsp; So, restriction estimators need to be able to <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> an argument<br/></li>
<li></span><span class="Comment"> * telling which relation is to be treated as the variable.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The call convention for a restriction estimator (oprrest function) is<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Selectivity oprrest (PlannerInfo *root,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid operator,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *args,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; int varRelid);<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * root: general information about the query (rtable and RelOptInfo lists<br/></li>
<li></span><span class="Comment"> * are particularly important for the estimator).<br/></li>
<li></span><span class="Comment"> * operator: OID of the specific operator in question.<br/></li>
<li></span><span class="Comment"> * args: argument list from the operator clause.<br/></li>
<li></span><span class="Comment"> * varRelid: if not zero, the relid (rtable index) of the relation to<br/></li>
<li></span><span class="Comment"> * be treated as the variable relation.&nbsp; May be zero if the args list<br/></li>
<li></span><span class="Comment"> * is known to contain <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> of only one relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is represented at the SQL level (in pg_proc) as<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; float8 oprrest (<a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a>, oid, <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a>, int4);<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The result is a selectivity, that is, a fraction (0 to 1) of the rows<br/></li>
<li></span><span class="Comment"> * of the relation that are expected to produce a TRUE result for the<br/></li>
<li></span><span class="Comment"> * given operator.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The call convention for a join estimator (oprjoin function) is similar<br/></li>
<li></span><span class="Comment"> * except that varRelid is not needed, and instead join information is<br/></li>
<li></span><span class="Comment"> * supplied:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Selectivity oprjoin (PlannerInfo *root,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid operator,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *args,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; JoinType jointype,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; SpecialJoinInfo *sjinfo);<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; float8 oprjoin (<a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a>, oid, <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a>, int2, <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a>);<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * (Before Postgres 8.4, join estimators had only the first four of these<br/></li>
<li></span><span class="Comment"> * parameters.&nbsp; That signature is still allowed, but deprecated.)&nbsp; The<br/></li>
<li></span><span class="Comment"> * relationship between jointype and sjinfo is explained in the comments for<br/></li>
<li></span><span class="Comment"> * <a href="../../optimizer/path/clausesel.c.html#L667" title="optimizer/path/clausesel.c:667">clause_selectivity</a>() --- the short version is that jointype is usually<br/></li>
<li></span><span class="Comment"> * best ignored in favor of examining sjinfo.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Join selectivity for regular inner and outer joins is defined as the<br/></li>
<li></span><span class="Comment"> * fraction (0 to 1) of the cross product of the relations that is expected<br/></li>
<li></span><span class="Comment"> * to produce a TRUE result for the given operator.&nbsp; For both semi and anti<br/></li>
<li></span><span class="Comment"> * joins, however, the selectivity is defined as the fraction of the left-hand<br/></li>
<li></span><span class="Comment"> * side relation's rows that are expected to have a match (ie, at least one<br/></li>
<li></span><span class="Comment"> * row with a TRUE result) in the right-hand side.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For both oprrest and oprjoin <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, the operator's input collation OID<br/></li>
<li></span><span class="Comment"> * (if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>) is passed using the standard fmgr mechanism, so that the estimator<br/></li>
<li></span><span class="Comment"> * function can fetch it with PG_GET_COLLATION().&nbsp; Note, however, that all<br/></li>
<li></span><span class="Comment"> * statistics in pg_statistic are currently built using the relevant column's<br/></li>
<li></span><span class="Comment"> * collation.<br/></li>
<li></span><span class="Comment"> *----------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;ctype.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;math.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/brin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/brin_page.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/gin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/table.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/tableam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/visibilitymap.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_am.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_collation.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_operator.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_statistic.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_statistic_ext.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/nodeAgg.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/makefuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/nodeFuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/clauses.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/cost.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/optimizer.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/pathnode.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/paths.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/plancat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_clause.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_relation.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parsetree.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;statistics/statistics.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/bufmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/acl.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/array.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/date.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/datum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgroids.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/index_selfuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/pg_locale.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/selfuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/snapmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/spccache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/syscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/timestamp.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/typcache.h&quot;<br/></li>
<li></span><br/></li>
<li><a id="L144">&#x200c;</a><span class="PreProc">#define <span class="linkable">DEFAULT_PAGE_CPU_MULTIPLIER</span> </span><span class="Constant">50.0<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Hooks for plugins to get control when we ask for stats */<br/></li>
<li><a id="L147">&#x200c;</a></span>get_relation_stats_hook_type <span class="linkable">get_relation_stats_hook</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L148">&#x200c;</a>get_index_stats_hook_type <span class="linkable">get_index_stats_hook</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">double</span> <a href="#L236" title="utils/adt/selfuncs.c:236">eqsel_internal</a>(PG_FUNCTION_ARGS, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> negate);<br/></li>
<li><span class="Type">static</span> <span class="Type">double</span> <a href="#L2434" title="utils/adt/selfuncs.c:2434">eqjoinsel_inner</a>(Oid opfuncoid, Oid collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VariableStatData *vardata1, VariableStatData *vardata2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span> nd1, <span class="Type">double</span> nd2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isdefault1, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isdefault2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AttStatsSlot *sslot1, AttStatsSlot *sslot2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_statistic stats1, Form_pg_statistic stats2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> have_mcvs1, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> have_mcvs2);<br/></li>
<li><span class="Type">static</span> <span class="Type">double</span> <a href="#L2631" title="utils/adt/selfuncs.c:2631">eqjoinsel_semi</a>(Oid opfuncoid, Oid collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VariableStatData *vardata1, VariableStatData *vardata2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">double</span> nd1, <span class="Type">double</span> nd2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isdefault1, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isdefault2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AttStatsSlot *sslot1, AttStatsSlot *sslot2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Form_pg_statistic stats1, Form_pg_statistic stats2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> have_mcvs1, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> have_mcvs2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *inner_rel);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L3954" title="utils/adt/selfuncs.c:3954">estimate_multivariate_ndistinct</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *rel, List **varinfos, <span class="Type">double</span> *ndistinct);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L4305" title="utils/adt/selfuncs.c:4305">convert_to_scalar</a>(Datum value, Oid valuetypid, Oid collid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span> *scaledvalue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum lobound, Datum hibound, Oid boundstypid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span> *scaledlobound, <span class="Type">double</span> *scaledhibound);<br/></li>
<li><span class="Type">static</span> <span class="Type">double</span> <a href="#L4452" title="utils/adt/selfuncs.c:4452">convert_numeric_to_scalar</a>(Datum value, Oid typid, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *failure);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4514" title="utils/adt/selfuncs.c:4514">convert_string_to_scalar</a>(<span class="Type">char</span> *value,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">double</span> *scaledvalue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">char</span> *lobound,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">double</span> *scaledlobound,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">char</span> *hibound,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">double</span> *scaledhibound);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4726" title="utils/adt/selfuncs.c:4726">convert_bytea_to_scalar</a>(Datum value,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span> *scaledvalue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum lobound,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span> *scaledlobound,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum hibound,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span> *scaledhibound);<br/></li>
<li><span class="Type">static</span> <span class="Type">double</span> <a href="#L4594" title="utils/adt/selfuncs.c:4594">convert_one_string_to_scalar</a>(<span class="Type">char</span> *value,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> rangelo, <span class="Type">int</span> rangehi);<br/></li>
<li><span class="Type">static</span> <span class="Type">double</span> <a href="#L4774" title="utils/adt/selfuncs.c:4774">convert_one_bytea_to_scalar</a>(<span class="Type">unsigned</span> <span class="Type">char</span> *value, <span class="Type">int</span> valuelen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> rangelo, <span class="Type">int</span> rangehi);<br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<a href="#L4645" title="utils/adt/selfuncs.c:4645">convert_string_datum</a>(Datum value, Oid typid, Oid collid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *failure);<br/></li>
<li><span class="Type">static</span> <span class="Type">double</span> <a href="#L4817" title="utils/adt/selfuncs.c:4817">convert_timevalue_to_scalar</a>(Datum value, Oid typid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *failure);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L5406" title="utils/adt/selfuncs.c:5406">examine_simple_variable</a>(PlannerInfo *root, Var *var,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VariableStatData *vardata);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L5897" title="utils/adt/selfuncs.c:5897">get_variable_range</a>(PlannerInfo *root, VariableStatData *vardata,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid sortop, Oid collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum *min, Datum *max);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L6024" title="utils/adt/selfuncs.c:6024">get_stats_slot_range</a>(AttStatsSlot *sslot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid opfuncoid, FmgrInfo *opproc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid collation, int16 typLen, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> typByVal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum *min, Datum *max, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *p_have_data);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L6087" title="utils/adt/selfuncs.c:6087">get_actual_variable_range</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VariableStatData *vardata,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid sortop, Oid collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum *min, Datum *max);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L6267" title="utils/adt/selfuncs.c:6267">get_actual_variable_endpoint</a>(Relation heapRel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relation indexRel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ScanDirection indexscandir,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ScanKey scankeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; int16 typLen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> typByVal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TupleTableSlot *tableslot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MemoryContext outercontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum *endpointDatum);<br/></li>
<li><span class="Type">static</span> RelOptInfo *<a href="#L6428" title="utils/adt/selfuncs.c:6428">find_join_input_rel</a>(PlannerInfo *root, Relids relids);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L227" title="utils/adt/selfuncs.c:227">eqsel</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - Selectivity of &quot;=&quot; for <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> data types.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this routine is also used to estimate selectivity for some<br/></li>
<li></span><span class="Comment"> * operators that are not &quot;=&quot; but have comparable selectivity behavior,<br/></li>
<li></span><span class="Comment"> * such as &quot;~=&quot; (geometric approximate-match).&nbsp; Even for &quot;=&quot;, we must<br/></li>
<li></span><span class="Comment"> * keep in mind that the left and right datatypes may differ.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L227">&#x200c;</a><span class="linkable">eqsel</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8((float8) <a href="#L236" title="utils/adt/selfuncs.c:236">eqsel_internal</a>(fcinfo, <span class="Constant">false</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Common code for <a href="#L227" title="utils/adt/selfuncs.c:227">eqsel</a>() and <a href="#L557" title="utils/adt/selfuncs.c:557">neqsel</a>()<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">double<br/></li>
<li><a id="L236">&#x200c;</a></span><span class="linkable">eqsel_internal</span>(PG_FUNCTION_ARGS, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> negate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; operator = PG_GETARG_OID(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *args = (List *) PG_GETARG_POINTER(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; varRelid = PG_GETARG_INT32(<span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collation = PG_GET_COLLATION();<br/></li>
<li>&nbsp; &nbsp; VariableStatData vardata;<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *other;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; varonleft;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; selec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When asked about &lt;&gt;, we do the estimation using the corresponding =<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operator, then convert to &lt;&gt; via &quot;1.0 - eq_selectivity - nullfrac&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (negate)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; operator = <a href="../cache/lsyscache.c.html#L1533" title="utils/cache/lsyscache.c:1533">get_negator</a>(operator);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(operator))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Use default selectivity (should we raise an error instead?) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1.0</span> - DEFAULT_EQ_SEL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If expression is not variable = something or something = variable, then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * punt and return a default estimate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L4883" title="utils/adt/selfuncs.c:4883">get_restriction_variable</a>(root, args, varRelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;vardata, &amp;other, &amp;varonleft))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> negate ? (<span class="Constant">1.0</span> - DEFAULT_EQ_SEL) : DEFAULT_EQ_SEL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can do a lot better if the something is a constant.&nbsp; (Note: the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Const might result from estimation rather than being a simple constant<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in the query.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(other, Const))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; selec = <a href="#L295" title="utils/adt/selfuncs.c:295">var_eq_const</a>(&amp;vardata, operator, collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ((Const *) other)-&gt;constvalue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ((Const *) other)-&gt;constisnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; varonleft, negate);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; selec = <a href="#L466" title="utils/adt/selfuncs.c:466">var_eq_non_const</a>(&amp;vardata, operator, collation, other,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; varonleft, negate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ReleaseVariableStats(vardata);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> selec;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L295" title="utils/adt/selfuncs.c:295">var_eq_const</a> --- <a href="#L227" title="utils/adt/selfuncs.c:227">eqsel</a> for var = const case<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is exported so that some other estimation <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> can use it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">double<br/></li>
<li><a id="L295">&#x200c;</a></span><span class="linkable">var_eq_const</span>(VariableStatData *vardata, Oid oproid, Oid collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum constval, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> constisnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> varonleft, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> negate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; selec;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; nullfrac = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isdefault;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opfuncoid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the constant is NULL, assume operator is strict and return zero, ie,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operator will never return TRUE.&nbsp; (It's zero even for a negator op.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (constisnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Grab the nullfrac for use below.&nbsp; Note we allow use of nullfrac<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * regardless of security check.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(vardata-&gt;statsTuple))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_statistic stats;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stats = (Form_pg_statistic) GETSTRUCT(vardata-&gt;statsTuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nullfrac = stats-&gt;stanullfrac;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we matched the var to a unique index or DISTINCT clause, assume<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there is exactly one match regardless of anything else.&nbsp; (This is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * slightly bogus, since the index or clause's equality operator might be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * different from ours, but it's much more likely to be right than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ignoring the information.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (vardata-&gt;isunique &amp;&amp; vardata-&gt;rel &amp;&amp; vardata-&gt;rel-&gt;tuples &gt;= <span class="Constant">1.0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; selec = <span class="Constant">1.0</span> / vardata-&gt;rel-&gt;tuples;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (HeapTupleIsValid(vardata-&gt;statsTuple) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L5735" title="utils/adt/selfuncs.c:5735">statistic_proc_security_check</a>(vardata,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (opfuncoid = <a href="../cache/lsyscache.c.html#L1285" title="utils/cache/lsyscache.c:1285">get_opcode</a>(oproid))))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AttStatsSlot sslot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; match = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Is the constant &quot;=&quot; to <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the column's most common <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (Although the given operator may not really be &quot;=&quot;, we will assume<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that seeing whether it returns TRUE is an appropriate test.&nbsp; If you<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't like this, maybe you shouldn't be using <a href="#L227" title="utils/adt/selfuncs.c:227">eqsel</a> for your<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * operator...)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../cache/lsyscache.c.html#L3234" title="utils/cache/lsyscache.c:3234">get_attstatsslot</a>(&amp;sslot, vardata-&gt;statsTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; STATISTIC_KIND_MCV, InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LOCAL_FCINFO(fcinfo, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; eqproc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../fmgr/fmgr.c.html#L127" title="utils/fmgr/fmgr.c:127">fmgr_info</a>(opfuncoid, &amp;eqproc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Save a few cycles by setting up the fcinfo struct just once.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Using FunctionCallInvoke directly also avoids failure if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * eqproc returns NULL, though really equality <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * never do that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InitFunctionCallInfoData(*fcinfo, &amp;eqproc, <span class="Constant">2</span>, collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* be careful to apply operator right way 'round */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (varonleft)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].value = constval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].value = constval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; sslot.nvalues; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; fresult;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (varonleft)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].value = sslot.<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].value = sslot.<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fresult = FunctionCallInvoke(fcinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!fcinfo-&gt;isnull &amp;&amp; DatumGetBool(fresult))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; match = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no most-common-value info available */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (match)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Constant is &quot;=&quot; to this common value.&nbsp; We know selectivity<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * exactly (or as exactly as ANALYZE could calculate it, anyway).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = sslot.numbers[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Comparison is against a constant that is neither NULL nor <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of the common <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.&nbsp; Its selectivity cannot be more than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; sumcommon = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; otherdistinct;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; sslot.nnumbers; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sumcommon += sslot.numbers[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = <span class="Constant">1.0</span> - sumcommon - nullfrac;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CLAMP_PROBABILITY(selec);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and in fact it's probably a good deal less. We approximate that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * all the not-common <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> share this remaining fraction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * equally, so we divide by the number of other distinct <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; otherdistinct = <a href="#L5764" title="utils/adt/selfuncs.c:5764">get_variable_numdistinct</a>(vardata, &amp;isdefault) -<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sslot.nnumbers;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (otherdistinct &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec /= otherdistinct;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Another cross-check: selectivity shouldn't be estimated as more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * than the least common &quot;most common value&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sslot.nnumbers &gt; <span class="Constant">0</span> &amp;&amp; selec &gt; sslot.numbers[sslot.nnumbers - <span class="Constant">1</span>])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = sslot.numbers[sslot.nnumbers - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L3344" title="utils/cache/lsyscache.c:3344">free_attstatsslot</a>(&amp;sslot);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No ANALYZE stats available, so make a guess using estimated number<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of distinct <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> and assuming they are equally common. (The guess<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is unlikely to be very good, but we do know a few special cases.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; selec = <span class="Constant">1.0</span> / <a href="#L5764" title="utils/adt/selfuncs.c:5764">get_variable_numdistinct</a>(vardata, &amp;isdefault);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> adjust if we wanted &lt;&gt; rather than = */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (negate)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; selec = <span class="Constant">1.0</span> - selec - nullfrac;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* result should be in <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, but make sure... */<br/></li>
<li></span>&nbsp; &nbsp; CLAMP_PROBABILITY(selec);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> selec;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L466" title="utils/adt/selfuncs.c:466">var_eq_non_const</a> --- <a href="#L227" title="utils/adt/selfuncs.c:227">eqsel</a> for var = something-other-than-const case<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is exported so that some other estimation <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> can use it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">double<br/></li>
<li><a id="L466">&#x200c;</a></span><span class="linkable">var_eq_non_const</span>(VariableStatData *vardata, Oid oproid, Oid collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Node *other,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> varonleft, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> negate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; selec;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; nullfrac = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isdefault;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Grab the nullfrac for use below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(vardata-&gt;statsTuple))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_statistic stats;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stats = (Form_pg_statistic) GETSTRUCT(vardata-&gt;statsTuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nullfrac = stats-&gt;stanullfrac;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we matched the var to a unique index or DISTINCT clause, assume<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there is exactly one match regardless of anything else.&nbsp; (This is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * slightly bogus, since the index or clause's equality operator might be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * different from ours, but it's much more likely to be right than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ignoring the information.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (vardata-&gt;isunique &amp;&amp; vardata-&gt;rel &amp;&amp; vardata-&gt;rel-&gt;tuples &gt;= <span class="Constant">1.0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; selec = <span class="Constant">1.0</span> / vardata-&gt;rel-&gt;tuples;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (HeapTupleIsValid(vardata-&gt;statsTuple))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; ndistinct;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AttStatsSlot sslot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Search is for a value that we do not know a priori, but we will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * assume it is not NULL.&nbsp; Estimate the selectivity as non-null<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fraction divided by number of distinct <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, so that we get a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * result averaged over all possible <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> whether common or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * uncommon.&nbsp; (Essentially, we are assuming that the not-yet-known<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * comparison value is equally likely to be <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the possible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, regardless of their frequency in the table.&nbsp; Is that a good<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * idea?)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; selec = <span class="Constant">1.0</span> - nullfrac;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ndistinct = <a href="#L5764" title="utils/adt/selfuncs.c:5764">get_variable_numdistinct</a>(vardata, &amp;isdefault);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ndistinct &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec /= ndistinct;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Cross-check: selectivity should never be estimated as more than the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * most common value's.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../cache/lsyscache.c.html#L3234" title="utils/cache/lsyscache.c:3234">get_attstatsslot</a>(&amp;sslot, vardata-&gt;statsTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; STATISTIC_KIND_MCV, InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ATTSTATSSLOT_NUMBERS))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sslot.nnumbers &gt; <span class="Constant">0</span> &amp;&amp; selec &gt; sslot.numbers[<span class="Constant">0</span>])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = sslot.numbers[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L3344" title="utils/cache/lsyscache.c:3344">free_attstatsslot</a>(&amp;sslot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No ANALYZE stats available, so make a guess using estimated number<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of distinct <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> and assuming they are equally common. (The guess<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is unlikely to be very good, but we do know a few special cases.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; selec = <span class="Constant">1.0</span> / <a href="#L5764" title="utils/adt/selfuncs.c:5764">get_variable_numdistinct</a>(vardata, &amp;isdefault);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> adjust if we wanted &lt;&gt; rather than = */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (negate)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; selec = <span class="Constant">1.0</span> - selec - nullfrac;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* result should be in <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, but make sure... */<br/></li>
<li></span>&nbsp; &nbsp; CLAMP_PROBABILITY(selec);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> selec;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L557" title="utils/adt/selfuncs.c:557">neqsel</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - Selectivity of &quot;!=&quot; for <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> data types.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This routine is also used for some operators that are not &quot;!=&quot;<br/></li>
<li></span><span class="Comment"> * but have comparable selectivity behavior.&nbsp; See above comments<br/></li>
<li></span><span class="Comment"> * for <a href="#L227" title="utils/adt/selfuncs.c:227">eqsel</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L557">&#x200c;</a><span class="linkable">neqsel</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8((float8) <a href="#L236" title="utils/adt/selfuncs.c:236">eqsel_internal</a>(fcinfo, <span class="Constant">true</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L580" title="utils/adt/selfuncs.c:580">scalarineqsel</a>&nbsp; &nbsp; &nbsp; &nbsp; - Selectivity of &quot;&lt;&quot;, &quot;&lt;=&quot;, &quot;&gt;&quot;, &quot;&gt;=&quot; for scalars.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is the guts of <a href="#L1471" title="utils/adt/selfuncs.c:1471">scalarltsel</a>/<a href="#L1480" title="utils/adt/selfuncs.c:1480">scalarlesel</a>/<a href="#L1489" title="utils/adt/selfuncs.c:1489">scalargtsel</a>/<a href="#L1498" title="utils/adt/selfuncs.c:1498">scalargesel</a>.<br/></li>
<li></span><span class="Comment"> * The isgt and iseq flags distinguish which of the four cases apply.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller has commuted the clause, if necessary, so that we can treat<br/></li>
<li></span><span class="Comment"> * the variable as being on the left.&nbsp; The caller must also make sure that<br/></li>
<li></span><span class="Comment"> * the other side of the clause is a non-null Const, and dissect that into<br/></li>
<li></span><span class="Comment"> * a value and datatype.&nbsp; (This definition simplifies some callers that<br/></li>
<li></span><span class="Comment"> * want to estimate against a computed value instead of a Const node.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This routine works for <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> datatype (or pair of datatypes) known to<br/></li>
<li></span><span class="Comment"> * <a href="#L4305" title="utils/adt/selfuncs.c:4305">convert_to_scalar</a>().&nbsp; If it is applied to some other datatype,<br/></li>
<li></span><span class="Comment"> * it will return an approximate estimate based on assuming that the constant<br/></li>
<li></span><span class="Comment"> * value falls in the middle of the bin identified by binary search.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">double<br/></li>
<li><a id="L580">&#x200c;</a></span><span class="linkable">scalarineqsel</span>(PlannerInfo *root, Oid operator, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isgt, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> iseq,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VariableStatData *vardata, Datum constval, Oid consttype)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Form_pg_statistic stats;<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; opproc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; mcv_selec,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hist_selec,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sumcommon;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; selec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(vardata-&gt;statsTuple))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No stats are available.&nbsp; Typically this means we have to fall back<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * on the default estimate; but if the variable is CTID then we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * make an estimate based on comparing the constant to the table size.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (vardata-&gt;var &amp;&amp; IsA(vardata-&gt;var, Var) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((Var *) vardata-&gt;var)-&gt;varattno == SelfItemPointerAttributeNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointer itemptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; block;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; density;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the relation's empty, we're going to include all of it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (This is mostly to avoid divide-by-zero below.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (vardata-&gt;rel-&gt;pages == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemptr = (ItemPointer) DatumGetPointer(constval);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; block = ItemPointerGetBlockNumberNoCheck(itemptr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Determine the average number of tuples per page (density).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since the last page will, on average, be only half full, we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * estimate it to have half as many tuples as earlier pages.&nbsp; So<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * give it half the weight of a regular page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; density = vardata-&gt;rel-&gt;tuples / (vardata-&gt;rel-&gt;pages - <span class="Constant">0.5</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If target is the last page, use half the density. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (block &gt;= vardata-&gt;rel-&gt;pages - <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; density *= <span class="Constant">0.5</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Using the average tuples per page, calculate how far into the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page the itemptr is likely to be and adjust block accordingly,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * by adding that fraction of a whole block (but never more than a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * whole block, no matter how high the itemptr's offset is).&nbsp; Here<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we are ignoring the possibility of dead-tuple line pointers,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * which is fairly bogus, but we lack the info to do better.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (density &gt; <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber offset = ItemPointerGetOffsetNumberNoCheck(itemptr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; block += <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(offset / density, <span class="Constant">1.0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Convert relative block number to selectivity.&nbsp; Again, the last<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page has only half weight.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = block / (vardata-&gt;rel-&gt;pages - <span class="Constant">0.5</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The calculation so far gave us a selectivity for the &quot;&lt;=&quot; case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We'll have one fewer tuple for &quot;&lt;&quot; and one additional tuple for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * &quot;&gt;=&quot;, the latter of which we'll reverse the selectivity for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * below, so we can simply subtract one tuple for both cases.&nbsp; The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cases that need this adjustment can be identified by iseq being<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to isgt.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (iseq == isgt &amp;&amp; vardata-&gt;rel-&gt;tuples &gt;= <span class="Constant">1.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec -= (<span class="Constant">1.0</span> / vardata-&gt;rel-&gt;tuples);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Finally, reverse the selectivity for the &quot;&gt;&quot;, &quot;&gt;=&quot; cases. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isgt)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = <span class="Constant">1.0</span> - selec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CLAMP_PROBABILITY(selec);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> selec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no stats available, so default result */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DEFAULT_INEQ_SEL;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; stats = (Form_pg_statistic) GETSTRUCT(vardata-&gt;statsTuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../fmgr/fmgr.c.html#L127" title="utils/fmgr/fmgr.c:127">fmgr_info</a>(<a href="../cache/lsyscache.c.html#L1285" title="utils/cache/lsyscache.c:1285">get_opcode</a>(operator), &amp;opproc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we have most-common-<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> info, add up the fractions of the MCV<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * entries that satisfy MCV OP CONST.&nbsp; These fractions contribute directly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to the result selectivity.&nbsp; Also add up the total fraction represented<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * by MCV entries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; mcv_selec = <a href="#L732" title="utils/adt/selfuncs.c:732">mcv_selectivity</a>(vardata, &amp;opproc, collation, constval, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;sumcommon);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there is a histogram, determine which bin the constant falls in, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * compute the resulting contribution to selectivity.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; hist_selec = <a href="#L1041" title="utils/adt/selfuncs.c:1041">ineq_histogram_selectivity</a>(root, vardata,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; operator, &amp;opproc, isgt, iseq,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constval, consttype);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> the results from the MCV and histogram calculations,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * realizing that the histogram covers only the non-null <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> that are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not listed in MCV.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; selec = <span class="Constant">1.0</span> - stats-&gt;stanullfrac - sumcommon;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (hist_selec &gt;= <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; selec *= hist_selec;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If no histogram but there are <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> not accounted for by MCV,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * arbitrarily assume half of them will match.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; selec *= <span class="Constant">0.5</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; selec += mcv_selec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* result should be in <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, but make sure... */<br/></li>
<li></span>&nbsp; &nbsp; CLAMP_PROBABILITY(selec);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> selec;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L732" title="utils/adt/selfuncs.c:732">mcv_selectivity</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - Examine the MCV list for selectivity estimates<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Determine the fraction of the variable's MCV population that satisfies<br/></li>
<li></span><span class="Comment"> * the predicate (VAR OP CONST), or (CONST OP VAR) if !varonleft.&nbsp; Also<br/></li>
<li></span><span class="Comment"> * compute the fraction of the total column population represented by the MCV<br/></li>
<li></span><span class="Comment"> * list.&nbsp; This code will work for <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> boolean-returning predicate operator.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The function result is the MCV selectivity, and the fraction of the<br/></li>
<li></span><span class="Comment"> * total population is returned into *sumcommonp.&nbsp; Zeroes are returned<br/></li>
<li></span><span class="Comment"> * if there is no MCV list.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">double<br/></li>
<li><a id="L732">&#x200c;</a></span><span class="linkable">mcv_selectivity</span>(VariableStatData *vardata, FmgrInfo *opproc, Oid collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum constval, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> varonleft,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span> *sumcommonp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; mcv_selec,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sumcommon;<br/></li>
<li>&nbsp; &nbsp; AttStatsSlot sslot;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; mcv_selec = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; sumcommon = <span class="Constant">0.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(vardata-&gt;statsTuple) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5735" title="utils/adt/selfuncs.c:5735">statistic_proc_security_check</a>(vardata, opproc-&gt;fn_oid) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L3234" title="utils/cache/lsyscache.c:3234">get_attstatsslot</a>(&amp;sslot, vardata-&gt;statsTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; STATISTIC_KIND_MCV, InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LOCAL_FCINFO(fcinfo, <span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We invoke the opproc &quot;by hand&quot; so that we won't fail on NULL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * results.&nbsp; Such cases won't arise for normal comparison <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but <a href="#L914" title="utils/adt/selfuncs.c:914">generic_restriction_selectivity</a> could perhaps be used with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * operators that can return NULL.&nbsp; A small side benefit is to not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * need to re-<a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the fcinfo struct from scratch each time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; InitFunctionCallInfoData(*fcinfo, opproc, <span class="Constant">2</span>, collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* be careful to apply operator right way 'round */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (varonleft)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].value = constval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].value = constval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; sslot.nvalues; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; fresult;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (varonleft)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].value = sslot.<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].value = sslot.<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fresult = FunctionCallInvoke(fcinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!fcinfo-&gt;isnull &amp;&amp; DatumGetBool(fresult))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mcv_selec += sslot.numbers[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sumcommon += sslot.numbers[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L3344" title="utils/cache/lsyscache.c:3344">free_attstatsslot</a>(&amp;sslot);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *sumcommonp = sumcommon;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> mcv_selec;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L823" title="utils/adt/selfuncs.c:823">histogram_selectivity</a>&nbsp; &nbsp; - Examine the histogram for selectivity estimates<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Determine the fraction of the variable's histogram entries that satisfy<br/></li>
<li></span><span class="Comment"> * the predicate (VAR OP CONST), or (CONST OP VAR) if !varonleft.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This code will work for <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> boolean-returning predicate operator, whether<br/></li>
<li></span><span class="Comment"> * or not it has anything to do with the histogram sort operator.&nbsp; We are<br/></li>
<li></span><span class="Comment"> * essentially using the histogram just as a representative sample.&nbsp; However,<br/></li>
<li></span><span class="Comment"> * small histograms are unlikely to be all that representative, so the caller<br/></li>
<li></span><span class="Comment"> * should be prepared to fall back on some other estimation approach when the<br/></li>
<li></span><span class="Comment"> * histogram is missing or very small.&nbsp; It may also be prudent to <a href="../../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> this<br/></li>
<li></span><span class="Comment"> * approach with another one when the histogram is small.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the actual histogram size is not at least min_hist_size, we won't bother<br/></li>
<li></span><span class="Comment"> * to do the calculation at all.&nbsp; Also, if the n_skip parameter is &gt; 0, we<br/></li>
<li></span><span class="Comment"> * ignore the first and last n_skip histogram elements, on the grounds that<br/></li>
<li></span><span class="Comment"> * they are outliers and hence not very representative.&nbsp; Typical <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for<br/></li>
<li></span><span class="Comment"> * these parameters are 10 and 1.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The function result is the selectivity, or -1 if there is no histogram<br/></li>
<li></span><span class="Comment"> * or it's smaller than min_hist_size.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The output parameter *hist_size receives the actual histogram size,<br/></li>
<li></span><span class="Comment"> * or zero if no histogram.&nbsp; Callers may use this number to decide how<br/></li>
<li></span><span class="Comment"> * much faith to put in the function result.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that the result disregards both the most-common-<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> (if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>) and<br/></li>
<li></span><span class="Comment"> * null entries.&nbsp; The caller is expected to <a href="../../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> this result with<br/></li>
<li></span><span class="Comment"> * statistics for those portions of the column population.&nbsp; It may also be<br/></li>
<li></span><span class="Comment"> * prudent to clamp the result <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, ie, disbelieve exact 0 or 1 outputs.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">double<br/></li>
<li><a id="L823">&#x200c;</a></span><span class="linkable">histogram_selectivity</span>(VariableStatData *vardata,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FmgrInfo *opproc, Oid collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum constval, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> varonleft,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> min_hist_size, <span class="Type">int</span> n_skip,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> *hist_size)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; AttStatsSlot sslot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check sanity of parameters */<br/></li>
<li></span>&nbsp; &nbsp; Assert(n_skip &gt;= <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(min_hist_size &gt; <span class="Constant">2</span> * n_skip);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(vardata-&gt;statsTuple) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5735" title="utils/adt/selfuncs.c:5735">statistic_proc_security_check</a>(vardata, opproc-&gt;fn_oid) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L3234" title="utils/cache/lsyscache.c:3234">get_attstatsslot</a>(&amp;sslot, vardata-&gt;statsTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; STATISTIC_KIND_HISTOGRAM, InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ATTSTATSSLOT_VALUES))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *hist_size = sslot.nvalues;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sslot.nvalues &gt;= min_hist_size)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LOCAL_FCINFO(fcinfo, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nmatch = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We invoke the opproc &quot;by hand&quot; so that we won't fail on NULL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * results.&nbsp; Such cases won't arise for normal comparison<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, but <a href="#L914" title="utils/adt/selfuncs.c:914">generic_restriction_selectivity</a> could perhaps be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * used with operators that can return NULL.&nbsp; A small side benefit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is to not need to re-<a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the fcinfo struct from scratch<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * each time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InitFunctionCallInfoData(*fcinfo, opproc, <span class="Constant">2</span>, collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* be careful to apply operator right way 'round */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (varonleft)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].value = constval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].value = constval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = n_skip; i &lt; sslot.nvalues - n_skip; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; fresult;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (varonleft)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].value = sslot.<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].value = sslot.<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fresult = FunctionCallInvoke(fcinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!fcinfo-&gt;isnull &amp;&amp; DatumGetBool(fresult))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nmatch++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = ((<span class="Type">double</span>) nmatch) / ((<span class="Type">double</span>) (sslot.nvalues - <span class="Constant">2</span> * n_skip));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L3344" title="utils/cache/lsyscache.c:3344">free_attstatsslot</a>(&amp;sslot);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *hist_size = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L914" title="utils/adt/selfuncs.c:914">generic_restriction_selectivity</a>&nbsp; &nbsp; &nbsp; &nbsp; - Selectivity for almost anything<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function estimates selectivity for operators that we don't have <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * special knowledge about, but are on data types that we collect standard<br/></li>
<li></span><span class="Comment"> * MCV and/or histogram statistics for.&nbsp; (Additional assumptions are that<br/></li>
<li></span><span class="Comment"> * the operator is strict and immutable, or at least stable.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If we have &quot;VAR OP CONST&quot; or &quot;CONST OP VAR&quot;, selectivity is estimated by<br/></li>
<li></span><span class="Comment"> * applying the operator to each <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> of the column's MCV and/or histogram<br/></li>
<li></span><span class="Comment"> * stats, and merging the results using the assumption that the histogram is<br/></li>
<li></span><span class="Comment"> * a reasonable random sample of the column's non-MCV population.&nbsp; Note that<br/></li>
<li></span><span class="Comment"> * if the operator's semantics are related to the histogram ordering, this<br/></li>
<li></span><span class="Comment"> * might not be such a great assumption; other <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> such as<br/></li>
<li></span><span class="Comment"> * <a href="#L580" title="utils/adt/selfuncs.c:580">scalarineqsel</a>() are probably a better match in such cases.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Otherwise, fall back to the default selectivity provided by the caller.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">double<br/></li>
<li><a id="L914">&#x200c;</a></span><span class="linkable">generic_restriction_selectivity</span>(PlannerInfo *root, Oid oproid, Oid collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *args, <span class="Type">int</span> varRelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span> default_selectivity)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; selec;<br/></li>
<li>&nbsp; &nbsp; VariableStatData vardata;<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *other;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; varonleft;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If expression is not variable OP something or something OP variable,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * then punt and return the default estimate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L4883" title="utils/adt/selfuncs.c:4883">get_restriction_variable</a>(root, args, varRelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;vardata, &amp;other, &amp;varonleft))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> default_selectivity;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the something is a NULL constant, assume operator is strict and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * return zero, ie, operator will never return TRUE.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(other, Const) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ((Const *) other)-&gt;constisnull)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ReleaseVariableStats(vardata);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(other, Const))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Variable is being compared to a known non-null constant */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; constval = ((Const *) other)-&gt;constvalue;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; opproc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; mcvsum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; mcvsel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; nullfrac;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hist_size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../fmgr/fmgr.c.html#L127" title="utils/fmgr/fmgr.c:127">fmgr_info</a>(<a href="../cache/lsyscache.c.html#L1285" title="utils/cache/lsyscache.c:1285">get_opcode</a>(oproid), &amp;opproc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Calculate the selectivity for the column's most common <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; mcvsel = <a href="#L732" title="utils/adt/selfuncs.c:732">mcv_selectivity</a>(&amp;vardata, &amp;opproc, collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; constval, varonleft,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;mcvsum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the histogram is large enough, see what fraction of it matches<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the query, and assume that's representative of the non-MCV<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * population.&nbsp; Otherwise use the default selectivity for the non-MCV<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * population.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; selec = <a href="#L823" title="utils/adt/selfuncs.c:823">histogram_selectivity</a>(&amp;vardata, &amp;opproc, collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constval, varonleft,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">10</span>, <span class="Constant">1</span>, &amp;hist_size);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (selec &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Nope, fall back on default */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = default_selectivity;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (hist_size &lt; <span class="Constant">100</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For histogram sizes from 10 to 100, we <a href="../../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> the histogram<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and default selectivities, putting increasingly more trust in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the histogram for larger sizes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; hist_weight = hist_size / <span class="Constant">100.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = selec * hist_weight +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; default_selectivity * (<span class="Constant">1.0</span> - hist_weight);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* In <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case, don't believe extremely small or large estimates. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (selec &lt; <span class="Constant">0.0001</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = <span class="Constant">0.0001</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (selec &gt; <span class="Constant">0.9999</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = <span class="Constant">0.9999</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Don't forget to account for nulls. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(vardata.statsTuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nullfrac = ((Form_pg_statistic) GETSTRUCT(vardata.statsTuple))-&gt;stanullfrac;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nullfrac = <span class="Constant">0.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> the results from the MCV and histogram calculations,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * realizing that the histogram covers only the non-null <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * are not listed in MCV.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; selec *= <span class="Constant">1.0</span> - nullfrac - mcvsum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; selec += mcvsel;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Comparison value is not constant, so we can't do anything */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; selec = default_selectivity;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ReleaseVariableStats(vardata);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* result should be in <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, but make sure... */<br/></li>
<li></span>&nbsp; &nbsp; CLAMP_PROBABILITY(selec);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> selec;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L1041" title="utils/adt/selfuncs.c:1041">ineq_histogram_selectivity</a>&nbsp; &nbsp; - Examine the histogram for <a href="#L580" title="utils/adt/selfuncs.c:580">scalarineqsel</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Determine the fraction of the variable's histogram population that<br/></li>
<li></span><span class="Comment"> * satisfies the inequality condition, ie, VAR &lt; (or &lt;=, &gt;, &gt;=) CONST.<br/></li>
<li></span><span class="Comment"> * The isgt and iseq flags distinguish which of the four cases apply.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * While opproc could be looked up from the operator OID, common callers<br/></li>
<li></span><span class="Comment"> * also need to call it separately, so we make the caller pass both.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns -1 if there is no histogram (valid results will always be &gt;= 0).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that the result disregards both the most-common-<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> (if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>) and<br/></li>
<li></span><span class="Comment"> * null entries.&nbsp; The caller is expected to <a href="../../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> this result with<br/></li>
<li></span><span class="Comment"> * statistics for those portions of the column population.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is exported so that some other estimation <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> can use it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">double<br/></li>
<li><a id="L1041">&#x200c;</a></span><span class="linkable">ineq_histogram_selectivity</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VariableStatData *vardata,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid opoid, FmgrInfo *opproc, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isgt, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> iseq,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum constval, Oid consttype)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; hist_selec;<br/></li>
<li>&nbsp; &nbsp; AttStatsSlot sslot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; hist_selec = -<span class="Constant">1.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Someday, ANALYZE might store more than one histogram per rel/att,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * corresponding to more than one possible sort ordering defined for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * column type.&nbsp; Right <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, we know there is only one, so just grab it and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * see if it matches the query.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that we can't use opoid as search argument; the staop appearing in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pg_statistic will be for the relevant '&lt;' operator, but what we have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might be some other inequality operator such as '&gt;='.&nbsp; (Even if opoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is a '&lt;' operator, it could be cross-type.)&nbsp; Hence we must use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../cache/lsyscache.c.html#L749" title="utils/cache/lsyscache.c:749">comparison_ops_are_compatible</a>() to see if the operators match.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(vardata-&gt;statsTuple) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5735" title="utils/adt/selfuncs.c:5735">statistic_proc_security_check</a>(vardata, opproc-&gt;fn_oid) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L3234" title="utils/cache/lsyscache.c:3234">get_attstatsslot</a>(&amp;sslot, vardata-&gt;statsTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; STATISTIC_KIND_HISTOGRAM, InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ATTSTATSSLOT_VALUES))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sslot.nvalues &gt; <span class="Constant">1</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sslot.stacoll == collation &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L749" title="utils/cache/lsyscache.c:749">comparison_ops_are_compatible</a>(sslot.staop, opoid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Use binary search to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the desired location, namely the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * right end of the histogram bin containing the comparison value,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * which is the leftmost entry for which the comparison operator<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * succeeds (if isgt) or fails (if !isgt).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In this loop, we pay no attention to whether the operator iseq<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * or not; that detail will be mopped up below.&nbsp; (We cannot tell,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * anyway, whether the operator thinks the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the binary search accesses the first or last histogram<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entry, we try to replace that endpoint with the true column min<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * or max as found by <a href="#L6087" title="utils/adt/selfuncs.c:6087">get_actual_variable_range</a>().&nbsp; This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ameliorates misestimates when the min or max is moving as a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * result of changes since the last ANALYZE.&nbsp; Note that this could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * result in effectively including MCVs into the histogram that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * weren't there <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>, but we don't try to correct for that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; histfrac;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lobound = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* first possible slot to search */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hibound = sslot.nvalues;&nbsp; &nbsp; <span class="Comment">/* last+1 slot to search */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; have_end = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If there are only two histogram entries, we'll want up-to-date<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for both.&nbsp; (If there are more than two, we need at most<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * one of them to be updated, so we deal with that within the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * loop.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sslot.nvalues == <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; have_end = <a href="#L6087" title="utils/adt/selfuncs.c:6087">get_actual_variable_range</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; vardata,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sslot.staop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;sslot.<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;sslot.<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">1</span>]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (lobound &lt; hibound)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; probe = (lobound + hibound) / <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; ltcmp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> ourselves about to <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> to the first or last<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * histogram entry, first try to replace it with the actual<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * current min or max (unless we already did so above).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (probe == <span class="Constant">0</span> &amp;&amp; sslot.nvalues &gt; <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; have_end = <a href="#L6087" title="utils/adt/selfuncs.c:6087">get_actual_variable_range</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; vardata,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sslot.staop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;sslot.<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (probe == sslot.nvalues - <span class="Constant">1</span> &amp;&amp; sslot.nvalues &gt; <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; have_end = <a href="#L6087" title="utils/adt/selfuncs.c:6087">get_actual_variable_range</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; vardata,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sslot.staop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;sslot.<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[probe]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ltcmp = DatumGetBool(<a href="../fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(opproc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sslot.<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[probe],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; constval));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isgt)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ltcmp = !ltcmp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ltcmp)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lobound = probe + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hibound = probe;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lobound &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Constant is below <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> histogram boundary.&nbsp; More<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * precisely, we have found that no entry in the histogram<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * satisfies the inequality clause (if !isgt) or they all do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (if isgt).&nbsp; We estimate that that's true of the entire<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * table, so set histfrac to 0.0 (which we'll flip to 1.0<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * below, if isgt).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; histfrac = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (lobound &gt;= sslot.nvalues)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Inverse case: constant is above <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> histogram boundary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; histfrac = <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We have <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i-1] &lt;= constant &lt;= <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i]. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = lobound;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; eq_selec = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; val,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; high,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; binfrac;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In the cases where we'll need it below, obtain an estimate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of the selectivity of &quot;x = constval&quot;.&nbsp; We use a calculation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * similar to what <a href="#L295" title="utils/adt/selfuncs.c:295">var_eq_const</a>() does for a non-MCV constant,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ie, estimate that all distinct non-MCV <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> occur equally<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * often.&nbsp; But multiplication by &quot;1.0 - sumcommon - nullfrac&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will be done by our caller, so we shouldn't do that here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Therefore we can't try to clamp the estimate by reference<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to the least common MCV; the result would be too small.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: since this is effectively assuming that constval<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * isn't an MCV, it's logically dubious if constval in fact is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * one.&nbsp; But we have to apply *some* correction for equality,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and anyway we cannot tell if constval is an MCV, since we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't have a suitable equality operator at hand.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i == <span class="Constant">1</span> || isgt == iseq)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; otherdistinct;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isdefault;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AttStatsSlot mcvslot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get estimated number of distinct <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; otherdistinct = <a href="#L5764" title="utils/adt/selfuncs.c:5764">get_variable_numdistinct</a>(vardata,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;isdefault);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Subtract off the number of known MCVs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../cache/lsyscache.c.html#L3234" title="utils/cache/lsyscache.c:3234">get_attstatsslot</a>(&amp;mcvslot, vardata-&gt;statsTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; STATISTIC_KIND_MCV, InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ATTSTATSSLOT_NUMBERS))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; otherdistinct -= mcvslot.nnumbers;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L3344" title="utils/cache/lsyscache.c:3344">free_attstatsslot</a>(&amp;mcvslot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If result doesn't seem sane, leave eq_selec at 0 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (otherdistinct &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eq_selec = <span class="Constant">1.0</span> / otherdistinct;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Convert the constant and the two nearest bin boundary<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to a uniform comparison scale, and do a linear<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * interpolation within this bin.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L4305" title="utils/adt/selfuncs.c:4305">convert_to_scalar</a>(constval, consttype, collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;val,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sslot.<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i - <span class="Constant">1</span>], sslot.<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vardata-&gt;vartype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;low, &amp;high))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (high &lt;= low)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* cope if bin boundaries appear identical */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; binfrac = <span class="Constant">0.5</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (val &lt;= low)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; binfrac = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (val &gt;= high)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; binfrac = <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; binfrac = (val - low) / (high - low);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Watch out for the possibility that we got a NaN or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Infinity from the division.&nbsp; This can happen<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * despite the previous checks, if for example &quot;low&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is -Infinity.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnan(binfrac) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; binfrac &lt; <span class="Constant">0.0</span> || binfrac &gt; <span class="Constant">1.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; binfrac = <span class="Constant">0.5</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ideally we'd produce an error here, on the grounds that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the given operator shouldn't have scalarXXsel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * registered as its selectivity func unless we can deal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with its operand types.&nbsp; But currently, all manner of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * stuff is invoking scalarXXsel, so give a default<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * estimate until that can be fixed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; binfrac = <span class="Constant">0.5</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now, compute the overall selectivity across the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * represented by the histogram.&nbsp; We have i-1 full bins and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * binfrac partial bin below the constant.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; histfrac = (<span class="Type">double</span>) (i - <span class="Constant">1</span>) + binfrac;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; histfrac /= (<span class="Type">double</span>) (sslot.nvalues - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * At this point, histfrac is an estimate of the fraction of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the population represented by the histogram that satisfies<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * &quot;x &lt;= constval&quot;.&nbsp; Somewhat remarkably, this statement is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * true regardless of which operator we were doing the probes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with, so long as <a href="#L4305" title="utils/adt/selfuncs.c:4305">convert_to_scalar</a>() delivers reasonable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * results.&nbsp; If the probe constant is <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to some histogram<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entry, we would have considered the bin to the left of that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entry if probing with &quot;&lt;&quot; or &quot;&gt;=&quot;, or the bin to the right<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if probing with &quot;&lt;=&quot; or &quot;&gt;&quot;; but binfrac would have come<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * out as 1.0 in the first case and 0.0 in the second, leading<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to the same histfrac in either case.&nbsp; For probe constants<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * between histogram entries, we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the same bin and get the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * same estimate with <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> operator.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The fact that the estimate corresponds to &quot;x &lt;= constval&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and not &quot;x &lt; constval&quot; is because of the way that ANALYZE<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * constructs the histogram: each entry is, effectively, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rightmost value in its sample bucket.&nbsp; So selectivity<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> that are exact multiples of 1/(histogram_size-1)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * should be understood as estimates including a histogram<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entry plus everything to its left.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * However, that breaks down for the first histogram entry,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * which necessarily is the leftmost value in its sample<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * bucket.&nbsp; That means the first histogram bin is slightly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * narrower than the rest, by an amount <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to eq_selec.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Another way to say that is that we want &quot;x &lt;= leftmost&quot; to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be estimated as eq_selec not zero.&nbsp; So, if we're dealing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with the first bin (i==1), rescale to make that true while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * adjusting the rest of that bin linearly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; histfrac += eq_selec * (<span class="Constant">1.0</span> - binfrac);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * &quot;x &lt;= constval&quot; is good if we want an estimate for &quot;&lt;=&quot; or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * &quot;&gt;&quot;, but if we are estimating for &quot;&lt;&quot; or &quot;&gt;=&quot;, we <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to decrease the estimate by eq_selec.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isgt == iseq)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; histfrac -= eq_selec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now the estimate is finished for &quot;&lt;&quot; and &quot;&lt;=&quot; cases.&nbsp; If we are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * estimating for &quot;&gt;&quot; or &quot;&gt;=&quot;, flip it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hist_selec = isgt ? (<span class="Constant">1.0</span> - histfrac) : histfrac;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The histogram boundaries are only approximate to begin with,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and may well be out of date anyway.&nbsp; Therefore, don't believe<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * extremely small or large selectivity estimates --- unless we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * got actual current endpoint <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> from the table, in which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * case just do the usual sanity clamp.&nbsp; Somewhat arbitrarily, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * set the cutoff for other cases at a hundredth of the histogram<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * resolution.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (have_end)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CLAMP_PROBABILITY(hist_selec);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; cutoff = <span class="Constant">0.01</span> / (<span class="Type">double</span>) (sslot.nvalues - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hist_selec &lt; cutoff)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hist_selec = cutoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (hist_selec &gt; <span class="Constant">1.0</span> - cutoff)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hist_selec = <span class="Constant">1.0</span> - cutoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (sslot.nvalues &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we get here, we have a histogram but it's not sorted the way<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we want.&nbsp; Do a brute-force search to see how many of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entries satisfy the comparison condition, and take that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fraction as our estimate.&nbsp; (This is identical to the inner loop<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of <a href="#L823" title="utils/adt/selfuncs.c:823">histogram_selectivity</a>; maybe share code?)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LOCAL_FCINFO(fcinfo, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nmatch = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InitFunctionCallInfoData(*fcinfo, opproc, <span class="Constant">2</span>, collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].value = constval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; sslot.nvalues; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; fresult;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].value = sslot.<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fresult = FunctionCallInvoke(fcinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!fcinfo-&gt;isnull &amp;&amp; DatumGetBool(fresult))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nmatch++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hist_selec = ((<span class="Type">double</span>) nmatch) / ((<span class="Type">double</span>) sslot.nvalues);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * As above, clamp to a hundredth of the histogram resolution.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This case is surely even less trustworthy than the normal one,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so we shouldn't believe exact 0 or 1 selectivity.&nbsp; (Maybe the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * clamp should be more restrictive in this case?)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; cutoff = <span class="Constant">0.01</span> / (<span class="Type">double</span>) (sslot.nvalues - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hist_selec &lt; cutoff)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hist_selec = cutoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (hist_selec &gt; <span class="Constant">1.0</span> - cutoff)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hist_selec = <span class="Constant">1.0</span> - cutoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L3344" title="utils/cache/lsyscache.c:3344">free_attstatsslot</a>(&amp;sslot);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> hist_selec;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Common wrapper function for the selectivity estimators that simply<br/></li>
<li></span><span class="Comment"> * invoke <a href="#L580" title="utils/adt/selfuncs.c:580">scalarineqsel</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Datum<br/></li>
<li><a id="L1400">&#x200c;</a><span class="linkable">scalarineqsel_wrapper</span>(PG_FUNCTION_ARGS, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isgt, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> iseq)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; operator = PG_GETARG_OID(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *args = (List *) PG_GETARG_POINTER(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; varRelid = PG_GETARG_INT32(<span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collation = PG_GET_COLLATION();<br/></li>
<li>&nbsp; &nbsp; VariableStatData vardata;<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *other;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; varonleft;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; constval;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; consttype;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; selec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If expression is not variable op something or something op variable,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * then punt and return a default estimate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L4883" title="utils/adt/selfuncs.c:4883">get_restriction_variable</a>(root, args, varRelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;vardata, &amp;other, &amp;varonleft))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(DEFAULT_INEQ_SEL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Can't do anything useful if the something is not a constant, either.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!IsA(other, Const))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ReleaseVariableStats(vardata);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(DEFAULT_INEQ_SEL);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the constant is NULL, assume operator is strict and return zero, ie,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operator will never return TRUE.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (((Const *) other)-&gt;constisnull)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ReleaseVariableStats(vardata);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(<span class="Constant">0.0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; constval = ((Const *) other)-&gt;constvalue;<br/></li>
<li>&nbsp; &nbsp; consttype = ((Const *) other)-&gt;consttype;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Force the var to be on the left to simplify logic in <a href="#L580" title="utils/adt/selfuncs.c:580">scalarineqsel</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!varonleft)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; operator = <a href="../cache/lsyscache.c.html#L1509" title="utils/cache/lsyscache.c:1509">get_commutator</a>(operator);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!operator)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Use default selectivity (should we raise an error instead?) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReleaseVariableStats(vardata);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(DEFAULT_INEQ_SEL);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; isgt = !isgt;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The rest of the work is done by <a href="#L580" title="utils/adt/selfuncs.c:580">scalarineqsel</a>(). */<br/></li>
<li></span>&nbsp; &nbsp; selec = <a href="#L580" title="utils/adt/selfuncs.c:580">scalarineqsel</a>(root, operator, isgt, iseq, collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;vardata, constval, consttype);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ReleaseVariableStats(vardata);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8((float8) selec);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1471" title="utils/adt/selfuncs.c:1471">scalarltsel</a>&nbsp; &nbsp; &nbsp; &nbsp; - Selectivity of &quot;&lt;&quot; for scalars.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1471">&#x200c;</a><span class="linkable">scalarltsel</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1400" title="utils/adt/selfuncs.c:1400">scalarineqsel_wrapper</a>(fcinfo, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1480" title="utils/adt/selfuncs.c:1480">scalarlesel</a>&nbsp; &nbsp; &nbsp; &nbsp; - Selectivity of &quot;&lt;=&quot; for scalars.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1480">&#x200c;</a><span class="linkable">scalarlesel</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1400" title="utils/adt/selfuncs.c:1400">scalarineqsel_wrapper</a>(fcinfo, <span class="Constant">false</span>, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1489" title="utils/adt/selfuncs.c:1489">scalargtsel</a>&nbsp; &nbsp; &nbsp; &nbsp; - Selectivity of &quot;&gt;&quot; for scalars.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1489">&#x200c;</a><span class="linkable">scalargtsel</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1400" title="utils/adt/selfuncs.c:1400">scalarineqsel_wrapper</a>(fcinfo, <span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1498" title="utils/adt/selfuncs.c:1498">scalargesel</a>&nbsp; &nbsp; &nbsp; &nbsp; - Selectivity of &quot;&gt;=&quot; for scalars.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1498">&#x200c;</a><span class="linkable">scalargesel</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1400" title="utils/adt/selfuncs.c:1400">scalarineqsel_wrapper</a>(fcinfo, <span class="Constant">true</span>, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1512" title="utils/adt/selfuncs.c:1512">boolvarsel</a>&nbsp; &nbsp; &nbsp; &nbsp; - Selectivity of Boolean variable.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This can actually be called on <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> boolean-valued expression.&nbsp; If it<br/></li>
<li></span><span class="Comment"> * involves only Vars of the specified relation, and if there are statistics<br/></li>
<li></span><span class="Comment"> * about the Var or expression (the latter is possible if it's indexed) then<br/></li>
<li></span><span class="Comment"> * we'll produce a real estimate; otherwise it's just a default.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Selectivity<br/></li>
<li><a id="L1512">&#x200c;</a><span class="linkable">boolvarsel</span>(PlannerInfo *root, Node *arg, <span class="Type">int</span> varRelid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; VariableStatData vardata;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; selec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L5012" title="utils/adt/selfuncs.c:5012">examine_variable</a>(root, arg, varRelid, &amp;vardata);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(vardata.statsTuple))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * A boolean variable V is equivalent to the clause V = 't', so we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * compute the selectivity as if that is what we have.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; selec = <a href="#L295" title="utils/adt/selfuncs.c:295">var_eq_const</a>(&amp;vardata, BooleanEqualOperator, InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BoolGetDatum(<span class="Constant">true</span>), <span class="Constant">false</span>, <span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Otherwise, the default estimate is 0.5 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; selec = <span class="Constant">0.5</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; ReleaseVariableStats(vardata);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> selec;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1540" title="utils/adt/selfuncs.c:1540">booltestsel</a>&nbsp; &nbsp; &nbsp; &nbsp; - Selectivity of BooleanTest Node.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Selectivity<br/></li>
<li><a id="L1540">&#x200c;</a><span class="linkable">booltestsel</span>(PlannerInfo *root, BoolTestType booltesttype, Node *arg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> varRelid, JoinType jointype, SpecialJoinInfo *sjinfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; VariableStatData vardata;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; selec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L5012" title="utils/adt/selfuncs.c:5012">examine_variable</a>(root, arg, varRelid, &amp;vardata);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(vardata.statsTuple))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_statistic stats;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; freq_null;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AttStatsSlot sslot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stats = (Form_pg_statistic) GETSTRUCT(vardata.statsTuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; freq_null = stats-&gt;stanullfrac;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../cache/lsyscache.c.html#L3234" title="utils/cache/lsyscache.c:3234">get_attstatsslot</a>(&amp;sslot, vardata.statsTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; STATISTIC_KIND_MCV, InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; sslot.nnumbers &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; freq_true;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; freq_false;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Get first MCV frequency and derive frequency for true.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (DatumGetBool(sslot.<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">0</span>]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; freq_true = sslot.numbers[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; freq_true = <span class="Constant">1.0</span> - sslot.numbers[<span class="Constant">0</span>] - freq_null;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Next derive frequency for false. Then use these as appropriate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to derive frequency for each case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; freq_false = <span class="Constant">1.0</span> - freq_true - freq_null;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (booltesttype)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> IS_UNKNOWN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> only NULL <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = freq_null;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> IS_NOT_UNKNOWN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> non-NULL <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = <span class="Constant">1.0</span> - freq_null;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> IS_TRUE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> only TRUE <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = freq_true;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> IS_NOT_TRUE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> non-TRUE <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = <span class="Constant">1.0</span> - freq_true;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> IS_FALSE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> only FALSE <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = freq_false;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> IS_NOT_FALSE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> non-FALSE <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = <span class="Constant">1.0</span> - freq_false;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized booltesttype: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) booltesttype);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = <span class="Constant">0.0</span>;&nbsp; &nbsp; <span class="Comment">/* Keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L3344" title="utils/cache/lsyscache.c:3344">free_attstatsslot</a>(&amp;sslot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No most-common-value info available. Still have null fraction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * information, so use it for IS [NOT] UNKNOWN. Otherwise adjust<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for null fraction and assume a 50-50 split of TRUE and FALSE.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (booltesttype)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> IS_UNKNOWN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> only NULL <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = freq_null;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> IS_NOT_UNKNOWN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> non-NULL <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = <span class="Constant">1.0</span> - freq_null;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> IS_TRUE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> IS_FALSE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Assume we <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> half of the non-NULL <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = (<span class="Constant">1.0</span> - freq_null) / <span class="Constant">2.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> IS_NOT_TRUE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> IS_NOT_FALSE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Assume we <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> NULLs plus half of the non-NULLs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* equiv. to freq_null + (1.0 - freq_null) / 2.0 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = (freq_null + <span class="Constant">1.0</span>) / <span class="Constant">2.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized booltesttype: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) booltesttype);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = <span class="Constant">0.0</span>;&nbsp; &nbsp; <span class="Comment">/* Keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we can't get variable statistics for the argument, perhaps<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../optimizer/path/clausesel.c.html#L667" title="optimizer/path/clausesel.c:667">clause_selectivity</a> can do something with it.&nbsp; We ignore the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * possibility of a NULL value when using <a href="../../optimizer/path/clausesel.c.html#L667" title="optimizer/path/clausesel.c:667">clause_selectivity</a>, and just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * assume the value is either TRUE or FALSE.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (booltesttype)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> IS_UNKNOWN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = DEFAULT_UNK_SEL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> IS_NOT_UNKNOWN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = DEFAULT_NOT_UNK_SEL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> IS_TRUE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> IS_NOT_FALSE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = (<span class="Type">double</span>) <a href="../../optimizer/path/clausesel.c.html#L667" title="optimizer/path/clausesel.c:667">clause_selectivity</a>(root, arg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; varRelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jointype, sjinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> IS_FALSE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> IS_NOT_TRUE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = <span class="Constant">1.0</span> - (<span class="Type">double</span>) <a href="../../optimizer/path/clausesel.c.html#L667" title="optimizer/path/clausesel.c:667">clause_selectivity</a>(root, arg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; varRelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jointype, sjinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized booltesttype: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) booltesttype);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = <span class="Constant">0.0</span>;&nbsp; &nbsp; <span class="Comment">/* Keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ReleaseVariableStats(vardata);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* result should be in <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, but make sure... */<br/></li>
<li></span>&nbsp; &nbsp; CLAMP_PROBABILITY(selec);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (Selectivity) selec;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1698" title="utils/adt/selfuncs.c:1698">nulltestsel</a>&nbsp; &nbsp; &nbsp; &nbsp; - Selectivity of NullTest Node.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Selectivity<br/></li>
<li><a id="L1698">&#x200c;</a><span class="linkable">nulltestsel</span>(PlannerInfo *root, NullTestType nulltesttype, Node *arg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> varRelid, JoinType jointype, SpecialJoinInfo *sjinfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; VariableStatData vardata;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; selec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L5012" title="utils/adt/selfuncs.c:5012">examine_variable</a>(root, arg, varRelid, &amp;vardata);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(vardata.statsTuple))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_statistic stats;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; freq_null;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stats = (Form_pg_statistic) GETSTRUCT(vardata.statsTuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; freq_null = stats-&gt;stanullfrac;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (nulltesttype)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> IS_NULL:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Use freq_null directly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = freq_null;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> IS_NOT_NULL:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Select not unknown (not null) <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>. Calculate from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * freq_null.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = <span class="Constant">1.0</span> - freq_null;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized nulltesttype: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) nulltesttype);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Selectivity) <span class="Constant">0</span>; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (vardata.var &amp;&amp; IsA(vardata.var, Var) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ((Var *) vardata.var)-&gt;varattno &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There are no stats for system columns, but we know they are never<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * NULL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; selec = (nulltesttype == IS_NULL) ? <span class="Constant">0.0</span> : <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No ANALYZE stats available, so make a guess<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (nulltesttype)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> IS_NULL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = DEFAULT_UNK_SEL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> IS_NOT_NULL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = DEFAULT_NOT_UNK_SEL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized nulltesttype: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) nulltesttype);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Selectivity) <span class="Constant">0</span>; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ReleaseVariableStats(vardata);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* result should be in <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, but make sure... */<br/></li>
<li></span>&nbsp; &nbsp; CLAMP_PROBABILITY(selec);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (Selectivity) selec;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1783" title="utils/adt/selfuncs.c:1783">strip_array_coercion</a> - strip binary-compatible relabeling from an array expr<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For array <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, the parser normally generates ArrayCoerceExpr conversions,<br/></li>
<li></span><span class="Comment"> * but it seems possible that RelabelType might show up.&nbsp; Also, the <a href="../../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a><br/></li>
<li></span><span class="Comment"> * is not currently tense about collapsing stacked ArrayCoerceExpr nodes,<br/></li>
<li></span><span class="Comment"> * so we need to be ready to deal with more than one level.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Node *<br/></li>
<li><a id="L1783">&#x200c;</a><span class="linkable">strip_array_coercion</span>(Node *node)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (node &amp;&amp; IsA(node, ArrayCoerceExpr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ArrayCoerceExpr *acoerce = (ArrayCoerceExpr *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the per-<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> expression is just a RelabelType on top of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * CaseTestExpr, then we know it's a binary-compatible relabeling.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(acoerce-&gt;elemexpr, RelabelType) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IsA(((RelabelType *) acoerce-&gt;elemexpr)-&gt;arg, CaseTestExpr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node = (Node *) acoerce-&gt;arg;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (node &amp;&amp; IsA(node, RelabelType))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We don't really expect this case, but may as well cope */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node = (Node *) ((RelabelType *) node)-&gt;arg;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> node;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1816" title="utils/adt/selfuncs.c:1816">scalararraysel</a>&nbsp; &nbsp; &nbsp; &nbsp; - Selectivity of ScalarArrayOpExpr Node.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Selectivity<br/></li>
<li><a id="L1816">&#x200c;</a><span class="linkable">scalararraysel</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ScalarArrayOpExpr *clause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_join_clause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> varRelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; JoinType jointype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; SpecialJoinInfo *sjinfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; operator = clause-&gt;opno;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; useOr = clause-&gt;useOr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isEquality = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isInequality = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *leftop;<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *rightop;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nominal_element_type;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nominal_element_collation;<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typentry;<br/></li>
<li>&nbsp; &nbsp; RegProcedure oprsel;<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; oprselproc;<br/></li>
<li>&nbsp; &nbsp; Selectivity s1;<br/></li>
<li>&nbsp; &nbsp; Selectivity s1disjoint;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* First, deconstruct the expression */<br/></li>
<li></span>&nbsp; &nbsp; Assert(list_length(clause-&gt;args) == <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; leftop = (Node *) linitial(clause-&gt;args);<br/></li>
<li>&nbsp; &nbsp; rightop = (Node *) lsecond(clause-&gt;args);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* aggressively reduce both sides to constants */<br/></li>
<li></span>&nbsp; &nbsp; leftop = <a href="../../optimizer/util/clauses.c.html#L2395" title="optimizer/util/clauses.c:2395">estimate_expression_value</a>(root, leftop);<br/></li>
<li>&nbsp; &nbsp; rightop = <a href="../../optimizer/util/clauses.c.html#L2395" title="optimizer/util/clauses.c:2395">estimate_expression_value</a>(root, rightop);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* get nominal (after relabeling) <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type of rightop */<br/></li>
<li></span>&nbsp; &nbsp; nominal_element_type = <a href="../cache/lsyscache.c.html#L2832" title="utils/cache/lsyscache.c:2832">get_base_element_type</a>(<a href="../../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>(rightop));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(nominal_element_type))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Selectivity) <span class="Constant">0.5</span>;&nbsp; &nbsp; <span class="Comment">/* probably shouldn't happen */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* get nominal collation, too, for generating constants */<br/></li>
<li></span>&nbsp; &nbsp; nominal_element_collation = <a href="../../nodes/nodeFuncs.c.html#L816" title="nodes/nodeFuncs.c:816">exprCollation</a>(rightop);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* look through <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> binary-compatible relabeling of rightop */<br/></li>
<li></span>&nbsp; &nbsp; rightop = <a href="#L1783" title="utils/adt/selfuncs.c:1783">strip_array_coercion</a>(rightop);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Detect whether the operator is the default equality or inequality<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operator of the array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; typentry = <a href="../cache/typcache.c.html#L346" title="utils/cache/typcache.c:346">lookup_type_cache</a>(nominal_element_type, TYPECACHE_EQ_OPR);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(typentry-&gt;eq_opr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (operator == typentry-&gt;eq_opr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isEquality = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../cache/lsyscache.c.html#L1533" title="utils/cache/lsyscache.c:1533">get_negator</a>(operator) == typentry-&gt;eq_opr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isInequality = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If it is equality or inequality, we might be able to estimate this as a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * form of array containment; for instance &quot;const = ANY(column)&quot; can be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * treated as &quot;ARRAY[const] &lt;@ column&quot;.&nbsp; <a href="array_selfuncs.c.html#L81" title="utils/adt/array_selfuncs.c:81">scalararraysel_containment</a> tries<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that, and returns the selectivity estimate if successful, or -1 if not.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((isEquality || isInequality) &amp;&amp; !is_join_clause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s1 = <a href="array_selfuncs.c.html#L81" title="utils/adt/array_selfuncs.c:81">scalararraysel_containment</a>(root, leftop, rightop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nominal_element_type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isEquality, useOr, varRelid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s1 &gt;= <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> s1;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Look up the underlying operator's selectivity estimator. Punt if it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * hasn't got one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (is_join_clause)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oprsel = <a href="../cache/lsyscache.c.html#L1581" title="utils/cache/lsyscache.c:1581">get_oprjoin</a>(operator);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oprsel = <a href="../cache/lsyscache.c.html#L1557" title="utils/cache/lsyscache.c:1557">get_oprrest</a>(operator);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!oprsel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Selectivity) <span class="Constant">0.5</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../fmgr/fmgr.c.html#L127" title="utils/fmgr/fmgr.c:127">fmgr_info</a>(oprsel, &amp;oprselproc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In the array-containment check above, we must only believe that an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operator is equality or inequality if it is the default btree equality<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operator (or its negator) for the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type, since those are the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operators that array containment will use.&nbsp; But in what follows, we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be a little laxer, and also believe that <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> operators using <a href="#L227" title="utils/adt/selfuncs.c:227">eqsel</a>() or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L557" title="utils/adt/selfuncs.c:557">neqsel</a>() as selectivity estimator act like equality or inequality.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (oprsel == F_EQSEL || oprsel == F_EQJOINSEL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; isEquality = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (oprsel == F_NEQSEL || oprsel == F_NEQJOINSEL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; isInequality = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We consider three cases:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 1. rightop is an Array constant: deconstruct the array, apply the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operator's selectivity function for each array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>, and <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * results in the same way that clausesel.c does for AND/OR combinations.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 2. rightop is an ARRAY[] construct: apply the operator's selectivity<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * function for each <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> of the ARRAY[] construct, and <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 3. otherwise, make a guess ...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rightop &amp;&amp; IsA(rightop, Const))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; arraydatum = ((Const *) rightop)-&gt;constvalue;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; arrayisnull = ((Const *) rightop)-&gt;constisnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ArrayType&nbsp; *arrayval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; elmlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; elmbyval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; elmalign;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_elems;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *elem_values;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *elem_nulls;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (arrayisnull)&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* qual can't succeed if null array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Selectivity) <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; arrayval = DatumGetArrayTypeP(arraydatum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L2271" title="utils/cache/lsyscache.c:2271">get_typlenbyvalalign</a>(ARR_ELEMTYPE(arrayval),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;elmlen, &amp;elmbyval, &amp;elmalign);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="arrayfuncs.c.html#L3612" title="utils/adt/arrayfuncs.c:3612">deconstruct_array</a>(arrayval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ARR_ELEMTYPE(arrayval),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmlen, elmbyval, elmalign,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;elem_values, &amp;elem_nulls, &amp;num_elems);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For generic operators, we assume the probability of success is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * independent for each array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>.&nbsp; But for &quot;= ANY&quot; or &quot;&lt;&gt; ALL&quot;,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if the array elements are distinct (which'd typically be the case)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * then the probabilities are disjoint, and we should just sum them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we were being really tense we would try to confirm that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * elements are all distinct, but that would be expensive and it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * doesn't seem to be worth the cycles; it would amount to penalizing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * well-written queries in favor of poorly-written ones.&nbsp; However, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * do protect ourselves a little <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> by checking whether the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * disjointness assumption leads to an impossible (out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * probability; if so, we fall back to the normal calculation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; s1 = s1disjoint = (useOr ? <span class="Constant">0.0</span> : <span class="Constant">1.0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; num_elems; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *args;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Selectivity s2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; args = list_make2(leftop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/makefuncs.c.html#L301" title="nodes/makefuncs.c:301">makeConst</a>(nominal_element_type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nominal_element_collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elem_values[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elem_nulls[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmbyval));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (is_join_clause)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s2 = DatumGetFloat8(<a href="../fmgr/fmgr.c.html#L1223" title="utils/fmgr/fmgr.c:1223">FunctionCall5Coll</a>(&amp;oprselproc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clause-&gt;inputcollid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(root),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(operator),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(args),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Int16GetDatum(jointype),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(sjinfo)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s2 = DatumGetFloat8(<a href="../fmgr/fmgr.c.html#L1196" title="utils/fmgr/fmgr.c:1196">FunctionCall4Coll</a>(&amp;oprselproc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clause-&gt;inputcollid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(root),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(operator),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(args),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Int32GetDatum(varRelid)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (useOr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s1 = s1 + s2 - s1 * s2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isEquality)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s1disjoint += s2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s1 = s1 * s2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isInequality)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s1disjoint += s2 - <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> disjoint-probability estimate if in <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((useOr ? isEquality : isInequality) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s1disjoint &gt;= <span class="Constant">0.0</span> &amp;&amp; s1disjoint &lt;= <span class="Constant">1.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s1 = s1disjoint;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (rightop &amp;&amp; IsA(rightop, ArrayExpr) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !((ArrayExpr *) rightop)-&gt;multidims)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ArrayExpr&nbsp; *arrayexpr = (ArrayExpr *) rightop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; elmlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; elmbyval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L2251" title="utils/cache/lsyscache.c:2251">get_typlenbyval</a>(arrayexpr-&gt;element_typeid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;elmlen, &amp;elmbyval);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We use the assumption of disjoint probabilities here too, although<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the odds of <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> array elements are rather higher if the elements<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * are not all constants (which they won't be, else constant folding<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * would have reduced the ArrayExpr to a Const).&nbsp; In this path it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * critical to have the sanity check on the s1disjoint estimate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; s1 = s1disjoint = (useOr ? <span class="Constant">0.0</span> : <span class="Constant">1.0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(l, arrayexpr-&gt;elements)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *elem = (Node *) lfirst(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *args;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Selectivity s2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Theoretically, if elem isn't of nominal_element_type we should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * insert a RelabelType, but it seems unlikely that <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> operator<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * estimation function would really care ...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; args = list_make2(leftop, elem);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (is_join_clause)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s2 = DatumGetFloat8(<a href="../fmgr/fmgr.c.html#L1223" title="utils/fmgr/fmgr.c:1223">FunctionCall5Coll</a>(&amp;oprselproc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clause-&gt;inputcollid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(root),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(operator),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(args),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Int16GetDatum(jointype),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(sjinfo)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s2 = DatumGetFloat8(<a href="../fmgr/fmgr.c.html#L1196" title="utils/fmgr/fmgr.c:1196">FunctionCall4Coll</a>(&amp;oprselproc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clause-&gt;inputcollid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(root),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(operator),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(args),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Int32GetDatum(varRelid)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (useOr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s1 = s1 + s2 - s1 * s2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isEquality)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s1disjoint += s2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s1 = s1 * s2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isInequality)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s1disjoint += s2 - <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> disjoint-probability estimate if in <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((useOr ? isEquality : isInequality) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s1disjoint &gt;= <span class="Constant">0.0</span> &amp;&amp; s1disjoint &lt;= <span class="Constant">1.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s1 = s1disjoint;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CaseTestExpr *dummyexpr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *args;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Selectivity s2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We need a dummy rightop to pass to the operator selectivity<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * routine.&nbsp; It can be pretty much anything that doesn't look like a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * constant; CaseTestExpr is a convenient choice.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; dummyexpr = makeNode(CaseTestExpr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dummyexpr-&gt;typeId = nominal_element_type;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dummyexpr-&gt;typeMod = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dummyexpr-&gt;collation = clause-&gt;inputcollid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; args = list_make2(leftop, dummyexpr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (is_join_clause)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s2 = DatumGetFloat8(<a href="../fmgr/fmgr.c.html#L1223" title="utils/fmgr/fmgr.c:1223">FunctionCall5Coll</a>(&amp;oprselproc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clause-&gt;inputcollid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(root),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(operator),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(args),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Int16GetDatum(jointype),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(sjinfo)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s2 = DatumGetFloat8(<a href="../fmgr/fmgr.c.html#L1196" title="utils/fmgr/fmgr.c:1196">FunctionCall4Coll</a>(&amp;oprselproc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clause-&gt;inputcollid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(root),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(operator),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(args),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Int32GetDatum(varRelid)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s1 = useOr ? <span class="Constant">0.0</span> : <span class="Constant">1.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Arbitrarily assume 10 elements in the eventual array value (see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * also <a href="#L2136" title="utils/adt/selfuncs.c:2136">estimate_array_length</a>).&nbsp; We don't risk an assumption of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * disjoint probabilities here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <span class="Constant">10</span>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (useOr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s1 = s1 + s2 - s1 * s2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s1 = s1 * s2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* result should be in <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, but make sure... */<br/></li>
<li></span>&nbsp; &nbsp; CLAMP_PROBABILITY(s1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> s1;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Estimate number of elements in the array yielded by an expression.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: the result is integral, but we use &quot;double&quot; to avoid overflow<br/></li>
<li></span><span class="Comment"> * concerns.&nbsp; Most callers will use it in double-type expressions anyway.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">double<br/></li>
<li><a id="L2136">&#x200c;</a></span><span class="linkable">estimate_array_length</span>(PlannerInfo *root, Node *arrayexpr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* look through <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> binary-compatible relabeling of arrayexpr */<br/></li>
<li></span>&nbsp; &nbsp; arrayexpr = <a href="#L1783" title="utils/adt/selfuncs.c:1783">strip_array_coercion</a>(arrayexpr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (arrayexpr &amp;&amp; IsA(arrayexpr, Const))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; arraydatum = ((Const *) arrayexpr)-&gt;constvalue;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; arrayisnull = ((Const *) arrayexpr)-&gt;constisnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ArrayType&nbsp; *arrayval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (arrayisnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; arrayval = DatumGetArrayTypeP(arraydatum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="arrayutils.c.html#L57" title="utils/adt/arrayutils.c:57">ArrayGetNItems</a>(ARR_NDIM(arrayval), ARR_DIMS(arrayval));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (arrayexpr &amp;&amp; IsA(arrayexpr, ArrayExpr) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !((ArrayExpr *) arrayexpr)-&gt;multidims)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> list_length(((ArrayExpr *) arrayexpr)-&gt;elements);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (arrayexpr)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* See if we can <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> statistics about it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; VariableStatData vardata;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AttStatsSlot sslot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; nelem = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5012" title="utils/adt/selfuncs.c:5012">examine_variable</a>(root, arrayexpr, <span class="Constant">0</span>, &amp;vardata);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(vardata.statsTuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Found stats, so use the average <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> count, which is stored<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in the last stanumbers <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> of the DECHIST statistics.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Actually that is the average count of *distinct* elements;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * perhaps we should scale it up somewhat?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../cache/lsyscache.c.html#L3234" title="utils/cache/lsyscache.c:3234">get_attstatsslot</a>(&amp;sslot, vardata.statsTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; STATISTIC_KIND_DECHIST, InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ATTSTATSSLOT_NUMBERS))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sslot.nnumbers &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nelem = <a href="../../optimizer/path/costsize.c.html#L202" title="optimizer/path/costsize.c:202">clamp_row_est</a>(sslot.numbers[sslot.nnumbers - <span class="Constant">1</span>]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L3344" title="utils/cache/lsyscache.c:3344">free_attstatsslot</a>(&amp;sslot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ReleaseVariableStats(vardata);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nelem &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> nelem;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Else use a default guess --- this should match <a href="#L1816" title="utils/adt/selfuncs.c:1816">scalararraysel</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">10</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2202" title="utils/adt/selfuncs.c:2202">rowcomparesel</a>&nbsp; &nbsp; &nbsp; &nbsp; - Selectivity of RowCompareExpr Node.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We estimate RowCompare selectivity by considering just the first (high<br/></li>
<li></span><span class="Comment"> * order) columns, which makes it equivalent to an ordinary OpExpr.&nbsp; While<br/></li>
<li></span><span class="Comment"> * this estimate could be refined by considering additional columns, it<br/></li>
<li></span><span class="Comment"> * seems unlikely that we could do a lot better without multi-column<br/></li>
<li></span><span class="Comment"> * statistics.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Selectivity<br/></li>
<li><a id="L2202">&#x200c;</a><span class="linkable">rowcomparesel</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RowCompareExpr *clause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> varRelid, JoinType jointype, SpecialJoinInfo *sjinfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Selectivity s1;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opno = linitial_oid(clause-&gt;opnos);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inputcollid = linitial_oid(clause-&gt;inputcollids);<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *opargs;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_join_clause;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Build equivalent arg list for single operator */<br/></li>
<li></span>&nbsp; &nbsp; opargs = list_make2(linitial(clause-&gt;largs), linitial(clause-&gt;rargs));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Decide if it's a join clause.&nbsp; This should match clausesel.c's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../optimizer/path/clausesel.c.html#L586" title="optimizer/path/clausesel.c:586">treat_as_join_clause</a>(), except that we intentionally consider only the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * leading columns and not the rest of the clause.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (varRelid != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Caller is forcing restriction mode (eg, because we are examining an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * inner indexscan qual).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; is_join_clause = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (sjinfo == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It must be a restriction clause, since it's being evaluated at a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * scan node.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; is_join_clause = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise, it's a join if there's more than one base relation used.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; is_join_clause = (<a href="../../optimizer/util/clauses.c.html#L2130" title="optimizer/util/clauses.c:2130">NumRelids</a>(root, (Node *) opargs) &gt; <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (is_join_clause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Estimate selectivity for a join clause. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; s1 = <a href="../../optimizer/util/plancat.c.html#L1969" title="optimizer/util/plancat.c:1969">join_selectivity</a>(root, opno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opargs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inputcollid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jointype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sjinfo);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Estimate selectivity for a restriction clause. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; s1 = <a href="../../optimizer/util/plancat.c.html#L1930" title="optimizer/util/plancat.c:1930">restriction_selectivity</a>(root, opno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; opargs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; inputcollid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; varRelid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> s1;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2269" title="utils/adt/selfuncs.c:2269">eqjoinsel</a>&nbsp; &nbsp; &nbsp; &nbsp; - Join selectivity of &quot;=&quot;<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2269">&#x200c;</a><span class="linkable">eqjoinsel</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; operator = PG_GETARG_OID(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *args = (List *) PG_GETARG_POINTER(<span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef NOT_USED<br/></li>
<li></span>&nbsp; &nbsp; JoinType&nbsp; &nbsp; jointype = (JoinType) PG_GETARG_INT16(<span class="Constant">3</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; SpecialJoinInfo *sjinfo = (SpecialJoinInfo *) PG_GETARG_POINTER(<span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collation = PG_GET_COLLATION();<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; selec;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; selec_inner;<br/></li>
<li>&nbsp; &nbsp; VariableStatData vardata1;<br/></li>
<li>&nbsp; &nbsp; VariableStatData vardata2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; nd1;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; nd2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isdefault1;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isdefault2;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opfuncoid;<br/></li>
<li>&nbsp; &nbsp; AttStatsSlot sslot1;<br/></li>
<li>&nbsp; &nbsp; AttStatsSlot sslot2;<br/></li>
<li>&nbsp; &nbsp; Form_pg_statistic stats1 = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; Form_pg_statistic stats2 = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; have_mcvs1 = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; have_mcvs2 = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; get_mcv_stats;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; join_is_reversed;<br/></li>
<li>&nbsp; &nbsp; RelOptInfo *inner_rel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L4943" title="utils/adt/selfuncs.c:4943">get_join_variables</a>(root, args, sjinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;vardata1, &amp;vardata2, &amp;join_is_reversed);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nd1 = <a href="#L5764" title="utils/adt/selfuncs.c:5764">get_variable_numdistinct</a>(&amp;vardata1, &amp;isdefault1);<br/></li>
<li>&nbsp; &nbsp; nd2 = <a href="#L5764" title="utils/adt/selfuncs.c:5764">get_variable_numdistinct</a>(&amp;vardata2, &amp;isdefault2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; opfuncoid = <a href="../cache/lsyscache.c.html#L1285" title="utils/cache/lsyscache.c:1285">get_opcode</a>(operator);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memset(&amp;sslot1, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(sslot1));<br/></li>
<li>&nbsp; &nbsp; memset(&amp;sslot2, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(sslot2));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * There is no use in fetching one side's MCVs if we lack MCVs for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * other side, so do a quick check to verify that both stats exist.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; get_mcv_stats = (HeapTupleIsValid(vardata1.statsTuple) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HeapTupleIsValid(vardata2.statsTuple) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../cache/lsyscache.c.html#L3234" title="utils/cache/lsyscache.c:3234">get_attstatsslot</a>(&amp;sslot1, vardata1.statsTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; STATISTIC_KIND_MCV, InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../cache/lsyscache.c.html#L3234" title="utils/cache/lsyscache.c:3234">get_attstatsslot</a>(&amp;sslot2, vardata2.statsTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; STATISTIC_KIND_MCV, InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(vardata1.statsTuple))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* note we allow use of nullfrac regardless of security check */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; stats1 = (Form_pg_statistic) GETSTRUCT(vardata1.statsTuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (get_mcv_stats &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5735" title="utils/adt/selfuncs.c:5735">statistic_proc_security_check</a>(&amp;vardata1, opfuncoid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; have_mcvs1 = <a href="../cache/lsyscache.c.html#L3234" title="utils/cache/lsyscache.c:3234">get_attstatsslot</a>(&amp;sslot1, vardata1.statsTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; STATISTIC_KIND_MCV, InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(vardata2.statsTuple))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* note we allow use of nullfrac regardless of security check */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; stats2 = (Form_pg_statistic) GETSTRUCT(vardata2.statsTuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (get_mcv_stats &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5735" title="utils/adt/selfuncs.c:5735">statistic_proc_security_check</a>(&amp;vardata2, opfuncoid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; have_mcvs2 = <a href="../cache/lsyscache.c.html#L3234" title="utils/cache/lsyscache.c:3234">get_attstatsslot</a>(&amp;sslot2, vardata2.statsTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; STATISTIC_KIND_MCV, InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We need to compute the inner-join selectivity in all cases */<br/></li>
<li></span>&nbsp; &nbsp; selec_inner = <a href="#L2434" title="utils/adt/selfuncs.c:2434">eqjoinsel_inner</a>(opfuncoid, collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;vardata1, &amp;vardata2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nd1, nd2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isdefault1, isdefault2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;sslot1, &amp;sslot2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stats1, stats2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; have_mcvs1, have_mcvs2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (sjinfo-&gt;jointype)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JOIN_INNER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JOIN_LEFT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JOIN_FULL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = selec_inner;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JOIN_SEMI:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JOIN_ANTI:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Look up the join's inner relation.&nbsp; min_righthand is sufficient<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * information because neither SEMI nor ANTI joins permit <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reassociation into or out of their RHS, so the righthand will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * always be exactly that set of rels.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inner_rel = <a href="#L6428" title="utils/adt/selfuncs.c:6428">find_join_input_rel</a>(root, sjinfo-&gt;min_righthand);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!join_is_reversed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = <a href="#L2631" title="utils/adt/selfuncs.c:2631">eqjoinsel_semi</a>(opfuncoid, collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;vardata1, &amp;vardata2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nd1, nd2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; isdefault1, isdefault2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;sslot1, &amp;sslot2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; stats1, stats2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; have_mcvs1, have_mcvs2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; inner_rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; commop = <a href="../cache/lsyscache.c.html#L1509" title="utils/cache/lsyscache.c:1509">get_commutator</a>(operator);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; commopfuncoid = OidIsValid(commop) ? <a href="../cache/lsyscache.c.html#L1285" title="utils/cache/lsyscache.c:1285">get_opcode</a>(commop) : InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = <a href="#L2631" title="utils/adt/selfuncs.c:2631">eqjoinsel_semi</a>(commopfuncoid, collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;vardata2, &amp;vardata1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nd2, nd1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; isdefault2, isdefault1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;sslot2, &amp;sslot1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; stats2, stats1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; have_mcvs2, have_mcvs1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; inner_rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We should never estimate the output of a semijoin to be more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rows than we estimate for an inner join with the same input<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rels and join condition; it's obviously impossible for that to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * happen.&nbsp; The former estimate is N1 * Ssemi while the latter is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * N1 * N2 * Sinner, so we may clamp Ssemi &lt;= N2 * Sinner.&nbsp; Doing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this is worthwhile because of the shakier estimation rules we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * use in <a href="#L2631" title="utils/adt/selfuncs.c:2631">eqjoinsel_semi</a>, particularly in cases where it has to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * punt entirely.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(selec, inner_rel-&gt;rows * selec_inner);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* other <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> not expected here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized join type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) sjinfo-&gt;jointype);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L3344" title="utils/cache/lsyscache.c:3344">free_attstatsslot</a>(&amp;sslot1);<br/></li>
<li>&nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L3344" title="utils/cache/lsyscache.c:3344">free_attstatsslot</a>(&amp;sslot2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ReleaseVariableStats(vardata1);<br/></li>
<li>&nbsp; &nbsp; ReleaseVariableStats(vardata2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; CLAMP_PROBABILITY(selec);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8((float8) selec);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2434" title="utils/adt/selfuncs.c:2434">eqjoinsel_inner</a> --- <a href="#L2269" title="utils/adt/selfuncs.c:2269">eqjoinsel</a> for normal inner join<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We also use this for LEFT/FULL outer joins; it's not presently clear<br/></li>
<li></span><span class="Comment"> * that it's worth trying to distinguish them here.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">double<br/></li>
<li><a id="L2434">&#x200c;</a></span><span class="linkable">eqjoinsel_inner</span>(Oid opfuncoid, Oid collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VariableStatData *vardata1, VariableStatData *vardata2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span> nd1, <span class="Type">double</span> nd2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isdefault1, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isdefault2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AttStatsSlot *sslot1, AttStatsSlot *sslot2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_statistic stats1, Form_pg_statistic stats2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> have_mcvs1, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> have_mcvs2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; selec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (have_mcvs1 &amp;&amp; have_mcvs2)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have most-common-value lists for both relations.&nbsp; Run through<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the lists to see which MCVs actually join to each other with the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * given operator.&nbsp; This allows us to determine the exact join<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * selectivity for the portion of the relations represented by the MCV<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lists.&nbsp; We still have to estimate for the remaining population, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in a skewed distribution this gives us a big leg up in accuracy.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For motivation see the analysis in Y. Ioannidis and S.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Christodoulakis, &quot;On the propagation of errors in the size of join<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * results&quot;, Technical Report 1018, Computer Science Dept., University<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of Wisconsin, Madison, March 1991 (available from ftp.cs.wisc.edu).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; LOCAL_FCINFO(fcinfo, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; eqproc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *hasmatch1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *hasmatch2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; nullfrac1 = stats1-&gt;stanullfrac;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; nullfrac2 = stats2-&gt;stanullfrac;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; matchprodfreq,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matchfreq1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matchfreq2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unmatchfreq1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unmatchfreq2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; otherfreq1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; otherfreq2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; totalsel1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; totalsel2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nmatches;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../fmgr/fmgr.c.html#L127" title="utils/fmgr/fmgr.c:127">fmgr_info</a>(opfuncoid, &amp;eqproc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Save a few cycles by setting up the fcinfo struct just once. Using<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * FunctionCallInvoke directly also avoids failure if the eqproc<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * returns NULL, though really equality <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> should never do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; InitFunctionCallInfoData(*fcinfo, &amp;eqproc, <span class="Constant">2</span>, collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hasmatch1 = (<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(sslot1-&gt;nvalues * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hasmatch2 = (<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(sslot2-&gt;nvalues * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note we assume that each MCV will match at most one member of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * other MCV list.&nbsp; If the operator isn't really equality, there could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be multiple matches --- but we don't look for them, both for speed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and because the math wouldn't add up...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; matchprodfreq = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nmatches = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; sslot1-&gt;nvalues; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].value = sslot1-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = <span class="Constant">0</span>; j &lt; sslot2-&gt;nvalues; j++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; fresult;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hasmatch2[j])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].value = sslot2-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[j];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fresult = FunctionCallInvoke(fcinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!fcinfo-&gt;isnull &amp;&amp; DatumGetBool(fresult))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hasmatch1[i] = hasmatch2[j] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matchprodfreq += sslot1-&gt;numbers[i] * sslot2-&gt;numbers[j];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nmatches++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CLAMP_PROBABILITY(matchprodfreq);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Sum up frequencies of matched and unmatched MCVs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; matchfreq1 = unmatchfreq1 = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; sslot1-&gt;nvalues; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hasmatch1[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matchfreq1 += sslot1-&gt;numbers[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unmatchfreq1 += sslot1-&gt;numbers[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CLAMP_PROBABILITY(matchfreq1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CLAMP_PROBABILITY(unmatchfreq1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; matchfreq2 = unmatchfreq2 = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; sslot2-&gt;nvalues; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hasmatch2[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matchfreq2 += sslot2-&gt;numbers[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unmatchfreq2 += sslot2-&gt;numbers[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CLAMP_PROBABILITY(matchfreq2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CLAMP_PROBABILITY(unmatchfreq2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(hasmatch1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(hasmatch2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Compute total frequency of non-null <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> that are not in the MCV<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lists.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; otherfreq1 = <span class="Constant">1.0</span> - nullfrac1 - matchfreq1 - unmatchfreq1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; otherfreq2 = <span class="Constant">1.0</span> - nullfrac2 - matchfreq2 - unmatchfreq2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CLAMP_PROBABILITY(otherfreq1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CLAMP_PROBABILITY(otherfreq2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can estimate the total selectivity from the point of view of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relation 1 as: the known selectivity for matched MCVs, plus<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unmatched MCVs that are assumed to match against random members of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relation 2's non-MCV population, plus non-MCV <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> that are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * assumed to match against random members of relation 2's unmatched<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * MCVs plus non-MCV <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; totalsel1 = matchprodfreq;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nd2 &gt; sslot2-&gt;nvalues)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; totalsel1 += unmatchfreq1 * otherfreq2 / (nd2 - sslot2-&gt;nvalues);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nd2 &gt; nmatches)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; totalsel1 += otherfreq1 * (otherfreq2 + unmatchfreq2) /<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (nd2 - nmatches);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Same estimate from the point of view of relation 2. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; totalsel2 = matchprodfreq;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nd1 &gt; sslot1-&gt;nvalues)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; totalsel2 += unmatchfreq2 * otherfreq1 / (nd1 - sslot1-&gt;nvalues);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nd1 &gt; nmatches)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; totalsel2 += otherfreq2 * (otherfreq1 + unmatchfreq1) /<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (nd1 - nmatches);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Use the smaller of the two estimates.&nbsp; This can be justified in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * essentially the same terms as given below for the no-stats case: to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a first approximation, we are estimating from the point of view of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the relation with smaller nd.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; selec = (totalsel1 &lt; totalsel2) ? totalsel1 : totalsel2;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We do not have MCV lists for both sides.&nbsp; Estimate the join<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * selectivity as MIN(1/nd1,1/nd2)*(1-nullfrac1)*(1-nullfrac2). This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is plausible if we assume that the join operator is strict and the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * non-null <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are about equally distributed: a given non-null<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple of rel1 will join to either zero or N2*(1-nullfrac2)/nd2 rows<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of rel2, so total join rows are at most<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * N1*(1-nullfrac1)*N2*(1-nullfrac2)/nd2 giving a join selectivity of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not more than (1-nullfrac1)*(1-nullfrac2)/nd2. By the same logic it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is not more than (1-nullfrac1)*(1-nullfrac2)/nd1, so the expression<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with MIN() is an <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound.&nbsp; Using the MIN() means we estimate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * from the point of view of the relation with smaller nd (since the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * larger nd is determining the MIN).&nbsp; It is reasonable to assume that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * most tuples in this rel will have join partners, so the bound is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * probably reasonably tight and should be taken as-is.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> Can we be smarter if we have an MCV list for just one side? It<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * seems that if we assume <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> distribution for the other side, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * end up with the same answer anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; nullfrac1 = stats1 ? stats1-&gt;stanullfrac : <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; nullfrac2 = stats2 ? stats2-&gt;stanullfrac : <span class="Constant">0.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; selec = (<span class="Constant">1.0</span> - nullfrac1) * (<span class="Constant">1.0</span> - nullfrac2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nd1 &gt; nd2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec /= nd1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec /= nd2;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> selec;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2631" title="utils/adt/selfuncs.c:2631">eqjoinsel_semi</a> --- <a href="#L2269" title="utils/adt/selfuncs.c:2269">eqjoinsel</a> for semi join<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * (Also used for anti join, which we are supposed to estimate the same way.)<br/></li>
<li></span><span class="Comment"> * Caller has ensured that vardata1 is the LHS variable.<br/></li>
<li></span><span class="Comment"> * Unlike <a href="#L2434" title="utils/adt/selfuncs.c:2434">eqjoinsel_inner</a>, we have to cope with opfuncoid being InvalidOid.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">double<br/></li>
<li><a id="L2631">&#x200c;</a></span><span class="linkable">eqjoinsel_semi</span>(Oid opfuncoid, Oid collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VariableStatData *vardata1, VariableStatData *vardata2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">double</span> nd1, <span class="Type">double</span> nd2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isdefault1, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isdefault2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AttStatsSlot *sslot1, AttStatsSlot *sslot2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Form_pg_statistic stats1, Form_pg_statistic stats2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> have_mcvs1, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> have_mcvs2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *inner_rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; selec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We clamp nd2 to be not more than what we estimate the inner relation's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * size to be.&nbsp; This is intuitively somewhat reasonable since obviously<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there can't be more than that many distinct <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> coming from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inner rel.&nbsp; The reason for the asymmetry (ie, that we don't clamp nd1<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * likewise) is that this is the only pathway by which restriction clauses<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * applied to the inner rel will affect the join result size estimate,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * since <a href="../../optimizer/path/costsize.c.html#L5318" title="optimizer/path/costsize.c:5318">set_joinrel_size_estimates</a> will multiply SEMI/ANTI selectivity by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * only the outer rel's size.&nbsp; If we clamped nd1 we'd be double-counting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the selectivity of outer-rel restrictions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can apply this clamping both with respect to the base relation from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which the join variable comes (if there is just one), and to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * immediate inner input relation of the current join.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we clamp, we can treat nd2 as being a non-default estimate; it's not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * great, maybe, but it didn't come out of nowhere either.&nbsp; This is most<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * helpful when the inner relation is empty and consequently has no stats.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (vardata2-&gt;rel)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nd2 &gt;= vardata2-&gt;rel-&gt;rows)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nd2 = vardata2-&gt;rel-&gt;rows;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isdefault2 = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nd2 &gt;= inner_rel-&gt;rows)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nd2 = inner_rel-&gt;rows;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; isdefault2 = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (have_mcvs1 &amp;&amp; have_mcvs2 &amp;&amp; OidIsValid(opfuncoid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have most-common-value lists for both relations.&nbsp; Run through<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the lists to see which MCVs actually join to each other with the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * given operator.&nbsp; This allows us to determine the exact join<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * selectivity for the portion of the relations represented by the MCV<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lists.&nbsp; We still have to estimate for the remaining population, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in a skewed distribution this gives us a big leg up in accuracy.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; LOCAL_FCINFO(fcinfo, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; eqproc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *hasmatch1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *hasmatch2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; nullfrac1 = stats1-&gt;stanullfrac;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; matchfreq1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uncertainfrac,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uncertain;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nmatches,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clamped_nvalues2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The clamping above could have resulted in nd2 being less than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sslot2-&gt;nvalues; in which case, we assume that precisely the nd2<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * most common <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in the relation will appear in the join input,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and so <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> to only the first nd2 members of the MCV list.&nbsp; Of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * course this is frequently wrong, but it's the best bet we can make.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; clamped_nvalues2 = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(sslot2-&gt;nvalues, nd2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../fmgr/fmgr.c.html#L127" title="utils/fmgr/fmgr.c:127">fmgr_info</a>(opfuncoid, &amp;eqproc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Save a few cycles by setting up the fcinfo struct just once. Using<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * FunctionCallInvoke directly also avoids failure if the eqproc<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * returns NULL, though really equality <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> should never do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; InitFunctionCallInfoData(*fcinfo, &amp;eqproc, <span class="Constant">2</span>, collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hasmatch1 = (<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(sslot1-&gt;nvalues * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hasmatch2 = (<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(clamped_nvalues2 * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note we assume that each MCV will match at most one member of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * other MCV list.&nbsp; If the operator isn't really equality, there could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be multiple matches --- but we don't look for them, both for speed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and because the math wouldn't add up...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nmatches = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; sslot1-&gt;nvalues; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].value = sslot1-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = <span class="Constant">0</span>; j &lt; clamped_nvalues2; j++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; fresult;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hasmatch2[j])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].value = sslot2-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[j];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fresult = FunctionCallInvoke(fcinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!fcinfo-&gt;isnull &amp;&amp; DatumGetBool(fresult))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hasmatch1[i] = hasmatch2[j] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nmatches++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Sum up frequencies of matched MCVs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; matchfreq1 = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; sslot1-&gt;nvalues; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hasmatch1[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matchfreq1 += sslot1-&gt;numbers[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CLAMP_PROBABILITY(matchfreq1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(hasmatch1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(hasmatch2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now we need to estimate the fraction of relation 1 that has at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * least one join partner.&nbsp; We know for certain that the matched MCVs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * do, so that gives us a <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound, but we're really in the dark<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * about everything else.&nbsp; Our crude approach is: if nd1 &lt;= nd2 then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * assume all non-null rel1 rows have join partners, else assume for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the uncertain rows that a fraction nd2/nd1 have join partners. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can discount the known-matched MCVs from the distinct-<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> counts<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> doing the division.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Crude as the above is, it's completely useless if we don't have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reliable ndistinct <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for both sides.&nbsp; Hence, if either nd1 or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * nd2 is default, punt and assume half of the uncertain rows have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * join partners.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!isdefault1 &amp;&amp; !isdefault2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nd1 -= nmatches;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nd2 -= nmatches;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nd1 &lt;= nd2 || nd2 &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uncertainfrac = <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uncertainfrac = nd2 / nd1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uncertainfrac = <span class="Constant">0.5</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uncertain = <span class="Constant">1.0</span> - matchfreq1 - nullfrac1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CLAMP_PROBABILITY(uncertain);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; selec = matchfreq1 + uncertainfrac * uncertain;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Without MCV lists for both sides, we can only use the heuristic<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * about nd1 vs nd2.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; nullfrac1 = stats1 ? stats1-&gt;stanullfrac : <span class="Constant">0.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!isdefault1 &amp;&amp; !isdefault2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nd1 &lt;= nd2 || nd2 &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = <span class="Constant">1.0</span> - nullfrac1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = (nd2 / nd1) * (<span class="Constant">1.0</span> - nullfrac1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = <span class="Constant">0.5</span> * (<span class="Constant">1.0</span> - nullfrac1);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> selec;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2819" title="utils/adt/selfuncs.c:2819">neqjoinsel</a>&nbsp; &nbsp; &nbsp; &nbsp; - Join selectivity of &quot;!=&quot;<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2819">&#x200c;</a><span class="linkable">neqjoinsel</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; operator = PG_GETARG_OID(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *args = (List *) PG_GETARG_POINTER(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; JoinType&nbsp; &nbsp; jointype = (JoinType) PG_GETARG_INT16(<span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; SpecialJoinInfo *sjinfo = (SpecialJoinInfo *) PG_GETARG_POINTER(<span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collation = PG_GET_COLLATION();<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (jointype == JOIN_SEMI || jointype == JOIN_ANTI)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For semi-joins, if there is more than one distinct value in the RHS<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relation then every non-null LHS row must <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a row to join since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it can only be <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to one of them.&nbsp; We'll assume that there is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * always more than one distinct RHS value for the sake of stability,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * though in theory we could have special cases for empty RHS<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (selectivity = 0) and single-distinct-value RHS (selectivity =<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fraction of LHS that has the same value as the single RHS value).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For anti-joins, if we use the same assumption that there is more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * than one distinct key in the RHS relation, then every non-null LHS<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * row must be suppressed by the anti-join.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * So either way, the selectivity estimate should be 1 - nullfrac.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; VariableStatData leftvar;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; VariableStatData rightvar;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; reversed;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; statsTuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; nullfrac;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4943" title="utils/adt/selfuncs.c:4943">get_join_variables</a>(root, args, sjinfo, &amp;leftvar, &amp;rightvar, &amp;reversed);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; statsTuple = reversed ? rightvar.statsTuple : leftvar.statsTuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(statsTuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nullfrac = ((Form_pg_statistic) GETSTRUCT(statsTuple))-&gt;stanullfrac;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nullfrac = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ReleaseVariableStats(leftvar);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ReleaseVariableStats(rightvar);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">1.0</span> - nullfrac;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We want 1 - <a href="#L2269" title="utils/adt/selfuncs.c:2269">eqjoinsel</a>() where the equality operator is the one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * associated with this != operator, that is, its negator.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eqop = <a href="../cache/lsyscache.c.html#L1533" title="utils/cache/lsyscache.c:1533">get_negator</a>(operator);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (eqop)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DatumGetFloat8(<a href="../fmgr/fmgr.c.html#L886" title="utils/fmgr/fmgr.c:886">DirectFunctionCall5Coll</a>(<a href="#L2269" title="utils/adt/selfuncs.c:2269">eqjoinsel</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PointerGetDatum(root),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectIdGetDatum(eqop),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PointerGetDatum(args),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Int16GetDatum(jointype),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PointerGetDatum(sjinfo)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Use default selectivity (should we raise an error instead?) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = DEFAULT_EQ_SEL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">1.0</span> - result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2897" title="utils/adt/selfuncs.c:2897">scalarltjoinsel</a> - Join selectivity of &quot;&lt;&quot; for scalars<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2897">&#x200c;</a><span class="linkable">scalarltjoinsel</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(DEFAULT_INEQ_SEL);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2906" title="utils/adt/selfuncs.c:2906">scalarlejoinsel</a> - Join selectivity of &quot;&lt;=&quot; for scalars<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2906">&#x200c;</a><span class="linkable">scalarlejoinsel</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(DEFAULT_INEQ_SEL);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2915" title="utils/adt/selfuncs.c:2915">scalargtjoinsel</a> - Join selectivity of &quot;&gt;&quot; for scalars<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2915">&#x200c;</a><span class="linkable">scalargtjoinsel</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(DEFAULT_INEQ_SEL);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2924" title="utils/adt/selfuncs.c:2924">scalargejoinsel</a> - Join selectivity of &quot;&gt;=&quot; for scalars<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2924">&#x200c;</a><span class="linkable">scalargejoinsel</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(DEFAULT_INEQ_SEL);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2952" title="utils/adt/selfuncs.c:2952">mergejoinscansel</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - Scan selectivity of <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> join.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> join will stop as soon as it exhausts either input stream.<br/></li>
<li></span><span class="Comment"> * Therefore, if we can estimate the ranges of both input variables,<br/></li>
<li></span><span class="Comment"> * we can estimate how much of the input will actually be read.&nbsp; This<br/></li>
<li></span><span class="Comment"> * can have a considerable impact on the cost when using indexscans.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Also, we can estimate how much of each input has to be read <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the<br/></li>
<li></span><span class="Comment"> * first join pair is found, which will affect the join's startup time.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * clause should be a clause already known to be mergejoinable.&nbsp; opfamily,<br/></li>
<li></span><span class="Comment"> * strategy, and nulls_first specify the sort ordering being used.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The outputs are:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; *leftstart is set to the fraction of the left-hand variable expected<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; to be scanned <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the first join pair is found (0 to 1).<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; *leftend is set to the fraction of the left-hand variable expected<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; to be scanned <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the join terminates (0 to 1).<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; *rightstart, *rightend similarly for the right-hand variable.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2952">&#x200c;</a></span><span class="linkable">mergejoinscansel</span>(PlannerInfo *root, Node *clause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid opfamily, <span class="Type">int</span> strategy, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nulls_first,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Selectivity *leftstart, Selectivity *leftend,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Selectivity *rightstart, Selectivity *rightend)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *left,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *right;<br/></li>
<li>&nbsp; &nbsp; VariableStatData leftvar,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rightvar;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op_strategy;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op_lefttype;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op_righttype;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lsortop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rsortop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lstatop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rstatop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ltop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; revltop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; revleop;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isgt;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; leftmin,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leftmax,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rightmin,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rightmax;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; selec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set default results if we can't figure anything out. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">XXX</span><span class="Comment"> should default &quot;start&quot; fraction be a <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> more than 0? */<br/></li>
<li></span>&nbsp; &nbsp; *leftstart = *rightstart = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; *leftend = *rightend = <span class="Constant">1.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Deconstruct the <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> clause */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!is_opclause(clause))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* shouldn't happen */<br/></li>
<li></span>&nbsp; &nbsp; opno = ((OpExpr *) clause)-&gt;opno;<br/></li>
<li>&nbsp; &nbsp; collation = ((OpExpr *) clause)-&gt;inputcollid;<br/></li>
<li>&nbsp; &nbsp; left = get_leftop((Expr *) clause);<br/></li>
<li>&nbsp; &nbsp; right = get_rightop((Expr *) clause);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!right)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* shouldn't happen */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Look for stats for the inputs */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L5012" title="utils/adt/selfuncs.c:5012">examine_variable</a>(root, left, <span class="Constant">0</span>, &amp;leftvar);<br/></li>
<li>&nbsp; &nbsp; <a href="#L5012" title="utils/adt/selfuncs.c:5012">examine_variable</a>(root, right, <span class="Constant">0</span>, &amp;rightvar);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Extract the operator's declared left/right datatypes */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L136" title="utils/cache/lsyscache.c:136">get_op_opfamily_properties</a>(opno, opfamily, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;op_strategy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;op_lefttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;op_righttype);<br/></li>
<li>&nbsp; &nbsp; Assert(op_strategy == BTEqualStrategyNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Look up the various operators we need.&nbsp; If we don't <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> them all, it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * probably means the opfamily is broken, but we just fail silently.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: we expect that pg_statistic histograms will be sorted by the '&lt;'<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operator, regardless of which sort direction we are considering.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (strategy)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTLessStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isgt = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (op_lefttype == op_righttype)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* easy case */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ltop = <a href="../cache/lsyscache.c.html#L166" title="utils/cache/lsyscache.c:166">get_opfamily_member</a>(opfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; op_lefttype, op_righttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BTLessStrategyNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leop = <a href="../cache/lsyscache.c.html#L166" title="utils/cache/lsyscache.c:166">get_opfamily_member</a>(opfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; op_lefttype, op_righttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BTLessEqualStrategyNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lsortop = ltop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rsortop = ltop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lstatop = lsortop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rstatop = rsortop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; revltop = ltop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; revleop = leop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ltop = <a href="../cache/lsyscache.c.html#L166" title="utils/cache/lsyscache.c:166">get_opfamily_member</a>(opfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; op_lefttype, op_righttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BTLessStrategyNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leop = <a href="../cache/lsyscache.c.html#L166" title="utils/cache/lsyscache.c:166">get_opfamily_member</a>(opfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; op_lefttype, op_righttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BTLessEqualStrategyNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lsortop = <a href="../cache/lsyscache.c.html#L166" title="utils/cache/lsyscache.c:166">get_opfamily_member</a>(opfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op_lefttype, op_lefttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTLessStrategyNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rsortop = <a href="../cache/lsyscache.c.html#L166" title="utils/cache/lsyscache.c:166">get_opfamily_member</a>(opfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op_righttype, op_righttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTLessStrategyNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lstatop = lsortop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rstatop = rsortop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; revltop = <a href="../cache/lsyscache.c.html#L166" title="utils/cache/lsyscache.c:166">get_opfamily_member</a>(opfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op_righttype, op_lefttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTLessStrategyNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; revleop = <a href="../cache/lsyscache.c.html#L166" title="utils/cache/lsyscache.c:166">get_opfamily_member</a>(opfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op_righttype, op_lefttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTLessEqualStrategyNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTGreaterStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* descending-order case */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isgt = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (op_lefttype == op_righttype)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* easy case */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ltop = <a href="../cache/lsyscache.c.html#L166" title="utils/cache/lsyscache.c:166">get_opfamily_member</a>(opfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; op_lefttype, op_righttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BTGreaterStrategyNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leop = <a href="../cache/lsyscache.c.html#L166" title="utils/cache/lsyscache.c:166">get_opfamily_member</a>(opfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; op_lefttype, op_righttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BTGreaterEqualStrategyNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lsortop = ltop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rsortop = ltop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lstatop = <a href="../cache/lsyscache.c.html#L166" title="utils/cache/lsyscache.c:166">get_opfamily_member</a>(opfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op_lefttype, op_lefttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTLessStrategyNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rstatop = lstatop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; revltop = ltop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; revleop = leop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ltop = <a href="../cache/lsyscache.c.html#L166" title="utils/cache/lsyscache.c:166">get_opfamily_member</a>(opfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; op_lefttype, op_righttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BTGreaterStrategyNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leop = <a href="../cache/lsyscache.c.html#L166" title="utils/cache/lsyscache.c:166">get_opfamily_member</a>(opfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; op_lefttype, op_righttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BTGreaterEqualStrategyNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lsortop = <a href="../cache/lsyscache.c.html#L166" title="utils/cache/lsyscache.c:166">get_opfamily_member</a>(opfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op_lefttype, op_lefttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTGreaterStrategyNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rsortop = <a href="../cache/lsyscache.c.html#L166" title="utils/cache/lsyscache.c:166">get_opfamily_member</a>(opfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op_righttype, op_righttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTGreaterStrategyNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lstatop = <a href="../cache/lsyscache.c.html#L166" title="utils/cache/lsyscache.c:166">get_opfamily_member</a>(opfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op_lefttype, op_lefttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTLessStrategyNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rstatop = <a href="../cache/lsyscache.c.html#L166" title="utils/cache/lsyscache.c:166">get_opfamily_member</a>(opfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op_righttype, op_righttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTLessStrategyNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; revltop = <a href="../cache/lsyscache.c.html#L166" title="utils/cache/lsyscache.c:166">get_opfamily_member</a>(opfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op_righttype, op_lefttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTGreaterStrategyNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; revleop = <a href="../cache/lsyscache.c.html#L166" title="utils/cache/lsyscache.c:166">get_opfamily_member</a>(opfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op_righttype, op_lefttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTGreaterEqualStrategyNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> fail;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* shouldn't get here */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(lsortop) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !OidIsValid(rsortop) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !OidIsValid(lstatop) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !OidIsValid(rstatop) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !OidIsValid(ltop) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !OidIsValid(leop) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !OidIsValid(revltop) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !OidIsValid(revleop))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> fail;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* insufficient info in catalogs */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Try to get ranges of both inputs */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!isgt)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L5897" title="utils/adt/selfuncs.c:5897">get_variable_range</a>(root, &amp;leftvar, lstatop, collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;leftmin, &amp;leftmax))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> fail;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> available from stats */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L5897" title="utils/adt/selfuncs.c:5897">get_variable_range</a>(root, &amp;rightvar, rstatop, collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;rightmin, &amp;rightmax))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> fail;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> available from stats */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* need to swap the max and min */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L5897" title="utils/adt/selfuncs.c:5897">get_variable_range</a>(root, &amp;leftvar, lstatop, collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;leftmax, &amp;leftmin))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> fail;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> available from stats */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L5897" title="utils/adt/selfuncs.c:5897">get_variable_range</a>(root, &amp;rightvar, rstatop, collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;rightmax, &amp;rightmin))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> fail;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> available from stats */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now, the fraction of the left variable that will be scanned is the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fraction that's &lt;= the right-side maximum value.&nbsp; But only believe<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * non-default estimates, else stick with our 1.0.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; selec = <a href="#L580" title="utils/adt/selfuncs.c:580">scalarineqsel</a>(root, leop, isgt, <span class="Constant">true</span>, collation, &amp;leftvar,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rightmax, op_righttype);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (selec != DEFAULT_INEQ_SEL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *leftend = selec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And similarly for the right variable. */<br/></li>
<li></span>&nbsp; &nbsp; selec = <a href="#L580" title="utils/adt/selfuncs.c:580">scalarineqsel</a>(root, revleop, isgt, <span class="Constant">true</span>, collation, &amp;rightvar,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leftmax, op_lefttype);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (selec != DEFAULT_INEQ_SEL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *rightend = selec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Only one of the two &quot;end&quot; fractions can really be less than 1.0;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * believe the smaller estimate and reset the other one to exactly 1.0. If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we get exactly <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> estimates (as can easily happen with self-joins),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * believe neither.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (*leftend &gt; *rightend)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *leftend = <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*leftend &lt; *rightend)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *rightend = <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *leftend = *rightend = <span class="Constant">1.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also, the fraction of the left variable that will be scanned <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * first join pair is found is the fraction that's &lt; the right-side<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * minimum value.&nbsp; But only believe non-default estimates, else stick with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * our own default.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; selec = <a href="#L580" title="utils/adt/selfuncs.c:580">scalarineqsel</a>(root, ltop, isgt, <span class="Constant">false</span>, collation, &amp;leftvar,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rightmin, op_righttype);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (selec != DEFAULT_INEQ_SEL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *leftstart = selec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And similarly for the right variable. */<br/></li>
<li></span>&nbsp; &nbsp; selec = <a href="#L580" title="utils/adt/selfuncs.c:580">scalarineqsel</a>(root, revltop, isgt, <span class="Constant">false</span>, collation, &amp;rightvar,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leftmin, op_lefttype);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (selec != DEFAULT_INEQ_SEL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *rightstart = selec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Only one of the two &quot;start&quot; fractions can really be more than zero;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * believe the larger estimate and reset the other one to exactly 0.0. If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we get exactly <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> estimates (as can easily happen with self-joins),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * believe neither.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (*leftstart &lt; *rightstart)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *leftstart = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*leftstart &gt; *rightstart)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *rightstart = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *leftstart = *rightstart = <span class="Constant">0.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the sort order is nulls-first, we're going to have to <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> over <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nulls too.&nbsp; These would not have been counted by <a href="#L580" title="utils/adt/selfuncs.c:580">scalarineqsel</a>, and we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can safely add in this fraction regardless of whether we believe<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L580" title="utils/adt/selfuncs.c:580">scalarineqsel</a>'s results or not.&nbsp; But be sure to clamp the sum to 1.0!<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nulls_first)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_statistic stats;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(leftvar.statsTuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stats = (Form_pg_statistic) GETSTRUCT(leftvar.statsTuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *leftstart += stats-&gt;stanullfrac;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CLAMP_PROBABILITY(*leftstart);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *leftend += stats-&gt;stanullfrac;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CLAMP_PROBABILITY(*leftend);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(rightvar.statsTuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stats = (Form_pg_statistic) GETSTRUCT(rightvar.statsTuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *rightstart += stats-&gt;stanullfrac;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CLAMP_PROBABILITY(*rightstart);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *rightend += stats-&gt;stanullfrac;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CLAMP_PROBABILITY(*rightend);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Disbelieve start &gt;= end, just in case that can happen */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (*leftstart &gt;= *leftend)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *leftstart = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *leftend = <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*rightstart &gt;= *rightend)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *rightstart = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *rightend = <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="Statement">fail</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; ReleaseVariableStats(leftvar);<br/></li>
<li>&nbsp; &nbsp; ReleaseVariableStats(rightvar);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L3257" title="utils/adt/selfuncs.c:3257">matchingsel</a> -- generic matching-operator selectivity support<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Use these for <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> operators that (a) are on data types for which we collect<br/></li>
<li></span><span class="Comment"> * standard statistics, and (b) have behavior for which the default estimate<br/></li>
<li></span><span class="Comment"> * (twice DEFAULT_EQ_SEL) is sane.&nbsp; Typically that is good for match-like<br/></li>
<li></span><span class="Comment"> * operators.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L3257">&#x200c;</a><span class="linkable">matchingsel</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; operator = PG_GETARG_OID(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *args = (List *) PG_GETARG_POINTER(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; varRelid = PG_GETARG_INT32(<span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collation = PG_GET_COLLATION();<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; selec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Use generic restriction selectivity logic. */<br/></li>
<li></span>&nbsp; &nbsp; selec = <a href="#L914" title="utils/adt/selfuncs.c:914">generic_restriction_selectivity</a>(root, operator, collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; args, varRelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DEFAULT_MATCHING_SEL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8((float8) selec);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3275">&#x200c;</a><span class="linkable">matchingjoinsel</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Just punt, for the moment. */<br/></li>
<li></span>&nbsp; &nbsp; PG_RETURN_FLOAT8(DEFAULT_MATCHING_SEL);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Helper routine for <a href="#L3416" title="utils/adt/selfuncs.c:3416">estimate_num_groups</a>: add an item to a list of<br/></li>
<li></span><span class="Comment"> * GroupVarInfos, but only if it's not known <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the existing<br/></li>
<li></span><span class="Comment"> * entries.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *var;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* might be an expression, not just a Var */<br/></li>
<li></span>&nbsp; &nbsp; RelOptInfo *rel;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* relation it belongs to */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; ndistinct;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* # distinct <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isdefault;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* true if DEFAULT_NUM_DISTINCT was used */<br/></li>
<li><a id="L3293">&#x200c;</a></span>} <span class="linkable">GroupVarInfo</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> List *<br/></li>
<li><a id="L3296">&#x200c;</a><span class="linkable">add_unique_group_var</span>(PlannerInfo *root, List *varinfos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Node *var, VariableStatData *vardata)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L3293" title="utils/adt/selfuncs.c:3293">GroupVarInfo</a> *varinfo;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; ndistinct;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isdefault;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ndistinct = <a href="#L5764" title="utils/adt/selfuncs.c:5764">get_variable_numdistinct</a>(vardata, &amp;isdefault);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, varinfos)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; varinfo = (<a href="#L3293" title="utils/adt/selfuncs.c:3293">GroupVarInfo</a> *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Drop exact duplicates */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(var, varinfo-&gt;var))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> varinfos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Drop known-<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a>, but only if they belong to different<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relations (see comments for <a href="#L3416" title="utils/adt/selfuncs.c:3416">estimate_num_groups</a>)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (vardata-&gt;rel != varinfo-&gt;rel &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../optimizer/path/equivclass.c.html#L2465" title="optimizer/path/equivclass.c:2465">exprs_known_equal</a>(root, var, varinfo-&gt;var))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (varinfo-&gt;ndistinct &lt;= ndistinct)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Keep older item, forget new one */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> varinfos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> the older item */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; varinfos = foreach_delete_current(varinfos, lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; varinfo = (<a href="#L3293" title="utils/adt/selfuncs.c:3293">GroupVarInfo</a> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L3293" title="utils/adt/selfuncs.c:3293">GroupVarInfo</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; varinfo-&gt;var = var;<br/></li>
<li>&nbsp; &nbsp; varinfo-&gt;rel = vardata-&gt;rel;<br/></li>
<li>&nbsp; &nbsp; varinfo-&gt;ndistinct = ndistinct;<br/></li>
<li>&nbsp; &nbsp; varinfo-&gt;isdefault = isdefault;<br/></li>
<li>&nbsp; &nbsp; varinfos = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(varinfos, varinfo);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> varinfos;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3416" title="utils/adt/selfuncs.c:3416">estimate_num_groups</a>&nbsp; &nbsp; &nbsp; &nbsp; - Estimate number of groups in a grouped query<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Given a query having a GROUP BY clause, estimate how many groups there<br/></li>
<li></span><span class="Comment"> * will be --- ie, the number of distinct combinations of the GROUP BY<br/></li>
<li></span><span class="Comment"> * expressions.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This routine is also used to estimate the number of rows emitted by<br/></li>
<li></span><span class="Comment"> * a DISTINCT filtering step; that is an isomorphic problem.&nbsp; (Note:<br/></li>
<li></span><span class="Comment"> * actually, we only use it for DISTINCT when there's no grouping or<br/></li>
<li></span><span class="Comment"> * aggregation ahead of the DISTINCT.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Inputs:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; root - the query<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; groupExprs - list of expressions being grouped by<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; input_rows - number of rows estimated to arrive at the group/unique<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; filter step<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; pgset - NULL, or a List** pointing to a grouping set to filter the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; groupExprs against<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Outputs:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; estinfo - When passed as non-NULL, the function will set bits in the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &quot;flags&quot; field in order to provide callers with additional information<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; about the estimation.&nbsp; Currently, we only set the SELFLAG_USED_DEFAULT<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> if we used <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> default <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in the estimation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Given the lack of <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> cross-correlation statistics in the system, it's<br/></li>
<li></span><span class="Comment"> * impossible to do anything really trustworthy with GROUP BY conditions<br/></li>
<li></span><span class="Comment"> * involving multiple Vars.&nbsp; We should however avoid assuming the worst<br/></li>
<li></span><span class="Comment"> * case (all possible cross-product terms actually appear as groups) since<br/></li>
<li></span><span class="Comment"> * very often the grouped-by Vars are highly correlated.&nbsp; Our current approach<br/></li>
<li></span><span class="Comment"> * is as follows:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; 1.&nbsp; Expressions yielding boolean are assumed to contribute two groups,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; independently of their content, and are ignored in the subsequent<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; steps.&nbsp; This is mainly because tests like &quot;col IS NULL&quot; break the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; heuristic used in step 2 especially badly.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; 2.&nbsp; Reduce the given expressions to a list of unique Vars used.&nbsp; For<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; example, GROUP BY a, a + b is treated the same as GROUP BY a, b.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; It is clearly correct not to count the same Var more than once.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; It is also reasonable to treat f(x) the same as x: f() cannot<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; increase the number of distinct <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> (unless it is volatile,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; which we consider unlikely for grouping), but it probably won't<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; reduce the number of distinct <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> much either.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; As a special case, if a GROUP BY expression can be matched to an<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; expressional index for which we have statistics, then we treat the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; whole expression as though it were just a Var.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; 3.&nbsp; If the list contains Vars of different relations that are known <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; due to equivalence classes, then drop all but one of the Vars from each<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; known-<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> set, keeping the one with smallest estimated # of <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; (since the extra <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of the others can't appear in joined rows).<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Note the reason we only consider Vars of different relations is that<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; if we considered ones of the same rel, we'd be double-counting the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; restriction selectivity of the equality in the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> step.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; 4.&nbsp; For Vars within a single source rel, we multiply together the numbers<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; of <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, clamp to the number of rows in the rel (divided by 10 if<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; more than one Var), and then multiply by a factor based on the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; selectivity of the restriction clauses for that rel.&nbsp; When there's<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; more than one Var, the initial product is probably too high (it's the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; worst case) but clamping to a fraction of the rel's rows seems to be a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; helpful heuristic for not letting the estimate get out of hand.&nbsp; (The<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; factor of 10 is derived from pre-Postgres-7.4 practice.)&nbsp; The factor<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; we multiply by to adjust for the restriction selectivity assumes that<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; the restriction clauses are independent of the grouping, which may not<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; be a valid assumption, but it's hard to do better.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; 5.&nbsp; If there are Vars from multiple rels, we <a href="../../regex/regcomp.c.html#L1584" title="regex/regcomp.c:1584">repeat</a> step 4 for each such<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; rel, and multiply the results together.<br/></li>
<li></span><span class="Comment"> * Note that rels not containing grouped Vars are ignored completely, as are<br/></li>
<li></span><span class="Comment"> * join clauses.&nbsp; Such rels cannot increase the number of groups, and we<br/></li>
<li></span><span class="Comment"> * assume such clauses do not reduce the number either (somewhat bogus,<br/></li>
<li></span><span class="Comment"> * but we don't have the info to do better).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">double<br/></li>
<li><a id="L3416">&#x200c;</a></span><span class="linkable">estimate_num_groups</span>(PlannerInfo *root, List *groupExprs, <span class="Type">double</span> input_rows,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List **pgset, EstimationInfo *estinfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *varinfos = NIL;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; srf_multiplier = <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; numdistinct;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Zero the estinfo output parameter, if non-NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (estinfo != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memset(estinfo, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(EstimationInfo));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't ever want to return an estimate of zero groups, as that tends<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to lead to division-by-zero and other unpleasantness.&nbsp; The input_rows<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * estimate is usually already at least 1, but clamp it just in case it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * isn't.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; input_rows = <a href="../../optimizer/path/costsize.c.html#L202" title="optimizer/path/costsize.c:202">clamp_row_est</a>(input_rows);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If no grouping columns, there's exactly one group.&nbsp; (This can't happen<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for normal cases with GROUP BY or DISTINCT, but it is possible for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * corner cases with set operations.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (groupExprs == NIL || (pgset &amp;&amp; *pgset == NIL))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Count groups derived from boolean grouping expressions.&nbsp; For other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * expressions, <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the unique Vars used, treating an expression as a Var<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if we can <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> stats for it.&nbsp; For each one, record the statistical<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * estimate of number of distinct <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> (total in its table, without<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * regard for filtering).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; numdistinct = <span class="Constant">1.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(l, groupExprs)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *groupexpr = (Node *) lfirst(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; this_srf_multiplier;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; VariableStatData vardata;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *varshere;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *l2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* is expression in this grouping set? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pgset &amp;&amp; !<a href="../../nodes/list.c.html#L702" title="nodes/list.c:702">list_member_int</a>(*pgset, i++))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Set-returning <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> in grouping columns are a <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> problematic.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The code below will effectively ignore their SRF nature and come up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with a numdistinct estimate as though they were scalar <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We compensate by scaling up the end result by the largest SRF<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rowcount estimate.&nbsp; (This will be an overestimate if the SRF<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * produces multiple copies of <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> output value, but it seems best to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * assume the SRF's outputs are distinct.&nbsp; In <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case, it's probably<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pointless to worry too much about this without much better<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * estimates for SRF output rowcounts than we have today.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; this_srf_multiplier = <a href="../../optimizer/util/clauses.c.html#L289" title="optimizer/util/clauses.c:289">expression_returns_set_rows</a>(root, groupexpr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (srf_multiplier &lt; this_srf_multiplier)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; srf_multiplier = this_srf_multiplier;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Short-circuit for expressions returning boolean */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>(groupexpr) == BOOLOID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numdistinct *= <span class="Constant">2.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If <a href="#L5012" title="utils/adt/selfuncs.c:5012">examine_variable</a> is able to deduce anything about the GROUP BY<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * expression, treat it as a single variable even if it's really more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * complicated.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> This has the consequence that if there's a statistics object on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the expression, we don't split it into individual Vars. This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * affects our selection of statistics in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L3954" title="utils/adt/selfuncs.c:3954">estimate_multivariate_ndistinct</a>, because it's probably better to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * use more accurate estimate for each expression and treat them as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * independent, than to <a href="../../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> estimates for the extracted variables<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * when we don't know how that relates to the expressions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5012" title="utils/adt/selfuncs.c:5012">examine_variable</a>(root, groupexpr, <span class="Constant">0</span>, &amp;vardata);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(vardata.statsTuple) || vardata.isunique)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; varinfos = <a href="#L3296" title="utils/adt/selfuncs.c:3296">add_unique_group_var</a>(root, varinfos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; groupexpr, &amp;vardata);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReleaseVariableStats(vardata);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ReleaseVariableStats(vardata);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Else <a href="../../regex/regc_nfa.c.html#L1713" title="regex/regc_nfa.c:1713">pull</a> out the component Vars.&nbsp; Handle PlaceHolderVars by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * recursing into their arguments (effectively assuming that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * PlaceHolderVar doesn't change the number of groups, which boils<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * down to ignoring the possible addition of nulls to the result set).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; varshere = <a href="../../optimizer/util/var.c.html#L607" title="optimizer/util/var.c:607">pull_var_clause</a>(groupexpr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PVC_RECURSE_AGGREGATES |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PVC_RECURSE_WINDOWFUNCS |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PVC_RECURSE_PLACEHOLDERS);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> variable-free GROUP BY item, then either it is a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * constant (and we can ignore it) or it contains a volatile function;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in the latter case we punt and assume that each input row will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * yield a distinct group.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (varshere == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../optimizer/util/clauses.c.html#L538" title="optimizer/util/clauses.c:538">contain_volatile_functions</a>(groupexpr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> input_rows;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Else add variables to varinfos list<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(l2, varshere)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *var = (Node *) lfirst(l2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5012" title="utils/adt/selfuncs.c:5012">examine_variable</a>(root, var, <span class="Constant">0</span>, &amp;vardata);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; varinfos = <a href="#L3296" title="utils/adt/selfuncs.c:3296">add_unique_group_var</a>(root, varinfos, var, &amp;vardata);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReleaseVariableStats(vardata);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> no Vars, we must have an all-constant or all-boolean GROUP BY<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (varinfos == NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Apply SRF multiplier as we would do in the long path */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; numdistinct *= srf_multiplier;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Round off */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; numdistinct = ceil(numdistinct);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Guard against out-of-<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> answers */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (numdistinct &gt; input_rows)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numdistinct = input_rows;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (numdistinct &lt; <span class="Constant">1.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numdistinct = <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> numdistinct;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Group Vars by relation and estimate total numdistinct.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For each iteration of the outer loop, we process the frontmost Var in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * varinfos, plus all other Vars in the same relation.&nbsp; We remove these<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Vars from the newvarinfos list for the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> iteration. This is the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * easiest way to group Vars of same rel together.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3293" title="utils/adt/selfuncs.c:3293">GroupVarInfo</a> *varinfo1 = (<a href="#L3293" title="utils/adt/selfuncs.c:3293">GroupVarInfo</a> *) linitial(varinfos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *rel = varinfo1-&gt;rel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; reldistinct = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; relmaxndistinct = reldistinct;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relvarcount = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *newvarinfos = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *relvarinfos = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Split the list of varinfos in two - one for the current rel, one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for remaining Vars on other rels.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; relvarinfos = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(relvarinfos, varinfo1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; for_each_from(l, varinfos, <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3293" title="utils/adt/selfuncs.c:3293">GroupVarInfo</a> *varinfo2 = (<a href="#L3293" title="utils/adt/selfuncs.c:3293">GroupVarInfo</a> *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (varinfo2-&gt;rel == varinfo1-&gt;rel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* varinfos on current rel */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relvarinfos = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(relvarinfos, varinfo2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not time to process varinfo2 yet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newvarinfos = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(newvarinfos, varinfo2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Get the numdistinct estimate for the Vars of this rel.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * iteratively search for multivariate n-distinct with maximum number<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a>; assuming that each var group is independent of the others,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we multiply them together.&nbsp; Any remaining relvarinfos after no more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * multivariate matches are found are assumed independent too, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * their individual ndistinct estimates are multiplied also.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * While iterating, count how many separate numdistinct <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * apply.&nbsp; We apply a fudge factor below, but only if we multiplied<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * more than one such <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (relvarinfos)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; mvndistinct;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3954" title="utils/adt/selfuncs.c:3954">estimate_multivariate_ndistinct</a>(root, rel, &amp;relvarinfos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;mvndistinct))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reldistinct *= mvndistinct;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (relmaxndistinct &lt; mvndistinct)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relmaxndistinct = mvndistinct;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relvarcount++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(l, relvarinfos)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3293" title="utils/adt/selfuncs.c:3293">GroupVarInfo</a> *varinfo2 = (<a href="#L3293" title="utils/adt/selfuncs.c:3293">GroupVarInfo</a> *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reldistinct *= varinfo2-&gt;ndistinct;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (relmaxndistinct &lt; varinfo2-&gt;ndistinct)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relmaxndistinct = varinfo2-&gt;ndistinct;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relvarcount++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When varinfo2's isdefault is set then we'd better set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the SELFLAG_USED_DEFAULT <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> in the EstimationInfo.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (estinfo != <span class="Constant">NULL</span> &amp;&amp; varinfo2-&gt;isdefault)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; estinfo-&gt;flags |= SELFLAG_USED_DEFAULT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we're done with this relation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relvarinfos = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Sanity check --- don't divide by zero if empty relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(IS_SIMPLE_REL(rel));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;tuples &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Clamp to size of rel, or size of rel / 10 if multiple Vars. The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fudge factor is because the Vars are probably correlated but we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't know by how much.&nbsp; We should never clamp to less than the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * largest ndistinct value for <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the Vars, though, since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there will surely be at least that many groups.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; clamp = rel-&gt;tuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (relvarcount &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clamp *= <span class="Constant">0.1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (clamp &lt; relmaxndistinct)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clamp = relmaxndistinct;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* for sanity in case some ndistinct is too large: */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (clamp &gt; rel-&gt;tuples)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clamp = rel-&gt;tuples;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (reldistinct &gt; clamp)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reldistinct = clamp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Update the estimate based on the restriction selectivity,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * guarding against division by zero when reldistinct is zero.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Also <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> this if we know that we are returning all rows.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (reldistinct &gt; <span class="Constant">0</span> &amp;&amp; rel-&gt;rows &lt; rel-&gt;tuples)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Given a table containing N rows with n distinct <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * uniform distribution, if we <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> p rows at random then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the expected number of distinct <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> selected is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * n * (1 - product((N-N/n-i)/(N-i), i=0..p-1))<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * = n * (1 - (N-N/n)! / (N-N/n-p)! * (N-p)! / N!)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * See &quot;Approximating block accesses in database<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * organizations&quot;, S. B. Yao, Communications of the ACM,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Volume 20 Issue 4, April 1977 Pages 260-261.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Alternatively, re-arranging the terms from the factorials,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this may be written as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * n * (1 - product((N-p-i)/(N-i), i=0..N/n-1))<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This form of the formula is more efficient to compute in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the common case where p is larger than N/n.&nbsp; Additionally,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * as pointed out by Dell'Era, if i &lt;&lt; N for all terms in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * product, it can be approximated by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * n * (1 - ((N-p)/N)^(N/n))<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * See &quot;Expected distinct <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> when selecting from a bag<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * without replacement&quot;, Alberto Dell'Era,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * http://www.adellera.it/investigations/distinct_balls/.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The condition i &lt;&lt; N is equivalent to n &gt;&gt; 1, so this is a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * good approximation when the number of distinct <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the table is large.&nbsp; It turns out that this formula also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * works well even when n is small.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reldistinct *=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Constant">1</span> - pow((rel-&gt;tuples - rel-&gt;rows) / rel-&gt;tuples,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rel-&gt;tuples / reldistinct));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reldistinct = <a href="../../optimizer/path/costsize.c.html#L202" title="optimizer/path/costsize.c:202">clamp_row_est</a>(reldistinct);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Update estimate of total distinct groups.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numdistinct *= reldistinct;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; varinfos = newvarinfos;<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (varinfos != NIL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now we can account for the effects of <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> SRFs */<br/></li>
<li></span>&nbsp; &nbsp; numdistinct *= srf_multiplier;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Round off */<br/></li>
<li></span>&nbsp; &nbsp; numdistinct = ceil(numdistinct);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Guard against out-of-<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> answers */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (numdistinct &gt; input_rows)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; numdistinct = input_rows;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (numdistinct &lt; <span class="Constant">1.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; numdistinct = <span class="Constant">1.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> numdistinct;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Estimate <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> bucket statistics when the specified expression is used<br/></li>
<li></span><span class="Comment"> * as a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> key for the given number of buckets.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This attempts to determine two <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 1. The frequency of the most common value of the expression (returns<br/></li>
<li></span><span class="Comment"> * zero into *mcv_freq if we can't get that).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 2. The &quot;bucketsize fraction&quot;, ie, average number of entries in a bucket<br/></li>
<li></span><span class="Comment"> * divided by total tuples in relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment"> This is really pretty bogus since we're effectively assuming that the<br/></li>
<li></span><span class="Comment"> * distribution of <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> keys will be the same after applying restriction<br/></li>
<li></span><span class="Comment"> * clauses as it was in the underlying relation.&nbsp; However, we are not nearly<br/></li>
<li></span><span class="Comment"> * smart enough to figure out how the restrict clauses might change the<br/></li>
<li></span><span class="Comment"> * distribution, so this will have to do for <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We are passed the number of buckets the executor will use for the given<br/></li>
<li></span><span class="Comment"> * input relation.&nbsp; If the data were perfectly distributed, with the same<br/></li>
<li></span><span class="Comment"> * number of tuples going into each available bucket, then the bucketsize<br/></li>
<li></span><span class="Comment"> * fraction would be 1/nbuckets.&nbsp; But this happy state of affairs will occur<br/></li>
<li></span><span class="Comment"> * only if (a) there are at least nbuckets distinct data <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, and (b)<br/></li>
<li></span><span class="Comment"> * we have a not-too-skewed data distribution.&nbsp; Otherwise the buckets will<br/></li>
<li></span><span class="Comment"> * be nonuniformly occupied.&nbsp; If the other relation in the join has a key<br/></li>
<li></span><span class="Comment"> * distribution similar to this one's, then the most-loaded buckets are<br/></li>
<li></span><span class="Comment"> * exactly those that will be probed most often.&nbsp; Therefore, the &quot;average&quot;<br/></li>
<li></span><span class="Comment"> * bucket size for costing purposes should really be taken as something close<br/></li>
<li></span><span class="Comment"> * to the &quot;worst case&quot; bucket size.&nbsp; We try to estimate this by adjusting the<br/></li>
<li></span><span class="Comment"> * fraction if there are too few distinct data <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, and then scaling up<br/></li>
<li></span><span class="Comment"> * by the ratio of the most common value's frequency to the average frequency.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If no statistics are available, use a default estimate of 0.1.&nbsp; This will<br/></li>
<li></span><span class="Comment"> * discourage use of a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> rather strongly if the inner relation is large,<br/></li>
<li></span><span class="Comment"> * which is what we want.&nbsp; We do not want to <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> unless we know that the<br/></li>
<li></span><span class="Comment"> * inner rel is well-dispersed (or the alternatives seem much worse).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller should also check that the mcv_freq is not so large that the<br/></li>
<li></span><span class="Comment"> * most common value would by itself require an impractically large bucket.<br/></li>
<li></span><span class="Comment"> * In a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> join, the executor can split buckets if they get too big, but<br/></li>
<li></span><span class="Comment"> * obviously that doesn't <a href="../../main/main.c.html#L320" title="main/main.c:320">help</a> for a bucket that contains many duplicates of<br/></li>
<li></span><span class="Comment"> * the same value.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3798">&#x200c;</a></span><span class="linkable">estimate_hash_bucket_stats</span>(PlannerInfo *root, Node *hashkey, <span class="Type">double</span> nbuckets,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Selectivity *mcv_freq,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Selectivity *bucketsize_frac)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; VariableStatData vardata;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; estfract,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndistinct,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stanullfrac,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; avgfreq;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isdefault;<br/></li>
<li>&nbsp; &nbsp; AttStatsSlot sslot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L5012" title="utils/adt/selfuncs.c:5012">examine_variable</a>(root, hashkey, <span class="Constant">0</span>, &amp;vardata);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Look up the frequency of the most common value, if available */<br/></li>
<li></span>&nbsp; &nbsp; *mcv_freq = <span class="Constant">0.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(vardata.statsTuple))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../cache/lsyscache.c.html#L3234" title="utils/cache/lsyscache.c:3234">get_attstatsslot</a>(&amp;sslot, vardata.statsTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; STATISTIC_KIND_MCV, InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ATTSTATSSLOT_NUMBERS))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The first MCV stat is for the most common value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sslot.nnumbers &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *mcv_freq = sslot.numbers[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L3344" title="utils/cache/lsyscache.c:3344">free_attstatsslot</a>(&amp;sslot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get number of distinct <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; ndistinct = <a href="#L5764" title="utils/adt/selfuncs.c:5764">get_variable_numdistinct</a>(&amp;vardata, &amp;isdefault);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If ndistinct isn't real, punt.&nbsp; We normally return 0.1, but if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * mcv_freq is known to be even higher than that, use it instead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isdefault)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *bucketsize_frac = (Selectivity) Max(<span class="Constant">0.1</span>, *mcv_freq);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ReleaseVariableStats(vardata);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get fraction that are null */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(vardata.statsTuple))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_statistic stats;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stats = (Form_pg_statistic) GETSTRUCT(vardata.statsTuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stanullfrac = stats-&gt;stanullfrac;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; stanullfrac = <span class="Constant">0.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Compute avg freq of all distinct data <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in raw relation */<br/></li>
<li></span>&nbsp; &nbsp; avgfreq = (<span class="Constant">1.0</span> - stanullfrac) / ndistinct;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Adjust ndistinct to account for restriction clauses.&nbsp; Observe we are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * assuming that the data distribution is affected uniformly by the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * restriction clauses!<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> Possibly better way, but much more expensive: multiply by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * selectivity of rel's restriction clauses that mention the target Var.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (vardata.rel &amp;&amp; vardata.rel-&gt;tuples &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ndistinct *= vardata.rel-&gt;rows / vardata.rel-&gt;tuples;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ndistinct = <a href="../../optimizer/path/costsize.c.html#L202" title="optimizer/path/costsize.c:202">clamp_row_est</a>(ndistinct);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initial estimate of bucketsize fraction is 1/nbuckets as long as the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * number of buckets is less than the expected number of distinct <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * otherwise it is 1/ndistinct.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ndistinct &gt; nbuckets)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; estfract = <span class="Constant">1.0</span> / nbuckets;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; estfract = <span class="Constant">1.0</span> / ndistinct;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Adjust estimated bucketsize upward to account for skewed distribution.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (avgfreq &gt; <span class="Constant">0.0</span> &amp;&amp; *mcv_freq &gt; avgfreq)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; estfract *= *mcv_freq / avgfreq;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Clamp bucketsize to sane <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> (the above adjustment could easily<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * produce an out-of-<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> result).&nbsp; We set the <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound a little above<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * zero, since zero isn't a very sane result.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (estfract &lt; <span class="Constant">1.0e-6</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; estfract = <span class="Constant">1.0e-6</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (estfract &gt; <span class="Constant">1.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; estfract = <span class="Constant">1.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *bucketsize_frac = (Selectivity) estfract;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ReleaseVariableStats(vardata);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3917" title="utils/adt/selfuncs.c:3917">estimate_hashagg_tablesize</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; estimate the number of bytes that a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> aggregate hashtable will<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; require based on the agg_costs, path width and number of groups.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We return the result as &quot;double&quot; to forestall <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> possible overflow<br/></li>
<li></span><span class="Comment"> * problem in the multiplication by dNumGroups.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment"> this may be over-estimating the size <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> that hashagg knows to omit<br/></li>
<li></span><span class="Comment"> * unneeded columns from the hashtable.&nbsp; Also for mixed-mode grouping sets,<br/></li>
<li></span><span class="Comment"> * grouping columns not in the hashed set are counted here even though hashagg<br/></li>
<li></span><span class="Comment"> * won't store them.&nbsp; Is this a problem?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">double<br/></li>
<li><a id="L3917">&#x200c;</a></span><span class="linkable">estimate_hashagg_tablesize</span>(PlannerInfo *root, Path *path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> AggClauseCosts *agg_costs, <span class="Type">double</span> dNumGroups)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; hashentrysize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; hashentrysize = <a href="../../executor/nodeAgg.c.html#L1694" title="executor/nodeAgg.c:1694">hash_agg_entry_size</a>(list_length(root-&gt;aggtransinfos),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path-&gt;pathtarget-&gt;width,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; agg_costs-&gt;transitionSpace);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that this disregards the effect of fill-factor and growth policy<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table.&nbsp; That's probably ok, given that the default<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fill-factor is relatively high.&nbsp; It'd be hard to meaningfully factor in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &quot;double-in-size&quot; growth policies here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> hashentrysize * dNumGroups;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Support routines<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Find applicable ndistinct statistics for the given list of VarInfos (which<br/></li>
<li></span><span class="Comment"> * must all belong to the given rel), and update *ndistinct to the estimate of<br/></li>
<li></span><span class="Comment"> * the MVNDistinctItem that best matches.&nbsp; If a match it found, *varinfos is<br/></li>
<li></span><span class="Comment"> * updated to remove the list of matched varinfos.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Varinfos that aren't for simple Vars are ignored.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return true if we're able to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a match, false otherwise.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3954">&#x200c;</a></span><span class="linkable">estimate_multivariate_ndistinct</span>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List **varinfos, <span class="Type">double</span> *ndistinct)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nmatches_vars;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nmatches_exprs;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; statOid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; MVNDistinct *stats;<br/></li>
<li>&nbsp; &nbsp; StatisticExtInfo *matched_info = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; RangeTblEntry *rte = planner_rt_fetch(rel-&gt;relid, root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* bail out immediately if the table has no extended statistics */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!rel-&gt;statlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* look for the ndistinct statistics object matching the most <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> */<br/></li>
<li></span>&nbsp; &nbsp; nmatches_vars = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we require at least two matches */<br/></li>
<li></span>&nbsp; &nbsp; nmatches_exprs = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, rel-&gt;statlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; StatisticExtInfo *info = (StatisticExtInfo *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nshared_vars = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nshared_exprs = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> statistics of other kinds */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (info-&gt;kind != STATS_EXT_NDISTINCT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> statistics with mismatching stxdinherit value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (info-&gt;inherit != rte-&gt;inh)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Determine how many expressions (and variables in non-matched<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * expressions) match. We'll then use these numbers to pick the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * statistics object that best matches the clauses.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc2, *varinfos)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc3;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3293" title="utils/adt/selfuncs.c:3293">GroupVarInfo</a> *varinfo = (<a href="#L3293" title="utils/adt/selfuncs.c:3293">GroupVarInfo</a> *) lfirst(lc2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(varinfo-&gt;rel == rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* simple Var, search in statistics keys directly */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(varinfo-&gt;var, Var))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attnum = ((Var *) varinfo-&gt;var)-&gt;varattno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ignore system attributes - we don't support statistics on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * them, so can't match them (and it'd fail as the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * negative).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!AttrNumberIsForUserDefinedAttr(attnum))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(attnum, info-&gt;keys))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nshared_vars++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* expression - see if it's in the statistics object */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lc3, info-&gt;exprs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *expr = (Node *) lfirst(lc3);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(varinfo-&gt;var, expr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nshared_exprs++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nshared_vars + nshared_exprs &lt; <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Does this statistics object match more columns than the currently<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * best object?&nbsp; If so, use this one instead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> This should break ties using name of the object, or something<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * like that, to make the outcome stable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((nshared_exprs &gt; nmatches_exprs) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (((nshared_exprs == nmatches_exprs)) &amp;&amp; (nshared_vars &gt; nmatches_vars)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; statOid = info-&gt;statOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nmatches_vars = nshared_vars;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nmatches_exprs = nshared_exprs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matched_info = info;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No match? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (statOid == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(nmatches_vars + nmatches_exprs &gt; <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; stats = <a href="../../statistics/mvdistinct.c.html#L148" title="statistics/mvdistinct.c:148">statext_ndistinct_load</a>(statOid, rte-&gt;inh);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we have a match, search it for the specific item that matches (there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * must be one), and construct the output <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stats)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *newlist = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MVNDistinctItem *item = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Bitmapset&nbsp; *matched = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attnum_offset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * How much we need to offset the attnums? If there are no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * expressions, no offset is needed. Otherwise offset enough to move<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the lowest one (which is <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to number of expressions) to 1.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (matched_info-&gt;exprs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attnum_offset = (list_length(matched_info-&gt;exprs) + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attnum_offset = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* see what actually matched */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc2, *varinfos)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc3;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idx;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3293" title="utils/adt/selfuncs.c:3293">GroupVarInfo</a> *varinfo = (<a href="#L3293" title="utils/adt/selfuncs.c:3293">GroupVarInfo</a> *) lfirst(lc2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Process a simple Var expression, by matching it to keys<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * directly. If there's a matching expression, we'll try matching<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(varinfo-&gt;var, Var))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attnum = ((Var *) varinfo-&gt;var)-&gt;varattno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ignore expressions on system attributes. Can't rely on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * bms check for negative <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!AttrNumberIsForUserDefinedAttr(attnum))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Is the variable covered by the statistics object? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(attnum, matched_info-&gt;keys))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attnum = attnum + attnum_offset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ensure sufficient offset */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(AttrNumberIsForUserDefinedAttr(attnum));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matched = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(matched, attnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> Maybe we should allow searching the expressions even if we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * found an attribute matching the expression? That would handle<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * trivial expressions like &quot;(a)&quot; but it seems fairly useless.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* expression - see if it's in the statistics object */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idx = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lc3, matched_info-&gt;exprs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *expr = (Node *) lfirst(lc3);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(varinfo-&gt;var, expr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attnum = -(idx + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attnum = attnum + attnum_offset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ensure sufficient offset */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(AttrNumberIsForUserDefinedAttr(attnum));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matched = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(matched, attnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* there should be just one matching expression */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idx++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Find the specific item that exactly matches the combination */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; stats-&gt;nitems; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MVNDistinctItem *tmpitem = &amp;stats-&gt;items[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tmpitem-&gt;nattributes != <a href="../../nodes/bitmapset.c.html#L751" title="nodes/bitmapset.c:751">bms_num_members</a>(matched))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* assume it's the right item */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item = tmpitem;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check that all item attributes/expressions fit the match */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = <span class="Constant">0</span>; j &lt; tmpitem-&gt;nattributes; j++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attnum = tmpitem-&gt;attributes[j];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Thanks to how we constructed the matched bitmap above, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can just offset all attnums the same way.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attnum = attnum + attnum_offset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(attnum, matched))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nah, it's not this item */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the item has all the matched attributes, we know it's the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * right one - there can't be a better one. matching more.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (item)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make sure we found an item. There has to be one, because ndistinct<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * statistics includes all combinations of attributes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!item)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;corrupt MVNDistinct entry&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Form the output varinfo list, keeping only unmatched ones */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, *varinfos)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3293" title="utils/adt/selfuncs.c:3293">GroupVarInfo</a> *varinfo = (<a href="#L3293" title="utils/adt/selfuncs.c:3293">GroupVarInfo</a> *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc3;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Let's look at plain variables first, because it's the most<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * common case and the check is quite cheap. We can simply get the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * attnum and check (with an offset) matched bitmap.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(varinfo-&gt;var, Var))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attnum = ((Var *) varinfo-&gt;var)-&gt;varattno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If it's a system attribute, we're done. We don't support<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * extended statistics on system attributes, so it's clearly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not matched. Just keep the expression and continue.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!AttrNumberIsForUserDefinedAttr(attnum))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newlist = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(newlist, varinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* apply the same offset as above */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attnum += attnum_offset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if it's not matched, keep the varinfo */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(attnum, matched))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newlist = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(newlist, varinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The rest of the loop deals with complex expressions. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Process complex expressions, not just simple Vars.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * First, we search for an exact match of an expression. If we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> one, we can just discard the whole <a href="#L3293" title="utils/adt/selfuncs.c:3293">GroupVarInfo</a>, with all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the variables we extracted from it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise we inspect the individual <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a>, and try matching it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to variables in the item.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lc3, matched_info-&gt;exprs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *expr = (Node *) lfirst(lc3);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(varinfo-&gt;var, expr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* found exact match, <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newlist = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(newlist, varinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *varinfos = newlist;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *ndistinct = item-&gt;ndistinct;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4305" title="utils/adt/selfuncs.c:4305">convert_to_scalar</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Convert non-NULL <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of the indicated types to the comparison<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; scale needed by <a href="#L580" title="utils/adt/selfuncs.c:580">scalarineqsel</a>().<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Returns &quot;true&quot; if successful.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment"> this routine is a hack: ideally we should look up the conversion<br/></li>
<li></span><span class="Comment"> * subroutines in pg_type.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * All <a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> datatypes are simply converted to their equivalent<br/></li>
<li></span><span class="Comment"> * &quot;double&quot; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.&nbsp; (NUMERIC <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> that are outside the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of &quot;double&quot;<br/></li>
<li></span><span class="Comment"> * are clamped to +/- HUGE_VAL.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * String datatypes are converted by <a href="#L4514" title="utils/adt/selfuncs.c:4514">convert_string_to_scalar</a>(),<br/></li>
<li></span><span class="Comment"> * which is explained below.&nbsp; The reason why this routine deals with<br/></li>
<li></span><span class="Comment"> * three <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> at a time, not just one, is that we need it for strings.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The bytea datatype is just enough different from strings that it has<br/></li>
<li></span><span class="Comment"> * to be treated separately.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The several datatypes representing absolute times are all converted<br/></li>
<li></span><span class="Comment"> * to Timestamp, which is actually an int64, and then we promote that to<br/></li>
<li></span><span class="Comment"> * a double.&nbsp; Note this will give correct results even for the &quot;special&quot;<br/></li>
<li></span><span class="Comment"> * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of Timestamp, since those are chosen to <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> correctly;<br/></li>
<li></span><span class="Comment"> * see <a href="timestamp.c.html#L2270" title="utils/adt/timestamp.c:2270">timestamp_cmp</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The several datatypes representing relative times (intervals) are all<br/></li>
<li></span><span class="Comment"> * converted to measurements expressed in seconds.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L4305">&#x200c;</a></span><span class="linkable">convert_to_scalar</span>(Datum value, Oid valuetypid, Oid collid, <span class="Type">double</span> *scaledvalue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum lobound, Datum hibound, Oid boundstypid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span> *scaledlobound, <span class="Type">double</span> *scaledhibound)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; failure = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Both the valuetypid and the boundstypid should exactly match the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * declared input type(s) of the operator we are invoked for.&nbsp; However,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * extensions might try to use <a href="#L580" title="utils/adt/selfuncs.c:580">scalarineqsel</a> as estimator for operators<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with input type(s) we don't handle here; in such cases, we want to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * return false, not fail.&nbsp; In <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case, we mustn't assume that valuetypid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and boundstypid are identical.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> The histogram we are interpolating between points of could belong<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to a column that's only binary-compatible with the declared type. In<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * essence we are assuming that the semantics of binary-compatible types<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are enough alike that we can use a histogram generated with one type's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operators to estimate selectivity for the other's.&nbsp; This is outright<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * wrong in some cases --- in particular signed versus unsigned<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * interpretation could trip us up.&nbsp; But it's useful enough in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * majority of cases that we do it anyway.&nbsp; Should think about more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rigorous ways to do it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (valuetypid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Built-in <a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> types<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BOOLOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INT2OID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INT4OID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INT8OID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> FLOAT4OID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> FLOAT8OID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> NUMERICOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OIDOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REGPROCOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REGPROCEDUREOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REGOPEROID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REGOPERATOROID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REGCLASSOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REGTYPEOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REGCOLLATIONOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REGCONFIGOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REGDICTIONARYOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REGROLEOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REGNAMESPACEOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *scaledvalue = <a href="#L4452" title="utils/adt/selfuncs.c:4452">convert_numeric_to_scalar</a>(value, valuetypid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;failure);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *scaledlobound = <a href="#L4452" title="utils/adt/selfuncs.c:4452">convert_numeric_to_scalar</a>(lobound, boundstypid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;failure);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *scaledhibound = <a href="#L4452" title="utils/adt/selfuncs.c:4452">convert_numeric_to_scalar</a>(hibound, boundstypid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;failure);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> !failure;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Built-in string types<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CHAROID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BPCHAROID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> VARCHAROID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TEXTOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> NAMEOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *valstr = <a href="#L4645" title="utils/adt/selfuncs.c:4645">convert_string_datum</a>(value, valuetypid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collid, &amp;failure);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *lostr = <a href="#L4645" title="utils/adt/selfuncs.c:4645">convert_string_datum</a>(lobound, boundstypid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; collid, &amp;failure);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *histr = <a href="#L4645" title="utils/adt/selfuncs.c:4645">convert_string_datum</a>(hibound, boundstypid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; collid, &amp;failure);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Bail out if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> is not of string type.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * might leak converted strings for the other value(s), but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that's not worth troubling over.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (failure)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4514" title="utils/adt/selfuncs.c:4514">convert_string_to_scalar</a>(valstr, scaledvalue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lostr, scaledlobound,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; histr, scaledhibound);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(valstr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(lostr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(histr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Built-in bytea type<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BYTEAOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We only support bytea vs bytea comparison */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (boundstypid != BYTEAOID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4726" title="utils/adt/selfuncs.c:4726">convert_bytea_to_scalar</a>(value, scaledvalue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lobound, scaledlobound,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hibound, scaledhibound);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Built-in time types<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TIMESTAMPOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TIMESTAMPTZOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DATEOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERVALOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TIMEOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TIMETZOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *scaledvalue = <a href="#L4817" title="utils/adt/selfuncs.c:4817">convert_timevalue_to_scalar</a>(value, valuetypid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;failure);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *scaledlobound = <a href="#L4817" title="utils/adt/selfuncs.c:4817">convert_timevalue_to_scalar</a>(lobound, boundstypid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;failure);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *scaledhibound = <a href="#L4817" title="utils/adt/selfuncs.c:4817">convert_timevalue_to_scalar</a>(hibound, boundstypid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;failure);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> !failure;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Built-in network types<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INETOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CIDROID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> MACADDROID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> MACADDR8OID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *scaledvalue = <a href="network.c.html#L1502" title="utils/adt/network.c:1502">convert_network_to_scalar</a>(value, valuetypid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;failure);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *scaledlobound = <a href="network.c.html#L1502" title="utils/adt/network.c:1502">convert_network_to_scalar</a>(lobound, boundstypid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;failure);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *scaledhibound = <a href="network.c.html#L1502" title="utils/adt/network.c:1502">convert_network_to_scalar</a>(hibound, boundstypid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;failure);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> !failure;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Don't know how to convert */<br/></li>
<li></span>&nbsp; &nbsp; *scaledvalue = *scaledlobound = *scaledhibound = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Do <a href="#L4305" title="utils/adt/selfuncs.c:4305">convert_to_scalar</a>()'s work for <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> data type.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On failure (e.g., unsupported typid), set *failure to true;<br/></li>
<li></span><span class="Comment"> * otherwise, that variable is not changed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">double<br/></li>
<li><a id="L4452">&#x200c;</a></span><span class="linkable">convert_numeric_to_scalar</span>(Datum value, Oid typid, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *failure)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (typid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BOOLOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (<span class="Type">double</span>) DatumGetBool(value);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INT2OID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (<span class="Type">double</span>) DatumGetInt16(value);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INT4OID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (<span class="Type">double</span>) DatumGetInt32(value);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INT8OID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (<span class="Type">double</span>) DatumGetInt64(value);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> FLOAT4OID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (<span class="Type">double</span>) DatumGetFloat4(value);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> FLOAT8OID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (<span class="Type">double</span>) DatumGetFloat8(value);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> NUMERICOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Note: out-of-<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> will be clamped to +-HUGE_VAL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (<span class="Type">double</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DatumGetFloat8(DirectFunctionCall1(<a href="numeric.c.html#L4661" title="utils/adt/numeric.c:4661">numeric_float8_no_overflow</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; value));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OIDOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REGPROCOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REGPROCEDUREOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REGOPEROID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REGOPERATOROID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REGCLASSOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REGTYPEOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REGCOLLATIONOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REGCONFIGOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REGDICTIONARYOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REGROLEOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REGNAMESPACEOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we can treat OIDs as integers... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (<span class="Type">double</span>) DatumGetObjectId(value);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *failure = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Do <a href="#L4305" title="utils/adt/selfuncs.c:4305">convert_to_scalar</a>()'s work for <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> character-string data type.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * String datatypes are converted to a scale that ranges from 0 to 1,<br/></li>
<li></span><span class="Comment"> * where we visualize the bytes of the string as fractional digits.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We do not want the base to be 256, however, since that tends to<br/></li>
<li></span><span class="Comment"> * generate inflated selectivity estimates; few databases will have<br/></li>
<li></span><span class="Comment"> * occurrences of all 256 possible byte <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> at each position.<br/></li>
<li></span><span class="Comment"> * Instead, use the smallest and largest byte <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> seen in the bounds<br/></li>
<li></span><span class="Comment"> * as the estimated <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> for each byte, after some fudging to deal with<br/></li>
<li></span><span class="Comment"> * the fact that we probably aren't going to see the full <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> that way.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * An additional refinement is that we discard <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> common prefix of the<br/></li>
<li></span><span class="Comment"> * three strings <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> computing the scaled <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.&nbsp; This allows us to<br/></li>
<li></span><span class="Comment"> * &quot;zoom in&quot; when we encounter a narrow data <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.&nbsp; An example is a phone<br/></li>
<li></span><span class="Comment"> * number database where all the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> begin with the same area code.<br/></li>
<li></span><span class="Comment"> * (Actually, the bounds will be adjacent histogram-bin-boundary <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>,<br/></li>
<li></span><span class="Comment"> * so this is more likely to happen than you might think.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4514">&#x200c;</a></span><span class="linkable">convert_string_to_scalar</span>(<span class="Type">char</span> *value,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">double</span> *scaledvalue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">char</span> *lobound,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">double</span> *scaledlobound,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">char</span> *hibound,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">double</span> *scaledhibound)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rangelo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rangehi;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *sptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rangelo = rangehi = (<span class="Type">unsigned</span> <span class="Type">char</span>) hibound[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (sptr = lobound; *sptr; sptr++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rangelo &gt; (<span class="Type">unsigned</span> <span class="Type">char</span>) *sptr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rangelo = (<span class="Type">unsigned</span> <span class="Type">char</span>) *sptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rangehi &lt; (<span class="Type">unsigned</span> <span class="Type">char</span>) *sptr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rangehi = (<span class="Type">unsigned</span> <span class="Type">char</span>) *sptr;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (sptr = hibound; *sptr; sptr++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rangelo &gt; (<span class="Type">unsigned</span> <span class="Type">char</span>) *sptr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rangelo = (<span class="Type">unsigned</span> <span class="Type">char</span>) *sptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rangehi &lt; (<span class="Type">unsigned</span> <span class="Type">char</span>) *sptr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rangehi = (<span class="Type">unsigned</span> <span class="Type">char</span>) *sptr;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> includes <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-case ASCII chars, make it include all */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rangelo &lt;= <span class="Constant">'Z'</span> &amp;&amp; rangehi &gt;= <span class="Constant">'A'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rangelo &gt; <span class="Constant">'A'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rangelo = <span class="Constant">'A'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rangehi &lt; <span class="Constant">'Z'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rangehi = <span class="Constant">'Z'</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Ditto <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-case */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rangelo &lt;= <span class="Constant">'z'</span> &amp;&amp; rangehi &gt;= <span class="Constant">'a'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rangelo &gt; <span class="Constant">'a'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rangelo = <span class="Constant">'a'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rangehi &lt; <span class="Constant">'z'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rangehi = <span class="Constant">'z'</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Ditto digits */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rangelo &lt;= <span class="Constant">'9'</span> &amp;&amp; rangehi &gt;= <span class="Constant">'0'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rangelo &gt; <span class="Constant">'0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rangelo = <span class="Constant">'0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rangehi &lt; <span class="Constant">'9'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rangehi = <span class="Constant">'9'</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> includes less than 10 chars, assume we have not got enough<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * data, and make it include regular ASCII set.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rangehi - rangelo &lt; <span class="Constant">9</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rangelo = <span class="Constant">' '</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rangehi = <span class="Constant">127</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now strip <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> common prefix of the three strings.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (*lobound)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*lobound != *hibound || *lobound != *value)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lobound++, hibound++, value++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now we can do the conversions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; *scaledvalue = <a href="#L4594" title="utils/adt/selfuncs.c:4594">convert_one_string_to_scalar</a>(value, rangelo, rangehi);<br/></li>
<li>&nbsp; &nbsp; *scaledlobound = <a href="#L4594" title="utils/adt/selfuncs.c:4594">convert_one_string_to_scalar</a>(lobound, rangelo, rangehi);<br/></li>
<li>&nbsp; &nbsp; *scaledhibound = <a href="#L4594" title="utils/adt/selfuncs.c:4594">convert_one_string_to_scalar</a>(hibound, rangelo, rangehi);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">double<br/></li>
<li><a id="L4594">&#x200c;</a></span><span class="linkable">convert_one_string_to_scalar</span>(<span class="Type">char</span> *value, <span class="Type">int</span> rangelo, <span class="Type">int</span> rangehi)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slen = strlen(value);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; num,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; denom,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; base;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (slen &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0.0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* empty string has scalar value 0 */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * There seems little point in considering more than a dozen bytes from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the string.&nbsp; Since base is at least 10, that will give us nominal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * resolution of at least 12 decimal digits, which is surely far more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * precision than this estimation technique has got anyway (especially in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * non-C locales).&nbsp; Also, even with the maximum possible base of 256, this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ensures denom cannot grow larger than 256^13 = 2.03e31, which will not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * overflow on <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> known machine.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (slen &gt; <span class="Constant">12</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slen = <span class="Constant">12</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Convert initial characters to fraction */<br/></li>
<li></span>&nbsp; &nbsp; base = rangehi - rangelo + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; num = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; denom = base;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (slen-- &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ch = (<span class="Type">unsigned</span> <span class="Type">char</span>) *value++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ch &lt; rangelo)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ch = rangelo - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (ch &gt; rangehi)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ch = rangehi + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; num += ((<span class="Type">double</span>) (ch - rangelo)) / denom;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; denom *= base;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> num;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert a string-type Datum into a <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d, null-terminated string.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On failure (e.g., unsupported typid), set *failure to true;<br/></li>
<li></span><span class="Comment"> * otherwise, that variable is not changed.&nbsp; (We'll return NULL on failure.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When using a non-C locale, we must pass the string through strxfrm()<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> continuing, so as to generate correct locale-specific results.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L4645">&#x200c;</a><span class="linkable">convert_string_datum</span>(Datum value, Oid typid, Oid collid, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *failure)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *val;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (typid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CHAROID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val = (<span class="Type">char</span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val[<span class="Constant">0</span>] = DatumGetChar(value);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val[<span class="Constant">1</span>] = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BPCHAROID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> VARCHAROID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TEXTOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val = TextDatumGetCString(value);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> NAMEOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameData&nbsp;&nbsp; *nm = (NameData *) DatumGetPointer(value);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(NameStr(*nm));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *failure = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="pg_locale.c.html#L1317" title="utils/adt/pg_locale.c:1317">lc_collate_is_c</a>(collid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *xfrmstr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; xfrmlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; xfrmlen2 <a href="../../storage/lmgr/lock.c.html#L185" title="storage/lmgr/lock.c:185">PG_USED_FOR_ASSERTS_ONLY</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment">: We could guess at a suitable output buffer size and only call<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * strxfrm twice if our guess is too small.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment">: strxfrm doesn't support UTF-8 encoding on Win32, it can return<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * bogus data or set an error. This is not really a problem unless it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * crashes since it will only give an estimation error and nothing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fatal.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; xfrmlen = strxfrm(<span class="Constant">NULL</span>, val, <span class="Constant">0</span>);<br/></li>
<li><span class="PreProc">#ifdef WIN32<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * On Windows, strxfrm returns INT_MAX when an error occurs. Instead<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of trying to allocate this much memory (and fail), just return the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * original string unmodified as if we were in the C locale.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xfrmlen == <span class="Constant">INT_MAX</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> val;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; xfrmstr = (<span class="Type">char</span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(xfrmlen + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xfrmlen2 = strxfrm(xfrmstr, val, xfrmlen + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Some systems (e.g., glibc) can return a smaller value from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * second call than the first; thus the Assert must be &lt;= not ==.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(xfrmlen2 &lt;= xfrmlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(val);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; val = xfrmstr;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> val;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Do <a href="#L4305" title="utils/adt/selfuncs.c:4305">convert_to_scalar</a>()'s work for <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> bytea data type.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Very similar to <a href="#L4514" title="utils/adt/selfuncs.c:4514">convert_string_to_scalar</a> except we can't assume<br/></li>
<li></span><span class="Comment"> * null-termination and therefore pass explicit lengths around.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Also, assumptions about likely &quot;normal&quot; ranges of characters have been<br/></li>
<li></span><span class="Comment"> * removed - a data <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of 0..255 is always used, for <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.&nbsp; (Perhaps<br/></li>
<li></span><span class="Comment"> * someday we will add information about actual byte data <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> to<br/></li>
<li></span><span class="Comment"> * pg_statistic.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4726">&#x200c;</a></span><span class="linkable">convert_bytea_to_scalar</span>(Datum value,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span> *scaledvalue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum lobound,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span> *scaledlobound,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum hibound,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span> *scaledhibound)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *valuep = DatumGetByteaPP(value);<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *loboundp = DatumGetByteaPP(lobound);<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *hiboundp = DatumGetByteaPP(hibound);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rangelo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rangehi,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; valuelen = VARSIZE_ANY_EXHDR(valuep),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; loboundlen = VARSIZE_ANY_EXHDR(loboundp),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hiboundlen = VARSIZE_ANY_EXHDR(hiboundp),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; minlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> *valstr = (<span class="Type">unsigned</span> <span class="Type">char</span> *) VARDATA_ANY(valuep);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> *lostr = (<span class="Type">unsigned</span> <span class="Type">char</span> *) VARDATA_ANY(loboundp);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> *histr = (<span class="Type">unsigned</span> <span class="Type">char</span> *) VARDATA_ANY(hiboundp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Assume bytea data is uniformly distributed across all byte <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rangelo = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; rangehi = <span class="Constant">255</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now strip <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> common prefix of the three strings.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; minlen = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(<a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(valuelen, loboundlen), hiboundlen);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; minlen; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*lostr != *histr || *lostr != *valstr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lostr++, histr++, valstr++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; loboundlen--, hiboundlen--, valuelen--;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now we can do the conversions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; *scaledvalue = <a href="#L4774" title="utils/adt/selfuncs.c:4774">convert_one_bytea_to_scalar</a>(valstr, valuelen, rangelo, rangehi);<br/></li>
<li>&nbsp; &nbsp; *scaledlobound = <a href="#L4774" title="utils/adt/selfuncs.c:4774">convert_one_bytea_to_scalar</a>(lostr, loboundlen, rangelo, rangehi);<br/></li>
<li>&nbsp; &nbsp; *scaledhibound = <a href="#L4774" title="utils/adt/selfuncs.c:4774">convert_one_bytea_to_scalar</a>(histr, hiboundlen, rangelo, rangehi);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">double<br/></li>
<li><a id="L4774">&#x200c;</a></span><span class="linkable">convert_one_bytea_to_scalar</span>(<span class="Type">unsigned</span> <span class="Type">char</span> *value, <span class="Type">int</span> valuelen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> rangelo, <span class="Type">int</span> rangehi)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; num,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; denom,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; base;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (valuelen &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0.0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* empty string has scalar value 0 */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since base is 256, need not consider more than about 10 chars (even<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this many seems like overkill)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (valuelen &gt; <span class="Constant">10</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; valuelen = <span class="Constant">10</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Convert initial characters to fraction */<br/></li>
<li></span>&nbsp; &nbsp; base = rangehi - rangelo + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; num = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; denom = base;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (valuelen-- &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ch = *value++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ch &lt; rangelo)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ch = rangelo - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (ch &gt; rangehi)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ch = rangehi + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; num += ((<span class="Type">double</span>) (ch - rangelo)) / denom;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; denom *= base;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> num;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Do <a href="#L4305" title="utils/adt/selfuncs.c:4305">convert_to_scalar</a>()'s work for <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> timevalue data type.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On failure (e.g., unsupported typid), set *failure to true;<br/></li>
<li></span><span class="Comment"> * otherwise, that variable is not changed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">double<br/></li>
<li><a id="L4817">&#x200c;</a></span><span class="linkable">convert_timevalue_to_scalar</span>(Datum value, Oid typid, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *failure)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (typid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TIMESTAMPOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DatumGetTimestamp(value);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TIMESTAMPTZOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DatumGetTimestampTz(value);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DATEOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="date.c.html#L720" title="utils/adt/date.c:720">date2timestamp_no_overflow</a>(DatumGetDateADT(value));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERVALOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Interval&nbsp;&nbsp; *interval = DatumGetIntervalP(value);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Convert the month part of Interval to <a href="datetime.c.html#L84" title="utils/adt/datetime.c:84">days</a> using assumed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * average month length of 365.25/12.0 <a href="datetime.c.html#L84" title="utils/adt/datetime.c:84">days</a>.&nbsp; Not too<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * accurate, but plenty good enough for our purposes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This also works for infinite intervals, which just have all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fields set to INT_MIN/INT_MAX, and so will produce a result<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * smaller/larger than <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> finite interval.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> interval-&gt;time + interval-&gt;day * (<span class="Type">double</span>) USECS_PER_DAY +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; interval-&gt;month * ((DAYS_PER_YEAR / (<span class="Type">double</span>) MONTHS_PER_YEAR) * USECS_PER_DAY);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TIMEOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DatumGetTimeADT(value);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TIMETZOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimeTzADT&nbsp; *timetz = DatumGetTimeTzADTP(value);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* use GMT-equivalent time */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (<span class="Type">double</span>) (timetz-&gt;time + (timetz-&gt;zone * <span class="Constant">1000000.0</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *failure = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4883" title="utils/adt/selfuncs.c:4883">get_restriction_variable</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Examine the args of a restriction clause to see if it's of the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; form (variable op pseudoconstant) or (pseudoconstant op variable),<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; where &quot;variable&quot; could be either a Var or an expression in <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> of a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; single relation.&nbsp; If so, extract information about the variable,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; and also indicate which side it was on and the other argument.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Inputs:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; root: the <a href="../../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> info<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; args: clause argument list<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; varRelid: see specs for restriction selectivity <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Outputs: (these are valid only if true is returned)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; *vardata: gets information about variable (see <a href="#L5012" title="utils/adt/selfuncs.c:5012">examine_variable</a>)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; *other: gets other clause argument, aggressively reduced to a constant<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; *varonleft: set true if variable is on the left, false if on the right<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if a variable is identified, otherwise false.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: if there are Vars on both sides of the clause, we must fail, because<br/></li>
<li></span><span class="Comment"> * callers are expecting that the other side will act like a pseudoconstant.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L4883">&#x200c;</a></span><span class="linkable">get_restriction_variable</span>(PlannerInfo *root, List *args, <span class="Type">int</span> varRelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VariableStatData *vardata, Node **other,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *varonleft)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *left,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *right;<br/></li>
<li>&nbsp; &nbsp; VariableStatData rdata;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fail if not a binary opclause (probably shouldn't happen) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(args) != <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; left = (Node *) linitial(args);<br/></li>
<li>&nbsp; &nbsp; right = (Node *) lsecond(args);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Examine both sides.&nbsp; Note that when varRelid is nonzero, Vars of other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relations will be treated as pseudoconstants.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L5012" title="utils/adt/selfuncs.c:5012">examine_variable</a>(root, left, varRelid, vardata);<br/></li>
<li>&nbsp; &nbsp; <a href="#L5012" title="utils/adt/selfuncs.c:5012">examine_variable</a>(root, right, varRelid, &amp;rdata);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If one side is a variable and the other not, we win.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (vardata-&gt;rel &amp;&amp; rdata.rel == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *varonleft = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *other = <a href="../../optimizer/util/clauses.c.html#L2395" title="optimizer/util/clauses.c:2395">estimate_expression_value</a>(root, rdata.var);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Assume we need no ReleaseVariableStats(rdata) here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (vardata-&gt;rel == <span class="Constant">NULL</span> &amp;&amp; rdata.rel)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *varonleft = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *other = <a href="../../optimizer/util/clauses.c.html#L2395" title="optimizer/util/clauses.c:2395">estimate_expression_value</a>(root, vardata-&gt;var);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Assume we need no ReleaseVariableStats(*vardata) here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *vardata = rdata;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Oops, clause has wrong structure (probably var op var) */<br/></li>
<li></span>&nbsp; &nbsp; ReleaseVariableStats(*vardata);<br/></li>
<li>&nbsp; &nbsp; ReleaseVariableStats(rdata);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4943" title="utils/adt/selfuncs.c:4943">get_join_variables</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Apply <a href="#L5012" title="utils/adt/selfuncs.c:5012">examine_variable</a>() to each side of a join clause.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Also, attempt to identify whether the join clause has the same<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; or reversed sense compared to the SpecialJoinInfo.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We consider the join clause &quot;normal&quot; if it is &quot;lhs_var OP rhs_var&quot;,<br/></li>
<li></span><span class="Comment"> * or &quot;reversed&quot; if it is &quot;rhs_var OP lhs_var&quot;.&nbsp; In complicated cases<br/></li>
<li></span><span class="Comment"> * where we can't tell for sure, we default to assuming it's normal.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4943">&#x200c;</a></span><span class="linkable">get_join_variables</span>(PlannerInfo *root, List *args, SpecialJoinInfo *sjinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VariableStatData *vardata1, VariableStatData *vardata2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *join_is_reversed)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *left,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *right;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(args) != <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;join operator should take two arguments&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; left = (Node *) linitial(args);<br/></li>
<li>&nbsp; &nbsp; right = (Node *) lsecond(args);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L5012" title="utils/adt/selfuncs.c:5012">examine_variable</a>(root, left, <span class="Constant">0</span>, vardata1);<br/></li>
<li>&nbsp; &nbsp; <a href="#L5012" title="utils/adt/selfuncs.c:5012">examine_variable</a>(root, right, <span class="Constant">0</span>, vardata2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (vardata1-&gt;rel &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(vardata1-&gt;rel-&gt;relids, sjinfo-&gt;syn_righthand))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *join_is_reversed = <span class="Constant">true</span>;&nbsp; &nbsp; <span class="Comment">/* var1 is on RHS */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (vardata2-&gt;rel &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(vardata2-&gt;rel-&gt;relids, sjinfo-&gt;syn_lefthand))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *join_is_reversed = <span class="Constant">true</span>;&nbsp; &nbsp; <span class="Comment">/* var2 is on LHS */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *join_is_reversed = <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="../../statistics/extended_stats.c.html#L2425" title="statistics/extended_stats.c:2425">statext_expressions_load</a> copies the tuple, so just <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a> it. */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4971">&#x200c;</a></span><span class="linkable">ReleaseDummy</span>(HeapTuple tuple)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(tuple);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5012" title="utils/adt/selfuncs.c:5012">examine_variable</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Try to look up statistical data about an expression.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Fill in a VariableStatData struct to describe the expression.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Inputs:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; root: the <a href="../../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> info<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; node: the expression tree to examine<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; varRelid: see specs for restriction selectivity <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Outputs: *vardata is filled as follows:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; var: the input expression (with <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> binary relabeling stripped, if<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; it is or contains a variable; but otherwise the type is preserved)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; rel: RelOptInfo for relation containing variable; NULL if expression<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; contains no Vars (<a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a> this could point to a RelOptInfo of a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; subquery, not one in the current query).<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; statsTuple: the pg_statistic entry for the variable, if one exists;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; otherwise NULL.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; freefunc: pointer to a function to release statsTuple with.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; vartype: exposed type of the expression; this should always match<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; the declared input type of the operator we are estimating for.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; atttype, atttypmod: actual type/typmod of the &quot;var&quot; expression.&nbsp; This is<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; commonly the same as the exposed type of the variable argument,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; but can be different in binary-compatible-type cases.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; isunique: true if we were able to match the var to a unique index or a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; single-column DISTINCT clause, implying its <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are unique for<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; this query.&nbsp; (Caution: this should be trusted for statistical<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; purposes only, since we do not check indimmediate nor verify that<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; the exact same definition of equality applies.)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; acl_ok: true if current user has permission to read the column(s)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; underlying the pg_statistic entry.&nbsp; This is consulted by<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5735" title="utils/adt/selfuncs.c:5735">statistic_proc_security_check</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller is responsible for doing ReleaseVariableStats() <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> exiting.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L5012">&#x200c;</a></span><span class="linkable">examine_variable</span>(PlannerInfo *root, Node *node, <span class="Type">int</span> varRelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VariableStatData *vardata)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *basenode;<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; varnos;<br/></li>
<li>&nbsp; &nbsp; RelOptInfo *onerel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure we don't return dangling pointers in vardata */<br/></li>
<li></span>&nbsp; &nbsp; MemSet(vardata, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(VariableStatData));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Save the exposed type of the expression */<br/></li>
<li></span>&nbsp; &nbsp; vardata-&gt;vartype = <a href="../../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>(node);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Look inside <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> binary-compatible relabeling */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, RelabelType))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; basenode = (Node *) ((RelabelType *) node)-&gt;arg;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; basenode = node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fast path for a simple Var */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(basenode, Var) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (varRelid == <span class="Constant">0</span> || varRelid == ((Var *) basenode)-&gt;varno))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var = (Var *) basenode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set up result fields other than the stats tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; vardata-&gt;var = basenode;&nbsp; &nbsp; <span class="Comment">/* return Var without relabeling */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; vardata-&gt;rel = <a href="../../optimizer/util/relnode.c.html#L414" title="optimizer/util/relnode.c:414">find_base_rel</a>(root, var-&gt;varno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; vardata-&gt;atttype = var-&gt;vartype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; vardata-&gt;atttypmod = var-&gt;vartypmod;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; vardata-&gt;isunique = <a href="../../optimizer/util/plancat.c.html#L2191" title="optimizer/util/plancat.c:2191">has_unique_index</a>(vardata-&gt;rel, var-&gt;varattno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Try to locate some stats */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5406" title="utils/adt/selfuncs.c:5406">examine_simple_variable</a>(root, var, vardata);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Okay, it's a more complicated expression.&nbsp; Determine variable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * membership.&nbsp; Note that when varRelid isn't zero, only <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> of that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relation are considered &quot;real&quot; <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; varnos = <a href="../../optimizer/util/var.c.html#L108" title="optimizer/util/var.c:108">pull_varnos</a>(root, basenode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; onerel = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (bms_is_empty(varnos))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No Vars at all ... must be pseudo-constant clause */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L715" title="nodes/bitmapset.c:715">bms_get_singleton_member</a>(varnos, &amp;relid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (varRelid == <span class="Constant">0</span> || varRelid == relid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; onerel = <a href="../../optimizer/util/relnode.c.html#L414" title="optimizer/util/relnode.c:414">find_base_rel</a>(root, relid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vardata-&gt;rel = onerel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node = basenode;&nbsp; &nbsp; <span class="Comment">/* strip <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> relabeling */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* else treat it as a constant */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* varnos has multiple relids */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (varRelid == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* treat it as a variable of a join relation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vardata-&gt;rel = <a href="../../optimizer/util/relnode.c.html#L527" title="optimizer/util/relnode.c:527">find_join_rel</a>(root, varnos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node = basenode;&nbsp; &nbsp; <span class="Comment">/* strip <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> relabeling */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(varRelid, varnos))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ignore the <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> belonging to other relations */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vardata-&gt;rel = <a href="../../optimizer/util/relnode.c.html#L414" title="optimizer/util/relnode.c:414">find_base_rel</a>(root, varRelid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node = basenode;&nbsp; &nbsp; <span class="Comment">/* strip <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> relabeling */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* note: no point in expressional-index search here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* else treat it as a constant */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L239" title="nodes/bitmapset.c:239">bms_free</a>(varnos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; vardata-&gt;var = node;<br/></li>
<li>&nbsp; &nbsp; vardata-&gt;atttype = <a href="../../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>(node);<br/></li>
<li>&nbsp; &nbsp; vardata-&gt;atttypmod = <a href="../../nodes/nodeFuncs.c.html#L298" title="nodes/nodeFuncs.c:298">exprTypmod</a>(node);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (onerel)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have an expression in <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> of a single relation.&nbsp; Try to match<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it to expressional index columns, in hopes of finding some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * statistics.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that we consider all index columns including INCLUDE columns,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * since there could be stats for such columns.&nbsp; But the test for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * uniqueness needs to be warier.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> it's conceivable that there are multiple matches with different<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * index opfamilies; if so, we need to pick one that matches the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * operator we are estimating for.&nbsp; </span><span class="Todo">FIXME</span><span class="Comment"> later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *ilist;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *slist;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; userid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Determine the user ID to use for privilege checks: either<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * onerel-&gt;userid if it's set (e.g., in case we're accessing the table<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * via a view), or the current user otherwise.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we drill down to child relations, we keep using the same userid:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it's going to be the same anyway, due to how we set up the relation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tree (q.v. <a href="../../optimizer/util/relnode.c.html#L192" title="optimizer/util/relnode.c:192">build_simple_rel</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; userid = OidIsValid(onerel-&gt;userid) ? onerel-&gt;userid : <a href="../init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(ilist, onerel-&gt;indexlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexOptInfo *index = (IndexOptInfo *) lfirst(ilist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *indexpr_item;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexpr_item = list_head(index-&gt;indexprs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (indexpr_item == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no expressions here... */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (pos = <span class="Constant">0</span>; pos &lt; index-&gt;ncolumns; pos++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (index-&gt;indexkeys[pos] == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *indexkey;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (indexpr_item == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;too few entries in indexprs list&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexkey = (Node *) lfirst(indexpr_item);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (indexkey &amp;&amp; IsA(indexkey, RelabelType))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexkey = (Node *) ((RelabelType *) indexkey)-&gt;arg;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(node, indexkey))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Found a match ... is it a unique index? Tests here<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * should match <a href="../../optimizer/util/plancat.c.html#L2191" title="optimizer/util/plancat.c:2191">has_unique_index</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (index-&gt;unique &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index-&gt;nkeycolumns == <span class="Constant">1</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pos == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (index-&gt;indpred == NIL || index-&gt;predOK))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vardata-&gt;isunique = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Has it got stats?&nbsp; We only consider stats for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * non-partial indexes, since partial indexes probably<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't reflect whole-relation statistics; the above<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * check for uniqueness is the only info we take from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a partial index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * An index stats hook, however, must make its own<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * decisions about what to do with partial indexes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L148" title="utils/adt/selfuncs.c:148">get_index_stats_hook</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (*<a href="#L148" title="utils/adt/selfuncs.c:148">get_index_stats_hook</a>) (root, index-&gt;indexoid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pos + <span class="Constant">1</span>, vardata))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The hook took control of acquiring a stats<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple.&nbsp; If it did supply a tuple, it'd better<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have supplied a freefunc.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(vardata-&gt;statsTuple) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !vardata-&gt;freefunc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;no function provided to release variable stats with&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (index-&gt;indpred == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vardata-&gt;statsTuple =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/syscache.c.html#L240" title="utils/cache/syscache.c:240">SearchSysCache3</a>(STATRELATTINH,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(index-&gt;indexoid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Int16GetDatum(pos + <span class="Constant">1</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BoolGetDatum(<span class="Constant">false</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vardata-&gt;freefunc = <a href="../cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(vardata-&gt;statsTuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get index's table for permission check */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rte = planner_rt_fetch(index-&gt;rel-&gt;relid, root);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(rte-&gt;rtekind == RTE_RELATION);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For simplicity, we insist on the whole<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * table being selectable, rather than trying<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to identify which column(s) the index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * depends on.&nbsp; Also require all rows to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * selectable --- there must be no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * securityQuals from security barrier views<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * or RLS policies.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vardata-&gt;acl_ok =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rte-&gt;securityQuals == NIL &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../catalog/aclchk.c.html#L4079" title="catalog/aclchk.c:4079">pg_class_aclcheck</a>(rte-&gt;relid, userid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ACL_SELECT) == ACLCHECK_OK);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the user doesn't have permissions to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * access an inheritance child relation, check<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the permissions of the table actually<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * mentioned in the query, since most likely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the user does have that permission.&nbsp; Note<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that whole-table <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> privilege on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * parent doesn't quite guarantee that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * user could read all columns of the child.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * But in practice it's unlikely that <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * interesting security violation could result<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * from allowing access to the expression<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * index's stats, so we allow it anyway.&nbsp; See<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * similar code in <a href="#L5406" title="utils/adt/selfuncs.c:5406">examine_simple_variable</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for additional comments.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!vardata-&gt;acl_ok &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;append_rel_array != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AppendRelInfo *appinfo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; varno = index-&gt;rel-&gt;relid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appinfo = root-&gt;append_rel_array[varno];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (appinfo &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; planner_rt_fetch(appinfo-&gt;parent_relid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root)-&gt;rtekind == RTE_RELATION)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; varno = appinfo-&gt;parent_relid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appinfo = root-&gt;append_rel_array[varno];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (varno != index-&gt;rel-&gt;relid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Repeat access check on this rel */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rte = planner_rt_fetch(varno, root);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(rte-&gt;rtekind == RTE_RELATION);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vardata-&gt;acl_ok =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rte-&gt;securityQuals == NIL &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../catalog/aclchk.c.html#L4079" title="catalog/aclchk.c:4079">pg_class_aclcheck</a>(rte-&gt;relid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; userid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ACL_SELECT) == ACLCHECK_OK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* suppress leakproofness checks later */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vardata-&gt;acl_ok = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (vardata-&gt;statsTuple)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexpr_item = lnext(index-&gt;indexprs, indexpr_item);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (vardata-&gt;statsTuple)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Search extended statistics for one with a matching expression.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There might be multiple ones, so just grab the first one. In the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * future, we might consider the statistics target (and pick the most<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * accurate statistics) and maybe some other parameters.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(slist, onerel-&gt;statlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StatisticExtInfo *info = (StatisticExtInfo *) lfirst(slist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte = planner_rt_fetch(onerel-&gt;relid, root);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *expr_item;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Stop once we've found statistics for the expression (either<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * from extended stats, or for an index in the preceding loop).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (vardata-&gt;statsTuple)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> stats without per-expression stats */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (info-&gt;kind != STATS_EXT_EXPRESSIONS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> stats with mismatching stxdinherit value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (info-&gt;inherit != rte-&gt;inh)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pos = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(expr_item, info-&gt;exprs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *expr = (Node *) lfirst(expr_item);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(expr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* strip RelabelType <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> comparing it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (expr &amp;&amp; IsA(expr, RelabelType))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expr = (Node *) ((RelabelType *) expr)-&gt;arg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* found a match, see if we can extract pg_statistic row */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(node, expr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> Not sure if we should cache the tuple somewhere.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now we just create a new copy every time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vardata-&gt;statsTuple =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../statistics/extended_stats.c.html#L2425" title="statistics/extended_stats.c:2425">statext_expressions_load</a>(info-&gt;statOid, rte-&gt;inh, pos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vardata-&gt;freefunc = <a href="#L4971" title="utils/adt/selfuncs.c:4971">ReleaseDummy</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For simplicity, we insist on the whole table being<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * selectable, rather than trying to identify which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * column(s) the statistics object depends on.&nbsp; Also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * require all rows to be selectable --- there must be no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * securityQuals from security barrier views or RLS<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * policies.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vardata-&gt;acl_ok =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rte-&gt;securityQuals == NIL &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../catalog/aclchk.c.html#L4079" title="catalog/aclchk.c:4079">pg_class_aclcheck</a>(rte-&gt;relid, userid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ACL_SELECT) == ACLCHECK_OK);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the user doesn't have permissions to access an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * inheritance child relation, check the permissions of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the table actually mentioned in the query, since most<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * likely the user does have that permission.&nbsp; Note that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * whole-table <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> privilege on the parent doesn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * quite guarantee that the user could read all columns of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the child. But in practice it's unlikely that <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * interesting security violation could result from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * allowing access to the expression stats, so we allow it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * anyway.&nbsp; See similar code in <a href="#L5406" title="utils/adt/selfuncs.c:5406">examine_simple_variable</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for additional comments.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!vardata-&gt;acl_ok &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;append_rel_array != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AppendRelInfo *appinfo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; varno = onerel-&gt;relid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appinfo = root-&gt;append_rel_array[varno];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (appinfo &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; planner_rt_fetch(appinfo-&gt;parent_relid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root)-&gt;rtekind == RTE_RELATION)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; varno = appinfo-&gt;parent_relid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appinfo = root-&gt;append_rel_array[varno];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (varno != onerel-&gt;relid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Repeat access check on this rel */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rte = planner_rt_fetch(varno, root);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(rte-&gt;rtekind == RTE_RELATION);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vardata-&gt;acl_ok =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rte-&gt;securityQuals == NIL &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../catalog/aclchk.c.html#L4079" title="catalog/aclchk.c:4079">pg_class_aclcheck</a>(rte-&gt;relid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; userid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ACL_SELECT) == ACLCHECK_OK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pos++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5406" title="utils/adt/selfuncs.c:5406">examine_simple_variable</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Handle a simple Var for <a href="#L5012" title="utils/adt/selfuncs.c:5012">examine_variable</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is split out as a subroutine so that we can recurse to deal with<br/></li>
<li></span><span class="Comment"> * Vars referencing subqueries (either sub-SELECT-in-FROM or CTE style).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We already filled in all the fields of *vardata except for the stats tuple.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L5406">&#x200c;</a></span><span class="linkable">examine_simple_variable</span>(PlannerInfo *root, Var *var,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VariableStatData *vardata)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeTblEntry *rte = root-&gt;simple_rte_array[var-&gt;varno];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(IsA(rte, RangeTblEntry));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L147" title="utils/adt/selfuncs.c:147">get_relation_stats_hook</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (*<a href="#L147" title="utils/adt/selfuncs.c:147">get_relation_stats_hook</a>) (root, rte, var-&gt;varattno, vardata))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The hook took control of acquiring a stats tuple.&nbsp; If it did supply<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a tuple, it'd better have supplied a freefunc.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(vardata-&gt;statsTuple) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !vardata-&gt;freefunc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;no function provided to release variable stats with&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (rte-&gt;rtekind == RTE_RELATION)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Plain table or parent of an inheritance appendrel, so look up the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * column in pg_statistic<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; vardata-&gt;statsTuple = <a href="../cache/syscache.c.html#L240" title="utils/cache/syscache.c:240">SearchSysCache3</a>(STATRELATTINH,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(rte-&gt;relid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Int16GetDatum(var-&gt;varattno),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BoolGetDatum(rte-&gt;inh));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; vardata-&gt;freefunc = <a href="../cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(vardata-&gt;statsTuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *onerel = <a href="../../optimizer/util/relnode.c.html#L436" title="optimizer/util/relnode.c:436">find_base_rel_noerr</a>(root, var-&gt;varno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; userid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check if user has permission to read this column.&nbsp; We require<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * all rows to be accessible, so there must be no securityQuals<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * from security barrier views or RLS policies.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Normally the Var will have an associated RelOptInfo from which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we can <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> out which userid to do the check as; but it might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not if it's a RETURNING Var for an INSERT target relation.&nbsp; In<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that case use the RTEPermissionInfo associated with the RTE.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (onerel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; userid = onerel-&gt;userid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RTEPermissionInfo *perminfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perminfo = <a href="../../parser/parse_relation.c.html#L3903" title="parser/parse_relation.c:3903">getRTEPermissionInfo</a>(root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;rteperminfos, rte);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; userid = perminfo-&gt;checkAsUser;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(userid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; userid = <a href="../init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vardata-&gt;acl_ok =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rte-&gt;securityQuals == NIL &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((<a href="../../catalog/aclchk.c.html#L4079" title="catalog/aclchk.c:4079">pg_class_aclcheck</a>(rte-&gt;relid, userid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ACL_SELECT) == ACLCHECK_OK) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<a href="../../catalog/aclchk.c.html#L3908" title="catalog/aclchk.c:3908">pg_attribute_aclcheck</a>(rte-&gt;relid, var-&gt;varattno, userid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ACL_SELECT) == ACLCHECK_OK));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the user doesn't have permissions to access an inheritance<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * child relation or specifically this attribute, check the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * permissions of the table/column actually mentioned in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * query, since most likely the user does have that permission<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (else the query will fail at runtime), and if the user can read<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the column there then he can get the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of the child table<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * too.&nbsp; To do that, we must <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> out which of the root parent's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * attributes the child relation's attribute corresponds to.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!vardata-&gt;acl_ok &amp;&amp; var-&gt;varattno &gt; <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;append_rel_array != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AppendRelInfo *appinfo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; varno = var-&gt;varno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; varattno = var-&gt;varattno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appinfo = root-&gt;append_rel_array[varno];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Partitions are mapped to their immediate parent, not the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * root parent, so must be ready to walk up multiple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * AppendRelInfos.&nbsp; But stop if we hit a parent that is not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * RTE_RELATION --- that's a flattened UNION ALL subquery, not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * an inheritance parent.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (appinfo &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; planner_rt_fetch(appinfo-&gt;parent_relid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root)-&gt;rtekind == RTE_RELATION)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parent_varattno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (varattno &lt;= <span class="Constant">0</span> || varattno &gt; appinfo-&gt;num_child_cols)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; <span class="Comment">/* safety check */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parent_varattno = appinfo-&gt;parent_colnos[varattno - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (parent_varattno == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; <span class="Comment">/* Var is local to child */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; varno = appinfo-&gt;parent_relid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; varattno = parent_varattno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If the parent is itself a child, continue up. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appinfo = root-&gt;append_rel_array[varno];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In rare cases, the Var may be local to the child table, in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * which case, we've got to live with having no access to this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * column's stats.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Repeat the access check on this parent rel &amp; column */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rte = planner_rt_fetch(varno, root);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(rte-&gt;rtekind == RTE_RELATION);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Fine to use the same userid as it's the same in all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relations of a given inheritance tree.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vardata-&gt;acl_ok =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rte-&gt;securityQuals == NIL &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((<a href="../../catalog/aclchk.c.html#L4079" title="catalog/aclchk.c:4079">pg_class_aclcheck</a>(rte-&gt;relid, userid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ACL_SELECT) == ACLCHECK_OK) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<a href="../../catalog/aclchk.c.html#L3908" title="catalog/aclchk.c:3908">pg_attribute_aclcheck</a>(rte-&gt;relid, varattno, userid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ACL_SELECT) == ACLCHECK_OK));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* suppress <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> possible leakproofness checks later */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vardata-&gt;acl_ok = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> ((rte-&gt;rtekind == RTE_SUBQUERY &amp;&amp; !rte-&gt;inh) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (rte-&gt;rtekind == RTE_CTE &amp;&amp; !rte-&gt;self_reference))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Plain subquery (not one that was converted to an appendrel) or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * non-recursive CTE.&nbsp; In either case, we can try to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> out what the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Var refers to within the subquery.&nbsp; We <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> this for appendrel and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * recursive-CTE cases because <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> column stats we did <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * likely not be very relevant.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PlannerInfo *subroot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *subquery;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *subtlist;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *ste;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Punt if it's a whole-row var rather than a plain column reference.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;varattno == InvalidAttrNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise, <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the subquery's <a href="../../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> subroot.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rte-&gt;rtekind == RTE_SUBQUERY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *rel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Fetch RelOptInfo for subquery.&nbsp; Note that we don't change the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rel returned in vardata, since caller expects it to be a rel of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the caller's query level.&nbsp; Because we might already be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * recursing, we can't use that rel pointer either, but have to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * look up the Var's rel afresh.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel = <a href="../../optimizer/util/relnode.c.html#L414" title="optimizer/util/relnode.c:414">find_base_rel</a>(root, var-&gt;varno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subroot = rel-&gt;subroot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* CTE case is more difficult */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PlannerInfo *cteroot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; levelsup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndx;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan_id;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Find the referenced CTE, and locate the subroot previously made<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; levelsup = rte-&gt;ctelevelsup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cteroot = root;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (levelsup-- &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cteroot = cteroot-&gt;parent_root;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!cteroot)&nbsp; &nbsp; <span class="Comment">/* shouldn't happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;bad levelsup for CTE </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, rte-&gt;ctename);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: cte_plan_ids can be shorter than cteList, if we are still<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * working on planning the CTEs (ie, this is a side-reference from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * another CTE).&nbsp; So we mustn't use forboth here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndx = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, cteroot-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;cteList)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CommonTableExpr *cte = (CommonTableExpr *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(cte-&gt;ctename, rte-&gt;ctename) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndx++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lc == <span class="Constant">NULL</span>)&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* shouldn't happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> CTE </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, rte-&gt;ctename);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ndx &gt;= list_length(cteroot-&gt;cte_plan_ids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> plan for CTE </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, rte-&gt;ctename);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan_id = list_nth_int(cteroot-&gt;cte_plan_ids, ndx);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (plan_id &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;no plan was made for CTE </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, rte-&gt;ctename);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subroot = list_nth(root-&gt;glob-&gt;subroots, plan_id - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If the subquery hasn't been planned yet, we have to punt */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subroot == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(IsA(subroot, PlannerInfo));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We must use the subquery parsetree as mangled by the <a href="../../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a>, not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the raw version from the RTE, because we need a Var that will refer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to the subroot's live RelOptInfos.&nbsp; For instance, if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> subquery<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pullup happened during planning, Vars in the targetlist might have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * gotten replaced, and we need to see the replacement expressions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; subquery = subroot-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(IsA(subquery, Query));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Punt if subquery uses set operations or GROUP BY, as these will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * mash underlying columns' stats beyond recognition.&nbsp; (Set ops are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * particularly nasty; if we forged ahead, we would return stats<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relevant to only the leftmost subselect...)&nbsp; &nbsp; DISTINCT is also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * problematic, but we check that later because there is a possibility<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of learning something even with it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subquery-&gt;setOperations ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subquery-&gt;groupClause ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subquery-&gt;groupingSets)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get the subquery output expression referenced by the <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> Var */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subquery-&gt;returningList)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subtlist = subquery-&gt;returningList;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subtlist = subquery-&gt;targetList;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ste = <a href="../../parser/parse_relation.c.html#L3439" title="parser/parse_relation.c:3439">get_tle_by_resno</a>(subtlist, var-&gt;varattno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ste == <span class="Constant">NULL</span> || ste-&gt;resjunk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;subquery </span><span class="Special">%s</span><span class="Constant"> does not have attribute </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rte-&gt;eref-&gt;aliasname, var-&gt;varattno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; var = (Var *) ste-&gt;expr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If subquery uses DISTINCT, we can't make use of <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> stats for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * variable ... but, if it's the only DISTINCT column, we are entitled<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to consider it unique.&nbsp; We do the test this way so that it works<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for cases involving DISTINCT ON.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subquery-&gt;distinctClause)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (list_length(subquery-&gt;distinctClause) == <span class="Constant">1</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../parser/parse_clause.c.html#L3633" title="parser/parse_clause.c:3633">targetIsInSortList</a>(ste, InvalidOid, subquery-&gt;distinctClause))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vardata-&gt;isunique = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* cannot go further */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the sub-query originated from a view with the security_barrier<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * attribute, we must not look at the variable's statistics, though it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * seems all right to notice the existence of a DISTINCT clause. So<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * stop here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is probably a harsher restriction than necessary; it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * certainly OK for the selectivity estimator (which is a C function,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and therefore omnipotent anyway) to look at the statistics.&nbsp; But<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * many selectivity estimators will happily *invoke the operator<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * function* to try to work out a good estimate - and that's not OK.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * So for <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, don't dig down for stats.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rte-&gt;security_barrier)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Can only handle a simple Var of subquery's query level */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var &amp;&amp; IsA(var, Var) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varlevelsup == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * OK, recurse into the subquery.&nbsp; Note that the original setting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of vardata-&gt;isunique (which will surely be false) is left<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unchanged in this situation.&nbsp; That's what we want, since even<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if the underlying column is unique, the subquery may have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * joined to other tables in a way that creates duplicates.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5406" title="utils/adt/selfuncs.c:5406">examine_simple_variable</a>(subroot, var, vardata);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise, the Var comes from a FUNCTION or VALUES RTE.&nbsp; (We won't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * see RTE_JOIN here because join alias Vars have already been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * flattened.)&nbsp; &nbsp; There's not much we can do with function outputs, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * maybe someday try to be smarter about VALUES.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check whether it is permitted to call func_oid passing some of the<br/></li>
<li></span><span class="Comment"> * pg_statistic data in vardata.&nbsp; We allow this either if the user has SELECT<br/></li>
<li></span><span class="Comment"> * privileges on the table or column underlying the pg_statistic data or if<br/></li>
<li></span><span class="Comment"> * the function is marked leak-proof.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L5735">&#x200c;</a></span><span class="linkable">statistic_proc_security_check</span>(VariableStatData *vardata, Oid func_oid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (vardata-&gt;acl_ok)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(func_oid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../cache/lsyscache.c.html#L1837" title="utils/cache/lsyscache.c:1837">get_func_leakproof</a>(func_oid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereport(DEBUG2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;not using statistics because function </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not leak-proof&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../cache/lsyscache.c.html#L1608" title="utils/cache/lsyscache.c:1608">get_func_name</a>(func_oid))));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5764" title="utils/adt/selfuncs.c:5764">get_variable_numdistinct</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Estimate the number of distinct <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of a variable.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * vardata: results of <a href="#L5012" title="utils/adt/selfuncs.c:5012">examine_variable</a><br/></li>
<li></span><span class="Comment"> * *isdefault: set to true if the result is a default rather than based on<br/></li>
<li></span><span class="Comment"> * anything meaningful.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: be careful to produce a positive integral result, since callers may<br/></li>
<li></span><span class="Comment"> * <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> the result to exact integer counts, or might divide by it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">double<br/></li>
<li><a id="L5764">&#x200c;</a></span><span class="linkable">get_variable_numdistinct</span>(VariableStatData *vardata, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isdefault)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; stadistinct;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; stanullfrac = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; ntuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *isdefault = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine the stadistinct value to use.&nbsp; There are cases where we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * get an estimate even without a pg_statistic entry, or can get a better<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * value than is in pg_statistic.&nbsp; Grab stanullfrac too if we can <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (otherwise, assume no nulls, for lack of <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> better idea).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(vardata-&gt;statsTuple))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Use the pg_statistic entry */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_statistic stats;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stats = (Form_pg_statistic) GETSTRUCT(vardata-&gt;statsTuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stadistinct = stats-&gt;stadistinct;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stanullfrac = stats-&gt;stanullfrac;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (vardata-&gt;vartype == BOOLOID)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Special-case boolean columns: presumably, two distinct <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Are there <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other datatypes we should wire in special estimates<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; stadistinct = <span class="Constant">2.0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (vardata-&gt;rel &amp;&amp; vardata-&gt;rel-&gt;rtekind == RTE_VALUES)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the Var represents a column of a VALUES RTE, assume it's unique.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This could of course be very wrong, but it should tend to be true<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in well-written queries.&nbsp; We could consider examining the VALUES'<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * contents to get some real statistics; but that only works if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entries are all constants, and it would be pretty expensive anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; stadistinct = -<span class="Constant">1.0</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* unique (and all non null) */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't keep statistics for system columns, but in some cases we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can infer distinctness anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (vardata-&gt;var &amp;&amp; IsA(vardata-&gt;var, Var))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (((Var *) vardata-&gt;var)-&gt;varattno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SelfItemPointerAttributeNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stadistinct = -<span class="Constant">1.0</span>; <span class="Comment">/* unique (and all non null) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TableOidAttributeNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stadistinct = <span class="Constant">1.0</span>;&nbsp; &nbsp; <span class="Comment">/* only 1 value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stadistinct = <span class="Constant">0.0</span>;&nbsp; &nbsp; <span class="Comment">/* means &quot;unknown&quot; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stadistinct = <span class="Constant">0.0</span>;&nbsp; &nbsp; <span class="Comment">/* means &quot;unknown&quot; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> consider using <a href="#L3416" title="utils/adt/selfuncs.c:3416">estimate_num_groups</a> on expressions?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there is a unique index or DISTINCT clause for the variable, assume<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it is unique no matter what pg_statistic says; the statistics could be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * out of date, or we might have found a partial unique index that proves<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the var is unique for this query.&nbsp; However, we'd better still believe<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the null-fraction statistic.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (vardata-&gt;isunique)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stadistinct = -<span class="Constant">1.0</span> * (<span class="Constant">1.0</span> - stanullfrac);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we had an absolute estimate, use that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stadistinct &gt; <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../optimizer/path/costsize.c.html#L202" title="optimizer/path/costsize.c:202">clamp_row_est</a>(stadistinct);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Otherwise we need to get the relation size; punt if not available.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (vardata-&gt;rel == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *isdefault = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DEFAULT_NUM_DISTINCT;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; ntuples = vardata-&gt;rel-&gt;tuples;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ntuples &lt;= <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *isdefault = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DEFAULT_NUM_DISTINCT;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we had a relative estimate, use that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stadistinct &lt; <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../optimizer/path/costsize.c.html#L202" title="optimizer/path/costsize.c:202">clamp_row_est</a>(-stadistinct * ntuples);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * With no data, estimate ndistinct = ntuples if the table is small, else<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * use default.&nbsp; We use DEFAULT_NUM_DISTINCT as the cutoff for &quot;small&quot; so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that the behavior isn't discontinuous.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ntuples &lt; DEFAULT_NUM_DISTINCT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../optimizer/path/costsize.c.html#L202" title="optimizer/path/costsize.c:202">clamp_row_est</a>(ntuples);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *isdefault = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> DEFAULT_NUM_DISTINCT;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5897" title="utils/adt/selfuncs.c:5897">get_variable_range</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Estimate the minimum and maximum value of the specified variable.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; If successful, store <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in *min and *max, and return true.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; If no data available, return false.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * sortop is the &quot;&lt;&quot; comparison operator to use.&nbsp; This should generally<br/></li>
<li></span><span class="Comment"> * be &quot;&lt;&quot; not &quot;&gt;&quot;, as only the former is likely to be found in pg_statistic.<br/></li>
<li></span><span class="Comment"> * The collation must be specified too.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L5897">&#x200c;</a></span><span class="linkable">get_variable_range</span>(PlannerInfo *root, VariableStatData *vardata,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid sortop, Oid collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum *min, Datum *max)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; tmin = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; tmax = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; have_data = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; typLen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; typByVal;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opfuncoid;<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; opproc;<br/></li>
<li>&nbsp; &nbsp; AttStatsSlot sslot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> It's very tempting to try to use the actual column min and max, if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we can get them relatively-cheaply with an index probe.&nbsp; However, since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this function is called many times during join planning, that could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have unpleasant effects on planning speed.&nbsp; Need more investigation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> enabling this.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef NOT_USED<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L6087" title="utils/adt/selfuncs.c:6087">get_actual_variable_range</a>(root, vardata, sortop, collation, min, max))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(vardata-&gt;statsTuple))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no stats available, so default result */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we can't apply the sortop to the stats data, just fail.&nbsp; In<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * principle, if there's a histogram and no MCVs, we could return the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * histogram endpoints without ever applying the sortop ... but it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * probably not worth trying, because whatever the caller wants to do with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the endpoints would likely fail the security check too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L5735" title="utils/adt/selfuncs.c:5735">statistic_proc_security_check</a>(vardata,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (opfuncoid = <a href="../cache/lsyscache.c.html#L1285" title="utils/cache/lsyscache.c:1285">get_opcode</a>(sortop))))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; opproc.fn_oid = InvalidOid; <span class="Comment">/* mark this as not looked up yet */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L2251" title="utils/cache/lsyscache.c:2251">get_typlenbyval</a>(vardata-&gt;atttype, &amp;typLen, &amp;typByVal);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there is a histogram with the ordering we want, grab the first and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * last <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../cache/lsyscache.c.html#L3234" title="utils/cache/lsyscache.c:3234">get_attstatsslot</a>(&amp;sslot, vardata-&gt;statsTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; STATISTIC_KIND_HISTOGRAM, sortop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ATTSTATSSLOT_VALUES))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sslot.stacoll == collation &amp;&amp; sslot.nvalues &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmin = <a href="datum.c.html#L132" title="utils/adt/datum.c:132">datumCopy</a>(sslot.<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">0</span>], typByVal, typLen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmax = <a href="datum.c.html#L132" title="utils/adt/datum.c:132">datumCopy</a>(sslot.<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[sslot.nvalues - <span class="Constant">1</span>], typByVal, typLen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; have_data = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L3344" title="utils/cache/lsyscache.c:3344">free_attstatsslot</a>(&amp;sslot);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Otherwise, if there is a histogram with some other ordering, scan it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and get the min and max <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> according to the ordering we want.&nbsp; This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of course may not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> that are really extremal according to our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ordering, but it beats ignoring available data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!have_data &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L3234" title="utils/cache/lsyscache.c:3234">get_attstatsslot</a>(&amp;sslot, vardata-&gt;statsTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; STATISTIC_KIND_HISTOGRAM, InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ATTSTATSSLOT_VALUES))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6024" title="utils/adt/selfuncs.c:6024">get_stats_slot_range</a>(&amp;sslot, opfuncoid, &amp;opproc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; collation, typLen, typByVal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;tmin, &amp;tmax, &amp;have_data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L3344" title="utils/cache/lsyscache.c:3344">free_attstatsslot</a>(&amp;sslot);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we have most-common-<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> info, look for extreme MCVs.&nbsp; This is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * needed even if we also have a histogram, since the histogram excludes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the MCVs.&nbsp; However, if we *only* have MCVs and no histogram, we should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be pretty wary of deciding that that is a full representation of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * data.&nbsp; Proceed only if the MCVs represent the whole table (to within<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * roundoff error).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../cache/lsyscache.c.html#L3234" title="utils/cache/lsyscache.c:3234">get_attstatsslot</a>(&amp;sslot, vardata-&gt;statsTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; STATISTIC_KIND_MCV, InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; have_data ? ATTSTATSSLOT_VALUES :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; use_mcvs = have_data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!have_data)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; sumcommon = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; nullfrac;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; sslot.nnumbers; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sumcommon += sslot.numbers[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nullfrac = ((Form_pg_statistic) GETSTRUCT(vardata-&gt;statsTuple))-&gt;stanullfrac;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sumcommon + nullfrac &gt; <span class="Constant">0.99999</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; use_mcvs = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (use_mcvs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6024" title="utils/adt/selfuncs.c:6024">get_stats_slot_range</a>(&amp;sslot, opfuncoid, &amp;opproc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; collation, typLen, typByVal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;tmin, &amp;tmax, &amp;have_data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L3344" title="utils/cache/lsyscache.c:3344">free_attstatsslot</a>(&amp;sslot);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *min = tmin;<br/></li>
<li>&nbsp; &nbsp; *max = tmax;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> have_data;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6024" title="utils/adt/selfuncs.c:6024">get_stats_slot_range</a>: scan sslot for min/max <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Subroutine for <a href="#L5897" title="utils/adt/selfuncs.c:5897">get_variable_range</a>: update min/max/have_data according<br/></li>
<li></span><span class="Comment"> * to what we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> in the statistics array.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L6024">&#x200c;</a></span><span class="linkable">get_stats_slot_range</span>(AttStatsSlot *sslot, Oid opfuncoid, FmgrInfo *opproc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid collation, int16 typLen, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> typByVal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum *min, Datum *max, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *p_have_data)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; tmin = *min;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; tmax = *max;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; have_data = *p_have_data;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found_tmin = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found_tmax = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Look up the comparison function, if we didn't already do so */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (opproc-&gt;fn_oid != opfuncoid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../fmgr/fmgr.c.html#L127" title="utils/fmgr/fmgr.c:127">fmgr_info</a>(opfuncoid, opproc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Scan all the slot's <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; sslot-&gt;nvalues; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!have_data)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmin = tmax = sslot-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found_tmin = found_tmax = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *p_have_data = have_data = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (DatumGetBool(<a href="../fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(opproc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sslot-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i], tmin)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmin = sslot-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found_tmin = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (DatumGetBool(<a href="../fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(opproc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tmax, sslot-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i])))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmax = sslot-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found_tmax = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Copy the slot's <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, if we found new extreme <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (found_tmin)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *min = <a href="datum.c.html#L132" title="utils/adt/datum.c:132">datumCopy</a>(tmin, typByVal, typLen);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (found_tmax)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *max = <a href="datum.c.html#L132" title="utils/adt/datum.c:132">datumCopy</a>(tmax, typByVal, typLen);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6087" title="utils/adt/selfuncs.c:6087">get_actual_variable_range</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Attempt to identify the current *actual* minimum and/or maximum<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; of the specified variable, by looking for a suitable btree index<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; and fetching its low and/or high <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; If successful, store <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in *min and *max, and return true.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; (Either pointer can be NULL if that endpoint isn't needed.)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; If unsuccessful, return false.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * sortop is the &quot;&lt;&quot; comparison operator to use.<br/></li>
<li></span><span class="Comment"> * collation is the required collation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L6087">&#x200c;</a></span><span class="linkable">get_actual_variable_range</span>(PlannerInfo *root, VariableStatData *vardata,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid sortop, Oid collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum *min, Datum *max)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; have_data = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; RelOptInfo *rel = vardata-&gt;rel;<br/></li>
<li>&nbsp; &nbsp; RangeTblEntry *rte;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No hope if no relation or it doesn't have indexes */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel == <span class="Constant">NULL</span> || rel-&gt;indexlist == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If it has indexes it must be a plain relation */<br/></li>
<li></span>&nbsp; &nbsp; rte = root-&gt;simple_rte_array[rel-&gt;relid];<br/></li>
<li>&nbsp; &nbsp; Assert(rte-&gt;rtekind == RTE_RELATION);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ignore partitioned tables.&nbsp; Any indexes here are not real indexes */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rte-&gt;relkind == RELKIND_PARTITIONED_TABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Search through the indexes to see if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> match our problem */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, rel-&gt;indexlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexOptInfo *index = (IndexOptInfo *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ScanDirection indexscandir;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore non-btree indexes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (index-&gt;relam != BTREE_AM_OID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ignore partial indexes --- we only want stats that cover the entire<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (index-&gt;indpred != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The index list might include hypothetical indexes inserted by a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../optimizer/util/plancat.c.html#L115" title="optimizer/util/plancat.c:115">get_relation_info</a> hook --- don't try to access them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (index-&gt;hypothetical)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The first index column must match the desired variable, sortop, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * collation --- but we can use a descending-order index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (collation != index-&gt;indexcollations[<span class="Constant">0</span>])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* test first 'cause it's cheapest */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../optimizer/path/indxpath.c.html#L3704" title="optimizer/path/indxpath.c:3704">match_index_to_operand</a>(vardata-&gt;var, <span class="Constant">0</span>, index))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (<a href="../cache/lsyscache.c.html#L83" title="utils/cache/lsyscache.c:83">get_op_opfamily_strategy</a>(sortop, index-&gt;sortopfamily[<span class="Constant">0</span>]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTLessStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (index-&gt;reverse_sort[<span class="Constant">0</span>])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexscandir = BackwardScanDirection;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexscandir = ForwardScanDirection;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTGreaterStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (index-&gt;reverse_sort[<span class="Constant">0</span>])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexscandir = ForwardScanDirection;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexscandir = BackwardScanDirection;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* index doesn't match the sortop */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Found a suitable index to extract data from.&nbsp; Set up some data that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can be used by both invocations of <a href="#L6267" title="utils/adt/selfuncs.c:6267">get_actual_variable_endpoint</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContext tmpcontext;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; heapRel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; indexRel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot *slot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; typLen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; typByVal;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ScanKeyData scankeys[<span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make sure <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> cruft gets recycled when we're done */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmpcontext = AllocSetContextCreate(<a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;<a href="#L6087" title="utils/adt/selfuncs.c:6087">get_actual_variable_range</a> workspace&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(tmpcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Open the table and index so we can read from them.&nbsp; We should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already have some type of lock on each.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; heapRel = <a href="../../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(rte-&gt;relid, NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexRel = <a href="../../access/index/indexam.c.html#L133" title="access/index/indexam.c:133">index_open</a>(index-&gt;indexoid, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* build some stuff needed for indexscan execution */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot = <a href="../../access/table/tableam.c.html#L91" title="access/table/tableam.c:91">table_slot_create</a>(heapRel, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L2251" title="utils/cache/lsyscache.c:2251">get_typlenbyval</a>(vardata-&gt;atttype, &amp;typLen, &amp;typByVal);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* set up an IS NOT NULL scan key so that we ignore nulls */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/common/scankey.c.html#L32" title="access/common/scankey.c:32">ScanKeyEntryInitialize</a>(&amp;scankeys[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; SK_ISNULL | SK_SEARCHNOTNULL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">1</span>,&nbsp; &nbsp; <span class="Comment">/* index col to scan */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidStrategy, <span class="Comment">/* no strategy */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid,&nbsp; &nbsp; <span class="Comment">/* no strategy subtype */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid,&nbsp; &nbsp; <span class="Comment">/* no collation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid,&nbsp; &nbsp; <span class="Comment">/* no reg proc for this */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Datum) <span class="Constant">0</span>);&nbsp; &nbsp; <span class="Comment">/* constant */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If min is requested ... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (min)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; have_data = <a href="#L6267" title="utils/adt/selfuncs.c:6267">get_actual_variable_endpoint</a>(heapRel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; indexRel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; indexscandir,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; scankeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typLen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typByVal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; slot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; oldcontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; min);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If min not requested, still want to fetch max */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; have_data = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If max is requested, and we didn't already fail ... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (max &amp;&amp; have_data)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* scan in the opposite direction; all else is the same */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; have_data = <a href="#L6267" title="utils/adt/selfuncs.c:6267">get_actual_variable_endpoint</a>(heapRel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; indexRel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; -indexscandir,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; scankeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typLen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typByVal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; slot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; oldcontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; max);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Clean everything up */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/execTuples.c.html#L1341" title="executor/execTuples.c:1341">ExecDropSingleTupleTableSlot</a>(slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/index/indexam.c.html#L177" title="access/index/indexam.c:177">index_close</a>(indexRel, NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(heapRel, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(tmpcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* And we're done */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> have_data;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get one endpoint datum (min or max depending on indexscandir) from the<br/></li>
<li></span><span class="Comment"> * specified index.&nbsp; Return true if successful, false if not.<br/></li>
<li></span><span class="Comment"> * On success, endpoint value is stored to *endpointDatum (and copied into<br/></li>
<li></span><span class="Comment"> * outercontext).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * scankeys is a 1-<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> scankey array set up to reject nulls.<br/></li>
<li></span><span class="Comment"> * typLen/typByVal describe the datatype of the index's first column.<br/></li>
<li></span><span class="Comment"> * tableslot is a slot suitable to hold table tuples, in case we need<br/></li>
<li></span><span class="Comment"> * to probe the heap.<br/></li>
<li></span><span class="Comment"> * (We could compute these <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> locally, but that would mean computing them<br/></li>
<li></span><span class="Comment"> * twice when <a href="#L6087" title="utils/adt/selfuncs.c:6087">get_actual_variable_range</a> needs both the min and the max.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Failure occurs either when the index is empty, or we decide that it's<br/></li>
<li></span><span class="Comment"> * taking too long to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a suitable tuple.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L6267">&#x200c;</a></span><span class="linkable">get_actual_variable_endpoint</span>(Relation heapRel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relation indexRel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ScanDirection indexscandir,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ScanKey scankeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; int16 typLen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> typByVal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TupleTableSlot *tableslot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MemoryContext outercontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum *endpointDatum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; have_data = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; SnapshotData SnapshotNonVacuumable;<br/></li>
<li>&nbsp; &nbsp; IndexScanDesc index_scan;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; vmbuffer = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; BlockNumber last_heap_block = InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n_visited_heap_pages = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; ItemPointer tid;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[INDEX_MAX_KEYS];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull[INDEX_MAX_KEYS];<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We use the index-only-scan machinery for this.&nbsp; With mostly-static<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tables that's a win because it avoids a heap visit.&nbsp; It's also a win<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for dynamic data, but the reason is less obvious; read on for details.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In principle, we should scan the index with our current active<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * snapshot, which is the best approximation we've got to what the query<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will see when executed.&nbsp; But that won't be exact if a new snap is taken<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> running the query, and it can be very expensive if a lot of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * recently-dead or uncommitted rows exist at the beginning or end of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * index (because we'll laboriously fetch each one and reject it).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Instead, we use SnapshotNonVacuumable.&nbsp; That will <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> recently-dead<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and uncommitted rows as well as normal visible rows.&nbsp; On the other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * hand, it will reject known-dead rows, and thus not give a bogus answer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * when the extreme value has been deleted (unless the deletion was quite<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * recent); that case motivates not using SnapshotAny here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * A crucial point here is that SnapshotNonVacuumable, with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../storage/ipc/procarray.c.html#L4091" title="storage/ipc/procarray.c:4091">GlobalVisTestFor</a>(heapRel) as horizon, yields the inverse of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * condition that the indexscan will use to decide that index entries are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * killable (see <a href="../../access/heap/heapam.c.html#L1627" title="access/heap/heapam.c:1627">heap_hot_search_buffer</a>()).&nbsp; Therefore, if the snapshot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rejects a tuple (or more precisely, all tuples of a HOT chain) and we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have to continue scanning past it, we know that the indexscan will mark<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that index entry killed.&nbsp; That means that the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L6267" title="utils/adt/selfuncs.c:6267">get_actual_variable_endpoint</a>() call will not have to re-consider that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * index entry.&nbsp; In this way we avoid repetitive work when this function<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is used a lot during planning.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * But using SnapshotNonVacuumable creates a hazard of its own.&nbsp; In a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * recently-created index, some index entries may point at &quot;broken&quot; HOT<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * chains in which not all the tuple versions contain data matching the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * index entry.&nbsp; The live tuple version(s) certainly do match the index,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but SnapshotNonVacuumable can <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> recently-dead tuple versions that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't match.&nbsp; Hence, if we took data from the selected heap tuple, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might get a bogus answer that's not close to the index extremal value,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * or could even be NULL.&nbsp; We avoid this hazard because we take the data<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from the index entry not the heap.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Despite all this care, there are situations where we might <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> many<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * non-visible tuples near the end of the index.&nbsp; We don't want to expend<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a huge amount of time here, so we give up once we've read too many heap<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pages.&nbsp; When we fail for that reason, the caller will end up using<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * whatever extremal value is recorded in pg_statistic.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; InitNonVacuumableSnapshot(SnapshotNonVacuumable,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/procarray.c.html#L4091" title="storage/ipc/procarray.c:4091">GlobalVisTestFor</a>(heapRel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; index_scan = <a href="../../access/index/indexam.c.html#L256" title="access/index/indexam.c:256">index_beginscan</a>(heapRel, indexRel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;SnapshotNonVacuumable,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">1</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set it up for index-only scan */<br/></li>
<li></span>&nbsp; &nbsp; index_scan-&gt;xs_want_itup = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/index/indexam.c.html#L352" title="access/index/indexam.c:352">index_rescan</a>(index_scan, scankeys, <span class="Constant">1</span>, <span class="Constant">NULL</span>, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fetch first/<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> tuple in specified direction */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> ((tid = <a href="../../access/index/indexam.c.html#L574" title="access/index/indexam.c:574">index_getnext_tid</a>(index_scan, indexscandir)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber block = ItemPointerGetBlockNumber(tid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!VM_ALL_VISIBLE(heapRel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; block,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;vmbuffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Rats, we have to visit the heap to check visibility */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../access/index/indexam.c.html#L632" title="access/index/indexam.c:632">index_fetch_heap</a>(index_scan, tableslot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No visible tuple for this index entry, so we need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * advance to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> entry.&nbsp; Before doing so, count heap<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page fetches and give up if we've done too many.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't <a href="char.c.html#L172" title="utils/adt/char.c:172">charge</a> a page fetch if this is the same heap page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * as the previous tuple.&nbsp; This is on the conservative side,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * since other recently-accessed pages are probably still in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * buffers too; but it's good enough for this heuristic.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li><a id="L6364">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">VISITED_PAGES_LIMIT</span> </span><span class="Constant">100<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (block != last_heap_block)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last_heap_block = block;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n_visited_heap_pages++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (n_visited_heap_pages &gt; <a href="#L6364" title="utils/adt/selfuncs.c:6364">VISITED_PAGES_LIMIT</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no visible tuple, try <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> index entry */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We don't actually need the heap tuple for anything */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExecClearTuple(tableslot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't care whether there's more than one visible tuple in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the HOT chain; if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> are visible, that's good enough.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We expect that btree will return data in IndexTuple not HeapTuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * format.&nbsp; It's not lossy either.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!index_scan-&gt;xs_itup)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;no data returned for index-only scan&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (index_scan-&gt;xs_recheck)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected recheck indication from btree&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK to deconstruct the index tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/common/indextuple.c.html#L456" title="access/common/indextuple.c:456">index_deform_tuple</a>(index_scan-&gt;xs_itup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; index_scan-&gt;xs_itupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Shouldn't have got a null, but be careful */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnull[<span class="Constant">0</span>])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;found unexpected null value in index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(indexRel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Copy the index column value out to caller's context */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(outercontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *endpointDatum = <a href="datum.c.html#L132" title="utils/adt/datum.c:132">datumCopy</a>(<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">0</span>], typByVal, typLen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; have_data = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (vmbuffer != InvalidBuffer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(vmbuffer);<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/index/indexam.c.html#L378" title="access/index/indexam.c:378">index_endscan</a>(index_scan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> have_data;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6428" title="utils/adt/selfuncs.c:6428">find_join_input_rel</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Look up the input relation for a join.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We assume that the input relation's RelOptInfo must have been constructed<br/></li>
<li></span><span class="Comment"> * already.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> RelOptInfo *<br/></li>
<li><a id="L6428">&#x200c;</a><span class="linkable">find_join_input_rel</span>(PlannerInfo *root, Relids relids)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RelOptInfo *rel = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!bms_is_empty(relids))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L715" title="nodes/bitmapset.c:715">bms_get_singleton_member</a>(relids, &amp;relid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel = <a href="../../optimizer/util/relnode.c.html#L414" title="optimizer/util/relnode.c:414">find_base_rel</a>(root, relid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel = <a href="../../optimizer/util/relnode.c.html#L527" title="optimizer/util/relnode.c:527">find_join_rel</a>(root, relids);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rel == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> RelOptInfo for given relids&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> rel;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Index cost estimation <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Extract the actual indexquals (as RestrictInfos) from an IndexClause list<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L6460">&#x200c;</a><span class="linkable">get_quals_from_indexclauses</span>(List *indexclauses)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *result = NIL;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, indexclauses)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexClause *iclause = lfirst_node(IndexClause, lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc2, iclause-&gt;indexquals)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = lfirst_node(RestrictInfo, lc2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(result, rinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute the total evaluation cost of the comparison operands in a list<br/></li>
<li></span><span class="Comment"> * of index qual expressions.&nbsp; Since we know these will be evaluated just<br/></li>
<li></span><span class="Comment"> * once per scan, there's no need to distinguish startup from per-row cost.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This can be used either on the result of <a href="#L6460" title="utils/adt/selfuncs.c:6460">get_quals_from_indexclauses</a>(),<br/></li>
<li></span><span class="Comment"> * or directly on an indexorderbys list.&nbsp; In both cases, we expect that the<br/></li>
<li></span><span class="Comment"> * index key expression is on the left side of binary clauses.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Cost<br/></li>
<li><a id="L6490">&#x200c;</a><span class="linkable">index_other_operands_eval_cost</span>(PlannerInfo *root, List *indexquals)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; qual_arg_cost = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, indexquals)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *clause = (Expr *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *other_operand;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; QualCost&nbsp; &nbsp; index_qual_cost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Index quals will have RestrictInfos, indexorderbys won't.&nbsp; Look<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * through RestrictInfo if present.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(clause, RestrictInfo))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clause = ((RestrictInfo *) clause)-&gt;clause;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(clause, OpExpr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OpExpr&nbsp; &nbsp; &nbsp;&nbsp; *op = (OpExpr *) clause;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; other_operand = (Node *) lsecond(op-&gt;args);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(clause, RowCompareExpr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RowCompareExpr *rc = (RowCompareExpr *) clause;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; other_operand = (Node *) rc-&gt;rargs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(clause, ScalarArrayOpExpr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ScalarArrayOpExpr *saop = (ScalarArrayOpExpr *) clause;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; other_operand = (Node *) lsecond(saop-&gt;args);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(clause, NullTest))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; other_operand = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unsupported indexqual type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) nodeTag(clause));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; other_operand = <span class="Constant">NULL</span>;&nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../optimizer/path/costsize.c.html#L4666" title="optimizer/path/costsize.c:4666">cost_qual_eval_node</a>(&amp;index_qual_cost, other_operand, root);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qual_arg_cost += index_qual_cost.startup + index_qual_cost.per_tuple;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> qual_arg_cost;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L6544">&#x200c;</a></span><span class="linkable">genericcostestimate</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexPath *path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span> loop_count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GenericCosts *costs)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexOptInfo *index = path-&gt;indexinfo;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *indexQuals = <a href="#L6460" title="utils/adt/selfuncs.c:6460">get_quals_from_indexclauses</a>(path-&gt;indexclauses);<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *indexOrderBys = path-&gt;indexorderbys;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; indexStartupCost;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; indexTotalCost;<br/></li>
<li>&nbsp; &nbsp; Selectivity indexSelectivity;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; indexCorrelation;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; numIndexPages;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; numIndexTuples;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; spc_random_page_cost;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; num_sa_scans;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; num_outer_scans;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; num_scans;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; qual_op_cost;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; qual_arg_cost;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *selectivityQuals;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the index is partial, AND the index predicate with the explicitly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * given indexquals to produce a more accurate idea of the index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * selectivity.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; selectivityQuals = <a href="#L6767" title="utils/adt/selfuncs.c:6767">add_predicate_to_index_quals</a>(index, indexQuals);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If caller didn't give us an estimate for ScalarArrayOpExpr index scans,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * just assume that the number of index descents is the number of distinct<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * combinations of array elements from all of the scan's SAOP clauses.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; num_sa_scans = costs-&gt;num_sa_scans;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (num_sa_scans &lt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; num_sa_scans = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(l, indexQuals)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = (RestrictInfo *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(rinfo-&gt;clause, ScalarArrayOpExpr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ScalarArrayOpExpr *saop = (ScalarArrayOpExpr *) rinfo-&gt;clause;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; alength = <a href="#L2136" title="utils/adt/selfuncs.c:2136">estimate_array_length</a>(root, lsecond(saop-&gt;args));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (alength &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_sa_scans *= alength;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Estimate the fraction of <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a>-table tuples that will be visited */<br/></li>
<li></span>&nbsp; &nbsp; indexSelectivity = <a href="../../optimizer/path/clausesel.c.html#L100" title="optimizer/path/clausesel.c:100">clauselist_selectivity</a>(root, selectivityQuals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index-&gt;rel-&gt;relid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JOIN_INNER,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If caller didn't give us an estimate, estimate the number of index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuples that will be visited.&nbsp; We do it in this rather peculiar-looking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * way in order to get the right answer for partial indexes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; numIndexTuples = costs-&gt;numIndexTuples;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (numIndexTuples &lt;= <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; numIndexTuples = indexSelectivity * index-&gt;rel-&gt;tuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The above calculation counts all the tuples visited across all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * scans induced by ScalarArrayOpExpr nodes.&nbsp; We want to consider the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * average per-indexscan number, so adjust.&nbsp; This is a handy place to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * round to integer, too.&nbsp; (If caller supplied tuple estimate, it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * responsible for handling these considerations.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; numIndexTuples = rint(numIndexTuples / num_sa_scans);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can bound the number of tuples by the index size in <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case. Also,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * always estimate at least one tuple is touched, even when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * indexSelectivity estimate is tiny.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (numIndexTuples &gt; index-&gt;tuples)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; numIndexTuples = index-&gt;tuples;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (numIndexTuples &lt; <span class="Constant">1.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; numIndexTuples = <span class="Constant">1.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Estimate the number of index pages that will be retrieved.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We use the simplistic method of taking a pro-rata fraction of the total<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * number of index pages.&nbsp; In effect, this counts only leaf pages and not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> overhead such as index metapage or <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> tree levels.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In practice access to <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> index levels is often nearly free because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * those tend to stay in cache under load; moreover, the cost involved is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * highly dependent on index type.&nbsp; We therefore ignore such costs here<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and leave it to the caller to add a suitable <a href="char.c.html#L172" title="utils/adt/char.c:172">charge</a> if needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (index-&gt;pages &gt; <span class="Constant">1</span> &amp;&amp; index-&gt;tuples &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; numIndexPages = ceil(numIndexTuples * index-&gt;pages / index-&gt;tuples);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; numIndexPages = <span class="Constant">1.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fetch estimated page cost for tablespace containing index */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../cache/spccache.c.html#L182" title="utils/cache/spccache.c:182">get_tablespace_page_costs</a>(index-&gt;reltablespace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;spc_random_page_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now compute the disk access costs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The above calculations are all per-index-scan.&nbsp; However, if we are in a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nestloop inner scan, we can expect the scan to be repeated (with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * different search keys) for each row of the outer relation.&nbsp; Likewise,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ScalarArrayOpExpr quals result in multiple index scans.&nbsp; This creates<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the potential for cache effects to reduce the number of disk page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fetches needed.&nbsp; We want to estimate the average per-scan I/O cost in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the presence of caching.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We use the Mackert-Lohman formula (see costsize.c for details) to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * estimate the total number of page fetches that occur.&nbsp; While this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * wasn't what it was designed for, it seems a reasonable model anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that we are counting pages not tuples anymore, so we take N = T =<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * index size, as if there were one &quot;tuple&quot; per page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; num_outer_scans = loop_count;<br/></li>
<li>&nbsp; &nbsp; num_scans = num_sa_scans * num_outer_scans;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (num_scans &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; pages_fetched;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* total page fetches ignoring cache effects */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pages_fetched = numIndexPages * num_scans;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* use Mackert and Lohman formula to adjust for cache effects */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pages_fetched = <a href="../../optimizer/path/costsize.c.html#L898" title="optimizer/path/costsize.c:898">index_pages_fetched</a>(pages_fetched,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index-&gt;pages,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">double</span>) index-&gt;pages,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now compute the total disk access cost, and then report a pro-rated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * share for each outer scan.&nbsp; (Don't pro-rate for ScalarArrayOpExpr,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * since that's <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> to the indexscan.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; indexTotalCost = (pages_fetched * spc_random_page_cost)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; / num_outer_scans;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For a single index scan, we just <a href="char.c.html#L172" title="utils/adt/char.c:172">charge</a> spc_random_page_cost per<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page touched.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; indexTotalCost = numIndexPages * spc_random_page_cost;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * CPU cost: <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> complex expressions in the indexquals will need to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * evaluated once at the start of the scan to reduce them to runtime keys<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to pass to the index AM (see nodeIndexscan.c).&nbsp; We model the per-tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * CPU costs as <a href="../../optimizer/path/costsize.c.html#L122" title="optimizer/path/costsize.c:122">cpu_index_tuple_cost</a> plus one <a href="../../optimizer/path/costsize.c.html#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a> per<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * indexqual operator.&nbsp; Because we have numIndexTuples as a per-scan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * number, we have to multiply by num_sa_scans to get the correct result<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for ScalarArrayOpExpr cases.&nbsp; Similarly add in costs for <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ORDER BY expressions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: this neglects the possible costs of rechecking lossy operators.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Detecting that that might be needed seems more expensive than it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * worth, though, considering all the other inaccuracies here ...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; qual_arg_cost = <a href="#L6490" title="utils/adt/selfuncs.c:6490">index_other_operands_eval_cost</a>(root, indexQuals) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6490" title="utils/adt/selfuncs.c:6490">index_other_operands_eval_cost</a>(root, indexOrderBys);<br/></li>
<li>&nbsp; &nbsp; qual_op_cost = <a href="../../optimizer/path/costsize.c.html#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a> *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (list_length(indexQuals) + list_length(indexOrderBys));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; indexStartupCost = qual_arg_cost;<br/></li>
<li>&nbsp; &nbsp; indexTotalCost += qual_arg_cost;<br/></li>
<li>&nbsp; &nbsp; indexTotalCost += numIndexTuples * num_sa_scans * (<a href="../../optimizer/path/costsize.c.html#L122" title="optimizer/path/costsize.c:122">cpu_index_tuple_cost</a> + qual_op_cost);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Generic assumption about index correlation: there isn't <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; indexCorrelation = <span class="Constant">0.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Return everything to caller.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; costs-&gt;indexStartupCost = indexStartupCost;<br/></li>
<li>&nbsp; &nbsp; costs-&gt;indexTotalCost = indexTotalCost;<br/></li>
<li>&nbsp; &nbsp; costs-&gt;indexSelectivity = indexSelectivity;<br/></li>
<li>&nbsp; &nbsp; costs-&gt;indexCorrelation = indexCorrelation;<br/></li>
<li>&nbsp; &nbsp; costs-&gt;numIndexPages = numIndexPages;<br/></li>
<li>&nbsp; &nbsp; costs-&gt;numIndexTuples = numIndexTuples;<br/></li>
<li>&nbsp; &nbsp; costs-&gt;spc_random_page_cost = spc_random_page_cost;<br/></li>
<li>&nbsp; &nbsp; costs-&gt;num_sa_scans = num_sa_scans;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * If the index is partial, add its predicate to the given qual list.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * ANDing the index predicate with the explicitly given indexquals produces<br/></li>
<li></span><span class="Comment"> * a more accurate idea of the index's selectivity.&nbsp; However, we need to be<br/></li>
<li></span><span class="Comment"> * careful not to insert redundant clauses, because <a href="../../optimizer/path/clausesel.c.html#L100" title="optimizer/path/clausesel.c:100">clauselist_selectivity</a>()<br/></li>
<li></span><span class="Comment"> * is easily fooled into computing a too-low selectivity estimate.&nbsp; Our<br/></li>
<li></span><span class="Comment"> * approach is to add only the predicate clause(s) that cannot be proven to<br/></li>
<li></span><span class="Comment"> * be implied by the given indexquals.&nbsp; This successfully handles cases such<br/></li>
<li></span><span class="Comment"> * as a qual &quot;x = 42&quot; used with a partial index &quot;WHERE x &gt;= 40 AND x &lt; 50&quot;.<br/></li>
<li></span><span class="Comment"> * There are many other cases where we won't detect redundancy, leading to a<br/></li>
<li></span><span class="Comment"> * too-low selectivity estimate, which will bias the system in favor of using<br/></li>
<li></span><span class="Comment"> * partial indexes where possible.&nbsp; That is not necessarily bad though.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that indexQuals contains RestrictInfo nodes while the indpred<br/></li>
<li></span><span class="Comment"> * does not, so the output list will be mixed.&nbsp; This is OK for both<br/></li>
<li></span><span class="Comment"> * <a href="../../optimizer/util/predtest.c.html#L152" title="optimizer/util/predtest.c:152">predicate_implied_by</a>() and <a href="../../optimizer/path/clausesel.c.html#L100" title="optimizer/path/clausesel.c:100">clauselist_selectivity</a>(), but might be<br/></li>
<li></span><span class="Comment"> * problematic if the result were passed to other things.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L6767">&#x200c;</a><span class="linkable">add_predicate_to_index_quals</span>(IndexOptInfo *index, List *indexQuals)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *predExtraQuals = NIL;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (index-&gt;indpred == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> indexQuals;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, index-&gt;indpred)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *predQual = (Node *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *oneQual = list_make1(predQual);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../optimizer/util/predtest.c.html#L152" title="optimizer/util/predtest.c:152">predicate_implied_by</a>(oneQual, indexQuals, <span class="Constant">false</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; predExtraQuals = <a href="../../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(predExtraQuals, oneQual);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(predExtraQuals, indexQuals);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L6788">&#x200c;</a></span><span class="linkable">btcostestimate</span>(PlannerInfo *root, IndexPath *path, <span class="Type">double</span> loop_count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Cost *indexStartupCost, Cost *indexTotalCost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Selectivity *indexSelectivity, <span class="Type">double</span> *indexCorrelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">double</span> *indexPages)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexOptInfo *index = path-&gt;indexinfo;<br/></li>
<li>&nbsp; &nbsp; GenericCosts costs = {<span class="Constant">0</span>};<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid;<br/></li>
<li>&nbsp; &nbsp; AttrNumber&nbsp; &nbsp; colnum;<br/></li>
<li>&nbsp; &nbsp; VariableStatData vardata = {<span class="Constant">0</span>};<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; numIndexTuples;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; descentCost;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *indexBoundQuals;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexcol;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; eqQualHere;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found_saop;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found_is_null_op;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; num_sa_scans;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For a btree scan, only leading '=' quals plus inequality quals for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * immediately <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> attribute contribute to index selectivity (these are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the &quot;boundary quals&quot; that determine the starting and stopping points of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the index scan).&nbsp; Additional quals can suppress visits to the heap, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it's OK to count them in indexSelectivity, but they should not count<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for estimating numIndexTuples.&nbsp; So we must examine the given indexquals<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> out which ones count as boundary quals.&nbsp; We rely on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * knowledge that they are given in index column order.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For a RowCompareExpr, we consider only the first column, just as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L2202" title="utils/adt/selfuncs.c:2202">rowcomparesel</a>() does.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there's a ScalarArrayOpExpr in the quals, we'll actually perform up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to N index descents (not just one), but the ScalarArrayOpExpr's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operator can be considered to act the same as it normally does.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; indexBoundQuals = NIL;<br/></li>
<li>&nbsp; &nbsp; indexcol = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; eqQualHere = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; found_saop = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; found_is_null_op = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; num_sa_scans = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, path-&gt;indexclauses)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexClause *iclause = lfirst_node(IndexClause, lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (indexcol != iclause-&gt;indexcol)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Beginning of a new column's quals */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!eqQualHere)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* done if no '=' qual for indexcol */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eqQualHere = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexcol++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (indexcol != iclause-&gt;indexcol)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no quals at all for indexcol */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Examine each indexqual associated with this index clause */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc2, iclause-&gt;indexquals)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = lfirst_node(RestrictInfo, lc2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *clause = rinfo-&gt;clause;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clause_op = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op_strategy;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(clause, OpExpr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OpExpr&nbsp; &nbsp; &nbsp;&nbsp; *op = (OpExpr *) clause;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clause_op = op-&gt;opno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(clause, RowCompareExpr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RowCompareExpr *rc = (RowCompareExpr *) clause;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clause_op = linitial_oid(rc-&gt;opnos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(clause, ScalarArrayOpExpr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ScalarArrayOpExpr *saop = (ScalarArrayOpExpr *) clause;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *other_operand = (Node *) lsecond(saop-&gt;args);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; alength = <a href="#L2136" title="utils/adt/selfuncs.c:2136">estimate_array_length</a>(root, other_operand);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clause_op = saop-&gt;opno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found_saop = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* estimate SA descents by indexBoundQuals only */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (alength &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_sa_scans *= alength;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(clause, NullTest))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NullTest&nbsp;&nbsp; *nt = (NullTest *) clause;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nt-&gt;nulltesttype == IS_NULL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found_is_null_op = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* IS NULL is like = for selectivity purposes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eqQualHere = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unsupported indexqual type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) nodeTag(clause));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check for equality operator */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(clause_op))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op_strategy = <a href="../cache/lsyscache.c.html#L83" title="utils/cache/lsyscache.c:83">get_op_opfamily_strategy</a>(clause_op,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; index-&gt;opfamily[indexcol]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(op_strategy != <span class="Constant">0</span>);&nbsp; &nbsp; <span class="Comment">/* not a member of opfamily?? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (op_strategy == BTEqualStrategyNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eqQualHere = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexBoundQuals = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(indexBoundQuals, rinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If index is unique and we found an '=' clause for each column, we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * just assume numIndexTuples = 1 and <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the expensive<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../optimizer/path/clausesel.c.html#L100" title="optimizer/path/clausesel.c:100">clauselist_selectivity</a> calculations.&nbsp; However, a ScalarArrayOp or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NullTest invalidates that theory, even though it sets eqQualHere.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (index-&gt;unique &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexcol == index-&gt;nkeycolumns - <span class="Constant">1</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; eqQualHere &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !found_saop &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !found_is_null_op)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; numIndexTuples = <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *selectivityQuals;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Selectivity btreeSelectivity;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the index is partial, AND the index predicate with the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * index-bound quals to produce a more accurate idea of the number of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rows covered by the bound conditions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; selectivityQuals = <a href="#L6767" title="utils/adt/selfuncs.c:6767">add_predicate_to_index_quals</a>(index, indexBoundQuals);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; btreeSelectivity = <a href="../../optimizer/path/clausesel.c.html#L100" title="optimizer/path/clausesel.c:100">clauselist_selectivity</a>(root, selectivityQuals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index-&gt;rel-&gt;relid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JOIN_INNER,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; numIndexTuples = btreeSelectivity * index-&gt;rel-&gt;tuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * btree automatically combines individual ScalarArrayOpExpr primitive<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * index scans whenever the tuples covered by the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> set of array<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * keys are close to tuples covered by the current set.&nbsp; That puts a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * natural ceiling on the worst case number of descents -- there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cannot possibly be more than one descent per leaf page scanned.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Clamp the number of descents to at most 1/3 the number of index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pages.&nbsp; This avoids implausibly high estimates with low selectivity<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * paths, where scans usually require only one or two descents.&nbsp; This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is most likely to <a href="../../main/main.c.html#L320" title="main/main.c:320">help</a> when there are several SAOP clauses, where<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * naively accepting the total number of distinct combinations of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * array elements as the number of descents would frequently lead to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * wild overestimates.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We somewhat arbitrarily don't just make the cutoff the total number<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of leaf pages (we make it 1/3 the total number of pages instead) to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * give the btree code credit for its ability to continue on the leaf<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * level with low selectivity scans.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; num_sa_scans = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(num_sa_scans, ceil(index-&gt;pages * <span class="Constant">0.3333333</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; num_sa_scans = Max(num_sa_scans, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * As in <a href="#L6544" title="utils/adt/selfuncs.c:6544">genericcostestimate</a>(), we have to adjust for <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ScalarArrayOpExpr quals included in indexBoundQuals, and then round<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to integer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It is tempting to make <a href="#L6544" title="utils/adt/selfuncs.c:6544">genericcostestimate</a> behave as if SAOP<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * clauses work in almost the same way as scalar operators during<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * btree scans, making the top-level scan look like a continuous scan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (as opposed to num_sa_scans-many primitive index scans).&nbsp; After<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * all, btree scans mostly work like that at runtime.&nbsp; However, such a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * scheme would badly bias <a href="#L6544" title="utils/adt/selfuncs.c:6544">genericcostestimate</a>'s simplistic approach<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to calculating numIndexPages through prorating.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Stick with the approach taken by non-native SAOP scans for <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L6544" title="utils/adt/selfuncs.c:6544">genericcostestimate</a> will use the Mackert-Lohman formula to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * compensate for <a href="../../regex/regcomp.c.html#L1584" title="regex/regcomp.c:1584">repeat</a> page fetches, even though that definitely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * won't happen during btree scans (not for leaf pages, at least).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We're usually very pessimistic about the number of primitive index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * scans that will be required, but it's not clear how to do better.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; numIndexTuples = rint(numIndexTuples / num_sa_scans);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now do generic index cost estimation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; costs.numIndexTuples = numIndexTuples;<br/></li>
<li>&nbsp; &nbsp; costs.num_sa_scans = num_sa_scans;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6544" title="utils/adt/selfuncs.c:6544">genericcostestimate</a>(root, path, loop_count, &amp;costs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Add a CPU-cost component to represent the costs of initial btree<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * descent.&nbsp; We don't <a href="char.c.html#L172" title="utils/adt/char.c:172">charge</a> <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> I/O cost for touching <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> btree levels,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * since they tend to stay in cache, but we still have to do about log2(N)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * comparisons to descend a btree of N leaf tuples.&nbsp; We <a href="char.c.html#L172" title="utils/adt/char.c:172">charge</a> one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../optimizer/path/costsize.c.html#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a> per comparison.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there are ScalarArrayOpExprs, <a href="char.c.html#L172" title="utils/adt/char.c:172">charge</a> this once per estimated SA<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * index descent.&nbsp; The ones after the first one are not startup cost so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * far as the overall plan goes, so just add them to &quot;total&quot; cost.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (index-&gt;tuples &gt; <span class="Constant">1</span>)&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* avoid computing log(0) */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; descentCost = ceil(log(index-&gt;tuples) / log(<span class="Constant">2.0</span>)) * <a href="../../optimizer/path/costsize.c.html#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; costs.indexStartupCost += descentCost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; costs.indexTotalCost += costs.num_sa_scans * descentCost;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Even though we're not charging I/O cost for touching <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> btree pages,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it's still reasonable to <a href="char.c.html#L172" title="utils/adt/char.c:172">charge</a> some CPU cost per page descended<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * through.&nbsp; Moreover, if we had no such <a href="char.c.html#L172" title="utils/adt/char.c:172">charge</a> at all, bloated indexes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * would appear to have the same search cost as unbloated ones, at least<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in cases where only a single leaf page is expected to be visited.&nbsp; This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cost is somewhat arbitrarily set at 50x <a href="../../optimizer/path/costsize.c.html#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a> per page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * touched.&nbsp; The number of such pages is btree tree height plus one (ie,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we <a href="char.c.html#L172" title="utils/adt/char.c:172">charge</a> for the leaf page too).&nbsp; As above, <a href="char.c.html#L172" title="utils/adt/char.c:172">charge</a> once per estimated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * SA index descent.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; descentCost = (index-&gt;tree_height + <span class="Constant">1</span>) * <a href="#L144" title="utils/adt/selfuncs.c:144">DEFAULT_PAGE_CPU_MULTIPLIER</a> * <a href="../../optimizer/path/costsize.c.html#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a>;<br/></li>
<li>&nbsp; &nbsp; costs.indexStartupCost += descentCost;<br/></li>
<li>&nbsp; &nbsp; costs.indexTotalCost += costs.num_sa_scans * descentCost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we can get an estimate of the first column's ordering correlation C<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from pg_statistic, estimate the index correlation as C for a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * single-column index, or C * 0.75 for multiple columns. (The idea here<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is that multiple columns dilute the importance of the first column's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ordering, but don't negate it entirely.&nbsp; Before 8.0 we divided the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * correlation by the number of columns, but that seems too strong.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (index-&gt;indexkeys[<span class="Constant">0</span>] != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Simple variable --- look to stats for the underlying table */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte = planner_rt_fetch(index-&gt;rel-&gt;relid, root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(rte-&gt;rtekind == RTE_RELATION);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relid = rte-&gt;relid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(relid != InvalidOid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; colnum = index-&gt;indexkeys[<span class="Constant">0</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L147" title="utils/adt/selfuncs.c:147">get_relation_stats_hook</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (*<a href="#L147" title="utils/adt/selfuncs.c:147">get_relation_stats_hook</a>) (root, rte, colnum, &amp;vardata))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The hook took control of acquiring a stats tuple.&nbsp; If it did<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * supply a tuple, it'd better have supplied a freefunc.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(vardata.statsTuple) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !vardata.freefunc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;no function provided to release variable stats with&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vardata.statsTuple = <a href="../cache/syscache.c.html#L240" title="utils/cache/syscache.c:240">SearchSysCache3</a>(STATRELATTINH,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectIdGetDatum(relid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Int16GetDatum(colnum),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BoolGetDatum(rte-&gt;inh));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vardata.freefunc = <a href="../cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Expression --- maybe there are stats for the index itself */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; relid = index-&gt;indexoid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; colnum = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L148" title="utils/adt/selfuncs.c:148">get_index_stats_hook</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (*<a href="#L148" title="utils/adt/selfuncs.c:148">get_index_stats_hook</a>) (root, relid, colnum, &amp;vardata))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The hook took control of acquiring a stats tuple.&nbsp; If it did<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * supply a tuple, it'd better have supplied a freefunc.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(vardata.statsTuple) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !vardata.freefunc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;no function provided to release variable stats with&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vardata.statsTuple = <a href="../cache/syscache.c.html#L240" title="utils/cache/syscache.c:240">SearchSysCache3</a>(STATRELATTINH,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectIdGetDatum(relid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Int16GetDatum(colnum),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BoolGetDatum(<span class="Constant">false</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vardata.freefunc = <a href="../cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(vardata.statsTuple))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AttStatsSlot sslot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sortop = <a href="../cache/lsyscache.c.html#L166" title="utils/cache/lsyscache.c:166">get_opfamily_member</a>(index-&gt;opfamily[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; index-&gt;opcintype[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; index-&gt;opcintype[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BTLessStrategyNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(sortop) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L3234" title="utils/cache/lsyscache.c:3234">get_attstatsslot</a>(&amp;sslot, vardata.statsTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; STATISTIC_KIND_CORRELATION, sortop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ATTSTATSSLOT_NUMBERS))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; varCorrelation;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(sslot.nnumbers == <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; varCorrelation = sslot.numbers[<span class="Constant">0</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (index-&gt;reverse_sort[<span class="Constant">0</span>])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; varCorrelation = -varCorrelation;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (index-&gt;nkeycolumns &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; costs.indexCorrelation = varCorrelation * <span class="Constant">0.75</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; costs.indexCorrelation = varCorrelation;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L3344" title="utils/cache/lsyscache.c:3344">free_attstatsslot</a>(&amp;sslot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ReleaseVariableStats(vardata);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *indexStartupCost = costs.indexStartupCost;<br/></li>
<li>&nbsp; &nbsp; *indexTotalCost = costs.indexTotalCost;<br/></li>
<li>&nbsp; &nbsp; *indexSelectivity = costs.indexSelectivity;<br/></li>
<li>&nbsp; &nbsp; *indexCorrelation = costs.indexCorrelation;<br/></li>
<li>&nbsp; &nbsp; *indexPages = costs.numIndexPages;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L7131">&#x200c;</a></span><span class="linkable">hashcostestimate</span>(PlannerInfo *root, IndexPath *path, <span class="Type">double</span> loop_count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Cost *indexStartupCost, Cost *indexTotalCost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Selectivity *indexSelectivity, <span class="Type">double</span> *indexCorrelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">double</span> *indexPages)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GenericCosts costs = {<span class="Constant">0</span>};<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6544" title="utils/adt/selfuncs.c:6544">genericcostestimate</a>(root, path, loop_count, &amp;costs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * A <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> index has no descent costs as such, since the index AM can go<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * directly to the target bucket after computing the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> value.&nbsp; There<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are a couple of other <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>-specific costs that we could conceivably add<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * here, though:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ideally we'd <a href="char.c.html#L172" title="utils/adt/char.c:172">charge</a> spc_random_page_cost for each page in the target<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bucket, not just the numIndexPages pages that <a href="#L6544" title="utils/adt/selfuncs.c:6544">genericcostestimate</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * thought we'd visit.&nbsp; However in most cases we don't know which bucket<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that will be.&nbsp; There's no point in considering the average bucket size<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> AM makes sure that's always one page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Likewise, we could consider charging some CPU for each index tuple in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the bucket, if we knew how many there were.&nbsp; But the per-tuple cost is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * just a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> value comparison, not a general datatype-dependent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * comparison, so <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> such <a href="char.c.html#L172" title="utils/adt/char.c:172">charge</a> ought to be quite a <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> less than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../optimizer/path/costsize.c.html#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a>; which makes it probably not worth worrying about.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * A bigger issue is that chance <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>-value collisions will result in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * wasted probes into the heap.&nbsp; We don't currently attempt to model this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cost on the grounds that it's rare, but maybe it's not rare enough.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (Any fix for this ought to consider the generic lossy-operator problem,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * though; it's not entirely <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>-specific.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; *indexStartupCost = costs.indexStartupCost;<br/></li>
<li>&nbsp; &nbsp; *indexTotalCost = costs.indexTotalCost;<br/></li>
<li>&nbsp; &nbsp; *indexSelectivity = costs.indexSelectivity;<br/></li>
<li>&nbsp; &nbsp; *indexCorrelation = costs.indexCorrelation;<br/></li>
<li>&nbsp; &nbsp; *indexPages = costs.numIndexPages;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L7173">&#x200c;</a></span><span class="linkable">gistcostestimate</span>(PlannerInfo *root, IndexPath *path, <span class="Type">double</span> loop_count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Cost *indexStartupCost, Cost *indexTotalCost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Selectivity *indexSelectivity, <span class="Type">double</span> *indexCorrelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">double</span> *indexPages)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexOptInfo *index = path-&gt;indexinfo;<br/></li>
<li>&nbsp; &nbsp; GenericCosts costs = {<span class="Constant">0</span>};<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; descentCost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6544" title="utils/adt/selfuncs.c:6544">genericcostestimate</a>(root, path, loop_count, &amp;costs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We model index descent costs similarly to those for btree, but to do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that we first need an idea of the tree height.&nbsp; We somewhat arbitrarily<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * assume that the fanout is 100, meaning the tree height is at most<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * log100(index-&gt;pages).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Although this computation isn't really expensive enough to require<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * caching, we might as well use index-&gt;tree_height to cache it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (index-&gt;tree_height &lt; <span class="Constant">0</span>) <span class="Comment">/* unknown? */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (index-&gt;pages &gt; <span class="Constant">1</span>)&nbsp; &nbsp; <span class="Comment">/* avoid computing log(0) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index-&gt;tree_height = (<span class="Type">int</span>) (log(index-&gt;pages) / log(<span class="Constant">100.0</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index-&gt;tree_height = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Add a CPU-cost component to represent the costs of initial descent. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * just use log(N) here not log2(N) since the branching factor isn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * necessarily two anyway.&nbsp; As for btree, <a href="char.c.html#L172" title="utils/adt/char.c:172">charge</a> once per SA scan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (index-&gt;tuples &gt; <span class="Constant">1</span>)&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* avoid computing log(0) */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; descentCost = ceil(log(index-&gt;tuples)) * <a href="../../optimizer/path/costsize.c.html#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; costs.indexStartupCost += descentCost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; costs.indexTotalCost += costs.num_sa_scans * descentCost;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Likewise add a per-page <a href="char.c.html#L172" title="utils/adt/char.c:172">charge</a>, calculated the same as for btrees.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; descentCost = (index-&gt;tree_height + <span class="Constant">1</span>) * <a href="#L144" title="utils/adt/selfuncs.c:144">DEFAULT_PAGE_CPU_MULTIPLIER</a> * <a href="../../optimizer/path/costsize.c.html#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a>;<br/></li>
<li>&nbsp; &nbsp; costs.indexStartupCost += descentCost;<br/></li>
<li>&nbsp; &nbsp; costs.indexTotalCost += costs.num_sa_scans * descentCost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *indexStartupCost = costs.indexStartupCost;<br/></li>
<li>&nbsp; &nbsp; *indexTotalCost = costs.indexTotalCost;<br/></li>
<li>&nbsp; &nbsp; *indexSelectivity = costs.indexSelectivity;<br/></li>
<li>&nbsp; &nbsp; *indexCorrelation = costs.indexCorrelation;<br/></li>
<li>&nbsp; &nbsp; *indexPages = costs.numIndexPages;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L7228">&#x200c;</a></span><span class="linkable">spgcostestimate</span>(PlannerInfo *root, IndexPath *path, <span class="Type">double</span> loop_count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cost *indexStartupCost, Cost *indexTotalCost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Selectivity *indexSelectivity, <span class="Type">double</span> *indexCorrelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span> *indexPages)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexOptInfo *index = path-&gt;indexinfo;<br/></li>
<li>&nbsp; &nbsp; GenericCosts costs = {<span class="Constant">0</span>};<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; descentCost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6544" title="utils/adt/selfuncs.c:6544">genericcostestimate</a>(root, path, loop_count, &amp;costs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We model index descent costs similarly to those for btree, but to do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that we first need an idea of the tree height.&nbsp; We somewhat arbitrarily<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * assume that the fanout is 100, meaning the tree height is at most<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * log100(index-&gt;pages).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Although this computation isn't really expensive enough to require<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * caching, we might as well use index-&gt;tree_height to cache it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (index-&gt;tree_height &lt; <span class="Constant">0</span>) <span class="Comment">/* unknown? */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (index-&gt;pages &gt; <span class="Constant">1</span>)&nbsp; &nbsp; <span class="Comment">/* avoid computing log(0) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index-&gt;tree_height = (<span class="Type">int</span>) (log(index-&gt;pages) / log(<span class="Constant">100.0</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index-&gt;tree_height = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Add a CPU-cost component to represent the costs of initial descent. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * just use log(N) here not log2(N) since the branching factor isn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * necessarily two anyway.&nbsp; As for btree, <a href="char.c.html#L172" title="utils/adt/char.c:172">charge</a> once per SA scan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (index-&gt;tuples &gt; <span class="Constant">1</span>)&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* avoid computing log(0) */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; descentCost = ceil(log(index-&gt;tuples)) * <a href="../../optimizer/path/costsize.c.html#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; costs.indexStartupCost += descentCost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; costs.indexTotalCost += costs.num_sa_scans * descentCost;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Likewise add a per-page <a href="char.c.html#L172" title="utils/adt/char.c:172">charge</a>, calculated the same as for btrees.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; descentCost = (index-&gt;tree_height + <span class="Constant">1</span>) * <a href="#L144" title="utils/adt/selfuncs.c:144">DEFAULT_PAGE_CPU_MULTIPLIER</a> * <a href="../../optimizer/path/costsize.c.html#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a>;<br/></li>
<li>&nbsp; &nbsp; costs.indexStartupCost += descentCost;<br/></li>
<li>&nbsp; &nbsp; costs.indexTotalCost += costs.num_sa_scans * descentCost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *indexStartupCost = costs.indexStartupCost;<br/></li>
<li>&nbsp; &nbsp; *indexTotalCost = costs.indexTotalCost;<br/></li>
<li>&nbsp; &nbsp; *indexSelectivity = costs.indexSelectivity;<br/></li>
<li>&nbsp; &nbsp; *indexCorrelation = costs.indexCorrelation;<br/></li>
<li>&nbsp; &nbsp; *indexPages = costs.numIndexPages;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Support routines for <a href="#L7583" title="utils/adt/selfuncs.c:7583">gincostestimate</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; attHasFullScan[INDEX_MAX_KEYS];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; attHasNormalScan[INDEX_MAX_KEYS];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; partialEntries;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; exactEntries;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; searchEntries;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; arrayScans;<br/></li>
<li><a id="L7295">&#x200c;</a>} <span class="linkable">GinQualCounts</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Estimate the number of index terms that need to be searched for while<br/></li>
<li></span><span class="Comment"> * testing the given GIN query, and increment the counts in *counts<br/></li>
<li></span><span class="Comment"> * appropriately.&nbsp; If the query is unsatisfiable, return false.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L7303">&#x200c;</a></span><span class="linkable">gincost_pattern</span>(IndexOptInfo *index, <span class="Type">int</span> indexcol,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid clause_op, Datum query,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7295" title="utils/adt/selfuncs.c:7295">GinQualCounts</a> *counts)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; flinfo;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; extractProcOid;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collation;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strategy_op;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lefttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; righttype;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; nentries = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *partial_matches = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; Pointer&nbsp; &nbsp; *extra_data = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *nullFlags = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; searchMode = GIN_SEARCH_MODE_DEFAULT;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(indexcol &lt; index-&gt;nkeycolumns);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get the operator's strategy number and declared input data types within<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the index opfamily.&nbsp; (We don't need the latter, but we use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../cache/lsyscache.c.html#L136" title="utils/cache/lsyscache.c:136">get_op_opfamily_properties</a> because it will throw error if it fails to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a matching pg_amop entry.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L136" title="utils/cache/lsyscache.c:136">get_op_opfamily_properties</a>(clause_op, index-&gt;opfamily[indexcol], <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;strategy_op, &amp;lefttype, &amp;righttype);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * GIN always uses the &quot;default&quot; support <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, which are those with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lefttype == righttype == the opclass' opcintype (see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../cache/relcache.c.html#L1596" title="utils/cache/relcache.c:1596">IndexSupportInitialize</a> in relcache.c).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; extractProcOid = <a href="../cache/lsyscache.c.html#L796" title="utils/cache/lsyscache.c:796">get_opfamily_proc</a>(index-&gt;opfamily[indexcol],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; index-&gt;opcintype[indexcol],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; index-&gt;opcintype[indexcol],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GIN_EXTRACTQUERY_PROC);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(extractProcOid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* should not happen; throw same error as <a href="../../access/index/indexam.c.html#L860" title="access/index/indexam.c:860">index_getprocinfo</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;missing support function </span><span class="Special">%d</span><span class="Constant"> for attribute </span><span class="Special">%d</span><span class="Constant"> of index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GIN_EXTRACTQUERY_PROC, indexcol + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../cache/lsyscache.c.html#L1928" title="utils/cache/lsyscache.c:1928">get_rel_name</a>(index-&gt;indexoid));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Choose collation to pass to extractProc (should match <a href="../../access/gin/ginutil.c.html#L97" title="access/gin/ginutil.c:97">initGinState</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(index-&gt;indexcollations[indexcol]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; collation = index-&gt;indexcollations[indexcol];<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; collation = DEFAULT_COLLATION_OID;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../fmgr/fmgr.c.html#L127" title="utils/fmgr/fmgr.c:127">fmgr_info</a>(extractProcOid, &amp;flinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../fmgr/fmgr.c.html#L2070" title="utils/fmgr/fmgr.c:2070">set_fn_opclass_options</a>(&amp;flinfo, index-&gt;opclassoptions[indexcol]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../fmgr/fmgr.c.html#L1284" title="utils/fmgr/fmgr.c:1284">FunctionCall7Coll</a>(&amp;flinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; query,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(&amp;nentries),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UInt16GetDatum(strategy_op),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(&amp;partial_matches),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(&amp;extra_data),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(&amp;nullFlags),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(&amp;searchMode));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nentries &lt;= <span class="Constant">0</span> &amp;&amp; searchMode == GIN_SEARCH_MODE_DEFAULT)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No match is possible */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nentries; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For partial match we haven't <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> information to estimate number of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * matched entries in index, so, we just estimate it as 100<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (partial_matches &amp;&amp; partial_matches[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; counts-&gt;partialEntries += <span class="Constant">100</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; counts-&gt;exactEntries++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; counts-&gt;searchEntries++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (searchMode == GIN_SEARCH_MODE_DEFAULT)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; counts-&gt;attHasNormalScan[indexcol] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (searchMode == GIN_SEARCH_MODE_INCLUDE_EMPTY)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Treat &quot;include empty&quot; like an exact-match item */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; counts-&gt;attHasNormalScan[indexcol] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; counts-&gt;exactEntries++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; counts-&gt;searchEntries++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* It's GIN_SEARCH_MODE_ALL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; counts-&gt;attHasFullScan[indexcol] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Estimate the number of index terms that need to be searched for while<br/></li>
<li></span><span class="Comment"> * testing the given GIN index clause, and increment the counts in *counts<br/></li>
<li></span><span class="Comment"> * appropriately.&nbsp; If the query is unsatisfiable, return false.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L7417">&#x200c;</a></span><span class="linkable">gincost_opexpr</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexOptInfo *index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> indexcol,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OpExpr *clause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L7295" title="utils/adt/selfuncs.c:7295">GinQualCounts</a> *counts)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clause_op = clause-&gt;opno;<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *operand = (Node *) lsecond(clause-&gt;args);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* aggressively reduce to a constant, and look through relabeling */<br/></li>
<li></span>&nbsp; &nbsp; operand = <a href="../../optimizer/util/clauses.c.html#L2395" title="optimizer/util/clauses.c:2395">estimate_expression_value</a>(root, operand);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(operand, RelabelType))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; operand = (Node *) ((RelabelType *) operand)-&gt;arg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's impossible to call extractQuery method for unknown operand. So<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unless operand is a Const we can't do much; just assume there will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * one ordinary search entry from the operand at runtime.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!IsA(operand, Const))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; counts-&gt;exactEntries++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; counts-&gt;searchEntries++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If Const is null, there can be no matches */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (((Const *) operand)-&gt;constisnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Otherwise, apply extractQuery and get the actual term counts */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L7303" title="utils/adt/selfuncs.c:7303">gincost_pattern</a>(index, indexcol, clause_op,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ((Const *) operand)-&gt;constvalue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; counts);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Estimate the number of index terms that need to be searched for while<br/></li>
<li></span><span class="Comment"> * testing the given GIN index clause, and increment the counts in *counts<br/></li>
<li></span><span class="Comment"> * appropriately.&nbsp; If the query is unsatisfiable, return false.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A ScalarArrayOpExpr will give rise to N separate indexscans at runtime,<br/></li>
<li></span><span class="Comment"> * each of which involves one value from the RHS array, plus all the<br/></li>
<li></span><span class="Comment"> * non-array quals (if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>).&nbsp; To model this, we average the counts across<br/></li>
<li></span><span class="Comment"> * the RHS elements, and add the averages to the counts in *counts (which<br/></li>
<li></span><span class="Comment"> * correspond to per-indexscan costs).&nbsp; We also multiply counts-&gt;arrayScans<br/></li>
<li></span><span class="Comment"> * by N, causing <a href="#L7583" title="utils/adt/selfuncs.c:7583">gincostestimate</a> to scale up its estimates accordingly.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L7467">&#x200c;</a></span><span class="linkable">gincost_scalararrayopexpr</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexOptInfo *index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> indexcol,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ScalarArrayOpExpr *clause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span> numIndexEntries,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7295" title="utils/adt/selfuncs.c:7295">GinQualCounts</a> *counts)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clause_op = clause-&gt;opno;<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *rightop = (Node *) lsecond(clause-&gt;args);<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *arrayval;<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; elmlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; elmbyval;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; elmalign;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numElems;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *elemValues;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *elemNulls;<br/></li>
<li>&nbsp; &nbsp; <a href="#L7295" title="utils/adt/selfuncs.c:7295">GinQualCounts</a> arraycounts;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numPossible = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(clause-&gt;useOr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* aggressively reduce to a constant, and look through relabeling */<br/></li>
<li></span>&nbsp; &nbsp; rightop = <a href="../../optimizer/util/clauses.c.html#L2395" title="optimizer/util/clauses.c:2395">estimate_expression_value</a>(root, rightop);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(rightop, RelabelType))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rightop = (Node *) ((RelabelType *) rightop)-&gt;arg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's impossible to call extractQuery method for unknown operand. So<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unless operand is a Const we can't do much; just assume there will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * one ordinary search entry from each array entry at runtime, and fall<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * back on a probably-bad estimate of the number of array entries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!IsA(rightop, Const))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; counts-&gt;exactEntries++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; counts-&gt;searchEntries++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; counts-&gt;arrayScans *= <a href="#L2136" title="utils/adt/selfuncs.c:2136">estimate_array_length</a>(root, rightop);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If Const is null, there can be no matches */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (((Const *) rightop)-&gt;constisnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Otherwise, extract the array elements and iterate over them */<br/></li>
<li></span>&nbsp; &nbsp; arrayval = DatumGetArrayTypeP(((Const *) rightop)-&gt;constvalue);<br/></li>
<li>&nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L2271" title="utils/cache/lsyscache.c:2271">get_typlenbyvalalign</a>(ARR_ELEMTYPE(arrayval),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;elmlen, &amp;elmbyval, &amp;elmalign);<br/></li>
<li>&nbsp; &nbsp; <a href="arrayfuncs.c.html#L3612" title="utils/adt/arrayfuncs.c:3612">deconstruct_array</a>(arrayval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ARR_ELEMTYPE(arrayval),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmlen, elmbyval, elmalign,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;elemValues, &amp;elemNulls, &amp;numElems);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memset(&amp;arraycounts, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(arraycounts));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; numElems; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7295" title="utils/adt/selfuncs.c:7295">GinQualCounts</a> elemcounts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* NULL can't match anything, so ignore, as the executor will */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (elemNulls[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Otherwise, apply extractQuery and get the actual term counts */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memset(&amp;elemcounts, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(elemcounts));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L7303" title="utils/adt/selfuncs.c:7303">gincost_pattern</a>(index, indexcol, clause_op, elemValues[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;elemcounts))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We ignore array elements that are unsatisfiable patterns */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numPossible++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (elemcounts.attHasFullScan[indexcol] &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !elemcounts.attHasNormalScan[indexcol])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Full index scan will be required.&nbsp; We treat this as if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * every key in the index had been listed in the query; is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that reasonable?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elemcounts.partialEntries = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elemcounts.exactEntries = numIndexEntries;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elemcounts.searchEntries = numIndexEntries;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arraycounts.partialEntries += elemcounts.partialEntries;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arraycounts.exactEntries += elemcounts.exactEntries;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arraycounts.searchEntries += elemcounts.searchEntries;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (numPossible == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No satisfiable patterns in the array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now add the averages to the global counts.&nbsp; This will give us an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * estimate of the average number of terms searched for in each indexscan,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * including contributions from both array and non-array quals.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; counts-&gt;partialEntries += arraycounts.partialEntries / numPossible;<br/></li>
<li>&nbsp; &nbsp; counts-&gt;exactEntries += arraycounts.exactEntries / numPossible;<br/></li>
<li>&nbsp; &nbsp; counts-&gt;searchEntries += arraycounts.searchEntries / numPossible;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; counts-&gt;arrayScans *= numPossible;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GIN has search behavior completely different from other index types<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L7583">&#x200c;</a></span><span class="linkable">gincostestimate</span>(PlannerInfo *root, IndexPath *path, <span class="Type">double</span> loop_count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cost *indexStartupCost, Cost *indexTotalCost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Selectivity *indexSelectivity, <span class="Type">double</span> *indexCorrelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span> *indexPages)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexOptInfo *index = path-&gt;indexinfo;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *indexQuals = <a href="#L6460" title="utils/adt/selfuncs.c:6460">get_quals_from_indexclauses</a>(path-&gt;indexclauses);<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *selectivityQuals;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; numPages = index-&gt;pages,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numTuples = index-&gt;tuples;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; numEntryPages,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numDataPages,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numPendingPages,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numEntries;<br/></li>
<li>&nbsp; &nbsp; <a href="#L7295" title="utils/adt/selfuncs.c:7295">GinQualCounts</a> counts;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; matchPossible;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; fullIndexScan;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; partialScale;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; entryPagesFetched,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dataPagesFetched,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dataPagesFetchedBySel;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; qual_op_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qual_arg_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; spc_random_page_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outer_scans;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; descentCost;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; indexRel;<br/></li>
<li>&nbsp; &nbsp; GinStatsData ginStats;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Obtain statistical information from the meta page, if possible.&nbsp; Else<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * set ginStats to zeroes, and we'll cope below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!index-&gt;hypothetical)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Lock should have already been obtained in plancat.c */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; indexRel = <a href="../../access/index/indexam.c.html#L133" title="access/index/indexam.c:133">index_open</a>(index-&gt;indexoid, NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/gin/ginutil.c.html#L623" title="access/gin/ginutil.c:623">ginGetStats</a>(indexRel, &amp;ginStats);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/index/indexam.c.html#L177" title="access/index/indexam.c:177">index_close</a>(indexRel, NoLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memset(&amp;ginStats, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ginStats));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Assuming we got valid (nonzero) stats at all, nPendingPages can be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * trusted, but the other fields are data as of the last VACUUM.&nbsp; We can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scale them up to account for growth since then, but that method only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * goes so far; in the worst case, the stats might be for a completely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * empty index, and scaling them will produce pretty bogus numbers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Somewhat arbitrarily, set the cutoff for doing scaling at 4X growth; if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it's grown more than that, fall back to estimating things only from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * assumed-accurate index size.&nbsp; But we'll trust nPendingPages in <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so long as it's not clearly insane, ie, more than the index size.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ginStats.nPendingPages &lt; numPages)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; numPendingPages = ginStats.nPendingPages;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; numPendingPages = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (numPages &gt; <span class="Constant">0</span> &amp;&amp; ginStats.nTotalPages &lt;= numPages &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ginStats.nTotalPages &gt; numPages / <span class="Constant">4</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ginStats.nEntryPages &gt; <span class="Constant">0</span> &amp;&amp; ginStats.nEntries &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * OK, the stats seem close enough to sane to be trusted.&nbsp; But we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * still need to scale them by the ratio numPages / nTotalPages to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * account for growth since the last VACUUM.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; scale = numPages / ginStats.nTotalPages;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; numEntryPages = ceil(ginStats.nEntryPages * scale);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; numDataPages = ceil(ginStats.nDataPages * scale);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; numEntries = ceil(ginStats.nEntries * scale);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ensure we didn't round up too much */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; numEntryPages = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(numEntryPages, numPages - numPendingPages);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; numDataPages = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(numDataPages,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; numPages - numPendingPages - numEntryPages);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We might get here because it's a hypothetical index, or an index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * created pre-9.1 and never vacuumed since upgrading (in which case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * its stats would read as zeroes), or just because it's grown too<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * much since the last VACUUM for us to put our faith in scaling.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Invent some plausible <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> statistics based on the index page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * count (and clamp that to at least 10 pages, just in case).&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * estimate that 90% of the index is entry pages, and the rest is data<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pages.&nbsp; Estimate 100 entries per entry page; this is rather bogus<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * since it'll depend on the size of the keys, but it's more robust<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * than trying to predict the number of entries per heap tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; numPages = Max(numPages, <span class="Constant">10</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; numEntryPages = floor((numPages - numPendingPages) * <span class="Constant">0.90</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; numDataPages = numPages - numPendingPages - numEntryPages;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; numEntries = floor(numEntryPages * <span class="Constant">100</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* In an empty index, numEntries could be zero.&nbsp; Avoid divide-by-zero */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (numEntries &lt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; numEntries = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the index is partial, AND the index predicate with the index-bound<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * quals to produce a more accurate idea of the number of rows covered by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the bound conditions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; selectivityQuals = <a href="#L6767" title="utils/adt/selfuncs.c:6767">add_predicate_to_index_quals</a>(index, indexQuals);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Estimate the fraction of <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a>-table tuples that will be visited */<br/></li>
<li></span>&nbsp; &nbsp; *indexSelectivity = <a href="../../optimizer/path/clausesel.c.html#L100" title="optimizer/path/clausesel.c:100">clauselist_selectivity</a>(root, selectivityQuals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; index-&gt;rel-&gt;relid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; JOIN_INNER,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fetch estimated page cost for tablespace containing index */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../cache/spccache.c.html#L182" title="utils/cache/spccache.c:182">get_tablespace_page_costs</a>(index-&gt;reltablespace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;spc_random_page_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Generic assumption about index correlation: there isn't <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; *indexCorrelation = <span class="Constant">0.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Examine quals to estimate number of search entries &amp; partial matches<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; memset(&amp;counts, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(counts));<br/></li>
<li>&nbsp; &nbsp; counts.arrayScans = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; matchPossible = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, path-&gt;indexclauses)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexClause *iclause = lfirst_node(IndexClause, lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc2, iclause-&gt;indexquals)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = lfirst_node(RestrictInfo, lc2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *clause = rinfo-&gt;clause;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(clause, OpExpr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matchPossible = <a href="#L7417" title="utils/adt/selfuncs.c:7417">gincost_opexpr</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; iclause-&gt;indexcol,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (OpExpr *) clause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;counts);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!matchPossible)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(clause, ScalarArrayOpExpr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matchPossible = <a href="#L7467" title="utils/adt/selfuncs.c:7467">gincost_scalararrayopexpr</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iclause-&gt;indexcol,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (ScalarArrayOpExpr *) clause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numEntries,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;counts);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!matchPossible)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* shouldn't be anything else for a GIN index */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unsupported GIN indexqual type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) nodeTag(clause));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fall out if there were <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> provably-unsatisfiable quals */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!matchPossible)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *indexStartupCost = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *indexTotalCost = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *indexSelectivity = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If attribute has a full scan and at the same time doesn't have normal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scan, then we'll have to scan all non-null entries of that attribute.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Currently, we don't have per-attribute statistics for GIN.&nbsp; Thus, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * must assume the whole GIN index has to be scanned in this case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; fullIndexScan = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; index-&gt;nkeycolumns; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (counts.attHasFullScan[i] &amp;&amp; !counts.attHasNormalScan[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fullIndexScan = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fullIndexScan || indexQuals == NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Full index scan will be required.&nbsp; We treat this as if every key in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the index had been listed in the query; is that reasonable?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; counts.partialEntries = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; counts.exactEntries = numEntries;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; counts.searchEntries = numEntries;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Will we have more than one iteration of a nestloop scan? */<br/></li>
<li></span>&nbsp; &nbsp; outer_scans = loop_count;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Compute cost to begin scan, first of all, pay attention to pending<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; entryPagesFetched = numPendingPages;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Estimate number of entry pages read.&nbsp; We need to do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * counts.searchEntries searches.&nbsp; Use a power function as it should be,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but tuples on leaf pages usually is much greater. Here we include all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * searches in entry tree, including search of first entry in partial<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * match algorithm<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; entryPagesFetched += ceil(counts.searchEntries * rint(pow(numEntryPages, <span class="Constant">0.15</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Add an estimate of entry pages read by partial match algorithm. It's a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scan over leaf pages in entry tree.&nbsp; We haven't <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> useful stats here,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so estimate it as proportion.&nbsp; Because counts.partialEntries is really<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pretty bogus (see code above), it's possible that it is more than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * numEntries; clamp the proportion to ensure sanity.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; partialScale = counts.partialEntries / numEntries;<br/></li>
<li>&nbsp; &nbsp; partialScale = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(partialScale, <span class="Constant">1.0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; entryPagesFetched += ceil(numEntryPages * partialScale);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Partial match algorithm reads all data pages <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> doing actual scan,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so it's a startup cost.&nbsp; Again, we haven't <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> useful stats here, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * estimate it as proportion.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; dataPagesFetched = ceil(numDataPages * partialScale);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *indexStartupCost = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; *indexTotalCost = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Add a CPU-cost component to represent the costs of initial entry btree<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * descent.&nbsp; We don't <a href="char.c.html#L172" title="utils/adt/char.c:172">charge</a> <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> I/O cost for touching <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> btree levels,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * since they tend to stay in cache, but we still have to do about log2(N)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * comparisons to descend a btree of N leaf tuples.&nbsp; We <a href="char.c.html#L172" title="utils/adt/char.c:172">charge</a> one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../optimizer/path/costsize.c.html#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a> per comparison.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there are ScalarArrayOpExprs, <a href="char.c.html#L172" title="utils/adt/char.c:172">charge</a> this once per SA scan.&nbsp; The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ones after the first one are not startup cost so far as the overall<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * plan is concerned, so add them only to &quot;total&quot; cost.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (numEntries &gt; <span class="Constant">1</span>)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* avoid computing log(0) */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; descentCost = ceil(log(numEntries) / log(<span class="Constant">2.0</span>)) * <a href="../../optimizer/path/costsize.c.html#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *indexStartupCost += descentCost * counts.searchEntries;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *indexTotalCost += counts.arrayScans * descentCost * counts.searchEntries;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Add a cpu cost per entry-page fetched. This is not amortized over a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * loop.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; *indexStartupCost += entryPagesFetched * <a href="#L144" title="utils/adt/selfuncs.c:144">DEFAULT_PAGE_CPU_MULTIPLIER</a> * <a href="../../optimizer/path/costsize.c.html#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a>;<br/></li>
<li>&nbsp; &nbsp; *indexTotalCost += entryPagesFetched * counts.arrayScans * <a href="#L144" title="utils/adt/selfuncs.c:144">DEFAULT_PAGE_CPU_MULTIPLIER</a> * <a href="../../optimizer/path/costsize.c.html#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Add a cpu cost per data-page fetched. This is also not amortized over a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * loop. Since those are the data pages from the partial match algorithm,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="char.c.html#L172" title="utils/adt/char.c:172">charge</a> them as startup cost.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; *indexStartupCost += <a href="#L144" title="utils/adt/selfuncs.c:144">DEFAULT_PAGE_CPU_MULTIPLIER</a> * <a href="../../optimizer/path/costsize.c.html#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a> * dataPagesFetched;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since we add the startup cost to the total cost later on, remove the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * initial arrayscan from the total.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; *indexTotalCost += dataPagesFetched * (counts.arrayScans - <span class="Constant">1</span>) * <a href="#L144" title="utils/adt/selfuncs.c:144">DEFAULT_PAGE_CPU_MULTIPLIER</a> * <a href="../../optimizer/path/costsize.c.html#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Calculate cache effects if more than one scan due to nestloops or array<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * quals.&nbsp; The result is pro-rated per nestloop scan, but the array qual<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * factor shouldn't be pro-rated (<a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> <a href="#L6544" title="utils/adt/selfuncs.c:6544">genericcostestimate</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (outer_scans &gt; <span class="Constant">1</span> || counts.arrayScans &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entryPagesFetched *= outer_scans * counts.arrayScans;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entryPagesFetched = <a href="../../optimizer/path/costsize.c.html#L898" title="optimizer/path/costsize.c:898">index_pages_fetched</a>(entryPagesFetched,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (BlockNumber) numEntryPages,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numEntryPages, root);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entryPagesFetched /= outer_scans;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dataPagesFetched *= outer_scans * counts.arrayScans;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dataPagesFetched = <a href="../../optimizer/path/costsize.c.html#L898" title="optimizer/path/costsize.c:898">index_pages_fetched</a>(dataPagesFetched,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (BlockNumber) numDataPages,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; numDataPages, root);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dataPagesFetched /= outer_scans;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Here we use random page cost because logically-close pages could be far<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * apart on disk.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; *indexStartupCost += (entryPagesFetched + dataPagesFetched) * spc_random_page_cost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now compute the number of data pages fetched during the scan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We assume every entry to have the same number of items, and that there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is no overlap between them. (</span><span class="Todo">XXX</span><span class="Comment">: tsvector and array opclasses collect<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * statistics on the frequency of individual keys; it would be nice to use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * those here.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; dataPagesFetched = ceil(numDataPages * counts.exactEntries / numEntries);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there is a lot of overlap among the entries, in particular if one of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the entries is very frequent, the above calculation can grossly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * under-estimate.&nbsp; As a simple cross-check, calculate a <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound based<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on the overall selectivity of the quals.&nbsp; At a minimum, we must read<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * one item pointer for each matching entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The width of each item pointer varies, based on the level of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * compression.&nbsp; We don't have statistics on that, but an average of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * around 3 bytes per item is fairly typical.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; dataPagesFetchedBySel = ceil(*indexSelectivity *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (numTuples / (BLCKSZ / <span class="Constant">3</span>)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dataPagesFetchedBySel &gt; dataPagesFetched)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dataPagesFetched = dataPagesFetchedBySel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Add one page cpu-cost to the startup cost */<br/></li>
<li></span>&nbsp; &nbsp; *indexStartupCost += <a href="#L144" title="utils/adt/selfuncs.c:144">DEFAULT_PAGE_CPU_MULTIPLIER</a> * <a href="../../optimizer/path/costsize.c.html#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a> * counts.searchEntries;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Add once again a CPU-cost for those data pages, <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> amortizing for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cache.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; *indexTotalCost += dataPagesFetched * counts.arrayScans * <a href="#L144" title="utils/adt/selfuncs.c:144">DEFAULT_PAGE_CPU_MULTIPLIER</a> * <a href="../../optimizer/path/costsize.c.html#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Account for cache effects, the same as above */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (outer_scans &gt; <span class="Constant">1</span> || counts.arrayScans &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dataPagesFetched *= outer_scans * counts.arrayScans;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dataPagesFetched = <a href="../../optimizer/path/costsize.c.html#L898" title="optimizer/path/costsize.c:898">index_pages_fetched</a>(dataPagesFetched,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (BlockNumber) numDataPages,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; numDataPages, root);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dataPagesFetched /= outer_scans;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And apply <a href="../../optimizer/path/costsize.c.html#L120" title="optimizer/path/costsize.c:120">random_page_cost</a> as the cost per page */<br/></li>
<li></span>&nbsp; &nbsp; *indexTotalCost += *indexStartupCost +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dataPagesFetched * spc_random_page_cost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Add on index qual eval costs, much as in <a href="#L6544" title="utils/adt/selfuncs.c:6544">genericcostestimate</a>. We <a href="char.c.html#L172" title="utils/adt/char.c:172">charge</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cpu but we can disregard indexorderbys, since GIN doesn't support<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * those.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; qual_arg_cost = <a href="#L6490" title="utils/adt/selfuncs.c:6490">index_other_operands_eval_cost</a>(root, indexQuals);<br/></li>
<li>&nbsp; &nbsp; qual_op_cost = <a href="../../optimizer/path/costsize.c.html#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a> * list_length(indexQuals);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *indexStartupCost += qual_arg_cost;<br/></li>
<li>&nbsp; &nbsp; *indexTotalCost += qual_arg_cost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Add a cpu cost per search entry, corresponding to the actual visited<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * entries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; *indexTotalCost += (counts.searchEntries * counts.arrayScans) * (qual_op_cost);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now add a cpu cost per tuple in the posting lists / trees */<br/></li>
<li></span>&nbsp; &nbsp; *indexTotalCost += (numTuples * *indexSelectivity) * (<a href="../../optimizer/path/costsize.c.html#L122" title="optimizer/path/costsize.c:122">cpu_index_tuple_cost</a>);<br/></li>
<li>&nbsp; &nbsp; *indexPages = dataPagesFetched;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * BRIN has search behavior completely different from other index types<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L7973">&#x200c;</a></span><span class="linkable">brincostestimate</span>(PlannerInfo *root, IndexPath *path, <span class="Type">double</span> loop_count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Cost *indexStartupCost, Cost *indexTotalCost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Selectivity *indexSelectivity, <span class="Type">double</span> *indexCorrelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">double</span> *indexPages)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexOptInfo *index = path-&gt;indexinfo;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *indexQuals = <a href="#L6460" title="utils/adt/selfuncs.c:6460">get_quals_from_indexclauses</a>(path-&gt;indexclauses);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; numPages = index-&gt;pages;<br/></li>
<li>&nbsp; &nbsp; RelOptInfo *baserel = index-&gt;rel;<br/></li>
<li>&nbsp; &nbsp; RangeTblEntry *rte = planner_rt_fetch(baserel-&gt;relid, root);<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; spc_seq_page_cost;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; spc_random_page_cost;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; qual_arg_cost;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; qualSelectivity;<br/></li>
<li>&nbsp; &nbsp; BrinStatsData statsData;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; indexRanges;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; minimalRanges;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; estimatedRanges;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; selec;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; indexRel;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li>&nbsp; &nbsp; VariableStatData vardata;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(rte-&gt;rtekind == RTE_RELATION);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fetch estimated page cost for the tablespace containing the index */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../cache/spccache.c.html#L182" title="utils/cache/spccache.c:182">get_tablespace_page_costs</a>(index-&gt;reltablespace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;spc_random_page_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;spc_seq_page_cost);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Obtain some data from the index itself, if possible.&nbsp; Otherwise invent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * some plausible <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> statistics based on the relation page count.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!index-&gt;hypothetical)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * A lock should have already been obtained on the index in plancat.c.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; indexRel = <a href="../../access/index/indexam.c.html#L133" title="access/index/indexam.c:133">index_open</a>(index-&gt;indexoid, NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/brin/brin.c.html#L1637" title="access/brin/brin.c:1637">brinGetStats</a>(indexRel, &amp;statsData);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/index/indexam.c.html#L177" title="access/index/indexam.c:177">index_close</a>(indexRel, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* work out the actual number of ranges in the index */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; indexRanges = Max(ceil((<span class="Type">double</span>) baserel-&gt;pages /<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; statsData.pagesPerRange), <span class="Constant">1.0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Assume default number of pages per <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, and estimate the number<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of ranges based on that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; indexRanges = Max(ceil((<span class="Type">double</span>) baserel-&gt;pages /<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BRIN_DEFAULT_PAGES_PER_RANGE), <span class="Constant">1.0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; statsData.pagesPerRange = BRIN_DEFAULT_PAGES_PER_RANGE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; statsData.revmapNumPages = (indexRanges / REVMAP_PAGE_MAXITEMS) + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Compute index correlation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Because we can use all index quals equally when scanning, we can use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the largest correlation (in absolute value) among columns used by the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * query.&nbsp; Start at zero, the worst possible case.&nbsp; If we cannot <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * correlation statistics, we will keep it as 0.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; *indexCorrelation = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(l, path-&gt;indexclauses)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexClause *iclause = lfirst_node(IndexClause, l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attnum = index-&gt;indexkeys[iclause-&gt;indexcol];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* attempt to lookup stats in relation for this index column */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attnum != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Simple variable -- look to stats for the underlying table */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L147" title="utils/adt/selfuncs.c:147">get_relation_stats_hook</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (*<a href="#L147" title="utils/adt/selfuncs.c:147">get_relation_stats_hook</a>) (root, rte, attnum, &amp;vardata))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The hook took control of acquiring a stats tuple.&nbsp; If it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * did supply a tuple, it'd better have supplied a freefunc.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(vardata.statsTuple) &amp;&amp; !vardata.freefunc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;no function provided to release variable stats with&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vardata.statsTuple =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/syscache.c.html#L240" title="utils/cache/syscache.c:240">SearchSysCache3</a>(STATRELATTINH,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(rte-&gt;relid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Int16GetDatum(attnum),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BoolGetDatum(<span class="Constant">false</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vardata.freefunc = <a href="../cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Looks like we've found an expression column in the index. Let's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * see if there's <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> stats for it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* get the attnum from the 0-based index. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attnum = iclause-&gt;indexcol + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L148" title="utils/adt/selfuncs.c:148">get_index_stats_hook</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (*<a href="#L148" title="utils/adt/selfuncs.c:148">get_index_stats_hook</a>) (root, index-&gt;indexoid, attnum, &amp;vardata))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The hook took control of acquiring a stats tuple.&nbsp; If it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * did supply a tuple, it'd better have supplied a freefunc.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(vardata.statsTuple) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !vardata.freefunc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;no function provided to release variable stats with&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vardata.statsTuple = <a href="../cache/syscache.c.html#L240" title="utils/cache/syscache.c:240">SearchSysCache3</a>(STATRELATTINH,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectIdGetDatum(index-&gt;indexoid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Int16GetDatum(attnum),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BoolGetDatum(<span class="Constant">false</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vardata.freefunc = <a href="../cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(vardata.statsTuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AttStatsSlot sslot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../cache/lsyscache.c.html#L3234" title="utils/cache/lsyscache.c:3234">get_attstatsslot</a>(&amp;sslot, vardata.statsTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; STATISTIC_KIND_CORRELATION, InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ATTSTATSSLOT_NUMBERS))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; varCorrelation = <span class="Constant">0.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sslot.nnumbers &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; varCorrelation = fabs(sslot.numbers[<span class="Constant">0</span>]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (varCorrelation &gt; *indexCorrelation)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *indexCorrelation = varCorrelation;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L3344" title="utils/cache/lsyscache.c:3344">free_attstatsslot</a>(&amp;sslot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ReleaseVariableStats(vardata);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; qualSelectivity = <a href="../../optimizer/path/clausesel.c.html#L100" title="optimizer/path/clausesel.c:100">clauselist_selectivity</a>(root, indexQuals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; baserel-&gt;relid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; JOIN_INNER, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now calculate the minimum possible ranges we could match with if all of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the rows were in the perfect order in the table's heap.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; minimalRanges = ceil(indexRanges * qualSelectivity);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now estimate the number of ranges that we'll touch by using the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * indexCorrelation from the stats. Careful not to divide by zero (note<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we're using the absolute value of the correlation).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (*indexCorrelation &lt; <span class="Constant">1.0e-10</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; estimatedRanges = indexRanges;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; estimatedRanges = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(minimalRanges / *indexCorrelation, indexRanges);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we expect to visit this portion of the table */<br/></li>
<li></span>&nbsp; &nbsp; selec = estimatedRanges / indexRanges;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; CLAMP_PROBABILITY(selec);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *indexSelectivity = selec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Compute the index qual costs, much as in <a href="#L6544" title="utils/adt/selfuncs.c:6544">genericcostestimate</a>, to add to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the index costs.&nbsp; We can disregard indexorderbys, since BRIN doesn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * support those.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; qual_arg_cost = <a href="#L6490" title="utils/adt/selfuncs.c:6490">index_other_operands_eval_cost</a>(root, indexQuals);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Compute the startup cost as the cost to read the whole revmap<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sequentially, including the cost to execute the index quals.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; *indexStartupCost =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; spc_seq_page_cost * statsData.revmapNumPages * loop_count;<br/></li>
<li>&nbsp; &nbsp; *indexStartupCost += qual_arg_cost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * To read a BRIN index there might be a <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> of back and forth over<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * regular pages, as revmap might point to them out of sequential order;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * calculate the total cost as reading the whole index in random order.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; *indexTotalCost = *indexStartupCost +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; spc_random_page_cost * (numPages - statsData.revmapNumPages) * loop_count;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Charge a small amount per <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> tuple which we expect to match to. This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is meant to reflect the costs of manipulating the bitmap. The BRIN scan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will set a <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> for each page in the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> when we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a matching<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, so we must multiply the <a href="char.c.html#L172" title="utils/adt/char.c:172">charge</a> by the number of pages in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; *indexTotalCost += <span class="Constant">0.1</span> * <a href="../../optimizer/path/costsize.c.html#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a> * estimatedRanges *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; statsData.pagesPerRange;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *indexPages = index-&gt;pages;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
