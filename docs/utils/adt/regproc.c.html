<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/adt/regproc.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/adt/regproc.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L793">format_operator</a></li>
<li><a href="#L722">format_operator_extended</a></li>
<li><a href="#L806">format_operator_parts</a></li>
<li><a href="#L799">format_operator_qualified</a></li>
<li><a href="#L299">format_procedure</a></li>
<li><a href="#L326">format_procedure_extended</a></li>
<li><a href="#L398">format_procedure_parts</a></li>
<li><a href="#L305">format_procedure_qualified</a></li>
<li><a href="#L1868">parseDashOrOid</a></li>
<li><a href="#L1895">parseNameAndArgTypes</a></li>
<li><a href="#L1843">parseNumericOid</a></li>
<li><a href="#L882">regclassin</a></li>
<li><a href="#L943">regclassout</a></li>
<li><a href="#L1000">regclassrecv</a></li>
<li><a href="#L1010">regclasssend</a></li>
<li><a href="#L1026">regcollationin</a></li>
<li><a href="#L1086">regcollationout</a></li>
<li><a href="#L1144">regcollationrecv</a></li>
<li><a href="#L1154">regcollationsend</a></li>
<li><a href="#L1321">regconfigin</a></li>
<li><a href="#L1359">regconfigout</a></li>
<li><a href="#L1405">regconfigrecv</a></li>
<li><a href="#L1415">regconfigsend</a></li>
<li><a href="#L1431">regdictionaryin</a></li>
<li><a href="#L1469">regdictionaryout</a></li>
<li><a href="#L1516">regdictionaryrecv</a></li>
<li><a href="#L1526">regdictionarysend</a></li>
<li><a href="#L1658">regnamespacein</a></li>
<li><a href="#L1718">regnamespaceout</a></li>
<li><a href="#L1750">regnamespacerecv</a></li>
<li><a href="#L1760">regnamespacesend</a></li>
<li><a href="#L639">regoperatorin</a></li>
<li><a href="#L839">regoperatorout</a></li>
<li><a href="#L856">regoperatorrecv</a></li>
<li><a href="#L866">regoperatorsend</a></li>
<li><a href="#L478">regoperin</a></li>
<li><a href="#L545">regoperout</a></li>
<li><a href="#L613">regoperrecv</a></li>
<li><a href="#L623">regopersend</a></li>
<li><a href="#L224">regprocedurein</a></li>
<li><a href="#L435">regprocedureout</a></li>
<li><a href="#L452">regprocedurerecv</a></li>
<li><a href="#L462">regproceduresend</a></li>
<li><a href="#L66">regprocin</a></li>
<li><a href="#L136">regprocout</a></li>
<li><a href="#L198">regprocrecv</a></li>
<li><a href="#L208">regprocsend</a></li>
<li><a href="#L1541">regrolein</a></li>
<li><a href="#L1601">regroleout</a></li>
<li><a href="#L1633">regrolerecv</a></li>
<li><a href="#L1643">regrolesend</a></li>
<li><a href="#L1176">regtypein</a></li>
<li><a href="#L1247">regtypeout</a></li>
<li><a href="#L1295">regtyperecv</a></li>
<li><a href="#L1305">regtypesend</a></li>
<li><a href="#L1797">stringToQualifiedNameList</a></li>
<li><a href="#L1774">text_regclass</a></li>
<li><a href="#L925">to_regclass</a></li>
<li><a href="#L1068">to_regcollation</a></li>
<li><a href="#L1700">to_regnamespace</a></li>
<li><a href="#L527">to_regoper</a></li>
<li><a href="#L694">to_regoperator</a></li>
<li><a href="#L118">to_regproc</a></li>
<li><a href="#L278">to_regprocedure</a></li>
<li><a href="#L1583">to_regrole</a></li>
<li><a href="#L1209">to_regtype</a></li>
<li><a href="#L1229">to_regtypemod</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * regproc.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Functions for the built-in types regproc, regclass, regtype, etc.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * These types are all binary-compatible with type Oid, and rely on Oid<br/></li>
<li></span><span class="Comment"> * for comparison and so forth.&nbsp; Their only interesting behavior is in<br/></li>
<li></span><span class="Comment"> * special I/O conversion routines.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/adt/regproc.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;ctype.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/namespace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_class.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_collation.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_operator.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_proc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_ts_config.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_ts_dict.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lib/stringinfo.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;mb/pg_wchar.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/miscnodes.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/scansup.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/acl.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/regproc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/syscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/varlena.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1843" title="utils/adt/regproc.c:1843">parseNumericOid</a>(<span class="Type">char</span> *string, Oid *result, Node *escontext);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1868" title="utils/adt/regproc.c:1868">parseDashOrOid</a>(<span class="Type">char</span> *string, Oid *result, Node *escontext);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1895" title="utils/adt/regproc.c:1895">parseNameAndArgTypes</a>(<span class="Type">const</span> <span class="Type">char</span> *string, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> allowNone,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List **names, <span class="Type">int</span> *nargs, Oid *argtypes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Node *escontext);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*****************************************************************************<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; USER I/O ROUTINES&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment"> *****************************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L66" title="utils/adt/regproc.c:66">regprocin</a>&nbsp; &nbsp; &nbsp; &nbsp; - converts &quot;proname&quot; to proc OID<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We also <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> a <a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> OID, for symmetry with the output routine.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * '-' signifies unknown (OID 0).&nbsp; In all other cases, the input must<br/></li>
<li></span><span class="Comment"> * match an existing pg_proc entry.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L66">&#x200c;</a><span class="linkable">regprocin</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *pro_name_or_oid = PG_GETARG_CSTRING(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *escontext = fcinfo-&gt;context;<br/></li>
<li>&nbsp; &nbsp; RegProcedure result;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *names;<br/></li>
<li>&nbsp; &nbsp; FuncCandidateList clist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Handle &quot;-&quot; or <a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> OID */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1868" title="utils/adt/regproc.c:1868">parseDashOrOid</a>(pro_name_or_oid, &amp;result, escontext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_OID(result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Else it's a name, possibly schema-qualified */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We should never get here in bootstrap mode, as all references should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have been resolved by genbki.pl.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsBootstrapProcessingMode())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;regproc <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> must be OIDs in bootstrap mode&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Normal case: <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> the name into components and see if it matches <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pg_proc entries in the current search path.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; names = <a href="#L1797" title="utils/adt/regproc.c:1797">stringToQualifiedNameList</a>(pro_name_or_oid, escontext);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (names == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; clist = <a href="../../catalog/namespace.c.html#L1177" title="catalog/namespace.c:1177">FuncnameGetCandidates</a>(names, -<span class="Constant">1</span>, NIL, <span class="Constant">false</span>, <span class="Constant">false</span>, <span class="Constant">false</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (clist == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;function </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>, pro_name_or_oid)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (clist-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_AMBIGUOUS_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;more than one function named </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pro_name_or_oid)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = clist-&gt;oid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_OID(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L118" title="utils/adt/regproc.c:118">to_regproc</a>&nbsp; &nbsp; - converts &quot;proname&quot; to proc OID<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the name is not found, we return NULL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L118">&#x200c;</a><span class="linkable">to_regproc</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *pro_name = <a href="varlena.c.html#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>(PG_GETARG_TEXT_PP(<span class="Constant">0</span>));<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; ErrorSaveContext escontext = {T_ErrorSaveContext};<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../fmgr/fmgr.c.html#L1640" title="utils/fmgr/fmgr.c:1640">DirectInputFunctionCallSafe</a>(<a href="#L66" title="utils/adt/regproc.c:66">regprocin</a>, pro_name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid, -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Node *) &amp;escontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_DATUM(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L136" title="utils/adt/regproc.c:136">regprocout</a>&nbsp; &nbsp; &nbsp; &nbsp; - converts proc OID to &quot;pro_name&quot;<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L136">&#x200c;</a><span class="linkable">regprocout</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RegProcedure proid = PG_GETARG_OID(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; proctup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (proid == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<span class="Constant">&quot;-&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_CSTRING(result);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; proctup = <a href="../cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(PROCOID, ObjectIdGetDatum(proid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(proctup))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_proc procform = (Form_pg_proc) GETSTRUCT(proctup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *proname = NameStr(procform-&gt;proname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In bootstrap mode, <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the fancy namespace stuff and just return<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the proc name.&nbsp; (This path is only needed for debugging output<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * anyway.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsBootstrapProcessingMode())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(proname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *nspname;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FuncCandidateList clist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Would this proc be found (uniquely!) by <a href="#L66" title="utils/adt/regproc.c:66">regprocin</a>? If not,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * qualify it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clist = <a href="../../catalog/namespace.c.html#L1177" title="catalog/namespace.c:1177">FuncnameGetCandidates</a>(list_make1(<a href="../../nodes/value.c.html#L63" title="nodes/value.c:63">makeString</a>(proname)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -<span class="Constant">1</span>, NIL, <span class="Constant">false</span>, <span class="Constant">false</span>, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (clist != <span class="Constant">NULL</span> &amp;&amp; clist-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> == <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clist-&gt;oid == proid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nspname = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nspname = <a href="../cache/lsyscache.c.html#L3366" title="utils/cache/lsyscache.c:3366">get_namespace_name</a>(procform-&gt;pronamespace);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="ruleutils.c.html#L12707" title="utils/adt/ruleutils.c:12707">quote_qualified_identifier</a>(nspname, proname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(proctup);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If OID doesn't match <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pg_proc entry, return it numerically */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = (<span class="Type">char</span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(NAMEDATALEN);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(result, NAMEDATALEN, <span class="Constant">&quot;</span><span class="Special">%u</span><span class="Constant">&quot;</span>, proid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CSTRING(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L198" title="utils/adt/regproc.c:198">regprocrecv</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts external binary format to regproc<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L198">&#x200c;</a><span class="linkable">regprocrecv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Exactly the same as <a href="oid.c.html#L60" title="utils/adt/oid.c:60">oidrecv</a>, so share code */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="oid.c.html#L60" title="utils/adt/oid.c:60">oidrecv</a>(fcinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L208" title="utils/adt/regproc.c:208">regprocsend</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts regproc to binary format<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L208">&#x200c;</a><span class="linkable">regprocsend</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Exactly the same as <a href="oid.c.html#L71" title="utils/adt/oid.c:71">oidsend</a>, so share code */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="oid.c.html#L71" title="utils/adt/oid.c:71">oidsend</a>(fcinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L224" title="utils/adt/regproc.c:224">regprocedurein</a>&nbsp; &nbsp; &nbsp; &nbsp; - converts &quot;proname(args)&quot; to proc OID<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We also <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> a <a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> OID, for symmetry with the output routine.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * '-' signifies unknown (OID 0).&nbsp; In all other cases, the input must<br/></li>
<li></span><span class="Comment"> * match an existing pg_proc entry.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L224">&#x200c;</a><span class="linkable">regprocedurein</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *pro_name_or_oid = PG_GETARG_CSTRING(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *escontext = fcinfo-&gt;context;<br/></li>
<li>&nbsp; &nbsp; RegProcedure result;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *names;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nargs;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; argtypes[FUNC_MAX_ARGS];<br/></li>
<li>&nbsp; &nbsp; FuncCandidateList clist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Handle &quot;-&quot; or <a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> OID */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1868" title="utils/adt/regproc.c:1868">parseDashOrOid</a>(pro_name_or_oid, &amp;result, escontext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_OID(result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The rest of this wouldn't work in bootstrap mode */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsBootstrapProcessingMode())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;regprocedure <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> must be OIDs in bootstrap mode&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Else it's a name and arguments.&nbsp; Parse the name and arguments, look up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * potential matches in the current namespace search list, and scan to see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which one exactly matches the given argument types.&nbsp; (There will not be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * more than one match.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L1895" title="utils/adt/regproc.c:1895">parseNameAndArgTypes</a>(pro_name_or_oid, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;names, &amp;nargs, argtypes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; escontext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; clist = <a href="../../catalog/namespace.c.html#L1177" title="catalog/namespace.c:1177">FuncnameGetCandidates</a>(names, nargs, NIL, <span class="Constant">false</span>, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (; clist; clist = clist-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (memcmp(clist-&gt;args, argtypes, nargs * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid)) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (clist == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;function </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>, pro_name_or_oid)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = clist-&gt;oid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_OID(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L278" title="utils/adt/regproc.c:278">to_regprocedure</a>&nbsp; &nbsp; - converts &quot;proname(args)&quot; to proc OID<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the name is not found, we return NULL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L278">&#x200c;</a><span class="linkable">to_regprocedure</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *pro_name = <a href="varlena.c.html#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>(PG_GETARG_TEXT_PP(<span class="Constant">0</span>));<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; ErrorSaveContext escontext = {T_ErrorSaveContext};<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../fmgr/fmgr.c.html#L1640" title="utils/fmgr/fmgr.c:1640">DirectInputFunctionCallSafe</a>(<a href="#L224" title="utils/adt/regproc.c:224">regprocedurein</a>, pro_name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid, -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Node *) &amp;escontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_DATUM(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L299" title="utils/adt/regproc.c:299">format_procedure</a>&nbsp; &nbsp; &nbsp; &nbsp; - converts proc OID to &quot;pro_name(args)&quot;<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This exports the useful functionality of <a href="#L435" title="utils/adt/regproc.c:435">regprocedureout</a> for use<br/></li>
<li></span><span class="Comment"> * in other backend modules.&nbsp; The result is a <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d string.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L299">&#x200c;</a><span class="linkable">format_procedure</span>(Oid procedure_oid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L326" title="utils/adt/regproc.c:326">format_procedure_extended</a>(procedure_oid, <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">char</span> *<br/></li>
<li><a id="L305">&#x200c;</a><span class="linkable">format_procedure_qualified</span>(Oid procedure_oid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L326" title="utils/adt/regproc.c:326">format_procedure_extended</a>(procedure_oid, FORMAT_PROC_FORCE_QUALIFY);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L326" title="utils/adt/regproc.c:326">format_procedure_extended</a> - converts procedure OID to &quot;pro_name(args)&quot;<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This exports the useful functionality of <a href="#L435" title="utils/adt/regproc.c:435">regprocedureout</a> for use<br/></li>
<li></span><span class="Comment"> * in other backend modules.&nbsp; The result is a <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d string, or NULL.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Routine to produce regprocedure names; see <a href="#L299" title="utils/adt/regproc.c:299">format_procedure</a> above.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The following bits in 'flags' modify the behavior:<br/></li>
<li></span><span class="Comment"> * - FORMAT_PROC_INVALID_AS_NULL<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if the procedure OID is invalid or unknown, return NULL instead<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; of the <a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> OID.<br/></li>
<li></span><span class="Comment"> * - FORMAT_PROC_FORCE_QUALIFY<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; always schema-qualify procedure names, regardless of search_path<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L326">&#x200c;</a><span class="linkable">format_procedure_extended</span>(Oid procedure_oid, bits16 flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; proctup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; proctup = <a href="../cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(PROCOID, ObjectIdGetDatum(procedure_oid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(proctup))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_proc procform = (Form_pg_proc) GETSTRUCT(proctup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *proname = NameStr(procform-&gt;proname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nargs = procform-&gt;pronargs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *nspname;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; StringInfoData buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">XXX</span><span class="Comment"> no support here for bootstrap mode */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!IsBootstrapProcessingMode());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; initStringInfo(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Would this proc be found (given the right args) by <a href="#L224" title="utils/adt/regproc.c:224">regprocedurein</a>?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If not, or if caller requests it, we need to qualify it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((flags &amp; FORMAT_PROC_FORCE_QUALIFY) == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/namespace.c.html#L1681" title="catalog/namespace.c:1681">FunctionIsVisible</a>(procedure_oid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nspname = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nspname = <a href="../cache/lsyscache.c.html#L3366" title="utils/cache/lsyscache.c:3366">get_namespace_name</a>(procform-&gt;pronamespace);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;buf, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">(&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="ruleutils.c.html#L12707" title="utils/adt/ruleutils.c:12707">quote_qualified_identifier</a>(nspname, proname));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nargs; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; thisargtype = procform-&gt;proargtypes.<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(&amp;buf, <span class="Constant">','</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (flags &amp; FORMAT_PROC_FORCE_QUALIFY) != <span class="Constant">0</span> ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="format_type.c.html#L353" title="utils/adt/format_type.c:353">format_type_be_qualified</a>(thisargtype) :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(thisargtype));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(&amp;buf, <span class="Constant">')'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = buf.data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(proctup);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> ((flags &amp; FORMAT_PROC_INVALID_AS_NULL) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If object is undefined, return NULL as wanted by caller */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If OID doesn't match <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pg_proc entry, return it numerically */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = (<span class="Type">char</span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(NAMEDATALEN);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(result, NAMEDATALEN, <span class="Constant">&quot;</span><span class="Special">%u</span><span class="Constant">&quot;</span>, procedure_oid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Output an objname/objargs representation for the procedure with the<br/></li>
<li></span><span class="Comment"> * given OID.&nbsp; If it doesn't exist, an error is thrown.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This can be used to feed <a href="../../catalog/objectaddress.c.html#L922" title="catalog/objectaddress.c:922">get_object_address</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L398">&#x200c;</a></span><span class="linkable">format_procedure_parts</span>(Oid procedure_oid, List **objnames, List **objargs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> missing_ok)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; proctup;<br/></li>
<li>&nbsp; &nbsp; Form_pg_proc procform;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nargs;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; proctup = <a href="../cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(PROCOID, ObjectIdGetDatum(procedure_oid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(proctup))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!missing_ok)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for procedure with OID </span><span class="Special">%u</span><span class="Constant">&quot;</span>, procedure_oid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; procform = (Form_pg_proc) GETSTRUCT(proctup);<br/></li>
<li>&nbsp; &nbsp; nargs = procform-&gt;pronargs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *objnames = list_make2(<a href="../cache/lsyscache.c.html#L3390" title="utils/cache/lsyscache.c:3390">get_namespace_name_or_temp</a>(procform-&gt;pronamespace),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(NameStr(procform-&gt;proname)));<br/></li>
<li>&nbsp; &nbsp; *objargs = NIL;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nargs; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; thisargtype = procform-&gt;proargtypes.<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *objargs = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(*objargs, <a href="format_type.c.html#L353" title="utils/adt/format_type.c:353">format_type_be_qualified</a>(thisargtype));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(proctup);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L435" title="utils/adt/regproc.c:435">regprocedureout</a>&nbsp; &nbsp; &nbsp; &nbsp; - converts proc OID to &quot;pro_name(args)&quot;<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L435">&#x200c;</a><span class="linkable">regprocedureout</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RegProcedure proid = PG_GETARG_OID(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (proid == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<span class="Constant">&quot;-&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L299" title="utils/adt/regproc.c:299">format_procedure</a>(proid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CSTRING(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L452" title="utils/adt/regproc.c:452">regprocedurerecv</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts external binary format to regprocedure<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L452">&#x200c;</a><span class="linkable">regprocedurerecv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Exactly the same as <a href="oid.c.html#L60" title="utils/adt/oid.c:60">oidrecv</a>, so share code */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="oid.c.html#L60" title="utils/adt/oid.c:60">oidrecv</a>(fcinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L462" title="utils/adt/regproc.c:462">regproceduresend</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts regprocedure to binary format<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L462">&#x200c;</a><span class="linkable">regproceduresend</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Exactly the same as <a href="oid.c.html#L71" title="utils/adt/oid.c:71">oidsend</a>, so share code */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="oid.c.html#L71" title="utils/adt/oid.c:71">oidsend</a>(fcinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L478" title="utils/adt/regproc.c:478">regoperin</a>&nbsp; &nbsp; &nbsp; &nbsp; - converts &quot;oprname&quot; to operator OID<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We also <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> a <a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> OID, for symmetry with the output routine.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * '0' signifies unknown (OID 0).&nbsp; In all other cases, the input must<br/></li>
<li></span><span class="Comment"> * match an existing pg_operator entry.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L478">&#x200c;</a><span class="linkable">regoperin</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *opr_name_or_oid = PG_GETARG_CSTRING(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *escontext = fcinfo-&gt;context;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *names;<br/></li>
<li>&nbsp; &nbsp; FuncCandidateList clist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Handle &quot;0&quot; or <a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> OID */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1843" title="utils/adt/regproc.c:1843">parseNumericOid</a>(opr_name_or_oid, &amp;result, escontext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_OID(result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Else it's a name, possibly schema-qualified */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The rest of this wouldn't work in bootstrap mode */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsBootstrapProcessingMode())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;regoper <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> must be OIDs in bootstrap mode&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Normal case: <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> the name into components and see if it matches <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pg_operator entries in the current search path.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; names = <a href="#L1797" title="utils/adt/regproc.c:1797">stringToQualifiedNameList</a>(opr_name_or_oid, escontext);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (names == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; clist = <a href="../../catalog/namespace.c.html#L1873" title="catalog/namespace.c:1873">OpernameGetCandidates</a>(names, <span class="Special">'\0'</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (clist == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;operator does not exist: </span><span class="Special">%s</span><span class="Constant">&quot;</span>, opr_name_or_oid)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (clist-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_AMBIGUOUS_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;more than one operator named </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opr_name_or_oid)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = clist-&gt;oid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_OID(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L527" title="utils/adt/regproc.c:527">to_regoper</a>&nbsp; &nbsp; &nbsp; &nbsp; - converts &quot;oprname&quot; to operator OID<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the name is not found, we return NULL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L527">&#x200c;</a><span class="linkable">to_regoper</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *opr_name = <a href="varlena.c.html#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>(PG_GETARG_TEXT_PP(<span class="Constant">0</span>));<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; ErrorSaveContext escontext = {T_ErrorSaveContext};<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../fmgr/fmgr.c.html#L1640" title="utils/fmgr/fmgr.c:1640">DirectInputFunctionCallSafe</a>(<a href="#L478" title="utils/adt/regproc.c:478">regoperin</a>, opr_name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid, -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Node *) &amp;escontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_DATUM(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L545" title="utils/adt/regproc.c:545">regoperout</a>&nbsp; &nbsp; &nbsp; &nbsp; - converts operator OID to &quot;opr_name&quot;<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L545">&#x200c;</a><span class="linkable">regoperout</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../parser/parse_oper.c.html#L238" title="parser/parse_oper.c:238">oprid</a> = PG_GETARG_OID(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; opertup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../parser/parse_oper.c.html#L238" title="parser/parse_oper.c:238">oprid</a> == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<span class="Constant">&quot;0&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_CSTRING(result);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; opertup = <a href="../cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(OPEROID, ObjectIdGetDatum(<a href="../../parser/parse_oper.c.html#L238" title="parser/parse_oper.c:238">oprid</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(opertup))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_operator operform = (Form_pg_operator) GETSTRUCT(opertup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *oprname = NameStr(operform-&gt;oprname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In bootstrap mode, <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the fancy namespace stuff and just return<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the <a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a> name.&nbsp; (This path is only needed for debugging output<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * anyway.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsBootstrapProcessingMode())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(oprname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FuncCandidateList clist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Would this <a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a> be found (uniquely!) by <a href="#L478" title="utils/adt/regproc.c:478">regoperin</a>? If not,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * qualify it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clist = <a href="../../catalog/namespace.c.html#L1873" title="catalog/namespace.c:1873">OpernameGetCandidates</a>(list_make1(<a href="../../nodes/value.c.html#L63" title="nodes/value.c:63">makeString</a>(oprname)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Special">'\0'</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (clist != <span class="Constant">NULL</span> &amp;&amp; clist-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> == <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clist-&gt;oid == <a href="../../parser/parse_oper.c.html#L238" title="parser/parse_oper.c:238">oprid</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(oprname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *nspname;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nspname = <a href="../cache/lsyscache.c.html#L3366" title="utils/cache/lsyscache.c:3366">get_namespace_name</a>(operform-&gt;oprnamespace);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nspname = <a href="ruleutils.c.html#L12623" title="utils/adt/ruleutils.c:12623">quote_identifier</a>(nspname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = (<span class="Type">char</span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(strlen(nspname) + strlen(oprname) + <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sprintf(result, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%s</span><span class="Constant">&quot;</span>, nspname, oprname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(opertup);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If OID doesn't match <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pg_operator entry, return it numerically<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = (<span class="Type">char</span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(NAMEDATALEN);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(result, NAMEDATALEN, <span class="Constant">&quot;</span><span class="Special">%u</span><span class="Constant">&quot;</span>, <a href="../../parser/parse_oper.c.html#L238" title="parser/parse_oper.c:238">oprid</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CSTRING(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L613" title="utils/adt/regproc.c:613">regoperrecv</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts external binary format to regoper<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L613">&#x200c;</a><span class="linkable">regoperrecv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Exactly the same as <a href="oid.c.html#L60" title="utils/adt/oid.c:60">oidrecv</a>, so share code */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="oid.c.html#L60" title="utils/adt/oid.c:60">oidrecv</a>(fcinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L623" title="utils/adt/regproc.c:623">regopersend</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts regoper to binary format<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L623">&#x200c;</a><span class="linkable">regopersend</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Exactly the same as <a href="oid.c.html#L71" title="utils/adt/oid.c:71">oidsend</a>, so share code */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="oid.c.html#L71" title="utils/adt/oid.c:71">oidsend</a>(fcinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L639" title="utils/adt/regproc.c:639">regoperatorin</a>&nbsp; &nbsp; &nbsp; &nbsp; - converts &quot;oprname(args)&quot; to operator OID<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We also <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> a <a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> OID, for symmetry with the output routine.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * '0' signifies unknown (OID 0).&nbsp; In all other cases, the input must<br/></li>
<li></span><span class="Comment"> * match an existing pg_operator entry.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L639">&#x200c;</a><span class="linkable">regoperatorin</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *opr_name_or_oid = PG_GETARG_CSTRING(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *escontext = fcinfo-&gt;context;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *names;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nargs;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; argtypes[FUNC_MAX_ARGS];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Handle &quot;0&quot; or <a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> OID */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1843" title="utils/adt/regproc.c:1843">parseNumericOid</a>(opr_name_or_oid, &amp;result, escontext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_OID(result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The rest of this wouldn't work in bootstrap mode */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsBootstrapProcessingMode())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;regoperator <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> must be OIDs in bootstrap mode&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Else it's a name and arguments.&nbsp; Parse the name and arguments, look up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * potential matches in the current namespace search list, and scan to see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which one exactly matches the given argument types.&nbsp; (There will not be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * more than one match.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L1895" title="utils/adt/regproc.c:1895">parseNameAndArgTypes</a>(opr_name_or_oid, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;names, &amp;nargs, argtypes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; escontext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nargs == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_PARAMETER),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;missing argument&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Use NONE to denote the missing argument of a unary operator.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nargs != <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_TOO_MANY_ARGUMENTS),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;too many arguments&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Provide two argument types for operator.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="../../catalog/namespace.c.html#L1770" title="catalog/namespace.c:1770">OpernameGetOprid</a>(names, argtypes[<span class="Constant">0</span>], argtypes[<span class="Constant">1</span>]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;operator does not exist: </span><span class="Special">%s</span><span class="Constant">&quot;</span>, opr_name_or_oid)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_OID(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L694" title="utils/adt/regproc.c:694">to_regoperator</a>&nbsp; &nbsp; - converts &quot;oprname(args)&quot; to operator OID<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the name is not found, we return NULL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L694">&#x200c;</a><span class="linkable">to_regoperator</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *opr_name_or_oid = <a href="varlena.c.html#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>(PG_GETARG_TEXT_PP(<span class="Constant">0</span>));<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; ErrorSaveContext escontext = {T_ErrorSaveContext};<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../fmgr/fmgr.c.html#L1640" title="utils/fmgr/fmgr.c:1640">DirectInputFunctionCallSafe</a>(<a href="#L639" title="utils/adt/regproc.c:639">regoperatorin</a>, opr_name_or_oid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid, -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Node *) &amp;escontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_DATUM(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L722" title="utils/adt/regproc.c:722">format_operator_extended</a> - converts operator OID to &quot;opr_name(args)&quot;<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This exports the useful functionality of <a href="#L839" title="utils/adt/regproc.c:839">regoperatorout</a> for use<br/></li>
<li></span><span class="Comment"> * in other backend modules.&nbsp; The result is a <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d string, or NULL.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The following bits in 'flags' modify the behavior:<br/></li>
<li></span><span class="Comment"> * - FORMAT_OPERATOR_INVALID_AS_NULL<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if the operator OID is invalid or unknown, return NULL instead<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; of the <a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> OID.<br/></li>
<li></span><span class="Comment"> * - FORMAT_OPERATOR_FORCE_QUALIFY<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; always schema-qualify operator names, regardless of search_path<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L722">&#x200c;</a><span class="linkable">format_operator_extended</span>(Oid operator_oid, bits16 flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; opertup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; opertup = <a href="../cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(OPEROID, ObjectIdGetDatum(operator_oid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(opertup))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_operator operform = (Form_pg_operator) GETSTRUCT(opertup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *oprname = NameStr(operform-&gt;oprname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *nspname;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; StringInfoData buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">XXX</span><span class="Comment"> no support here for bootstrap mode */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!IsBootstrapProcessingMode());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; initStringInfo(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Would this <a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a> be found (given the right args) by <a href="#L639" title="utils/adt/regproc.c:639">regoperatorin</a>?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If not, or if caller explicitly requests it, we need to qualify it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((flags &amp; FORMAT_OPERATOR_FORCE_QUALIFY) != <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="../../catalog/namespace.c.html#L2034" title="catalog/namespace.c:2034">OperatorIsVisible</a>(operator_oid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nspname = <a href="../cache/lsyscache.c.html#L3366" title="utils/cache/lsyscache.c:3366">get_namespace_name</a>(operform-&gt;oprnamespace);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;buf, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="ruleutils.c.html#L12623" title="utils/adt/ruleutils.c:12623">quote_identifier</a>(nspname));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;buf, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">(&quot;</span>, oprname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (operform-&gt;oprleft)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;buf, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">,&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (flags &amp; FORMAT_OPERATOR_FORCE_QUALIFY) != <span class="Constant">0</span> ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="format_type.c.html#L353" title="utils/adt/format_type.c:353">format_type_be_qualified</a>(operform-&gt;oprleft) :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(operform-&gt;oprleft));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;buf, <span class="Constant">&quot;NONE,&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (operform-&gt;oprright)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;buf, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (flags &amp; FORMAT_OPERATOR_FORCE_QUALIFY) != <span class="Constant">0</span> ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="format_type.c.html#L353" title="utils/adt/format_type.c:353">format_type_be_qualified</a>(operform-&gt;oprright) :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(operform-&gt;oprright));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;buf, <span class="Constant">&quot;NONE)&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = buf.data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(opertup);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> ((flags &amp; FORMAT_OPERATOR_INVALID_AS_NULL) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If object is undefined, return NULL as wanted by caller */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If OID doesn't match <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pg_operator entry, return it numerically<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = (<span class="Type">char</span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(NAMEDATALEN);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(result, NAMEDATALEN, <span class="Constant">&quot;</span><span class="Special">%u</span><span class="Constant">&quot;</span>, operator_oid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">char</span> *<br/></li>
<li><a id="L793">&#x200c;</a><span class="linkable">format_operator</span>(Oid operator_oid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L722" title="utils/adt/regproc.c:722">format_operator_extended</a>(operator_oid, <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">char</span> *<br/></li>
<li><a id="L799">&#x200c;</a><span class="linkable">format_operator_qualified</span>(Oid operator_oid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L722" title="utils/adt/regproc.c:722">format_operator_extended</a>(operator_oid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FORMAT_OPERATOR_FORCE_QUALIFY);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L806">&#x200c;</a></span><span class="linkable">format_operator_parts</span>(Oid operator_oid, List **objnames, List **objargs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> missing_ok)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; opertup;<br/></li>
<li>&nbsp; &nbsp; Form_pg_operator oprForm;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; opertup = <a href="../cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(OPEROID, ObjectIdGetDatum(operator_oid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(opertup))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!missing_ok)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for operator with OID </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; operator_oid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oprForm = (Form_pg_operator) GETSTRUCT(opertup);<br/></li>
<li>&nbsp; &nbsp; *objnames = list_make2(<a href="../cache/lsyscache.c.html#L3390" title="utils/cache/lsyscache.c:3390">get_namespace_name_or_temp</a>(oprForm-&gt;oprnamespace),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(NameStr(oprForm-&gt;oprname)));<br/></li>
<li>&nbsp; &nbsp; *objargs = NIL;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (oprForm-&gt;oprleft)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *objargs = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(*objargs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="format_type.c.html#L353" title="utils/adt/format_type.c:353">format_type_be_qualified</a>(oprForm-&gt;oprleft));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (oprForm-&gt;oprright)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *objargs = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(*objargs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="format_type.c.html#L353" title="utils/adt/format_type.c:353">format_type_be_qualified</a>(oprForm-&gt;oprright));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(opertup);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L839" title="utils/adt/regproc.c:839">regoperatorout</a>&nbsp; &nbsp; &nbsp; &nbsp; - converts operator OID to &quot;opr_name(args)&quot;<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L839">&#x200c;</a><span class="linkable">regoperatorout</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../parser/parse_oper.c.html#L238" title="parser/parse_oper.c:238">oprid</a> = PG_GETARG_OID(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../parser/parse_oper.c.html#L238" title="parser/parse_oper.c:238">oprid</a> == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<span class="Constant">&quot;0&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L793" title="utils/adt/regproc.c:793">format_operator</a>(<a href="../../parser/parse_oper.c.html#L238" title="parser/parse_oper.c:238">oprid</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CSTRING(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L856" title="utils/adt/regproc.c:856">regoperatorrecv</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts external binary format to regoperator<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L856">&#x200c;</a><span class="linkable">regoperatorrecv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Exactly the same as <a href="oid.c.html#L60" title="utils/adt/oid.c:60">oidrecv</a>, so share code */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="oid.c.html#L60" title="utils/adt/oid.c:60">oidrecv</a>(fcinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L866" title="utils/adt/regproc.c:866">regoperatorsend</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts regoperator to binary format<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L866">&#x200c;</a><span class="linkable">regoperatorsend</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Exactly the same as <a href="oid.c.html#L71" title="utils/adt/oid.c:71">oidsend</a>, so share code */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="oid.c.html#L71" title="utils/adt/oid.c:71">oidsend</a>(fcinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L882" title="utils/adt/regproc.c:882">regclassin</a>&nbsp; &nbsp; &nbsp; &nbsp; - converts &quot;classname&quot; to class OID<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We also <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> a <a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> OID, for symmetry with the output routine.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * '-' signifies unknown (OID 0).&nbsp; In all other cases, the input must<br/></li>
<li></span><span class="Comment"> * match an existing pg_class entry.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L882">&#x200c;</a><span class="linkable">regclassin</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *class_name_or_oid = PG_GETARG_CSTRING(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *escontext = fcinfo-&gt;context;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *names;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Handle &quot;-&quot; or <a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> OID */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1868" title="utils/adt/regproc.c:1868">parseDashOrOid</a>(class_name_or_oid, &amp;result, escontext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_OID(result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Else it's a name, possibly schema-qualified */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The rest of this wouldn't work in bootstrap mode */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsBootstrapProcessingMode())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;regclass <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> must be OIDs in bootstrap mode&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Normal case: <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> the name into components and see if it matches <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pg_class entries in the current search path.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; names = <a href="#L1797" title="utils/adt/regproc.c:1797">stringToQualifiedNameList</a>(class_name_or_oid, escontext);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (names == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We might not even have permissions on this relation; don't lock it. */<br/></li>
<li></span>&nbsp; &nbsp; result = RangeVarGetRelid(<a href="../../catalog/namespace.c.html#L3539" title="catalog/namespace.c:3539">makeRangeVarFromNameList</a>(names), NoLock, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_TABLE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/namespace.c.html#L3579" title="catalog/namespace.c:3579">NameListToString</a>(names))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_OID(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L925" title="utils/adt/regproc.c:925">to_regclass</a>&nbsp; &nbsp; &nbsp; &nbsp; - converts &quot;classname&quot; to class OID<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the name is not found, we return NULL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L925">&#x200c;</a><span class="linkable">to_regclass</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *class_name = <a href="varlena.c.html#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>(PG_GETARG_TEXT_PP(<span class="Constant">0</span>));<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; ErrorSaveContext escontext = {T_ErrorSaveContext};<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../fmgr/fmgr.c.html#L1640" title="utils/fmgr/fmgr.c:1640">DirectInputFunctionCallSafe</a>(<a href="#L882" title="utils/adt/regproc.c:882">regclassin</a>, class_name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid, -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Node *) &amp;escontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_DATUM(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L943" title="utils/adt/regproc.c:943">regclassout</a>&nbsp; &nbsp; &nbsp; &nbsp; - converts class OID to &quot;class_name&quot;<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L943">&#x200c;</a><span class="linkable">regclassout</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; classid = PG_GETARG_OID(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; classtup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (classid == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<span class="Constant">&quot;-&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_CSTRING(result);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; classtup = <a href="../cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(RELOID, ObjectIdGetDatum(classid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(classtup))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_class classform = (Form_pg_class) GETSTRUCT(classtup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *classname = NameStr(classform-&gt;relname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In bootstrap mode, <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the fancy namespace stuff and just return<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the class name.&nbsp; (This path is only needed for debugging output<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * anyway.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsBootstrapProcessingMode())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(classname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *nspname;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Would this class be found by <a href="#L882" title="utils/adt/regproc.c:882">regclassin</a>? If not, qualify it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../catalog/namespace.c.html#L898" title="catalog/namespace.c:898">RelationIsVisible</a>(classid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nspname = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nspname = <a href="../cache/lsyscache.c.html#L3366" title="utils/cache/lsyscache.c:3366">get_namespace_name</a>(classform-&gt;relnamespace);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="ruleutils.c.html#L12707" title="utils/adt/ruleutils.c:12707">quote_qualified_identifier</a>(nspname, classname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(classtup);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If OID doesn't match <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pg_class entry, return it numerically */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = (<span class="Type">char</span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(NAMEDATALEN);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(result, NAMEDATALEN, <span class="Constant">&quot;</span><span class="Special">%u</span><span class="Constant">&quot;</span>, classid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CSTRING(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1000" title="utils/adt/regproc.c:1000">regclassrecv</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts external binary format to regclass<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1000">&#x200c;</a><span class="linkable">regclassrecv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Exactly the same as <a href="oid.c.html#L60" title="utils/adt/oid.c:60">oidrecv</a>, so share code */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="oid.c.html#L60" title="utils/adt/oid.c:60">oidrecv</a>(fcinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1010" title="utils/adt/regproc.c:1010">regclasssend</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts regclass to binary format<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1010">&#x200c;</a><span class="linkable">regclasssend</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Exactly the same as <a href="oid.c.html#L71" title="utils/adt/oid.c:71">oidsend</a>, so share code */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="oid.c.html#L71" title="utils/adt/oid.c:71">oidsend</a>(fcinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1026" title="utils/adt/regproc.c:1026">regcollationin</a>&nbsp; &nbsp; &nbsp; &nbsp; - converts &quot;collationname&quot; to collation OID<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We also <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> a <a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> OID, for symmetry with the output routine.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * '-' signifies unknown (OID 0).&nbsp; In all other cases, the input must<br/></li>
<li></span><span class="Comment"> * match an existing pg_collation entry.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1026">&#x200c;</a><span class="linkable">regcollationin</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *collation_name_or_oid = PG_GETARG_CSTRING(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *escontext = fcinfo-&gt;context;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *names;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Handle &quot;-&quot; or <a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> OID */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1868" title="utils/adt/regproc.c:1868">parseDashOrOid</a>(collation_name_or_oid, &amp;result, escontext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_OID(result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Else it's a name, possibly schema-qualified */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The rest of this wouldn't work in bootstrap mode */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsBootstrapProcessingMode())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;regcollation <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> must be OIDs in bootstrap mode&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Normal case: <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> the name into components and see if it matches <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pg_collation entries in the current search path.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; names = <a href="#L1797" title="utils/adt/regproc.c:1797">stringToQualifiedNameList</a>(collation_name_or_oid, escontext);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (names == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="../../catalog/namespace.c.html#L3956" title="catalog/namespace.c:3956">get_collation_oid</a>(names, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_OBJECT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;collation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> for encoding </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/namespace.c.html#L3579" title="catalog/namespace.c:3579">NameListToString</a>(names), <a href="../mb/mbutils.c.html#L1267" title="utils/mb/mbutils.c:1267">GetDatabaseEncodingName</a>())));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_OID(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1068" title="utils/adt/regproc.c:1068">to_regcollation</a>&nbsp; &nbsp; &nbsp; &nbsp; - converts &quot;collationname&quot; to collation OID<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the name is not found, we return NULL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1068">&#x200c;</a><span class="linkable">to_regcollation</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *collation_name = <a href="varlena.c.html#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>(PG_GETARG_TEXT_PP(<span class="Constant">0</span>));<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; ErrorSaveContext escontext = {T_ErrorSaveContext};<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../fmgr/fmgr.c.html#L1640" title="utils/fmgr/fmgr.c:1640">DirectInputFunctionCallSafe</a>(<a href="#L1026" title="utils/adt/regproc.c:1026">regcollationin</a>, collation_name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid, -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Node *) &amp;escontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_DATUM(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1086" title="utils/adt/regproc.c:1086">regcollationout</a>&nbsp; &nbsp; &nbsp; &nbsp; - converts collation OID to &quot;collation_name&quot;<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1086">&#x200c;</a><span class="linkable">regcollationout</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collationid = PG_GETARG_OID(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; collationtup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (collationid == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<span class="Constant">&quot;-&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_CSTRING(result);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; collationtup = <a href="../cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(COLLOID, ObjectIdGetDatum(collationid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(collationtup))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_collation collationform = (Form_pg_collation) GETSTRUCT(collationtup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *collationname = NameStr(collationform-&gt;collname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In bootstrap mode, <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the fancy namespace stuff and just return<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the collation name.&nbsp; (This path is only needed for debugging output<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * anyway.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsBootstrapProcessingMode())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(collationname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *nspname;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Would this collation be found by <a href="#L1026" title="utils/adt/regproc.c:1026">regcollationin</a>? If not,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * qualify it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../catalog/namespace.c.html#L2392" title="catalog/namespace.c:2392">CollationIsVisible</a>(collationid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nspname = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nspname = <a href="../cache/lsyscache.c.html#L3366" title="utils/cache/lsyscache.c:3366">get_namespace_name</a>(collationform-&gt;collnamespace);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="ruleutils.c.html#L12707" title="utils/adt/ruleutils.c:12707">quote_qualified_identifier</a>(nspname, collationname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(collationtup);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If OID doesn't match <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pg_collation entry, return it numerically */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = (<span class="Type">char</span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(NAMEDATALEN);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(result, NAMEDATALEN, <span class="Constant">&quot;</span><span class="Special">%u</span><span class="Constant">&quot;</span>, collationid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CSTRING(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1144" title="utils/adt/regproc.c:1144">regcollationrecv</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts external binary format to regcollation<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1144">&#x200c;</a><span class="linkable">regcollationrecv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Exactly the same as <a href="oid.c.html#L60" title="utils/adt/oid.c:60">oidrecv</a>, so share code */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="oid.c.html#L60" title="utils/adt/oid.c:60">oidrecv</a>(fcinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1154" title="utils/adt/regproc.c:1154">regcollationsend</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts regcollation to binary format<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1154">&#x200c;</a><span class="linkable">regcollationsend</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Exactly the same as <a href="oid.c.html#L71" title="utils/adt/oid.c:71">oidsend</a>, so share code */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="oid.c.html#L71" title="utils/adt/oid.c:71">oidsend</a>(fcinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1176" title="utils/adt/regproc.c:1176">regtypein</a>&nbsp; &nbsp; &nbsp; &nbsp; - converts &quot;typename&quot; to type OID<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The type name can be specified using the full type syntax recognized by<br/></li>
<li></span><span class="Comment"> * the parser; for example, DOUBLE PRECISION and INTEGER[] will work and be<br/></li>
<li></span><span class="Comment"> * translated to the correct type names.&nbsp; (We ignore <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> typmod info<br/></li>
<li></span><span class="Comment"> * generated by the parser, however.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We also <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> a <a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> OID, for symmetry with the output routine,<br/></li>
<li></span><span class="Comment"> * and for possible use in bootstrap mode.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * '-' signifies unknown (OID 0).&nbsp; In all other cases, the input must<br/></li>
<li></span><span class="Comment"> * match an existing pg_type entry.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1176">&#x200c;</a><span class="linkable">regtypein</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *typ_name_or_oid = PG_GETARG_CSTRING(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *escontext = fcinfo-&gt;context;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; typmod;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Handle &quot;-&quot; or <a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> OID */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1868" title="utils/adt/regproc.c:1868">parseDashOrOid</a>(typ_name_or_oid, &amp;result, escontext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_OID(result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Else it's a type name, possibly schema-qualified or decorated */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The rest of this wouldn't work in bootstrap mode */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsBootstrapProcessingMode())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;regtype <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> must be OIDs in bootstrap mode&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Normal case: invoke the full parser to deal with special cases such as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * array syntax.&nbsp; We don't need to check for <a href="../../parser/parse_type.c.html#L785" title="parser/parse_type.c:785">parseTypeString</a> failure,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * since we'll just return anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="../../parser/parse_type.c.html#L785" title="parser/parse_type.c:785">parseTypeString</a>(typ_name_or_oid, &amp;result, &amp;typmod, escontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_OID(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1209" title="utils/adt/regproc.c:1209">to_regtype</a>&nbsp; &nbsp; &nbsp; &nbsp; - converts &quot;typename&quot; to type OID<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the name is not found, we return NULL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1209">&#x200c;</a><span class="linkable">to_regtype</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *typ_name = <a href="varlena.c.html#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>(PG_GETARG_TEXT_PP(<span class="Constant">0</span>));<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; ErrorSaveContext escontext = {T_ErrorSaveContext};<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../fmgr/fmgr.c.html#L1640" title="utils/fmgr/fmgr.c:1640">DirectInputFunctionCallSafe</a>(<a href="#L1176" title="utils/adt/regproc.c:1176">regtypein</a>, typ_name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid, -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Node *) &amp;escontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_DATUM(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1229" title="utils/adt/regproc.c:1229">to_regtypemod</a>&nbsp; &nbsp; - converts &quot;typename&quot; to type modifier<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the name is not found, we return NULL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1229">&#x200c;</a><span class="linkable">to_regtypemod</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *typ_name = <a href="varlena.c.html#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>(PG_GETARG_TEXT_PP(<span class="Constant">0</span>));<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typid;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; typmod;<br/></li>
<li>&nbsp; &nbsp; ErrorSaveContext escontext = {T_ErrorSaveContext};<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We rely on <a href="../../parser/parse_type.c.html#L785" title="parser/parse_type.c:785">parseTypeString</a> to <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> the input. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../parser/parse_type.c.html#L785" title="parser/parse_type.c:785">parseTypeString</a>(typ_name, &amp;typid, &amp;typmod, (Node *) &amp;escontext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(typmod);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1247" title="utils/adt/regproc.c:1247">regtypeout</a>&nbsp; &nbsp; &nbsp; &nbsp; - converts type OID to &quot;typ_name&quot;<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1247">&#x200c;</a><span class="linkable">regtypeout</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typid = PG_GETARG_OID(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; typetup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (typid == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<span class="Constant">&quot;-&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_CSTRING(result);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typetup = <a href="../cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(TYPEOID, ObjectIdGetDatum(typid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(typetup))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_type typeform = (Form_pg_type) GETSTRUCT(typetup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In bootstrap mode, <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the fancy namespace stuff and just return<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the type name.&nbsp; (This path is only needed for debugging output<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * anyway.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsBootstrapProcessingMode())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *typname = NameStr(typeform-&gt;typname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(typname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(typid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(typetup);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If OID doesn't match <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pg_type entry, return it numerically */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = (<span class="Type">char</span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(NAMEDATALEN);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(result, NAMEDATALEN, <span class="Constant">&quot;</span><span class="Special">%u</span><span class="Constant">&quot;</span>, typid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CSTRING(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1295" title="utils/adt/regproc.c:1295">regtyperecv</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts external binary format to regtype<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1295">&#x200c;</a><span class="linkable">regtyperecv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Exactly the same as <a href="oid.c.html#L60" title="utils/adt/oid.c:60">oidrecv</a>, so share code */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="oid.c.html#L60" title="utils/adt/oid.c:60">oidrecv</a>(fcinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1305" title="utils/adt/regproc.c:1305">regtypesend</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts regtype to binary format<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1305">&#x200c;</a><span class="linkable">regtypesend</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Exactly the same as <a href="oid.c.html#L71" title="utils/adt/oid.c:71">oidsend</a>, so share code */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="oid.c.html#L71" title="utils/adt/oid.c:71">oidsend</a>(fcinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1321" title="utils/adt/regproc.c:1321">regconfigin</a>&nbsp; &nbsp; &nbsp; &nbsp; - converts &quot;tsconfigname&quot; to tsconfig OID<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We also <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> a <a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> OID, for symmetry with the output routine.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * '-' signifies unknown (OID 0).&nbsp; In all other cases, the input must<br/></li>
<li></span><span class="Comment"> * match an existing pg_ts_config entry.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1321">&#x200c;</a><span class="linkable">regconfigin</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *cfg_name_or_oid = PG_GETARG_CSTRING(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *escontext = fcinfo-&gt;context;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *names;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Handle &quot;-&quot; or <a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> OID */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1868" title="utils/adt/regproc.c:1868">parseDashOrOid</a>(cfg_name_or_oid, &amp;result, escontext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_OID(result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The rest of this wouldn't work in bootstrap mode */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsBootstrapProcessingMode())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;regconfig <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> must be OIDs in bootstrap mode&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Normal case: <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> the name into components and see if it matches <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pg_ts_config entries in the current search path.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; names = <a href="#L1797" title="utils/adt/regproc.c:1797">stringToQualifiedNameList</a>(cfg_name_or_oid, escontext);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (names == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="../../catalog/namespace.c.html#L3137" title="catalog/namespace.c:3137">get_ts_config_oid</a>(names, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_OBJECT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;text search configuration </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/namespace.c.html#L3579" title="catalog/namespace.c:3579">NameListToString</a>(names))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_OID(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1359" title="utils/adt/regproc.c:1359">regconfigout</a>&nbsp; &nbsp; &nbsp; &nbsp; - converts tsconfig OID to &quot;tsconfigname&quot;<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1359">&#x200c;</a><span class="linkable">regconfigout</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cfgid = PG_GETARG_OID(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; cfgtup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cfgid == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<span class="Constant">&quot;-&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_CSTRING(result);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cfgtup = <a href="../cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(TSCONFIGOID, ObjectIdGetDatum(cfgid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(cfgtup))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_ts_config cfgform = (Form_pg_ts_config) GETSTRUCT(cfgtup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *cfgname = NameStr(cfgform-&gt;cfgname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *nspname;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Would this config be found by <a href="#L1321" title="utils/adt/regproc.c:1321">regconfigin</a>? If not, qualify it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../catalog/namespace.c.html#L3195" title="catalog/namespace.c:3195">TSConfigIsVisible</a>(cfgid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nspname = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nspname = <a href="../cache/lsyscache.c.html#L3366" title="utils/cache/lsyscache.c:3366">get_namespace_name</a>(cfgform-&gt;cfgnamespace);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="ruleutils.c.html#L12707" title="utils/adt/ruleutils.c:12707">quote_qualified_identifier</a>(nspname, cfgname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(cfgtup);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If OID doesn't match <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pg_ts_config row, return it numerically */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = (<span class="Type">char</span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(NAMEDATALEN);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(result, NAMEDATALEN, <span class="Constant">&quot;</span><span class="Special">%u</span><span class="Constant">&quot;</span>, cfgid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CSTRING(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1405" title="utils/adt/regproc.c:1405">regconfigrecv</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts external binary format to regconfig<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1405">&#x200c;</a><span class="linkable">regconfigrecv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Exactly the same as <a href="oid.c.html#L60" title="utils/adt/oid.c:60">oidrecv</a>, so share code */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="oid.c.html#L60" title="utils/adt/oid.c:60">oidrecv</a>(fcinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1415" title="utils/adt/regproc.c:1415">regconfigsend</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts regconfig to binary format<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1415">&#x200c;</a><span class="linkable">regconfigsend</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Exactly the same as <a href="oid.c.html#L71" title="utils/adt/oid.c:71">oidsend</a>, so share code */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="oid.c.html#L71" title="utils/adt/oid.c:71">oidsend</a>(fcinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1431" title="utils/adt/regproc.c:1431">regdictionaryin</a>&nbsp; &nbsp; &nbsp; &nbsp; - converts &quot;tsdictionaryname&quot; to tsdictionary OID<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We also <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> a <a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> OID, for symmetry with the output routine.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * '-' signifies unknown (OID 0).&nbsp; In all other cases, the input must<br/></li>
<li></span><span class="Comment"> * match an existing pg_ts_dict entry.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1431">&#x200c;</a><span class="linkable">regdictionaryin</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *dict_name_or_oid = PG_GETARG_CSTRING(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *escontext = fcinfo-&gt;context;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *names;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Handle &quot;-&quot; or <a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> OID */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1868" title="utils/adt/regproc.c:1868">parseDashOrOid</a>(dict_name_or_oid, &amp;result, escontext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_OID(result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The rest of this wouldn't work in bootstrap mode */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsBootstrapProcessingMode())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;regdictionary <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> must be OIDs in bootstrap mode&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Normal case: <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> the name into components and see if it matches <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pg_ts_dict entries in the current search path.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; names = <a href="#L1797" title="utils/adt/regproc.c:1797">stringToQualifiedNameList</a>(dict_name_or_oid, escontext);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (names == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="../../catalog/namespace.c.html#L2846" title="catalog/namespace.c:2846">get_ts_dict_oid</a>(names, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_OBJECT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;text search dictionary </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/namespace.c.html#L3579" title="catalog/namespace.c:3579">NameListToString</a>(names))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_OID(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1469" title="utils/adt/regproc.c:1469">regdictionaryout</a>&nbsp; &nbsp; &nbsp; &nbsp; - converts tsdictionary OID to &quot;tsdictionaryname&quot;<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1469">&#x200c;</a><span class="linkable">regdictionaryout</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dictid = PG_GETARG_OID(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; dicttup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dictid == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<span class="Constant">&quot;-&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_CSTRING(result);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dicttup = <a href="../cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(TSDICTOID, ObjectIdGetDatum(dictid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(dicttup))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_ts_dict dictform = (Form_pg_ts_dict) GETSTRUCT(dicttup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *dictname = NameStr(dictform-&gt;dictname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *nspname;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Would this dictionary be found by <a href="#L1431" title="utils/adt/regproc.c:1431">regdictionaryin</a>? If not, qualify<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../catalog/namespace.c.html#L2904" title="catalog/namespace.c:2904">TSDictionaryIsVisible</a>(dictid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nspname = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nspname = <a href="../cache/lsyscache.c.html#L3366" title="utils/cache/lsyscache.c:3366">get_namespace_name</a>(dictform-&gt;dictnamespace);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="ruleutils.c.html#L12707" title="utils/adt/ruleutils.c:12707">quote_qualified_identifier</a>(nspname, dictname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(dicttup);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If OID doesn't match <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pg_ts_dict row, return it numerically */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = (<span class="Type">char</span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(NAMEDATALEN);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(result, NAMEDATALEN, <span class="Constant">&quot;</span><span class="Special">%u</span><span class="Constant">&quot;</span>, dictid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CSTRING(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1516" title="utils/adt/regproc.c:1516">regdictionaryrecv</a>&nbsp; &nbsp; - converts external binary format to regdictionary<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1516">&#x200c;</a><span class="linkable">regdictionaryrecv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Exactly the same as <a href="oid.c.html#L60" title="utils/adt/oid.c:60">oidrecv</a>, so share code */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="oid.c.html#L60" title="utils/adt/oid.c:60">oidrecv</a>(fcinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1526" title="utils/adt/regproc.c:1526">regdictionarysend</a>&nbsp; &nbsp; - converts regdictionary to binary format<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1526">&#x200c;</a><span class="linkable">regdictionarysend</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Exactly the same as <a href="oid.c.html#L71" title="utils/adt/oid.c:71">oidsend</a>, so share code */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="oid.c.html#L71" title="utils/adt/oid.c:71">oidsend</a>(fcinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1541" title="utils/adt/regproc.c:1541">regrolein</a>&nbsp; &nbsp; - converts &quot;rolename&quot; to role OID<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We also <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> a <a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> OID, for symmetry with the output routine.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * '-' signifies unknown (OID 0).&nbsp; In all other cases, the input must<br/></li>
<li></span><span class="Comment"> * match an existing pg_authid entry.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1541">&#x200c;</a><span class="linkable">regrolein</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *role_name_or_oid = PG_GETARG_CSTRING(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *escontext = fcinfo-&gt;context;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *names;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Handle &quot;-&quot; or <a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> OID */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1868" title="utils/adt/regproc.c:1868">parseDashOrOid</a>(role_name_or_oid, &amp;result, escontext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_OID(result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The rest of this wouldn't work in bootstrap mode */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsBootstrapProcessingMode())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;regrole <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> must be OIDs in bootstrap mode&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Normal case: see if the name matches <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pg_authid entry. */<br/></li>
<li></span>&nbsp; &nbsp; names = <a href="#L1797" title="utils/adt/regproc.c:1797">stringToQualifiedNameList</a>(role_name_or_oid, escontext);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (names == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(names) != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_NAME),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid name syntax&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="acl.c.html#L5414" title="utils/adt/acl.c:5414">get_role_oid</a>(strVal(linitial(names)), <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_OBJECT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;role </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strVal(linitial(names)))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_OID(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1583" title="utils/adt/regproc.c:1583">to_regrole</a>&nbsp; &nbsp; &nbsp; &nbsp; - converts &quot;rolename&quot; to role OID<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the name is not found, we return NULL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1583">&#x200c;</a><span class="linkable">to_regrole</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *role_name = <a href="varlena.c.html#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>(PG_GETARG_TEXT_PP(<span class="Constant">0</span>));<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; ErrorSaveContext escontext = {T_ErrorSaveContext};<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../fmgr/fmgr.c.html#L1640" title="utils/fmgr/fmgr.c:1640">DirectInputFunctionCallSafe</a>(<a href="#L1541" title="utils/adt/regproc.c:1541">regrolein</a>, role_name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid, -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Node *) &amp;escontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_DATUM(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1601" title="utils/adt/regproc.c:1601">regroleout</a>&nbsp; &nbsp; &nbsp; &nbsp; - converts role OID to &quot;role_name&quot;<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1601">&#x200c;</a><span class="linkable">regroleout</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; roleoid = PG_GETARG_OID(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (roleoid == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<span class="Constant">&quot;-&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_CSTRING(result);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="../init/miscinit.c.html#L980" title="utils/init/miscinit.c:980">GetUserNameFromId</a>(roleoid, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a> is not really necessary, but it avoids a compiler warning */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<a href="ruleutils.c.html#L12623" title="utils/adt/ruleutils.c:12623">quote_identifier</a>(result));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If OID doesn't match <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> role, return it numerically */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = (<span class="Type">char</span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(NAMEDATALEN);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(result, NAMEDATALEN, <span class="Constant">&quot;</span><span class="Special">%u</span><span class="Constant">&quot;</span>, roleoid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CSTRING(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1633" title="utils/adt/regproc.c:1633">regrolerecv</a> - converts external binary format to regrole<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1633">&#x200c;</a><span class="linkable">regrolerecv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Exactly the same as <a href="oid.c.html#L60" title="utils/adt/oid.c:60">oidrecv</a>, so share code */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="oid.c.html#L60" title="utils/adt/oid.c:60">oidrecv</a>(fcinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1643" title="utils/adt/regproc.c:1643">regrolesend</a> - converts regrole to binary format<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1643">&#x200c;</a><span class="linkable">regrolesend</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Exactly the same as <a href="oid.c.html#L71" title="utils/adt/oid.c:71">oidsend</a>, so share code */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="oid.c.html#L71" title="utils/adt/oid.c:71">oidsend</a>(fcinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1658" title="utils/adt/regproc.c:1658">regnamespacein</a>&nbsp; &nbsp; &nbsp; &nbsp; - converts &quot;nspname&quot; to namespace OID<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We also <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> a <a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> OID, for symmetry with the output routine.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * '-' signifies unknown (OID 0).&nbsp; In all other cases, the input must<br/></li>
<li></span><span class="Comment"> * match an existing pg_namespace entry.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1658">&#x200c;</a><span class="linkable">regnamespacein</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *nsp_name_or_oid = PG_GETARG_CSTRING(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *escontext = fcinfo-&gt;context;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *names;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Handle &quot;-&quot; or <a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> OID */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1868" title="utils/adt/regproc.c:1868">parseDashOrOid</a>(nsp_name_or_oid, &amp;result, escontext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_OID(result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The rest of this wouldn't work in bootstrap mode */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsBootstrapProcessingMode())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;regnamespace <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> must be OIDs in bootstrap mode&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Normal case: see if the name matches <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pg_namespace entry. */<br/></li>
<li></span>&nbsp; &nbsp; names = <a href="#L1797" title="utils/adt/regproc.c:1797">stringToQualifiedNameList</a>(nsp_name_or_oid, escontext);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (names == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(names) != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_NAME),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid name syntax&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="../../catalog/namespace.c.html#L3520" title="catalog/namespace.c:3520">get_namespace_oid</a>(strVal(linitial(names)), <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_SCHEMA),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;schema </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strVal(linitial(names)))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_OID(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1700" title="utils/adt/regproc.c:1700">to_regnamespace</a>&nbsp; &nbsp; &nbsp; &nbsp; - converts &quot;nspname&quot; to namespace OID<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the name is not found, we return NULL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1700">&#x200c;</a><span class="linkable">to_regnamespace</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *nsp_name = <a href="varlena.c.html#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>(PG_GETARG_TEXT_PP(<span class="Constant">0</span>));<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; ErrorSaveContext escontext = {T_ErrorSaveContext};<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../fmgr/fmgr.c.html#L1640" title="utils/fmgr/fmgr.c:1640">DirectInputFunctionCallSafe</a>(<a href="#L1658" title="utils/adt/regproc.c:1658">regnamespacein</a>, nsp_name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid, -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Node *) &amp;escontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_DATUM(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1718" title="utils/adt/regproc.c:1718">regnamespaceout</a>&nbsp; &nbsp; &nbsp; &nbsp; - converts namespace OID to &quot;nsp_name&quot;<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1718">&#x200c;</a><span class="linkable">regnamespaceout</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nspid = PG_GETARG_OID(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nspid == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<span class="Constant">&quot;-&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_CSTRING(result);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="../cache/lsyscache.c.html#L3366" title="utils/cache/lsyscache.c:3366">get_namespace_name</a>(nspid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a> is not really necessary, but it avoids a compiler warning */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<a href="ruleutils.c.html#L12623" title="utils/adt/ruleutils.c:12623">quote_identifier</a>(result));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If OID doesn't match <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> namespace, return it numerically */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = (<span class="Type">char</span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(NAMEDATALEN);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(result, NAMEDATALEN, <span class="Constant">&quot;</span><span class="Special">%u</span><span class="Constant">&quot;</span>, nspid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CSTRING(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1750" title="utils/adt/regproc.c:1750">regnamespacerecv</a>&nbsp; &nbsp; - converts external binary format to regnamespace<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1750">&#x200c;</a><span class="linkable">regnamespacerecv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Exactly the same as <a href="oid.c.html#L60" title="utils/adt/oid.c:60">oidrecv</a>, so share code */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="oid.c.html#L60" title="utils/adt/oid.c:60">oidrecv</a>(fcinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1760" title="utils/adt/regproc.c:1760">regnamespacesend</a>&nbsp; &nbsp; &nbsp; &nbsp; - converts regnamespace to binary format<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1760">&#x200c;</a><span class="linkable">regnamespacesend</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Exactly the same as <a href="oid.c.html#L71" title="utils/adt/oid.c:71">oidsend</a>, so share code */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="oid.c.html#L71" title="utils/adt/oid.c:71">oidsend</a>(fcinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1774" title="utils/adt/regproc.c:1774">text_regclass</a>: convert text to regclass<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This could be replaced by CoerceViaIO, except that we need to treat<br/></li>
<li></span><span class="Comment"> * text-to-regclass as an implicit cast to support legacy forms of <a href="../../commands/sequence.c.html#L586" title="commands/sequence.c:586">nextval</a>()<br/></li>
<li></span><span class="Comment"> * and related <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1774">&#x200c;</a><span class="linkable">text_regclass</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *relname = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; RangeVar&nbsp;&nbsp; *rv;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rv = <a href="../../catalog/namespace.c.html#L3539" title="catalog/namespace.c:3539">makeRangeVarFromNameList</a>(<a href="varlena.c.html#L3399" title="utils/adt/varlena.c:3399">textToQualifiedNameList</a>(relname));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We might not even have permissions on this relation; don't lock it. */<br/></li>
<li></span>&nbsp; &nbsp; result = RangeVarGetRelid(rv, NoLock, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_OID(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Given a C string, <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> it into a qualified-name list.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If escontext is an ErrorSaveContext node, invalid input will be<br/></li>
<li></span><span class="Comment"> * reported there instead of being thrown, and we return NIL.<br/></li>
<li></span><span class="Comment"> * (NIL is not possible as a success return, since empty-input is an error.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L1797">&#x200c;</a><span class="linkable">stringToQualifiedNameList</span>(<span class="Type">const</span> <span class="Type">char</span> *string, Node *escontext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *rawname;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *result = NIL;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *namelist;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We need a modifiable copy of the input string. */<br/></li>
<li></span>&nbsp; &nbsp; rawname = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(string);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="varlena.c.html#L3457" title="utils/adt/varlena.c:3457">SplitIdentifierString</a>(rawname, <span class="Constant">'.'</span>, &amp;namelist))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, NIL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_NAME),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid name syntax&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (namelist == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, NIL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_NAME),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid name syntax&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(l, namelist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *curname = (<span class="Type">char</span> *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(result, <a href="../../nodes/value.c.html#L63" title="nodes/value.c:63">makeString</a>(<a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(curname)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(rawname);<br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(namelist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*****************************************************************************<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; SUPPORT ROUTINES&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment"> *****************************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Given a C string, see if it is all-digits (and not empty).<br/></li>
<li></span><span class="Comment"> * If so, convert directly to OID and return true.<br/></li>
<li></span><span class="Comment"> * If it is not all-digits, return false.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If escontext is an ErrorSaveContext node, <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> error in <a href="oid.c.html#L37" title="utils/adt/oid.c:37">oidin</a>() will be<br/></li>
<li></span><span class="Comment"> * reported there instead of being thrown (but we still return true).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1843">&#x200c;</a></span><span class="linkable">parseNumericOid</span>(<span class="Type">char</span> *string, Oid *result, Node *escontext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (string[<span class="Constant">0</span>] &gt;= <span class="Constant">'0'</span> &amp;&amp; string[<span class="Constant">0</span>] &lt;= <span class="Constant">'9'</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; strspn(string, <span class="Constant">&quot;0123456789&quot;</span>) == strlen(string))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; oid_datum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We need not care here whether <a href="oid.c.html#L37" title="utils/adt/oid.c:37">oidin</a>() fails or not. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../fmgr/fmgr.c.html#L1640" title="utils/fmgr/fmgr.c:1640">DirectInputFunctionCallSafe</a>(<a href="oid.c.html#L37" title="utils/adt/oid.c:37">oidin</a>, string,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid, -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; escontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;oid_datum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *result = DatumGetObjectId(oid_datum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Prevent uninitialized-variable warnings from stupider compilers. */<br/></li>
<li></span>&nbsp; &nbsp; *result = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * As above, but also <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> &quot;-&quot; as meaning 0 (InvalidOid).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1868">&#x200c;</a></span><span class="linkable">parseDashOrOid</span>(<span class="Type">char</span> *string, Oid *result, Node *escontext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* '-' ? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (strcmp(string, <span class="Constant">&quot;-&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *result = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Numeric OID? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1843" title="utils/adt/regproc.c:1843">parseNumericOid</a>(string, result, escontext);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Given a C string, <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> it into a qualified function or operator name<br/></li>
<li></span><span class="Comment"> * followed by a parenthesized list of type names.&nbsp; Reduce the<br/></li>
<li></span><span class="Comment"> * type names to an array of OIDs (returned into *nargs and *argtypes;<br/></li>
<li></span><span class="Comment"> * the argtypes array should be of size FUNC_MAX_ARGS).&nbsp; The function or<br/></li>
<li></span><span class="Comment"> * operator name is returned to *names as a List of Strings.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If allowNone is true, <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> &quot;NONE&quot; and return it as InvalidOid (this is<br/></li>
<li></span><span class="Comment"> * for unary operators).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true on success, false on failure (the latter only possible<br/></li>
<li></span><span class="Comment"> * if escontext is an ErrorSaveContext node).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1895">&#x200c;</a></span><span class="linkable">parseNameAndArgTypes</span>(<span class="Type">const</span> <span class="Type">char</span> *string, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> allowNone, List **names,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> *nargs, Oid *argtypes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Node *escontext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *rawname;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ptr2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *typename;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; in_quote;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; had_comma;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paren_count;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typeid;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; typmod;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We need a modifiable copy of the input string. */<br/></li>
<li></span>&nbsp; &nbsp; rawname = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(string);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Scan to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the expected left paren; mustn't be quoted */<br/></li>
<li></span>&nbsp; &nbsp; in_quote = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (ptr = rawname; *ptr; ptr++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*ptr == <span class="Constant">'&quot;'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in_quote = !in_quote;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*ptr == <span class="Constant">'('</span> &amp;&amp; !in_quote)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*ptr == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;expected a left parenthesis&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Separate the name and <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> it into a list */<br/></li>
<li></span>&nbsp; &nbsp; *ptr++ = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; *names = <a href="#L1797" title="utils/adt/regproc.c:1797">stringToQualifiedNameList</a>(rawname, escontext);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*names == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for the trailing right parenthesis and remove it */<br/></li>
<li></span>&nbsp; &nbsp; ptr2 = ptr + strlen(ptr);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (--ptr2 &gt; ptr)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../parser/scansup.c.html#L117" title="parser/scansup.c:117">scanner_isspace</a>(*ptr2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*ptr2 != <span class="Constant">')'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;expected a right parenthesis&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *ptr2 = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Separate the remaining string into comma-separated type names */<br/></li>
<li></span>&nbsp; &nbsp; *nargs = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; had_comma = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* allow leading whitespace */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (<a href="../../parser/scansup.c.html#L117" title="parser/scansup.c:117">scanner_isspace</a>(*ptr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*ptr == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* End of string.&nbsp; Okay unless we had a comma <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (had_comma)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;expected a type name&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typename = ptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Find end of type name --- end of string or comma */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ... but not a quoted or parenthesized comma */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; in_quote = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; paren_count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (; *ptr; ptr++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*ptr == <span class="Constant">'&quot;'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in_quote = !in_quote;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*ptr == <span class="Constant">','</span> &amp;&amp; !in_quote &amp;&amp; paren_count == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!in_quote)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (*ptr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'('</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'['</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paren_count++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">')'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">']'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paren_count--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (in_quote || paren_count != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;improper type name&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr2 = ptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*ptr == <span class="Constant">','</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; had_comma = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *ptr++ = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; had_comma = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(*ptr == <span class="Special">'\0'</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Lop off trailing whitespace */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (--ptr2 &gt;= typename)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../parser/scansup.c.html#L117" title="parser/scansup.c:117">scanner_isspace</a>(*ptr2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *ptr2 = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (allowNone &amp;&amp; pg_strcasecmp(typename, <span class="Constant">&quot;<a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a>&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Special case for NONE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typeid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typmod = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Use full parser to resolve the type name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../parser/parse_type.c.html#L785" title="parser/parse_type.c:785">parseTypeString</a>(typename, &amp;typeid, &amp;typmod, escontext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*nargs &gt;= FUNC_MAX_ARGS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_TOO_MANY_ARGUMENTS),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;too many arguments&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; argtypes[*nargs] = typeid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (*nargs)++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(rawname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
