<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/adt/jsonfuncs.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/adt/jsonfuncs.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L101">AlenState</a></li>
<li><a href="#L105">AlenState</a></li>
<li><a href="#L165">ArrayIOData</a></li>
<li><a href="#L170">ArrayIOData</a></li>
<li><a href="#L161">ColumnIOData</a></li>
<li><a href="#L210">ColumnIOData</a></li>
<li><a href="#L173">CompositeIOData</a></li>
<li><a href="#L186">CompositeIOData</a></li>
<li><a href="#L189">DomainIOData</a></li>
<li><a href="#L195">DomainIOData</a></li>
<li><a href="#L108">EachState</a></li>
<li><a href="#L118">EachState</a></li>
<li><a href="#L121">ElementsState</a></li>
<li><a href="#L132">ElementsState</a></li>
<li><a href="#L85">GetState</a></li>
<li><a href="#L98">GetState</a></li>
<li><a href="#L64">IterateJsonStringValuesState</a></li>
<li><a href="#L72">IterateJsonStringValuesState</a></li>
<li><a href="#L135">JHashState</a></li>
<li><a href="#L143">JHashState</a></li>
<li><a href="#L307">JsObject</a></li>
<li><a href="#L315">JsObject</a></li>
<li><a href="#L291">JsValue</a></li>
<li><a href="#L305">JsValue</a></li>
<li><a href="#L146">JsonHashEntry</a></li>
<li><a href="#L151">JsonHashEntry</a></li>
<li><a href="#L54">OkeysState</a></li>
<li><a href="#L61">OkeysState</a></li>
<li><a href="#L258">PopulateArrayContext</a></li>
<li><a href="#L269">PopulateArrayContext</a></li>
<li><a href="#L272">PopulateArrayState</a></li>
<li><a href="#L280">PopulateArrayState</a></li>
<li><a href="#L236">PopulateRecordCache</a></li>
<li><a href="#L241">PopulateRecordCache</a></li>
<li><a href="#L244">PopulateRecordsetState</a></li>
<li><a href="#L255">PopulateRecordsetState</a></li>
<li><a href="#L162">RecordIOData</a></li>
<li><a href="#L227">RecordIOData</a></li>
<li><a href="#L154">ScalarIOData</a></li>
<li><a href="#L158">ScalarIOData</a></li>
<li><a href="#L283">StripnullState</a></li>
<li><a href="#L288">StripnullState</a></li>
<li><a href="#L75">TransformJsonStringValuesState</a></li>
<li><a href="#L82">TransformJsonStringValuesState</a></li>
<li><a href="#L198">TypeCat</a></li>
<li><a href="#L205">TypeCat</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L5030">IteratorConcat</a></li>
<li><a href="#L3469">JsObjectGetField</a></li>
<li><a href="#L2978">JsValueToJsObject</a></li>
<li><a href="#L1802">JsonbValueAsText</a></li>
<li><a href="#L1925">alen_array_element_start</a></li>
<li><a href="#L1897">alen_object_start</a></li>
<li><a href="#L1911">alen_scalar</a></li>
<li><a href="#L3453">allocate_record_info</a></li>
<li><a href="#L2165">each_array_start</a></li>
<li><a href="#L2117">each_object_field_end</a></li>
<li><a href="#L2095">each_object_field_start</a></li>
<li><a href="#L2179">each_scalar</a></li>
<li><a href="#L2055">each_worker</a></li>
<li><a href="#L1971">each_worker_jsonb</a></li>
<li><a href="#L2369">elements_array_element_end</a></li>
<li><a href="#L2347">elements_array_element_start</a></li>
<li><a href="#L2415">elements_object_start</a></li>
<li><a href="#L2430">elements_scalar</a></li>
<li><a href="#L2305">elements_worker</a></li>
<li><a href="#L2217">elements_worker_jsonb</a></li>
<li><a href="#L1398">get_array_element_end</a></li>
<li><a href="#L1350">get_array_element_start</a></li>
<li><a href="#L1332">get_array_end</a></li>
<li><a href="#L1292">get_array_start</a></li>
<li><a href="#L3787">get_json_object_as_hash</a></li>
<li><a href="#L1497">get_jsonb_path_all</a></li>
<li><a href="#L1176">get_object_end</a></li>
<li><a href="#L1241">get_object_field_end</a></li>
<li><a href="#L1194">get_object_field_start</a></li>
<li><a href="#L1157">get_object_start</a></li>
<li><a href="#L1021">get_path_all</a></li>
<li><a href="#L3612">get_record_type_from_argument</a></li>
<li><a href="#L3638">get_record_type_from_query</a></li>
<li><a href="#L1442">get_scalar</a></li>
<li><a href="#L1100">get_worker</a></li>
<li><a href="#L3906">hash_array_start</a></li>
<li><a href="#L3855">hash_object_field_end</a></li>
<li><a href="#L3829">hash_object_field_start</a></li>
<li><a href="#L3919">hash_scalar</a></li>
<li><a href="#L5686">iterate_json_values</a></li>
<li><a href="#L5618">iterate_jsonb_values</a></li>
<li><a href="#L5739">iterate_values_object_field_start</a></li>
<li><a href="#L5711">iterate_values_scalar</a></li>
<li><a href="#L919">json_array_element</a></li>
<li><a href="#L962">json_array_element_text</a></li>
<li><a href="#L2293">json_array_elements</a></li>
<li><a href="#L2299">json_array_elements_text</a></li>
<li><a href="#L1849">json_array_length</a></li>
<li><a href="#L5953">json_categorize_type</a></li>
<li><a href="#L1947">json_each</a></li>
<li><a href="#L1959">json_each_text</a></li>
<li><a href="#L638">json_errsave_error</a></li>
<li><a href="#L1006">json_extract_path</a></li>
<li><a href="#L1012">json_extract_path_text</a></li>
<li><a href="#L5926">json_get_first_token</a></li>
<li><a href="#L843">json_object_field</a></li>
<li><a href="#L881">json_object_field_text</a></li>
<li><a href="#L729">json_object_keys</a></li>
<li><a href="#L2492">json_populate_record</a></li>
<li><a href="#L3964">json_populate_recordset</a></li>
<li><a href="#L3335">json_populate_type</a></li>
<li><a href="#L4470">json_strip_nulls</a></li>
<li><a href="#L2499">json_to_record</a></li>
<li><a href="#L3971">json_to_recordset</a></li>
<li><a href="#L934">jsonb_array_element</a></li>
<li><a href="#L977">jsonb_array_element_text</a></li>
<li><a href="#L2205">jsonb_array_elements</a></li>
<li><a href="#L2211">jsonb_array_elements_text</a></li>
<li><a href="#L1875">jsonb_array_length</a></li>
<li><a href="#L4577">jsonb_concat</a></li>
<li><a href="#L4618">jsonb_delete</a></li>
<li><a href="#L4671">jsonb_delete_array</a></li>
<li><a href="#L4758">jsonb_delete_idx</a></li>
<li><a href="#L4938">jsonb_delete_path</a></li>
<li><a href="#L1953">jsonb_each</a></li>
<li><a href="#L1965">jsonb_each_text</a></li>
<li><a href="#L1485">jsonb_extract_path</a></li>
<li><a href="#L1491">jsonb_extract_path_text</a></li>
<li><a href="#L1528">jsonb_get_element</a></li>
<li><a href="#L4981">jsonb_insert</a></li>
<li><a href="#L859">jsonb_object_field</a></li>
<li><a href="#L897">jsonb_object_field_text</a></li>
<li><a href="#L565">jsonb_object_keys</a></li>
<li><a href="#L2461">jsonb_populate_record</a></li>
<li><a href="#L2474">jsonb_populate_record_valid</a></li>
<li><a href="#L3950">jsonb_populate_recordset</a></li>
<li><a href="#L4561">jsonb_pretty</a></li>
<li><a href="#L4822">jsonb_set</a></li>
<li><a href="#L1676">jsonb_set_element</a></li>
<li><a href="#L4871">jsonb_set_lax</a></li>
<li><a href="#L4503">jsonb_strip_nulls</a></li>
<li><a href="#L2485">jsonb_to_record</a></li>
<li><a href="#L3957">jsonb_to_recordset</a></li>
<li><a href="#L537">makeJsonLexContext</a></li>
<li><a href="#L806">okeys_array_start</a></li>
<li><a href="#L783">okeys_object_field_start</a></li>
<li><a href="#L821">okeys_scalar</a></li>
<li><a href="#L5550">parse_jsonb_index_flags</a></li>
<li><a href="#L516">pg_parse_json_or_errsave</a></li>
<li><a href="#L2911">populate_array</a></li>
<li><a href="#L2664">populate_array_array_end</a></li>
<li><a href="#L2557">populate_array_assign_ndims</a></li>
<li><a href="#L2587">populate_array_check_dimension</a></li>
<li><a href="#L2821">populate_array_dim_jsonb</a></li>
<li><a href="#L2615">populate_array_element</a></li>
<li><a href="#L2706">populate_array_element_end</a></li>
<li><a href="#L2688">populate_array_element_start</a></li>
<li><a href="#L2785">populate_array_json</a></li>
<li><a href="#L2641">populate_array_object_start</a></li>
<li><a href="#L2507">populate_array_report_expected_array</a></li>
<li><a href="#L2749">populate_array_scalar</a></li>
<li><a href="#L3054">populate_composite</a></li>
<li><a href="#L3208">populate_domain</a></li>
<li><a href="#L3497">populate_record</a></li>
<li><a href="#L3384">populate_record_field</a></li>
<li><a href="#L3675">populate_record_worker</a></li>
<li><a href="#L4244">populate_recordset_array_element_start</a></li>
<li><a href="#L4259">populate_recordset_array_start</a></li>
<li><a href="#L4221">populate_recordset_object_end</a></li>
<li><a href="#L4306">populate_recordset_object_field_end</a></li>
<li><a href="#L4283">populate_recordset_object_field_start</a></li>
<li><a href="#L4191">populate_recordset_object_start</a></li>
<li><a href="#L3978">populate_recordset_record</a></li>
<li><a href="#L4266">populate_recordset_scalar</a></li>
<li><a href="#L4017">populate_recordset_worker</a></li>
<li><a href="#L3121">populate_scalar</a></li>
<li><a href="#L3241">prepare_column_cache</a></li>
<li><a href="#L1699">push_null_elements</a></li>
<li><a href="#L1718">push_path</a></li>
<li><a href="#L674">report_json_context</a></li>
<li><a href="#L5158">setPath</a></li>
<li><a href="#L5379">setPathArray</a></li>
<li><a href="#L5240">setPathObject</a></li>
<li><a href="#L4436">sn_array_element_start</a></li>
<li><a href="#L4396">sn_array_end</a></li>
<li><a href="#L4386">sn_array_start</a></li>
<li><a href="#L4376">sn_object_end</a></li>
<li><a href="#L4406">sn_object_field_start</a></li>
<li><a href="#L4366">sn_object_start</a></li>
<li><a href="#L4447">sn_scalar</a></li>
<li><a href="#L5807">transform_json_string_values</a></li>
<li><a href="#L5760">transform_jsonb_string_values</a></li>
<li><a href="#L5898">transform_string_values_array_element_start</a></li>
<li><a href="#L5870">transform_string_values_array_end</a></li>
<li><a href="#L5860">transform_string_values_array_start</a></li>
<li><a href="#L5850">transform_string_values_object_end</a></li>
<li><a href="#L5880">transform_string_values_object_field_start</a></li>
<li><a href="#L5840">transform_string_values_object_start</a></li>
<li><a href="#L5909">transform_string_values_scalar</a></li>
<li><a href="#L3025">update_cached_tupdesc</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L51">JB_PATH_CONSISTENT_POSITION</a></li>
<li><a href="#L43">JB_PATH_CREATE</a></li>
<li><a href="#L48">JB_PATH_CREATE_OR_INSERT</a></li>
<li><a href="#L44">JB_PATH_DELETE</a></li>
<li><a href="#L50">JB_PATH_FILL_GAPS</a></li>
<li><a href="#L47">JB_PATH_INSERT_AFTER</a></li>
<li><a href="#L46">JB_PATH_INSERT_BEFORE</a></li>
<li><a href="#L45">JB_PATH_REPLACE</a></li>
<li><a href="#L333">JsObjectFree</a></li>
<li><a href="#L327">JsObjectIsEmpty</a></li>
<li><a href="#L318">JsValueIsNull</a></li>
<li><a href="#L323">JsValueIsString</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * jsonfuncs.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Functions to process JSON data types.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/adt/jsonfuncs.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;limits.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/jsonapi.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/string.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;fmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;funcapi.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lib/stringinfo.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;mb/pg_wchar.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/miscnodes.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_coerce.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/array.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgroids.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/hsearch.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/json.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/jsonb.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/jsonfuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/syscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/typcache.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Operations available for <a href="#L5158" title="utils/adt/jsonfuncs.c:5158">setPath</a> */<br/></li>
<li><a id="L43">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">JB_PATH_CREATE</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0x0001<br/></li>
<li><a id="L44">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">JB_PATH_DELETE</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0x0002<br/></li>
<li><a id="L45">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">JB_PATH_REPLACE</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0x0004<br/></li>
<li><a id="L46">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">JB_PATH_INSERT_BEFORE</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0x0008<br/></li>
<li><a id="L47">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">JB_PATH_INSERT_AFTER</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0x0010<br/></li>
<li><a id="L48">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">JB_PATH_CREATE_OR_INSERT</span> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (<a href="#L46" title="utils/adt/jsonfuncs.c:46">JB_PATH_INSERT_BEFORE</a> | <a href="#L47" title="utils/adt/jsonfuncs.c:47">JB_PATH_INSERT_AFTER</a> | <a href="#L43" title="utils/adt/jsonfuncs.c:43">JB_PATH_CREATE</a>)<br/></li>
<li><a id="L50">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">JB_PATH_FILL_GAPS</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0x0020<br/></li>
<li><a id="L51">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">JB_PATH_CONSISTENT_POSITION</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0x0040<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* state for <a href="#L729" title="utils/adt/jsonfuncs.c:729">json_object_keys</a> */<br/></li>
<li><a id="L54">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">OkeysState</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JsonLexContext *lex;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; **result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result_size;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result_count;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sent_count;<br/></li>
<li><a id="L61">&#x200c;</a>} <span class="linkable">OkeysState</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* state for <a href="#L5686" title="utils/adt/jsonfuncs.c:5686">iterate_json_values</a> function */<br/></li>
<li><a id="L64">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">IterateJsonStringValuesState</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JsonLexContext *lex;<br/></li>
<li>&nbsp; &nbsp; JsonIterateStringValuesAction action;&nbsp; &nbsp; <span class="Comment">/* an action that will be applied<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to each json value */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *action_state;&nbsp; &nbsp; <span class="Comment">/* <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> necessary context for iteration */<br/></li>
<li></span>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; flags;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* what kind of elements from a json we want<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to iterate */<br/></li>
<li><a id="L72">&#x200c;</a></span>} <span class="linkable">IterateJsonStringValuesState</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* state for <a href="#L5807" title="utils/adt/jsonfuncs.c:5807">transform_json_string_values</a> function */<br/></li>
<li><a id="L75">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">TransformJsonStringValuesState</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JsonLexContext *lex;<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; strval;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* resulting json */<br/></li>
<li></span>&nbsp; &nbsp; JsonTransformStringValuesAction action; <span class="Comment">/* an action that will be applied<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to each json value */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *action_state;&nbsp; &nbsp; <span class="Comment">/* <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> necessary context for transformation */<br/></li>
<li><a id="L82">&#x200c;</a></span>} <span class="linkable">TransformJsonStringValuesState</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* state for json_get* <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li><a id="L85">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">GetState</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JsonLexContext *lex;<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *tresult;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *result_start;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; normalize_results;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; next_scalar;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; npath;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* length of each path-related array */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; **path_names;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* field name(s) being sought */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *path_indexes;&nbsp; &nbsp; <span class="Comment">/* array index(es) being sought */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *pathok;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* is path matched to current depth? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *array_cur_index;&nbsp; &nbsp; <span class="Comment">/* current <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> index at each path<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * level */<br/></li>
<li><a id="L98">&#x200c;</a></span>} <span class="linkable">GetState</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* state for <a href="#L1849" title="utils/adt/jsonfuncs.c:1849">json_array_length</a> */<br/></li>
<li><a id="L101">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">AlenState</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JsonLexContext *lex;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count;<br/></li>
<li><a id="L105">&#x200c;</a>} <span class="linkable">AlenState</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* state for <a href="#L1947" title="utils/adt/jsonfuncs.c:1947">json_each</a> */<br/></li>
<li><a id="L108">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">EachState</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JsonLexContext *lex;<br/></li>
<li>&nbsp; &nbsp; <a href="../sort/tuplestore.c.html#L103" title="utils/sort/tuplestore.c:103">Tuplestorestate</a> *tuple_store;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; ret_tdesc;<br/></li>
<li>&nbsp; &nbsp; MemoryContext tmp_cxt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *result_start;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; normalize_results;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; next_scalar;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *normalized_scalar;<br/></li>
<li><a id="L118">&#x200c;</a>} <span class="linkable">EachState</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* state for <a href="#L2293" title="utils/adt/jsonfuncs.c:2293">json_array_elements</a> */<br/></li>
<li><a id="L121">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">ElementsState</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JsonLexContext *lex;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *function_name;<br/></li>
<li>&nbsp; &nbsp; <a href="../sort/tuplestore.c.html#L103" title="utils/sort/tuplestore.c:103">Tuplestorestate</a> *tuple_store;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; ret_tdesc;<br/></li>
<li>&nbsp; &nbsp; MemoryContext tmp_cxt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *result_start;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; normalize_results;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; next_scalar;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *normalized_scalar;<br/></li>
<li><a id="L132">&#x200c;</a>} <span class="linkable">ElementsState</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* state for <a href="#L3787" title="utils/adt/jsonfuncs.c:3787">get_json_object_as_hash</a> */<br/></li>
<li><a id="L135">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">JHashState</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JsonLexContext *lex;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *function_name;<br/></li>
<li>&nbsp; &nbsp; <a href="../hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a>&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *saved_scalar;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *save_json_start;<br/></li>
<li>&nbsp; &nbsp; JsonTokenType saved_token_type;<br/></li>
<li><a id="L143">&#x200c;</a>} <span class="linkable">JHashState</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* hashtable <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> */<br/></li>
<li><a id="L146">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">JsonHashEntry</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; fname[NAMEDATALEN]; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> key (MUST BE FIRST) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *val;<br/></li>
<li>&nbsp; &nbsp; JsonTokenType type;<br/></li>
<li><a id="L151">&#x200c;</a>} <span class="linkable">JsonHashEntry</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* structure to cache type I/O metadata needed for <a href="#L3121" title="utils/adt/jsonfuncs.c:3121">populate_scalar</a>() */<br/></li>
<li><a id="L154">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">ScalarIOData</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typioparam;<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; typiofunc;<br/></li>
<li><a id="L158">&#x200c;</a>} <span class="linkable">ScalarIOData</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* these two structures are used recursively */<br/></li>
<li><a id="L161">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">ColumnIOData</span> <span class="linkable">ColumnIOData</span>;<br/></li>
<li><a id="L162">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">RecordIOData</span> <span class="linkable">RecordIOData</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* structure to cache metadata needed for <a href="#L2911" title="utils/adt/jsonfuncs.c:2911">populate_array</a>() */<br/></li>
<li><a id="L165">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">ArrayIOData</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="rowtypes.c.html#L34" title="utils/adt/rowtypes.c:34">ColumnIOData</a> *element_info; <span class="Comment">/* metadata cache */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; element_type;&nbsp; &nbsp; <span class="Comment">/* array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type id */<br/></li>
<li></span>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; element_typmod; <span class="Comment">/* array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type modifier */<br/></li>
<li><a id="L170">&#x200c;</a></span>} <span class="linkable">ArrayIOData</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* structure to cache metadata needed for <a href="#L3054" title="utils/adt/jsonfuncs.c:3054">populate_composite</a>() */<br/></li>
<li><a id="L173">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">CompositeIOData</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We use pointer to a <a href="rowtypes.c.html#L43" title="utils/adt/rowtypes.c:43">RecordIOData</a> here because variable-length struct<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="rowtypes.c.html#L43" title="utils/adt/rowtypes.c:43">RecordIOData</a> can't be used directly in <a href="rowtypes.c.html#L34" title="utils/adt/rowtypes.c:34">ColumnIOData</a>.io union<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="rowtypes.c.html#L43" title="utils/adt/rowtypes.c:43">RecordIOData</a> *record_io;&nbsp; &nbsp; <span class="Comment">/* metadata cache for <a href="#L3497" title="utils/adt/jsonfuncs.c:3497">populate_record</a>() */<br/></li>
<li></span>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* cached tuple descriptor */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* these fields differ from target type only if domain over composite: */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; base_typid;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* base type id */<br/></li>
<li></span>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; base_typmod;&nbsp; &nbsp; <span class="Comment">/* base type modifier */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* this field is used only if target type is domain over composite: */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *domain_info;&nbsp; &nbsp; <span class="Comment">/* opaque cache for domain checks */<br/></li>
<li><a id="L186">&#x200c;</a></span>} <span class="linkable">CompositeIOData</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* structure to cache metadata needed for <a href="#L3208" title="utils/adt/jsonfuncs.c:3208">populate_domain</a>() */<br/></li>
<li><a id="L189">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">DomainIOData</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="rowtypes.c.html#L34" title="utils/adt/rowtypes.c:34">ColumnIOData</a> *base_io;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* metadata cache */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; base_typid;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* base type id */<br/></li>
<li></span>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; base_typmod;&nbsp; &nbsp; <span class="Comment">/* base type modifier */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *domain_info;&nbsp; &nbsp; <span class="Comment">/* opaque cache for domain checks */<br/></li>
<li><a id="L195">&#x200c;</a></span>} <span class="linkable">DomainIOData</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* enumeration type categories */<br/></li>
<li><a id="L198">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">enum</span> <span class="linkable">TypeCat</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TYPECAT_SCALAR = <span class="Constant">'s'</span>,<br/></li>
<li>&nbsp; &nbsp; TYPECAT_ARRAY = <span class="Constant">'a'</span>,<br/></li>
<li>&nbsp; &nbsp; TYPECAT_COMPOSITE = <span class="Constant">'c'</span>,<br/></li>
<li>&nbsp; &nbsp; TYPECAT_COMPOSITE_DOMAIN = <span class="Constant">'C'</span>,<br/></li>
<li>&nbsp; &nbsp; TYPECAT_DOMAIN = <span class="Constant">'d'</span>,<br/></li>
<li><a id="L205">&#x200c;</a>} <span class="linkable">TypeCat</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* these two are stolen from hstore / <a href="rowtypes.c.html#L329" title="utils/adt/rowtypes.c:329">record_out</a>, used in <a href="#L3497" title="utils/adt/jsonfuncs.c:3497">populate_record</a>* */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* structure to cache record metadata needed for <a href="#L3384" title="utils/adt/jsonfuncs.c:3384">populate_record_field</a>() */<br/></li>
<li><a id="L210">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">ColumnIOData</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typid;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* column type id */<br/></li>
<li></span>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; typmod;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* column type modifier */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L198" title="utils/adt/jsonfuncs.c:198">TypeCat</a>&nbsp; &nbsp; &nbsp; &nbsp; typcat;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* column type category */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L154" title="utils/adt/jsonfuncs.c:154">ScalarIOData</a> scalar_io;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* metadata cache for direct conversion<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * through input function */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">union<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L165" title="utils/adt/jsonfuncs.c:165">ArrayIOData</a> array;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L173" title="utils/adt/jsonfuncs.c:173">CompositeIOData</a> composite;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L189" title="utils/adt/jsonfuncs.c:189">DomainIOData</a> domain;<br/></li>
<li>&nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; io;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* metadata cache for various column type<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * categories */<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><span class="Comment">/* structure to cache record metadata needed for <a href="#L3497" title="utils/adt/jsonfuncs.c:3497">populate_record</a>() */<br/></li>
<li><a id="L227">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">RecordIOData</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; record_type;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; record_typmod;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ncolumns;<br/></li>
<li>&nbsp; &nbsp; <a href="rowtypes.c.html#L34" title="utils/adt/rowtypes.c:34">ColumnIOData</a> columns[FLEXIBLE_ARRAY_MEMBER];<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><span class="Comment">/* per-query cache for <a href="#L3675" title="utils/adt/jsonfuncs.c:3675">populate_record_worker</a> and <a href="#L4017" title="utils/adt/jsonfuncs.c:4017">populate_recordset_worker</a> */<br/></li>
<li><a id="L236">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">PopulateRecordCache</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; argtype;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* declared type of the record argument */<br/></li>
<li></span>&nbsp; &nbsp; <a href="rowtypes.c.html#L34" title="utils/adt/rowtypes.c:34">ColumnIOData</a> c;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* metadata cache for <a href="#L3054" title="utils/adt/jsonfuncs.c:3054">populate_composite</a>() */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContext fn_mcxt;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* where this is stored */<br/></li>
<li><a id="L241">&#x200c;</a></span>} <span class="linkable">PopulateRecordCache</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* per-call state for populate_recordset */<br/></li>
<li><a id="L244">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">PopulateRecordsetState</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JsonLexContext *lex;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *function_name;<br/></li>
<li>&nbsp; &nbsp; <a href="../hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a>&nbsp; &nbsp; &nbsp;&nbsp; *json_hash;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *saved_scalar;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *save_json_start;<br/></li>
<li>&nbsp; &nbsp; JsonTokenType saved_token_type;<br/></li>
<li>&nbsp; &nbsp; <a href="../sort/tuplestore.c.html#L103" title="utils/sort/tuplestore.c:103">Tuplestorestate</a> *tuple_store;<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeader rec;<br/></li>
<li>&nbsp; &nbsp; <a href="#L236" title="utils/adt/jsonfuncs.c:236">PopulateRecordCache</a> *cache;<br/></li>
<li><a id="L255">&#x200c;</a>} <span class="linkable">PopulateRecordsetState</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* common data for <a href="#L2785" title="utils/adt/jsonfuncs.c:2785">populate_array_json</a>() and <a href="#L2821" title="utils/adt/jsonfuncs.c:2821">populate_array_dim_jsonb</a>() */<br/></li>
<li><a id="L258">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">PopulateArrayContext</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayBuildState *astate;&nbsp; &nbsp; <span class="Comment">/* array build state */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L165" title="utils/adt/jsonfuncs.c:165">ArrayIOData</a> *aio;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* metadata cache */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContext acxt;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* array build memory context */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContext mcxt;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* cache memory context */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *colname;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* for diagnostics only */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *dims;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* dimensions */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *sizes;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* current dimension counters */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndims;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* number of dimensions */<br/></li>
<li></span>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *escontext;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* For soft-error handling */<br/></li>
<li><a id="L269">&#x200c;</a></span>} <span class="linkable">PopulateArrayContext</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* state for <a href="#L2785" title="utils/adt/jsonfuncs.c:2785">populate_array_json</a>() */<br/></li>
<li><a id="L272">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">PopulateArrayState</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JsonLexContext *lex;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* json lexer */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L258" title="utils/adt/jsonfuncs.c:258">PopulateArrayContext</a> *ctx;&nbsp; &nbsp; <span class="Comment">/* context */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *element_start;&nbsp; &nbsp; <span class="Comment">/* start of the current array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *element_scalar; <span class="Comment">/* current array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> token if it is a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * scalar */<br/></li>
<li></span>&nbsp; &nbsp; JsonTokenType element_type; <span class="Comment">/* current array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type */<br/></li>
<li><a id="L280">&#x200c;</a></span>} <span class="linkable">PopulateArrayState</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* state for <a href="#L4470" title="utils/adt/jsonfuncs.c:4470">json_strip_nulls</a> */<br/></li>
<li><a id="L283">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">StripnullState</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JsonLexContext *lex;<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; strval;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; skip_next_null;<br/></li>
<li><a id="L288">&#x200c;</a>} <span class="linkable">StripnullState</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* structure for generalized json/jsonb value passing */<br/></li>
<li><a id="L291">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">JsValue</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_json;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* json/jsonb */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">union<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *str;&nbsp; &nbsp; <span class="Comment">/* json string */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;&nbsp; &nbsp; <span class="Comment">/* json string length or -1 if null-terminated */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JsonTokenType type; <span class="Comment">/* json type */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; json;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* json value */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; JsonbValue *jsonb;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* jsonb value */<br/></li>
<li></span>&nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li><a id="L305">&#x200c;</a>} <span class="linkable">JsValue</span>;<br/></li>
<li><br/></li>
<li><a id="L307">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">JsObject</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_json;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* json/jsonb */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">union<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a>&nbsp; &nbsp; &nbsp;&nbsp; *json_hash;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; JsonbContainer *jsonb_cont;<br/></li>
<li>&nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li><a id="L315">&#x200c;</a>} <span class="linkable">JsObject</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* useful macros for testing <a href="#L291" title="utils/adt/jsonfuncs.c:291">JsValue</a> properties */<br/></li>
<li><a id="L318">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">JsValueIsNull</span>(jsv) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((jsv)-&gt;is_json ?&nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; (!(jsv)-&gt;val.json.str || (jsv)-&gt;val.json.type == JSON_TOKEN_NULL) : \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; (!(jsv)-&gt;val.jsonb || (jsv)-&gt;val.jsonb-&gt;type == jbvNull))<br/></li>
<li></span><br/></li>
<li><a id="L323">&#x200c;</a><span class="PreProc">#define <span class="linkable">JsValueIsString</span>(jsv) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((jsv)-&gt;is_json ? (jsv)-&gt;val.json.type == JSON_TOKEN_STRING \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; : ((jsv)-&gt;val.jsonb &amp;&amp; (jsv)-&gt;val.jsonb-&gt;type == jbvString))<br/></li>
<li></span><br/></li>
<li><a id="L327">&#x200c;</a><span class="PreProc">#define <span class="linkable">JsObjectIsEmpty</span>(jso) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((jso)-&gt;is_json \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; ? <a href="../hash/dynahash.c.html#L1341" title="utils/hash/dynahash.c:1341">hash_get_num_entries</a>((jso)-&gt;val.json_hash) == </span><span class="Constant">0</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; : ((jso)-&gt;val.jsonb_cont == </span><span class="Constant">NULL</span><span class="PreProc"> || \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; JsonContainerSize((jso)-&gt;val.jsonb_cont) == </span><span class="Constant">0</span><span class="PreProc">))<br/></li>
<li></span><br/></li>
<li><a id="L333">&#x200c;</a><span class="PreProc">#define <span class="linkable">JsObjectFree</span>(jso) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">do</span><span class="PreProc"> { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="PreProc"> ((jso)-&gt;is_json) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../hash/dynahash.c.html#L865" title="utils/hash/dynahash.c:865">hash_destroy</a>((jso)-&gt;val.json_hash); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; } </span><span class="Statement">while</span><span class="PreProc"> (</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L674" title="utils/adt/jsonfuncs.c:674">report_json_context</a>(JsonLexContext *lex);<br/></li>
<li><br/></li>
<li><span class="Comment">/* semantic action <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for <a href="#L729" title="utils/adt/jsonfuncs.c:729">json_object_keys</a> */<br/></li>
<li></span><span class="Type">static</span> JsonParseErrorType <a href="#L783" title="utils/adt/jsonfuncs.c:783">okeys_object_field_start</a>(<span class="Type">void</span> *state, <span class="Type">char</span> *fname, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isnull);<br/></li>
<li><span class="Type">static</span> JsonParseErrorType <a href="#L806" title="utils/adt/jsonfuncs.c:806">okeys_array_start</a>(<span class="Type">void</span> *state);<br/></li>
<li><span class="Type">static</span> JsonParseErrorType <a href="#L821" title="utils/adt/jsonfuncs.c:821">okeys_scalar</a>(<span class="Type">void</span> *state, <span class="Type">char</span> *token, JsonTokenType tokentype);<br/></li>
<li><br/></li>
<li><span class="Comment">/* semantic action <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for json_get* <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span><span class="Type">static</span> JsonParseErrorType <a href="#L1157" title="utils/adt/jsonfuncs.c:1157">get_object_start</a>(<span class="Type">void</span> *state);<br/></li>
<li><span class="Type">static</span> JsonParseErrorType <a href="#L1176" title="utils/adt/jsonfuncs.c:1176">get_object_end</a>(<span class="Type">void</span> *state);<br/></li>
<li><span class="Type">static</span> JsonParseErrorType <a href="#L1194" title="utils/adt/jsonfuncs.c:1194">get_object_field_start</a>(<span class="Type">void</span> *state, <span class="Type">char</span> *fname, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isnull);<br/></li>
<li><span class="Type">static</span> JsonParseErrorType <a href="#L1241" title="utils/adt/jsonfuncs.c:1241">get_object_field_end</a>(<span class="Type">void</span> *state, <span class="Type">char</span> *fname, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isnull);<br/></li>
<li><span class="Type">static</span> JsonParseErrorType <a href="#L1292" title="utils/adt/jsonfuncs.c:1292">get_array_start</a>(<span class="Type">void</span> *state);<br/></li>
<li><span class="Type">static</span> JsonParseErrorType <a href="#L1332" title="utils/adt/jsonfuncs.c:1332">get_array_end</a>(<span class="Type">void</span> *state);<br/></li>
<li><span class="Type">static</span> JsonParseErrorType <a href="#L1350" title="utils/adt/jsonfuncs.c:1350">get_array_element_start</a>(<span class="Type">void</span> *state, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isnull);<br/></li>
<li><span class="Type">static</span> JsonParseErrorType <a href="#L1398" title="utils/adt/jsonfuncs.c:1398">get_array_element_end</a>(<span class="Type">void</span> *state, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isnull);<br/></li>
<li><span class="Type">static</span> JsonParseErrorType <a href="#L1442" title="utils/adt/jsonfuncs.c:1442">get_scalar</a>(<span class="Type">void</span> *state, <span class="Type">char</span> *token, JsonTokenType tokentype);<br/></li>
<li><br/></li>
<li><span class="Comment">/* common worker function for json getter <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span><span class="Type">static</span> Datum <a href="#L1021" title="utils/adt/jsonfuncs.c:1021">get_path_all</a>(FunctionCallInfo fcinfo, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> as_text);<br/></li>
<li><span class="Type">static</span> text *<a href="#L1100" title="utils/adt/jsonfuncs.c:1100">get_worker</a>(text *json, <span class="Type">char</span> **tpath, <span class="Type">int</span> *ipath, <span class="Type">int</span> npath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> normalize_results);<br/></li>
<li><span class="Type">static</span> Datum <a href="#L1497" title="utils/adt/jsonfuncs.c:1497">get_jsonb_path_all</a>(FunctionCallInfo fcinfo, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> as_text);<br/></li>
<li><span class="Type">static</span> text *<a href="#L1802" title="utils/adt/jsonfuncs.c:1802">JsonbValueAsText</a>(JsonbValue *v);<br/></li>
<li><br/></li>
<li><span class="Comment">/* semantic action <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for <a href="#L1849" title="utils/adt/jsonfuncs.c:1849">json_array_length</a> */<br/></li>
<li></span><span class="Type">static</span> JsonParseErrorType <a href="#L1897" title="utils/adt/jsonfuncs.c:1897">alen_object_start</a>(<span class="Type">void</span> *state);<br/></li>
<li><span class="Type">static</span> JsonParseErrorType <a href="#L1911" title="utils/adt/jsonfuncs.c:1911">alen_scalar</a>(<span class="Type">void</span> *state, <span class="Type">char</span> *token, JsonTokenType tokentype);<br/></li>
<li><span class="Type">static</span> JsonParseErrorType <a href="#L1925" title="utils/adt/jsonfuncs.c:1925">alen_array_element_start</a>(<span class="Type">void</span> *state, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isnull);<br/></li>
<li><br/></li>
<li><span class="Comment">/* common workers for json{b}_each* <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span><span class="Type">static</span> Datum <a href="#L2055" title="utils/adt/jsonfuncs.c:2055">each_worker</a>(FunctionCallInfo fcinfo, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> as_text);<br/></li>
<li><span class="Type">static</span> Datum <a href="#L1971" title="utils/adt/jsonfuncs.c:1971">each_worker_jsonb</a>(FunctionCallInfo fcinfo, <span class="Type">const</span> <span class="Type">char</span> *funcname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> as_text);<br/></li>
<li><br/></li>
<li><span class="Comment">/* semantic action <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for <a href="#L1947" title="utils/adt/jsonfuncs.c:1947">json_each</a> */<br/></li>
<li></span><span class="Type">static</span> JsonParseErrorType <a href="#L2095" title="utils/adt/jsonfuncs.c:2095">each_object_field_start</a>(<span class="Type">void</span> *state, <span class="Type">char</span> *fname, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isnull);<br/></li>
<li><span class="Type">static</span> JsonParseErrorType <a href="#L2117" title="utils/adt/jsonfuncs.c:2117">each_object_field_end</a>(<span class="Type">void</span> *state, <span class="Type">char</span> *fname, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isnull);<br/></li>
<li><span class="Type">static</span> JsonParseErrorType <a href="#L2165" title="utils/adt/jsonfuncs.c:2165">each_array_start</a>(<span class="Type">void</span> *state);<br/></li>
<li><span class="Type">static</span> JsonParseErrorType <a href="#L2179" title="utils/adt/jsonfuncs.c:2179">each_scalar</a>(<span class="Type">void</span> *state, <span class="Type">char</span> *token, JsonTokenType tokentype);<br/></li>
<li><br/></li>
<li><span class="Comment">/* common workers for json{b}_array_elements_* <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span><span class="Type">static</span> Datum <a href="#L2305" title="utils/adt/jsonfuncs.c:2305">elements_worker</a>(FunctionCallInfo fcinfo, <span class="Type">const</span> <span class="Type">char</span> *funcname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> as_text);<br/></li>
<li><span class="Type">static</span> Datum <a href="#L2217" title="utils/adt/jsonfuncs.c:2217">elements_worker_jsonb</a>(FunctionCallInfo fcinfo, <span class="Type">const</span> <span class="Type">char</span> *funcname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> as_text);<br/></li>
<li><br/></li>
<li><span class="Comment">/* semantic action <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for <a href="#L2293" title="utils/adt/jsonfuncs.c:2293">json_array_elements</a> */<br/></li>
<li></span><span class="Type">static</span> JsonParseErrorType <a href="#L2415" title="utils/adt/jsonfuncs.c:2415">elements_object_start</a>(<span class="Type">void</span> *state);<br/></li>
<li><span class="Type">static</span> JsonParseErrorType <a href="#L2347" title="utils/adt/jsonfuncs.c:2347">elements_array_element_start</a>(<span class="Type">void</span> *state, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isnull);<br/></li>
<li><span class="Type">static</span> JsonParseErrorType <a href="#L2369" title="utils/adt/jsonfuncs.c:2369">elements_array_element_end</a>(<span class="Type">void</span> *state, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isnull);<br/></li>
<li><span class="Type">static</span> JsonParseErrorType <a href="#L2430" title="utils/adt/jsonfuncs.c:2430">elements_scalar</a>(<span class="Type">void</span> *state, <span class="Type">char</span> *token, JsonTokenType tokentype);<br/></li>
<li><br/></li>
<li><span class="Comment">/* turn a json object into a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table */<br/></li>
<li></span><span class="Type">static</span> <a href="../hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *<a href="#L3787" title="utils/adt/jsonfuncs.c:3787">get_json_object_as_hash</a>(<span class="Type">char</span> *json, <span class="Type">int</span> len, <span class="Type">const</span> <span class="Type">char</span> *funcname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Node *escontext);<br/></li>
<li><br/></li>
<li><span class="Comment">/* semantic actions for <a href="#L2785" title="utils/adt/jsonfuncs.c:2785">populate_array_json</a> */<br/></li>
<li></span><span class="Type">static</span> JsonParseErrorType <a href="#L2641" title="utils/adt/jsonfuncs.c:2641">populate_array_object_start</a>(<span class="Type">void</span> *_state);<br/></li>
<li><span class="Type">static</span> JsonParseErrorType <a href="#L2664" title="utils/adt/jsonfuncs.c:2664">populate_array_array_end</a>(<span class="Type">void</span> *_state);<br/></li>
<li><span class="Type">static</span> JsonParseErrorType <a href="#L2688" title="utils/adt/jsonfuncs.c:2688">populate_array_element_start</a>(<span class="Type">void</span> *_state, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isnull);<br/></li>
<li><span class="Type">static</span> JsonParseErrorType <a href="#L2706" title="utils/adt/jsonfuncs.c:2706">populate_array_element_end</a>(<span class="Type">void</span> *_state, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isnull);<br/></li>
<li><span class="Type">static</span> JsonParseErrorType <a href="#L2749" title="utils/adt/jsonfuncs.c:2749">populate_array_scalar</a>(<span class="Type">void</span> *_state, <span class="Type">char</span> *token, JsonTokenType tokentype);<br/></li>
<li><br/></li>
<li><span class="Comment">/* semantic action <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for <a href="#L3787" title="utils/adt/jsonfuncs.c:3787">get_json_object_as_hash</a> */<br/></li>
<li></span><span class="Type">static</span> JsonParseErrorType <a href="#L3829" title="utils/adt/jsonfuncs.c:3829">hash_object_field_start</a>(<span class="Type">void</span> *state, <span class="Type">char</span> *fname, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isnull);<br/></li>
<li><span class="Type">static</span> JsonParseErrorType <a href="#L3855" title="utils/adt/jsonfuncs.c:3855">hash_object_field_end</a>(<span class="Type">void</span> *state, <span class="Type">char</span> *fname, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isnull);<br/></li>
<li><span class="Type">static</span> JsonParseErrorType <a href="#L3906" title="utils/adt/jsonfuncs.c:3906">hash_array_start</a>(<span class="Type">void</span> *state);<br/></li>
<li><span class="Type">static</span> JsonParseErrorType <a href="#L3919" title="utils/adt/jsonfuncs.c:3919">hash_scalar</a>(<span class="Type">void</span> *state, <span class="Type">char</span> *token, JsonTokenType tokentype);<br/></li>
<li><br/></li>
<li><span class="Comment">/* semantic action <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for populate_recordset */<br/></li>
<li></span><span class="Type">static</span> JsonParseErrorType <a href="#L4283" title="utils/adt/jsonfuncs.c:4283">populate_recordset_object_field_start</a>(<span class="Type">void</span> *state, <span class="Type">char</span> *fname, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isnull);<br/></li>
<li><span class="Type">static</span> JsonParseErrorType <a href="#L4306" title="utils/adt/jsonfuncs.c:4306">populate_recordset_object_field_end</a>(<span class="Type">void</span> *state, <span class="Type">char</span> *fname, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isnull);<br/></li>
<li><span class="Type">static</span> JsonParseErrorType <a href="#L4266" title="utils/adt/jsonfuncs.c:4266">populate_recordset_scalar</a>(<span class="Type">void</span> *state, <span class="Type">char</span> *token, JsonTokenType tokentype);<br/></li>
<li><span class="Type">static</span> JsonParseErrorType <a href="#L4191" title="utils/adt/jsonfuncs.c:4191">populate_recordset_object_start</a>(<span class="Type">void</span> *state);<br/></li>
<li><span class="Type">static</span> JsonParseErrorType <a href="#L4221" title="utils/adt/jsonfuncs.c:4221">populate_recordset_object_end</a>(<span class="Type">void</span> *state);<br/></li>
<li><span class="Type">static</span> JsonParseErrorType <a href="#L4259" title="utils/adt/jsonfuncs.c:4259">populate_recordset_array_start</a>(<span class="Type">void</span> *state);<br/></li>
<li><span class="Type">static</span> JsonParseErrorType <a href="#L4244" title="utils/adt/jsonfuncs.c:4244">populate_recordset_array_element_start</a>(<span class="Type">void</span> *state, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isnull);<br/></li>
<li><br/></li>
<li><span class="Comment">/* semantic action <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for <a href="#L4470" title="utils/adt/jsonfuncs.c:4470">json_strip_nulls</a> */<br/></li>
<li></span><span class="Type">static</span> JsonParseErrorType <a href="#L4366" title="utils/adt/jsonfuncs.c:4366">sn_object_start</a>(<span class="Type">void</span> *state);<br/></li>
<li><span class="Type">static</span> JsonParseErrorType <a href="#L4376" title="utils/adt/jsonfuncs.c:4376">sn_object_end</a>(<span class="Type">void</span> *state);<br/></li>
<li><span class="Type">static</span> JsonParseErrorType <a href="#L4386" title="utils/adt/jsonfuncs.c:4386">sn_array_start</a>(<span class="Type">void</span> *state);<br/></li>
<li><span class="Type">static</span> JsonParseErrorType <a href="#L4396" title="utils/adt/jsonfuncs.c:4396">sn_array_end</a>(<span class="Type">void</span> *state);<br/></li>
<li><span class="Type">static</span> JsonParseErrorType <a href="#L4406" title="utils/adt/jsonfuncs.c:4406">sn_object_field_start</a>(<span class="Type">void</span> *state, <span class="Type">char</span> *fname, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isnull);<br/></li>
<li><span class="Type">static</span> JsonParseErrorType <a href="#L4436" title="utils/adt/jsonfuncs.c:4436">sn_array_element_start</a>(<span class="Type">void</span> *state, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isnull);<br/></li>
<li><span class="Type">static</span> JsonParseErrorType <a href="#L4447" title="utils/adt/jsonfuncs.c:4447">sn_scalar</a>(<span class="Type">void</span> *state, <span class="Type">char</span> *token, JsonTokenType tokentype);<br/></li>
<li><br/></li>
<li><span class="Comment">/* worker <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for <a href="#L3497" title="utils/adt/jsonfuncs.c:3497">populate_record</a>, to_record, populate_recordset and to_recordset */<br/></li>
<li></span><span class="Type">static</span> Datum <a href="#L4017" title="utils/adt/jsonfuncs.c:4017">populate_recordset_worker</a>(FunctionCallInfo fcinfo, <span class="Type">const</span> <span class="Type">char</span> *funcname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_json, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> have_record_arg);<br/></li>
<li><span class="Type">static</span> Datum <a href="#L3675" title="utils/adt/jsonfuncs.c:3675">populate_record_worker</a>(FunctionCallInfo fcinfo, <span class="Type">const</span> <span class="Type">char</span> *funcname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_json, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> have_record_arg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node *escontext);<br/></li>
<li><br/></li>
<li><span class="Comment">/* helper <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for <a href="#L3497" title="utils/adt/jsonfuncs.c:3497">populate_record</a>[set] */<br/></li>
<li></span><span class="Type">static</span> HeapTupleHeader <a href="#L3497" title="utils/adt/jsonfuncs.c:3497">populate_record</a>(TupleDesc tupdesc, <a href="rowtypes.c.html#L43" title="utils/adt/rowtypes.c:43">RecordIOData</a> **record_p,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HeapTupleHeader defaultval, MemoryContext mcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L307" title="utils/adt/jsonfuncs.c:307">JsObject</a> *obj, Node *escontext);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3612" title="utils/adt/jsonfuncs.c:3612">get_record_type_from_argument</a>(FunctionCallInfo fcinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *funcname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L236" title="utils/adt/jsonfuncs.c:236">PopulateRecordCache</a> *cache);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3638" title="utils/adt/jsonfuncs.c:3638">get_record_type_from_query</a>(FunctionCallInfo fcinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *funcname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L236" title="utils/adt/jsonfuncs.c:236">PopulateRecordCache</a> *cache);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2978" title="utils/adt/jsonfuncs.c:2978">JsValueToJsObject</a>(<a href="#L291" title="utils/adt/jsonfuncs.c:291">JsValue</a> *jsv, <a href="#L307" title="utils/adt/jsonfuncs.c:307">JsObject</a> *jso, Node *escontext);<br/></li>
<li><span class="Type">static</span> Datum <a href="#L3054" title="utils/adt/jsonfuncs.c:3054">populate_composite</a>(<a href="#L173" title="utils/adt/jsonfuncs.c:173">CompositeIOData</a> *io, Oid typid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *colname, MemoryContext mcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeader defaultval, <a href="#L291" title="utils/adt/jsonfuncs.c:291">JsValue</a> *jsv, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node *escontext);<br/></li>
<li><span class="Type">static</span> Datum <a href="#L3121" title="utils/adt/jsonfuncs.c:3121">populate_scalar</a>(<a href="#L154" title="utils/adt/jsonfuncs.c:154">ScalarIOData</a> *io, Oid typid, int32 typmod, <a href="#L291" title="utils/adt/jsonfuncs.c:291">JsValue</a> *jsv,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull, Node *escontext);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3241" title="utils/adt/jsonfuncs.c:3241">prepare_column_cache</a>(<a href="rowtypes.c.html#L34" title="utils/adt/rowtypes.c:34">ColumnIOData</a> *column, Oid typid, int32 typmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MemoryContext mcxt, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> need_scalar);<br/></li>
<li><span class="Type">static</span> Datum <a href="#L3384" title="utils/adt/jsonfuncs.c:3384">populate_record_field</a>(<a href="rowtypes.c.html#L34" title="utils/adt/rowtypes.c:34">ColumnIOData</a> *col, Oid typid, int32 typmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *colname, MemoryContext mcxt, Datum defaultval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L291" title="utils/adt/jsonfuncs.c:291">JsValue</a> *jsv, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull, Node *escontext);<br/></li>
<li><span class="Type">static</span> <a href="rowtypes.c.html#L43" title="utils/adt/rowtypes.c:43">RecordIOData</a> *<a href="#L3453" title="utils/adt/jsonfuncs.c:3453">allocate_record_info</a>(MemoryContext mcxt, <span class="Type">int</span> ncolumns);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L3469" title="utils/adt/jsonfuncs.c:3469">JsObjectGetField</a>(<a href="#L307" title="utils/adt/jsonfuncs.c:307">JsObject</a> *obj, <span class="Type">char</span> *field, <a href="#L291" title="utils/adt/jsonfuncs.c:291">JsValue</a> *jsv);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3978" title="utils/adt/jsonfuncs.c:3978">populate_recordset_record</a>(<a href="#L244" title="utils/adt/jsonfuncs.c:244">PopulateRecordsetState</a> *state, <a href="#L307" title="utils/adt/jsonfuncs.c:307">JsObject</a> *obj);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2785" title="utils/adt/jsonfuncs.c:2785">populate_array_json</a>(<a href="#L258" title="utils/adt/jsonfuncs.c:258">PopulateArrayContext</a> *ctx, <span class="Type">char</span> *json, <span class="Type">int</span> len);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2821" title="utils/adt/jsonfuncs.c:2821">populate_array_dim_jsonb</a>(<a href="#L258" title="utils/adt/jsonfuncs.c:258">PopulateArrayContext</a> *ctx, JsonbValue *jbv,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> ndim);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2507" title="utils/adt/jsonfuncs.c:2507">populate_array_report_expected_array</a>(<a href="#L258" title="utils/adt/jsonfuncs.c:258">PopulateArrayContext</a> *ctx, <span class="Type">int</span> ndim);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2557" title="utils/adt/jsonfuncs.c:2557">populate_array_assign_ndims</a>(<a href="#L258" title="utils/adt/jsonfuncs.c:258">PopulateArrayContext</a> *ctx, <span class="Type">int</span> ndims);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2587" title="utils/adt/jsonfuncs.c:2587">populate_array_check_dimension</a>(<a href="#L258" title="utils/adt/jsonfuncs.c:258">PopulateArrayContext</a> *ctx, <span class="Type">int</span> ndim);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2615" title="utils/adt/jsonfuncs.c:2615">populate_array_element</a>(<a href="#L258" title="utils/adt/jsonfuncs.c:258">PopulateArrayContext</a> *ctx, <span class="Type">int</span> ndim, <a href="#L291" title="utils/adt/jsonfuncs.c:291">JsValue</a> *jsv);<br/></li>
<li><span class="Type">static</span> Datum <a href="#L2911" title="utils/adt/jsonfuncs.c:2911">populate_array</a>(<a href="#L165" title="utils/adt/jsonfuncs.c:165">ArrayIOData</a> *aio, <span class="Type">const</span> <span class="Type">char</span> *colname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContext mcxt, <a href="#L291" title="utils/adt/jsonfuncs.c:291">JsValue</a> *jsv,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node *escontext);<br/></li>
<li><span class="Type">static</span> Datum <a href="#L3208" title="utils/adt/jsonfuncs.c:3208">populate_domain</a>(<a href="#L189" title="utils/adt/jsonfuncs.c:189">DomainIOData</a> *io, Oid typid, <span class="Type">const</span> <span class="Type">char</span> *colname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MemoryContext mcxt, <a href="#L291" title="utils/adt/jsonfuncs.c:291">JsValue</a> *jsv, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Node *escontext);<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> supporting <a href="#L4618" title="utils/adt/jsonfuncs.c:4618">jsonb_delete</a>, <a href="#L4822" title="utils/adt/jsonfuncs.c:4822">jsonb_set</a> and <a href="#L4577" title="utils/adt/jsonfuncs.c:4577">jsonb_concat</a> */<br/></li>
<li></span><span class="Type">static</span> JsonbValue *<a href="#L5030" title="utils/adt/jsonfuncs.c:5030">IteratorConcat</a>(JsonbIterator **it1, JsonbIterator **it2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JsonbParseState **state);<br/></li>
<li><span class="Type">static</span> JsonbValue *<a href="#L5158" title="utils/adt/jsonfuncs.c:5158">setPath</a>(JsonbIterator **it, Datum *path_elems,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *path_nulls, <span class="Type">int</span> path_len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; JsonbParseState **st, <span class="Type">int</span> level, JsonbValue *<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> op_type);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L5240" title="utils/adt/jsonfuncs.c:5240">setPathObject</a>(JsonbIterator **it, Datum *path_elems,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *path_nulls, <span class="Type">int</span> path_len, JsonbParseState **st,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> level,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JsonbValue *<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, uint32 npairs, <span class="Type">int</span> op_type);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L5379" title="utils/adt/jsonfuncs.c:5379">setPathArray</a>(JsonbIterator **it, Datum *path_elems,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *path_nulls, <span class="Type">int</span> path_len, JsonbParseState **st,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> level,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; JsonbValue *<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, uint32 nelems, <span class="Type">int</span> op_type);<br/></li>
<li><br/></li>
<li><span class="Comment">/* function supporting <a href="#L5686" title="utils/adt/jsonfuncs.c:5686">iterate_json_values</a> */<br/></li>
<li></span><span class="Type">static</span> JsonParseErrorType <a href="#L5711" title="utils/adt/jsonfuncs.c:5711">iterate_values_scalar</a>(<span class="Type">void</span> *state, <span class="Type">char</span> *token, JsonTokenType tokentype);<br/></li>
<li><span class="Type">static</span> JsonParseErrorType <a href="#L5739" title="utils/adt/jsonfuncs.c:5739">iterate_values_object_field_start</a>(<span class="Type">void</span> *state, <span class="Type">char</span> *fname, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isnull);<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> supporting <a href="#L5807" title="utils/adt/jsonfuncs.c:5807">transform_json_string_values</a> */<br/></li>
<li></span><span class="Type">static</span> JsonParseErrorType <a href="#L5840" title="utils/adt/jsonfuncs.c:5840">transform_string_values_object_start</a>(<span class="Type">void</span> *state);<br/></li>
<li><span class="Type">static</span> JsonParseErrorType <a href="#L5850" title="utils/adt/jsonfuncs.c:5850">transform_string_values_object_end</a>(<span class="Type">void</span> *state);<br/></li>
<li><span class="Type">static</span> JsonParseErrorType <a href="#L5860" title="utils/adt/jsonfuncs.c:5860">transform_string_values_array_start</a>(<span class="Type">void</span> *state);<br/></li>
<li><span class="Type">static</span> JsonParseErrorType <a href="#L5870" title="utils/adt/jsonfuncs.c:5870">transform_string_values_array_end</a>(<span class="Type">void</span> *state);<br/></li>
<li><span class="Type">static</span> JsonParseErrorType <a href="#L5880" title="utils/adt/jsonfuncs.c:5880">transform_string_values_object_field_start</a>(<span class="Type">void</span> *state, <span class="Type">char</span> *fname, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isnull);<br/></li>
<li><span class="Type">static</span> JsonParseErrorType <a href="#L5898" title="utils/adt/jsonfuncs.c:5898">transform_string_values_array_element_start</a>(<span class="Type">void</span> *state, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isnull);<br/></li>
<li><span class="Type">static</span> JsonParseErrorType <a href="#L5909" title="utils/adt/jsonfuncs.c:5909">transform_string_values_scalar</a>(<span class="Type">void</span> *state, <span class="Type">char</span> *token, JsonTokenType tokentype);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L516" title="utils/adt/jsonfuncs.c:516">pg_parse_json_or_errsave</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function is like pg_parse_json, except that it does not return a<br/></li>
<li></span><span class="Comment"> * JsonParseErrorType. Instead, in case of <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> failure, this function will<br/></li>
<li></span><span class="Comment"> * save error data into *escontext if that's an ErrorSaveContext, otherwise<br/></li>
<li></span><span class="Comment"> * ereport(ERROR).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns a boolean indicating success or failure (failure will only be<br/></li>
<li></span><span class="Comment"> * returned when escontext is an ErrorSaveContext).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L516">&#x200c;</a></span><span class="linkable">pg_parse_json_or_errsave</span>(JsonLexContext *lex, JsonSemAction *sem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Node *escontext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JsonParseErrorType result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = pg_parse_json(lex, sem);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result != JSON_SUCCESS)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L638" title="utils/adt/jsonfuncs.c:638">json_errsave_error</a>(result, lex, escontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L537" title="utils/adt/jsonfuncs.c:537">makeJsonLexContext</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is like makeJsonLexContextCstringLen, but it accepts a text value<br/></li>
<li></span><span class="Comment"> * directly.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>JsonLexContext *<br/></li>
<li><a id="L537">&#x200c;</a><span class="linkable">makeJsonLexContext</span>(JsonLexContext *lex, text *json, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> need_escapes)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Most callers pass a detoasted datum, but it's not clear that they all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * do.&nbsp; <a href="../fmgr/fmgr.c.html#L1864" title="utils/fmgr/fmgr.c:1864">pg_detoast_datum_packed</a>() is cheap insurance.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; json = <a href="../fmgr/fmgr.c.html#L1864" title="utils/fmgr/fmgr.c:1864">pg_detoast_datum_packed</a>(json);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> makeJsonLexContextCstringLen(lex,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VARDATA_ANY(json),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VARSIZE_ANY_EXHDR(json),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mb/mbutils.c.html#L1261" title="utils/mb/mbutils.c:1261">GetDatabaseEncoding</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; need_escapes);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * SQL function <a href="#L729" title="utils/adt/jsonfuncs.c:729">json_object_keys</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the set of keys for the object argument.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This SRF operates in value-per-call mode. It processes the<br/></li>
<li></span><span class="Comment"> * object during the first call, and the keys are simply stashed<br/></li>
<li></span><span class="Comment"> * in an array, whose size is expanded as necessary. This is probably<br/></li>
<li></span><span class="Comment"> * safe enough for a list of keys of a single object, since they are<br/></li>
<li></span><span class="Comment"> * limited in size to NAMEDATALEN and the number of keys is unlikely to<br/></li>
<li></span><span class="Comment"> * be so huge that it has major memory implications.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L565">&#x200c;</a><span class="linkable">jsonb_object_keys</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FuncCallContext *funcctx;<br/></li>
<li>&nbsp; &nbsp; <a href="#L54" title="utils/adt/jsonfuncs.c:54">OkeysState</a> *state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (SRF_IS_FIRSTCALL())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Jsonb&nbsp; &nbsp; &nbsp;&nbsp; *jb = PG_GETARG_JSONB_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; skipNested = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; JsonbIterator *it;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; JsonbValue&nbsp; &nbsp; v;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; JsonbIteratorToken r;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (JB_ROOT_IS_SCALAR(jb))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot call </span><span class="Special">%s</span><span class="Constant"> on a scalar&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;<a href="#L565" title="utils/adt/jsonfuncs.c:565">jsonb_object_keys</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (JB_ROOT_IS_ARRAY(jb))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot call </span><span class="Special">%s</span><span class="Constant"> on an array&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;<a href="#L565" title="utils/adt/jsonfuncs.c:565">jsonb_object_keys</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; funcctx = SRF_FIRSTCALL_INIT();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(funcctx-&gt;multi_call_memory_ctx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L54" title="utils/adt/jsonfuncs.c:54">OkeysState</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;result_size = JB_ROOT_COUNT(jb);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;result_count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;sent_count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;result = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(state-&gt;result_size * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">char</span> *));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; it = <a href="jsonb_util.c.html#L817" title="utils/adt/jsonb_util.c:817">JsonbIteratorInit</a>(&amp;jb-&gt;root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((r = <a href="jsonb_util.c.html#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a>(&amp;it, &amp;v, skipNested)) != WJB_DONE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; skipNested = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (r == WJB_KEY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *cstr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cstr = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(v.val.string.len + <span class="Constant">1</span> * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">char</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(cstr, v.val.string.val, v.val.string.len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cstr[v.val.string.len] = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;result[state-&gt;result_count++] = cstr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; funcctx-&gt;user_fctx = (<span class="Type">void</span> *) state;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; funcctx = SRF_PERCALL_SETUP();<br/></li>
<li>&nbsp; &nbsp; state = (<a href="#L54" title="utils/adt/jsonfuncs.c:54">OkeysState</a> *) funcctx-&gt;user_fctx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;sent_count &lt; state-&gt;result_count)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *nxt = state-&gt;result[state-&gt;sent_count++];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SRF_RETURN_NEXT(funcctx, CStringGetTextDatum(nxt));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SRF_RETURN_DONE(funcctx);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Report a JSON error.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L638">&#x200c;</a></span><span class="linkable">json_errsave_error</span>(JsonParseErrorType error, JsonLexContext *lex,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Node *escontext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (error == JSON_UNICODE_HIGH_ESCAPE ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; error == JSON_UNICODE_UNTRANSLATABLE ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; error == JSON_UNICODE_CODE_POINT_ZERO)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errsave(escontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNTRANSLATABLE_CHARACTER),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unsupported Unicode escape sequence&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1232" title="utils/error/elog.c:1232">errdetail_internal</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>, json_errdetail(error, lex)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L674" title="utils/adt/jsonfuncs.c:674">report_json_context</a>(lex)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (error == JSON_SEM_ACTION_FAILED)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* semantic action function had better have reported something */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!SOFT_ERROR_OCCURRED(escontext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;JSON semantic action function did not provide error information&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; errsave(escontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid input syntax for type </span><span class="Special">%s</span><span class="Constant">&quot;</span>, <span class="Constant">&quot;json&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1232" title="utils/error/elog.c:1232">errdetail_internal</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>, json_errdetail(error, lex)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L674" title="utils/adt/jsonfuncs.c:674">report_json_context</a>(lex)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Report a CONTEXT line for bogus JSON input.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * lex-&gt;token_terminator must be set to identify the spot where we detected<br/></li>
<li></span><span class="Comment"> * the error.&nbsp; Note that lex-&gt;token_start might be NULL, in case we recognized<br/></li>
<li></span><span class="Comment"> * error at EOF.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The return value isn't meaningful, but we make it non-void so that this<br/></li>
<li></span><span class="Comment"> * can be invoked inside ereport().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L674">&#x200c;</a></span><span class="linkable">report_json_context</span>(JsonLexContext *lex)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *context_start;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *context_end;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *line_start;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ctxt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ctxtlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *prefix;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *suffix;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Choose boundaries for the part of the input we will display */<br/></li>
<li></span>&nbsp; &nbsp; line_start = lex-&gt;line_start;<br/></li>
<li>&nbsp; &nbsp; context_start = line_start;<br/></li>
<li>&nbsp; &nbsp; context_end = lex-&gt;token_terminator;<br/></li>
<li>&nbsp; &nbsp; Assert(context_end &gt;= context_start);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Advance until we are close enough to context_end */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (context_end - context_start &gt;= <span class="Constant">50</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Advance to <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> multibyte character */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IS_HIGHBIT_SET(*context_start))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context_start += <a href="../mb/mbutils.c.html#L1023" title="utils/mb/mbutils.c:1023">pg_mblen</a>(context_start);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context_start++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We add &quot;...&quot; to indicate that the excerpt doesn't start at the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * beginning of the line ... but if we're within 3 characters of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * beginning of the line, we might as well just show the whole line.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (context_start - line_start &lt;= <span class="Constant">3</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context_start = line_start;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get a null-terminated copy of the data to present */<br/></li>
<li></span>&nbsp; &nbsp; ctxtlen = context_end - context_start;<br/></li>
<li>&nbsp; &nbsp; ctxt = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(ctxtlen + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; memcpy(ctxt, context_start, ctxtlen);<br/></li>
<li>&nbsp; &nbsp; ctxt[ctxtlen] = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Show the context, prefixing &quot;...&quot; if not starting at start of line, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * suffixing &quot;...&quot; if not ending at end of line.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; prefix = (context_start &gt; line_start) ? <span class="Constant">&quot;...&quot;</span> : <span class="Constant">&quot;&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; suffix = (lex-&gt;token_type != JSON_TOKEN_END &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context_end - lex-&gt;input &lt; lex-&gt;input_length &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *context_end != <span class="Special">'\n'</span> &amp;&amp; *context_end != <span class="Special">'\r'</span>) ? <span class="Constant">&quot;...&quot;</span> : <span class="Constant">&quot;&quot;</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> errcontext(<span class="Constant">&quot;JSON data, line </span><span class="Special">%d</span><span class="Constant">: </span><span class="Special">%s%s%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lex-&gt;line_number, prefix, ctxt, suffix);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L729">&#x200c;</a><span class="linkable">json_object_keys</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FuncCallContext *funcctx;<br/></li>
<li>&nbsp; &nbsp; <a href="#L54" title="utils/adt/jsonfuncs.c:54">OkeysState</a> *state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (SRF_IS_FIRSTCALL())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *json = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; JsonLexContext lex;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; JsonSemAction *sem;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; funcctx = SRF_FIRSTCALL_INIT();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(funcctx-&gt;multi_call_memory_ctx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L54" title="utils/adt/jsonfuncs.c:54">OkeysState</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sem = <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(JsonSemAction));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;lex = <a href="#L537" title="utils/adt/jsonfuncs.c:537">makeJsonLexContext</a>(&amp;lex, json, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;result_size = <span class="Constant">256</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;result_count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;sent_count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;result = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Constant">256</span> * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">char</span> *));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sem-&gt;semstate = (<span class="Type">void</span> *) state;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sem-&gt;array_start = <a href="#L806" title="utils/adt/jsonfuncs.c:806">okeys_array_start</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sem-&gt;scalar = <a href="#L821" title="utils/adt/jsonfuncs.c:821">okeys_scalar</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sem-&gt;object_field_start = <a href="#L783" title="utils/adt/jsonfuncs.c:783">okeys_object_field_start</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* remainder are all NULL, courtesy of <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a> above */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_parse_json_or_ereport(&amp;lex, sem);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keys are <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> in state-&gt;result */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; freeJsonLexContext(&amp;lex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(sem);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; funcctx-&gt;user_fctx = (<span class="Type">void</span> *) state;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; funcctx = SRF_PERCALL_SETUP();<br/></li>
<li>&nbsp; &nbsp; state = (<a href="#L54" title="utils/adt/jsonfuncs.c:54">OkeysState</a> *) funcctx-&gt;user_fctx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;sent_count &lt; state-&gt;result_count)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *nxt = state-&gt;result[state-&gt;sent_count++];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SRF_RETURN_NEXT(funcctx, CStringGetTextDatum(nxt));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SRF_RETURN_DONE(funcctx);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> JsonParseErrorType<br/></li>
<li><a id="L783">&#x200c;</a><span class="linkable">okeys_object_field_start</span>(<span class="Type">void</span> *state, <span class="Type">char</span> *fname, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L54" title="utils/adt/jsonfuncs.c:54">OkeysState</a> *_state = (<a href="#L54" title="utils/adt/jsonfuncs.c:54">OkeysState</a> *) state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* only collecting keys for the top level object */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (_state-&gt;lex-&gt;lex_level != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* enlarge result array if necessary */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (_state-&gt;result_count &gt;= _state-&gt;result_size)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;result_size *= <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;result = (<span class="Type">char</span> **)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(_state-&gt;result, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">char</span> *) * _state-&gt;result_size);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* save a copy of the field name */<br/></li>
<li></span>&nbsp; &nbsp; _state-&gt;result[_state-&gt;result_count++] = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(fname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> JsonParseErrorType<br/></li>
<li><a id="L806">&#x200c;</a><span class="linkable">okeys_array_start</span>(<span class="Type">void</span> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L54" title="utils/adt/jsonfuncs.c:54">OkeysState</a> *_state = (<a href="#L54" title="utils/adt/jsonfuncs.c:54">OkeysState</a> *) state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* top level must be a json object */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (_state-&gt;lex-&gt;lex_level == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot call </span><span class="Special">%s</span><span class="Constant"> on an array&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;<a href="#L729" title="utils/adt/jsonfuncs.c:729">json_object_keys</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> JsonParseErrorType<br/></li>
<li><a id="L821">&#x200c;</a><span class="linkable">okeys_scalar</span>(<span class="Type">void</span> *state, <span class="Type">char</span> *token, JsonTokenType tokentype)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L54" title="utils/adt/jsonfuncs.c:54">OkeysState</a> *_state = (<a href="#L54" title="utils/adt/jsonfuncs.c:54">OkeysState</a> *) state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* top level must be a json object */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (_state-&gt;lex-&gt;lex_level == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot call </span><span class="Special">%s</span><span class="Constant"> on a scalar&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;<a href="#L729" title="utils/adt/jsonfuncs.c:729">json_object_keys</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * json and jsonb getter <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> * these implement the -&gt; -&gt;&gt; #&gt; and #&gt;&gt; operators<br/></li>
<li></span><span class="Comment"> * and the json{b?}_extract_path*(json, text, ...) <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L843">&#x200c;</a><span class="linkable">json_object_field</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *json = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *fname = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *fnamestr = <a href="varlena.c.html#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>(fname);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L1100" title="utils/adt/jsonfuncs.c:1100">get_worker</a>(json, &amp;fnamestr, <span class="Constant">NULL</span>, <span class="Constant">1</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_TEXT_P(result);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L859">&#x200c;</a><span class="linkable">jsonb_object_field</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Jsonb&nbsp; &nbsp; &nbsp;&nbsp; *jb = PG_GETARG_JSONB_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *key = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; JsonbValue *v;<br/></li>
<li>&nbsp; &nbsp; JsonbValue&nbsp; &nbsp; vbuf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!JB_ROOT_IS_OBJECT(jb))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; v = <a href="jsonb_util.c.html#L398" title="utils/adt/jsonb_util.c:398">getKeyJsonValueFromContainer</a>(&amp;jb-&gt;root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VARDATA_ANY(key),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VARSIZE_ANY_EXHDR(key),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;vbuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (v != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_JSONB_P(<a href="jsonb_util.c.html#L92" title="utils/adt/jsonb_util.c:92">JsonbValueToJsonb</a>(v));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L881">&#x200c;</a><span class="linkable">json_object_field_text</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *json = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *fname = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *fnamestr = <a href="varlena.c.html#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>(fname);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L1100" title="utils/adt/jsonfuncs.c:1100">get_worker</a>(json, &amp;fnamestr, <span class="Constant">NULL</span>, <span class="Constant">1</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_TEXT_P(result);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L897">&#x200c;</a><span class="linkable">jsonb_object_field_text</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Jsonb&nbsp; &nbsp; &nbsp;&nbsp; *jb = PG_GETARG_JSONB_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *key = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; JsonbValue *v;<br/></li>
<li>&nbsp; &nbsp; JsonbValue&nbsp; &nbsp; vbuf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!JB_ROOT_IS_OBJECT(jb))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; v = <a href="jsonb_util.c.html#L398" title="utils/adt/jsonb_util.c:398">getKeyJsonValueFromContainer</a>(&amp;jb-&gt;root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VARDATA_ANY(key),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VARSIZE_ANY_EXHDR(key),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;vbuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (v != <span class="Constant">NULL</span> &amp;&amp; v-&gt;type != jbvNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_TEXT_P(<a href="#L1802" title="utils/adt/jsonfuncs.c:1802">JsonbValueAsText</a>(v));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L919">&#x200c;</a><span class="linkable">json_array_element</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *json = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L1100" title="utils/adt/jsonfuncs.c:1100">get_worker</a>(json, <span class="Constant">NULL</span>, &amp;<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>, <span class="Constant">1</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_TEXT_P(result);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L934">&#x200c;</a><span class="linkable">jsonb_array_element</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Jsonb&nbsp; &nbsp; &nbsp;&nbsp; *jb = PG_GETARG_JSONB_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; JsonbValue *v;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!JB_ROOT_IS_ARRAY(jb))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Handle negative subscript */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; nelements = JB_ROOT_COUNT(jb);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (-<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> &gt; nelements)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> += nelements;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; v = <a href="jsonb_util.c.html#L468" title="utils/adt/jsonb_util.c:468">getIthJsonbValueFromContainer</a>(&amp;jb-&gt;root, <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (v != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_JSONB_P(<a href="jsonb_util.c.html#L92" title="utils/adt/jsonb_util.c:92">JsonbValueToJsonb</a>(v));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L962">&#x200c;</a><span class="linkable">json_array_element_text</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *json = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L1100" title="utils/adt/jsonfuncs.c:1100">get_worker</a>(json, <span class="Constant">NULL</span>, &amp;<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>, <span class="Constant">1</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_TEXT_P(result);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L977">&#x200c;</a><span class="linkable">jsonb_array_element_text</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Jsonb&nbsp; &nbsp; &nbsp;&nbsp; *jb = PG_GETARG_JSONB_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; JsonbValue *v;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!JB_ROOT_IS_ARRAY(jb))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Handle negative subscript */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; nelements = JB_ROOT_COUNT(jb);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (-<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> &gt; nelements)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> += nelements;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; v = <a href="jsonb_util.c.html#L468" title="utils/adt/jsonb_util.c:468">getIthJsonbValueFromContainer</a>(&amp;jb-&gt;root, <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (v != <span class="Constant">NULL</span> &amp;&amp; v-&gt;type != jbvNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_TEXT_P(<a href="#L1802" title="utils/adt/jsonfuncs.c:1802">JsonbValueAsText</a>(v));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1006">&#x200c;</a><span class="linkable">json_extract_path</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1021" title="utils/adt/jsonfuncs.c:1021">get_path_all</a>(fcinfo, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1012">&#x200c;</a><span class="linkable">json_extract_path_text</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1021" title="utils/adt/jsonfuncs.c:1021">get_path_all</a>(fcinfo, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * common routine for extract_path <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Datum<br/></li>
<li><a id="L1021">&#x200c;</a><span class="linkable">get_path_all</span>(FunctionCallInfo fcinfo, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> as_text)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *json = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *path = PG_GETARG_ARRAYTYPE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *pathtext;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *pathnulls;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; npath;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; **tpath;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *ipath;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the array contains <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> null elements, return NULL, on the grounds<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that you'd have gotten NULL if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> RHS value were NULL in a nested<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * series of applications of the -&gt; operator.&nbsp; (Note: because we also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * return NULL for error cases such as no-such-field, this is true<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * regardless of the contents of the rest of the array.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="arrayfuncs.c.html#L3748" title="utils/adt/arrayfuncs.c:3748">array_contains_nulls</a>(path))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="arrayfuncs.c.html#L3678" title="utils/adt/arrayfuncs.c:3678">deconstruct_array_builtin</a>(path, TEXTOID, &amp;pathtext, &amp;pathnulls, &amp;npath);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tpath = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(npath * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">char</span> *));<br/></li>
<li>&nbsp; &nbsp; ipath = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(npath * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; npath; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!pathnulls[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tpath[i] = TextDatumGetCString(pathtext[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we have no idea at this stage what structure the document is so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * just convert anything in the path that we can to an integer and set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * all the other integers to INT_MIN which will never match.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*tpath[i] != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ind;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *endptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ind = strtoint(tpath[i], &amp;endptr, <span class="Constant">10</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (endptr == tpath[i] || *endptr != <span class="Special">'\0'</span> || errno != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ipath[i] = <span class="Constant">INT_MIN</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ipath[i] = ind;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ipath[i] = <span class="Constant">INT_MIN</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L1100" title="utils/adt/jsonfuncs.c:1100">get_worker</a>(json, tpath, ipath, npath, as_text);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_TEXT_P(result);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1100" title="utils/adt/jsonfuncs.c:1100">get_worker</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * common worker for all the json getter <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * json: JSON object (in text form)<br/></li>
<li></span><span class="Comment"> * tpath[]: field name(s) to extract<br/></li>
<li></span><span class="Comment"> * ipath[]: array index(es) (zero-based) to extract, accepts negatives<br/></li>
<li></span><span class="Comment"> * npath: length of tpath[] and/or ipath[]<br/></li>
<li></span><span class="Comment"> * normalize_results: true to de-escape string and null scalars<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * tpath can be NULL, or <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> one tpath[] entry can be NULL, if an object<br/></li>
<li></span><span class="Comment"> * field is not to be matched at that nesting level.&nbsp; Similarly, ipath can<br/></li>
<li></span><span class="Comment"> * be NULL, or <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> one ipath[] entry can be INT_MIN if an array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> is<br/></li>
<li></span><span class="Comment"> * not to be matched at that nesting level (a json datum should never be<br/></li>
<li></span><span class="Comment"> * large enough to have -INT_MIN elements due to MaxAllocSize restriction).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> text *<br/></li>
<li><a id="L1100">&#x200c;</a><span class="linkable">get_worker</span>(text *json,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">char</span> **tpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> *ipath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> npath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> normalize_results)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JsonSemAction *sem = <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(JsonSemAction));<br/></li>
<li>&nbsp; &nbsp; <a href="#L85" title="utils/adt/jsonfuncs.c:85">GetState</a>&nbsp;&nbsp; *state = <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L85" title="utils/adt/jsonfuncs.c:85">GetState</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(npath &gt;= <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;lex = <a href="#L537" title="utils/adt/jsonfuncs.c:537">makeJsonLexContext</a>(<span class="Constant">NULL</span>, json, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* is it &quot;_as_text&quot; variant? */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;normalize_results = normalize_results;<br/></li>
<li>&nbsp; &nbsp; state-&gt;npath = npath;<br/></li>
<li>&nbsp; &nbsp; state-&gt;path_names = tpath;<br/></li>
<li>&nbsp; &nbsp; state-&gt;path_indexes = ipath;<br/></li>
<li>&nbsp; &nbsp; state-&gt;pathok = <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>) * npath);<br/></li>
<li>&nbsp; &nbsp; state-&gt;array_cur_index = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>) * npath);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (npath &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;pathok[<span class="Constant">0</span>] = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sem-&gt;semstate = (<span class="Type">void</span> *) state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Not all variants need all the semantic routines. Only set the ones that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are actually needed for maximum efficiency.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; sem-&gt;scalar = <a href="#L1442" title="utils/adt/jsonfuncs.c:1442">get_scalar</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (npath == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sem-&gt;object_start = <a href="#L1157" title="utils/adt/jsonfuncs.c:1157">get_object_start</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sem-&gt;object_end = <a href="#L1176" title="utils/adt/jsonfuncs.c:1176">get_object_end</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sem-&gt;array_start = <a href="#L1292" title="utils/adt/jsonfuncs.c:1292">get_array_start</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sem-&gt;array_end = <a href="#L1332" title="utils/adt/jsonfuncs.c:1332">get_array_end</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tpath != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sem-&gt;object_field_start = <a href="#L1194" title="utils/adt/jsonfuncs.c:1194">get_object_field_start</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sem-&gt;object_field_end = <a href="#L1241" title="utils/adt/jsonfuncs.c:1241">get_object_field_end</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ipath != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sem-&gt;array_start = <a href="#L1292" title="utils/adt/jsonfuncs.c:1292">get_array_start</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sem-&gt;array_element_start = <a href="#L1350" title="utils/adt/jsonfuncs.c:1350">get_array_element_start</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sem-&gt;array_element_end = <a href="#L1398" title="utils/adt/jsonfuncs.c:1398">get_array_element_end</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pg_parse_json_or_ereport(state-&gt;lex, sem);<br/></li>
<li>&nbsp; &nbsp; freeJsonLexContext(state-&gt;lex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> state-&gt;tresult;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> JsonParseErrorType<br/></li>
<li><a id="L1157">&#x200c;</a><span class="linkable">get_object_start</span>(<span class="Type">void</span> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L85" title="utils/adt/jsonfuncs.c:85">GetState</a>&nbsp;&nbsp; *_state = (<a href="#L85" title="utils/adt/jsonfuncs.c:85">GetState</a> *) state;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lex_level = _state-&gt;lex-&gt;lex_level;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lex_level == <span class="Constant">0</span> &amp;&amp; _state-&gt;npath == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Special case: we should match the entire object.&nbsp; We only need this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * at outermost level because at nested levels the match will have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * been started by the outer field or array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> callback.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;result_start = _state-&gt;lex-&gt;token_start;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> JsonParseErrorType<br/></li>
<li><a id="L1176">&#x200c;</a><span class="linkable">get_object_end</span>(<span class="Type">void</span> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L85" title="utils/adt/jsonfuncs.c:85">GetState</a>&nbsp;&nbsp; *_state = (<a href="#L85" title="utils/adt/jsonfuncs.c:85">GetState</a> *) state;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lex_level = _state-&gt;lex-&gt;lex_level;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lex_level == <span class="Constant">0</span> &amp;&amp; _state-&gt;npath == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Special case: return the entire object */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *start = _state-&gt;result_start;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len = _state-&gt;lex-&gt;prev_token_terminator - start;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;tresult = <a href="varlena.c.html#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(start, len);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> JsonParseErrorType<br/></li>
<li><a id="L1194">&#x200c;</a><span class="linkable">get_object_field_start</span>(<span class="Type">void</span> *state, <span class="Type">char</span> *fname, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L85" title="utils/adt/jsonfuncs.c:85">GetState</a>&nbsp;&nbsp; *_state = (<a href="#L85" title="utils/adt/jsonfuncs.c:85">GetState</a> *) state;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; get_next = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lex_level = _state-&gt;lex-&gt;lex_level;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lex_level &lt;= _state-&gt;npath &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;pathok[lex_level - <span class="Constant">1</span>] &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;path_names != <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;path_names[lex_level - <span class="Constant">1</span>] != <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; strcmp(fname, _state-&gt;path_names[lex_level - <span class="Constant">1</span>]) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lex_level &lt; _state-&gt;npath)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if not at end of path just mark path ok */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;pathok[lex_level] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* end of path, so we want this value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; get_next = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (get_next)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* this object overrides <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> previous matching object */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;tresult = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;result_start = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (_state-&gt;normalize_results &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;lex-&gt;token_type == JSON_TOKEN_STRING)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* for as_text variants, tell <a href="#L1442" title="utils/adt/jsonfuncs.c:1442">get_scalar</a> to set it for us */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;next_scalar = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* for non-as_text variants, just note the json starting point */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;result_start = _state-&gt;lex-&gt;token_start;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> JsonParseErrorType<br/></li>
<li><a id="L1241">&#x200c;</a><span class="linkable">get_object_field_end</span>(<span class="Type">void</span> *state, <span class="Type">char</span> *fname, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L85" title="utils/adt/jsonfuncs.c:85">GetState</a>&nbsp;&nbsp; *_state = (<a href="#L85" title="utils/adt/jsonfuncs.c:85">GetState</a> *) state;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; get_last = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lex_level = _state-&gt;lex-&gt;lex_level;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* same tests as in <a href="#L1194" title="utils/adt/jsonfuncs.c:1194">get_object_field_start</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (lex_level &lt;= _state-&gt;npath &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;pathok[lex_level - <span class="Constant">1</span>] &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;path_names != <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;path_names[lex_level - <span class="Constant">1</span>] != <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; strcmp(fname, _state-&gt;path_names[lex_level - <span class="Constant">1</span>]) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lex_level &lt; _state-&gt;npath)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* done with this field so reset pathok */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;pathok[lex_level] = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* end of path, so we want this value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; get_last = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* for as_text scalar case, our work is already done */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (get_last &amp;&amp; _state-&gt;result_start != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * make a text object from the string from the previously noted json<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * start up to the end of the previous token (the lexer is by <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ahead of us on whatever came after what we're interested in).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnull &amp;&amp; _state-&gt;normalize_results)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;tresult = (text *) <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *start = _state-&gt;result_start;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len = _state-&gt;lex-&gt;prev_token_terminator - start;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;tresult = <a href="varlena.c.html#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(start, len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* this should be unnecessary but let's do it for cleanliness: */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;result_start = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> JsonParseErrorType<br/></li>
<li><a id="L1292">&#x200c;</a><span class="linkable">get_array_start</span>(<span class="Type">void</span> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L85" title="utils/adt/jsonfuncs.c:85">GetState</a>&nbsp;&nbsp; *_state = (<a href="#L85" title="utils/adt/jsonfuncs.c:85">GetState</a> *) state;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lex_level = _state-&gt;lex-&gt;lex_level;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lex_level &lt; _state-&gt;npath)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Initialize counting of elements in this array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;array_cur_index[lex_level] = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* INT_MIN value is reserved to represent invalid subscript */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (_state-&gt;path_indexes[lex_level] &lt; <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;path_indexes[lex_level] != <span class="Constant">INT_MIN</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Negative subscript -- convert to positive-wise subscript */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JsonParseErrorType error;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nelements;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; error = json_count_array_elements(_state-&gt;lex, &amp;nelements);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (error != JSON_SUCCESS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L638" title="utils/adt/jsonfuncs.c:638">json_errsave_error</a>(error, _state-&gt;lex, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (-_state-&gt;path_indexes[lex_level] &lt;= nelements)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;path_indexes[lex_level] += nelements;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (lex_level == <span class="Constant">0</span> &amp;&amp; _state-&gt;npath == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Special case: we should match the entire array.&nbsp; We only need this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * at the outermost level because at nested levels the match will have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * been started by the outer field or array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> callback.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;result_start = _state-&gt;lex-&gt;token_start;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> JsonParseErrorType<br/></li>
<li><a id="L1332">&#x200c;</a><span class="linkable">get_array_end</span>(<span class="Type">void</span> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L85" title="utils/adt/jsonfuncs.c:85">GetState</a>&nbsp;&nbsp; *_state = (<a href="#L85" title="utils/adt/jsonfuncs.c:85">GetState</a> *) state;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lex_level = _state-&gt;lex-&gt;lex_level;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lex_level == <span class="Constant">0</span> &amp;&amp; _state-&gt;npath == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Special case: return the entire array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *start = _state-&gt;result_start;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len = _state-&gt;lex-&gt;prev_token_terminator - start;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;tresult = <a href="varlena.c.html#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(start, len);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> JsonParseErrorType<br/></li>
<li><a id="L1350">&#x200c;</a><span class="linkable">get_array_element_start</span>(<span class="Type">void</span> *state, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L85" title="utils/adt/jsonfuncs.c:85">GetState</a>&nbsp;&nbsp; *_state = (<a href="#L85" title="utils/adt/jsonfuncs.c:85">GetState</a> *) state;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; get_next = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lex_level = _state-&gt;lex-&gt;lex_level;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Update array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> counter */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (lex_level &lt;= _state-&gt;npath)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;array_cur_index[lex_level - <span class="Constant">1</span>]++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lex_level &lt;= _state-&gt;npath &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;pathok[lex_level - <span class="Constant">1</span>] &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;path_indexes != <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;array_cur_index[lex_level - <span class="Constant">1</span>] == _state-&gt;path_indexes[lex_level - <span class="Constant">1</span>])<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lex_level &lt; _state-&gt;npath)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if not at end of path just mark path ok */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;pathok[lex_level] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* end of path, so we want this value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; get_next = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* same logic as for objects */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (get_next)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;tresult = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;result_start = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (_state-&gt;normalize_results &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;lex-&gt;token_type == JSON_TOKEN_STRING)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;next_scalar = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;result_start = _state-&gt;lex-&gt;token_start;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> JsonParseErrorType<br/></li>
<li><a id="L1398">&#x200c;</a><span class="linkable">get_array_element_end</span>(<span class="Type">void</span> *state, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L85" title="utils/adt/jsonfuncs.c:85">GetState</a>&nbsp;&nbsp; *_state = (<a href="#L85" title="utils/adt/jsonfuncs.c:85">GetState</a> *) state;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; get_last = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lex_level = _state-&gt;lex-&gt;lex_level;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* same tests as in <a href="#L1350" title="utils/adt/jsonfuncs.c:1350">get_array_element_start</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (lex_level &lt;= _state-&gt;npath &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;pathok[lex_level - <span class="Constant">1</span>] &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;path_indexes != <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;array_cur_index[lex_level - <span class="Constant">1</span>] == _state-&gt;path_indexes[lex_level - <span class="Constant">1</span>])<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lex_level &lt; _state-&gt;npath)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* done with this <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> so reset pathok */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;pathok[lex_level] = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* end of path, so we want this value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; get_last = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* same logic as for objects */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (get_last &amp;&amp; _state-&gt;result_start != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnull &amp;&amp; _state-&gt;normalize_results)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;tresult = (text *) <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *start = _state-&gt;result_start;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len = _state-&gt;lex-&gt;prev_token_terminator - start;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;tresult = <a href="varlena.c.html#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(start, len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;result_start = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> JsonParseErrorType<br/></li>
<li><a id="L1442">&#x200c;</a><span class="linkable">get_scalar</span>(<span class="Type">void</span> *state, <span class="Type">char</span> *token, JsonTokenType tokentype)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L85" title="utils/adt/jsonfuncs.c:85">GetState</a>&nbsp;&nbsp; *_state = (<a href="#L85" title="utils/adt/jsonfuncs.c:85">GetState</a> *) state;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lex_level = _state-&gt;lex-&gt;lex_level;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for whole-object match */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (lex_level == <span class="Constant">0</span> &amp;&amp; _state-&gt;npath == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (_state-&gt;normalize_results &amp;&amp; tokentype == JSON_TOKEN_STRING)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we want the de-escaped string */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;next_scalar = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (_state-&gt;normalize_results &amp;&amp; tokentype == JSON_TOKEN_NULL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;tresult = (text *) <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is a <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> hokey: we will suppress whitespace after the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * scalar token, but not whitespace <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it.&nbsp; Probably not worth<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * doing our own space-skipping to avoid that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *start = _state-&gt;lex-&gt;input;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len = _state-&gt;lex-&gt;prev_token_terminator - start;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;tresult = <a href="varlena.c.html#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(start, len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (_state-&gt;next_scalar)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* a de-escaped text value is wanted, so supply it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;tresult = <a href="varlena.c.html#L184" title="utils/adt/varlena.c:184">cstring_to_text</a>(token);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* make sure the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> call to <a href="#L1442" title="utils/adt/jsonfuncs.c:1442">get_scalar</a> doesn't overwrite it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;next_scalar = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1485">&#x200c;</a><span class="linkable">jsonb_extract_path</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1497" title="utils/adt/jsonfuncs.c:1497">get_jsonb_path_all</a>(fcinfo, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1491">&#x200c;</a><span class="linkable">jsonb_extract_path_text</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1497" title="utils/adt/jsonfuncs.c:1497">get_jsonb_path_all</a>(fcinfo, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> Datum<br/></li>
<li><a id="L1497">&#x200c;</a><span class="linkable">get_jsonb_path_all</span>(FunctionCallInfo fcinfo, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> as_text)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Jsonb&nbsp; &nbsp; &nbsp;&nbsp; *jb = PG_GETARG_JSONB_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *path = PG_GETARG_ARRAYTYPE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *pathtext;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *pathnulls;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; npath;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the array contains <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> null elements, return NULL, on the grounds<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that you'd have gotten NULL if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> RHS value were NULL in a nested<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * series of applications of the -&gt; operator.&nbsp; (Note: because we also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * return NULL for error cases such as no-such-field, this is true<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * regardless of the contents of the rest of the array.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="arrayfuncs.c.html#L3748" title="utils/adt/arrayfuncs.c:3748">array_contains_nulls</a>(path))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="arrayfuncs.c.html#L3678" title="utils/adt/arrayfuncs.c:3678">deconstruct_array_builtin</a>(path, TEXTOID, &amp;pathtext, &amp;pathnulls, &amp;npath);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="#L1528" title="utils/adt/jsonfuncs.c:1528">jsonb_get_element</a>(jb, pathtext, npath, &amp;isnull, as_text);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_DATUM(res);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1528">&#x200c;</a><span class="linkable">jsonb_get_element</span>(Jsonb *jb, Datum *path, <span class="Type">int</span> npath, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> as_text)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JsonbContainer *container = &amp;jb-&gt;root;<br/></li>
<li>&nbsp; &nbsp; JsonbValue *jbvp = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; have_object = <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; have_array = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *isnull = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Identify whether we have object, array, or scalar at top-level */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (JB_ROOT_IS_OBJECT(jb))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; have_object = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (JB_ROOT_IS_ARRAY(jb) &amp;&amp; !JB_ROOT_IS_SCALAR(jb))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; have_array = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(JB_ROOT_IS_ARRAY(jb) &amp;&amp; JB_ROOT_IS_SCALAR(jb));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Extract the scalar value, if it is what we'll return */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (npath &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jbvp = <a href="jsonb_util.c.html#L468" title="utils/adt/jsonb_util.c:468">getIthJsonbValueFromContainer</a>(container, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the array is empty, return the entire LHS object, on the grounds<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that we should do zero field or <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> extractions.&nbsp; For the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * non-scalar case we can just hand back the object without much work. For<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the scalar case, fall through and deal with the value below the loop.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (This inconsistency arises because there's no easy way to generate a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * JsonbValue directly for root-level containers.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (npath &lt;= <span class="Constant">0</span> &amp;&amp; jbvp == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (as_text)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PointerGetDatum(<a href="varlena.c.html#L184" title="utils/adt/varlena.c:184">cstring_to_text</a>(<a href="jsonb.c.html#L473" title="utils/adt/jsonb.c:473">JsonbToCString</a>(<span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; container,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VARSIZE(jb))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not text mode - just hand back the jsonb */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_JSONB_P(jb);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; npath; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (have_object)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *subscr = DatumGetTextPP(path[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jbvp = <a href="jsonb_util.c.html#L398" title="utils/adt/jsonb_util.c:398">getKeyJsonValueFromContainer</a>(container,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VARDATA_ANY(subscr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VARSIZE_ANY_EXHDR(subscr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (have_array)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lindex;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; index;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *indextext = TextDatumGetCString(path[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *endptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lindex = strtoint(indextext, &amp;endptr, <span class="Constant">10</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (endptr == indextext || *endptr != <span class="Special">'\0'</span> || errno != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *isnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PointerGetDatum(<span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lindex &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index = (uint32) lindex;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Handle negative subscript */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; nelements;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Container must be array, but make sure */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!JsonContainerIsArray(container))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;not a jsonb array&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nelements = JsonContainerSize(container);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lindex == <span class="Constant">INT_MIN</span> || -lindex &gt; nelements)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *isnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PointerGetDatum(<span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index = nelements + lindex;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jbvp = <a href="jsonb_util.c.html#L468" title="utils/adt/jsonb_util.c:468">getIthJsonbValueFromContainer</a>(container, index);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* scalar, extraction yields a null */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *isnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PointerGetDatum(<span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (jbvp == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *isnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PointerGetDatum(<span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (i == npath - <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (jbvp-&gt;type == jbvBinary)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; container = jbvp-&gt;val.binary.data;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; have_object = JsonContainerIsObject(container);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; have_array = JsonContainerIsArray(container);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!JsonContainerIsScalar(container));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(IsAJsonbScalar(jbvp));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; have_object = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; have_array = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (as_text)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (jbvp-&gt;type == jbvNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *isnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PointerGetDatum(<span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PointerGetDatum(<a href="#L1802" title="utils/adt/jsonfuncs.c:1802">JsonbValueAsText</a>(jbvp));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Jsonb&nbsp; &nbsp; &nbsp;&nbsp; *res = <a href="jsonb_util.c.html#L92" title="utils/adt/jsonb_util.c:92">JsonbValueToJsonb</a>(jbvp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not text mode - just hand back the jsonb */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_JSONB_P(res);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1676">&#x200c;</a><span class="linkable">jsonb_set_element</span>(Jsonb *jb, Datum *path, <span class="Type">int</span> path_len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JsonbValue *<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JsonbValue *res;<br/></li>
<li>&nbsp; &nbsp; JsonbParseState *state = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; JsonbIterator *it;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *path_nulls = <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(path_len * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>-&gt;type == jbvArray &amp;&amp; <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>-&gt;val.array.rawScalar)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> = <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>-&gt;val.array.elems[<span class="Constant">0</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; it = <a href="jsonb_util.c.html#L817" title="utils/adt/jsonb_util.c:817">JsonbIteratorInit</a>(&amp;jb-&gt;root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="#L5158" title="utils/adt/jsonfuncs.c:5158">setPath</a>(&amp;it, path, path_nulls, path_len, &amp;state, <span class="Constant">0</span>, <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L43" title="utils/adt/jsonfuncs.c:43">JB_PATH_CREATE</a> | <a href="#L50" title="utils/adt/jsonfuncs.c:50">JB_PATH_FILL_GAPS</a> |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L51" title="utils/adt/jsonfuncs.c:51">JB_PATH_CONSISTENT_POSITION</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(path_nulls);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_JSONB_P(<a href="jsonb_util.c.html#L92" title="utils/adt/jsonb_util.c:92">JsonbValueToJsonb</a>(res));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1699">&#x200c;</a></span><span class="linkable">push_null_elements</span>(JsonbParseState **ps, <span class="Type">int</span> num)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JsonbValue&nbsp; &nbsp; null;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; null.type = jbvNull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (num-- &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="jsonb_util.c.html#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(ps, WJB_ELEM, &amp;null);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Prepare a new structure containing nested empty objects and arrays<br/></li>
<li></span><span class="Comment"> * corresponding to the specified path, and assign a new value at the end of<br/></li>
<li></span><span class="Comment"> * this path. E.g. the path [a][0][b] with the new value 1 will produce the<br/></li>
<li></span><span class="Comment"> * structure {a: [{b: 1}]}.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller is responsible to make sure such path does not exist yet.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1718">&#x200c;</a></span><span class="linkable">push_path</span>(JsonbParseState **st, <span class="Type">int</span> level, Datum *path_elems,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *path_nulls, <span class="Type">int</span> path_len, JsonbValue *<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tpath contains expected type of an empty jsonb created at each level<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * higher or <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> than the current one, either jbvObject or jbvArray.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since it contains only information about path slice from level to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * end, the access index must be normalized by level.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">enum</span> jbvType *tpath = <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>((path_len - level) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">enum</span> jbvType));<br/></li>
<li>&nbsp; &nbsp; JsonbValue&nbsp; &nbsp; newkey;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create first part of the chain with beginning tokens. For the current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * level WJB_BEGIN_OBJECT/WJB_BEGIN_ARRAY was already created, so start<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = level + <span class="Constant">1</span>; i &lt; path_len; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *c,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *badp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lindex;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (path_nulls[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Try to convert to an integer to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> out the expected type, object<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * or array.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; c = TextDatumGetCString(path_elems[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lindex = strtoint(c, &amp;badp, <span class="Constant">10</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (badp == c || *badp != <span class="Special">'\0'</span> || errno != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* text, an object is expected */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newkey.type = jbvString;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newkey.val.string.val = c;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newkey.val.string.len = strlen(c);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="jsonb_util.c.html#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(st, WJB_BEGIN_OBJECT, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="jsonb_util.c.html#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(st, WJB_KEY, &amp;newkey);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tpath[i - level] = jbvObject;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* integer, an array is expected */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="jsonb_util.c.html#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(st, WJB_BEGIN_ARRAY, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1699" title="utils/adt/jsonfuncs.c:1699">push_null_elements</a>(st, lindex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tpath[i - level] = jbvArray;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> an actual value for either an object or array */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tpath[(path_len - level) - <span class="Constant">1</span>] == jbvArray)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="jsonb_util.c.html#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(st, WJB_ELEM, <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="jsonb_util.c.html#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(st, WJB_VALUE, <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Close everything up to the last but one level. The last one will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * closed outside of this function.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = path_len - <span class="Constant">1</span>; i &gt; level; i--)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (path_nulls[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tpath[i - level] == jbvObject)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="jsonb_util.c.html#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(st, WJB_END_OBJECT, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="jsonb_util.c.html#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(st, WJB_END_ARRAY, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the text representation of the given JsonbValue.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> text *<br/></li>
<li><a id="L1802">&#x200c;</a><span class="linkable">JsonbValueAsText</span>(JsonbValue *v)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (v-&gt;type)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jbvNull:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jbvBool:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> v-&gt;val.boolean ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="varlena.c.html#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(<span class="Constant">&quot;true&quot;</span>, <span class="Constant">4</span>) :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="varlena.c.html#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(<span class="Constant">&quot;false&quot;</span>, <span class="Constant">5</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jbvString:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="varlena.c.html#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(v-&gt;val.string.val,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v-&gt;val.string.len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jbvNumeric:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; cstr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cstr = DirectFunctionCall1(<a href="numeric.c.html#L807" title="utils/adt/numeric.c:807">numeric_out</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PointerGetDatum(v-&gt;val.<a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="varlena.c.html#L184" title="utils/adt/varlena.c:184">cstring_to_text</a>(DatumGetCString(cstr));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jbvBinary:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StringInfoData jtext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; initStringInfo(&amp;jtext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="jsonb.c.html#L473" title="utils/adt/jsonb.c:473">JsonbToCString</a>(&amp;jtext, v-&gt;val.binary.data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v-&gt;val.binary.len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="varlena.c.html#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(jtext.data, jtext.len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized jsonb type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, (<span class="Type">int</span>) v-&gt;type);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * SQL function <a href="#L1849" title="utils/adt/jsonfuncs.c:1849">json_array_length</a>(json) -&gt; int<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1849">&#x200c;</a><span class="linkable">json_array_length</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *json = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L101" title="utils/adt/jsonfuncs.c:101">AlenState</a>&nbsp; *state;<br/></li>
<li>&nbsp; &nbsp; JsonLexContext lex;<br/></li>
<li>&nbsp; &nbsp; JsonSemAction *sem;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L101" title="utils/adt/jsonfuncs.c:101">AlenState</a>));<br/></li>
<li>&nbsp; &nbsp; state-&gt;lex = <a href="#L537" title="utils/adt/jsonfuncs.c:537">makeJsonLexContext</a>(&amp;lex, json, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a> does this for us */<br/></li>
<li></span><span class="PreProc">#if 0<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; state-&gt;count = 0;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; sem = <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(JsonSemAction));<br/></li>
<li>&nbsp; &nbsp; sem-&gt;semstate = (<span class="Type">void</span> *) state;<br/></li>
<li>&nbsp; &nbsp; sem-&gt;object_start = <a href="#L1897" title="utils/adt/jsonfuncs.c:1897">alen_object_start</a>;<br/></li>
<li>&nbsp; &nbsp; sem-&gt;scalar = <a href="#L1911" title="utils/adt/jsonfuncs.c:1911">alen_scalar</a>;<br/></li>
<li>&nbsp; &nbsp; sem-&gt;array_element_start = <a href="#L1925" title="utils/adt/jsonfuncs.c:1925">alen_array_element_start</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pg_parse_json_or_ereport(state-&gt;lex, sem);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(state-&gt;count);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1875">&#x200c;</a><span class="linkable">jsonb_array_length</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Jsonb&nbsp; &nbsp; &nbsp;&nbsp; *jb = PG_GETARG_JSONB_P(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (JB_ROOT_IS_SCALAR(jb))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot get array length of a scalar&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!JB_ROOT_IS_ARRAY(jb))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot get array length of a non-array&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(JB_ROOT_COUNT(jb));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * These <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> two checks ensure that the json is an array (since it can't be<br/></li>
<li></span><span class="Comment"> * a scalar or an object).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> JsonParseErrorType<br/></li>
<li><a id="L1897">&#x200c;</a><span class="linkable">alen_object_start</span>(<span class="Type">void</span> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L101" title="utils/adt/jsonfuncs.c:101">AlenState</a>&nbsp; *_state = (<a href="#L101" title="utils/adt/jsonfuncs.c:101">AlenState</a> *) state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* json structure check */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (_state-&gt;lex-&gt;lex_level == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot get array length of a non-array&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> JsonParseErrorType<br/></li>
<li><a id="L1911">&#x200c;</a><span class="linkable">alen_scalar</span>(<span class="Type">void</span> *state, <span class="Type">char</span> *token, JsonTokenType tokentype)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L101" title="utils/adt/jsonfuncs.c:101">AlenState</a>&nbsp; *_state = (<a href="#L101" title="utils/adt/jsonfuncs.c:101">AlenState</a> *) state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* json structure check */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (_state-&gt;lex-&gt;lex_level == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot get array length of a scalar&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> JsonParseErrorType<br/></li>
<li><a id="L1925">&#x200c;</a><span class="linkable">alen_array_element_start</span>(<span class="Type">void</span> *state, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L101" title="utils/adt/jsonfuncs.c:101">AlenState</a>&nbsp; *_state = (<a href="#L101" title="utils/adt/jsonfuncs.c:101">AlenState</a> *) state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* just count up all the level 1 elements */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (_state-&gt;lex-&gt;lex_level == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;count++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * SQL function <a href="#L1947" title="utils/adt/jsonfuncs.c:1947">json_each</a> and <a href="#L1959" title="utils/adt/jsonfuncs.c:1959">json_each_text</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * decompose a json object into key value pairs.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Unlike <a href="#L729" title="utils/adt/jsonfuncs.c:729">json_object_keys</a>() these SRFs operate in materialize mode,<br/></li>
<li></span><span class="Comment"> * stashing results into a Tuplestore object as they go.<br/></li>
<li></span><span class="Comment"> * The construction of tuples is done using a temporary memory context<br/></li>
<li></span><span class="Comment"> * that is cleared out after each tuple is built.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1947">&#x200c;</a><span class="linkable">json_each</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2055" title="utils/adt/jsonfuncs.c:2055">each_worker</a>(fcinfo, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1953">&#x200c;</a><span class="linkable">jsonb_each</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1971" title="utils/adt/jsonfuncs.c:1971">each_worker_jsonb</a>(fcinfo, <span class="Constant">&quot;<a href="#L1953" title="utils/adt/jsonfuncs.c:1953">jsonb_each</a>&quot;</span>, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1959">&#x200c;</a><span class="linkable">json_each_text</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2055" title="utils/adt/jsonfuncs.c:2055">each_worker</a>(fcinfo, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1965">&#x200c;</a><span class="linkable">jsonb_each_text</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1971" title="utils/adt/jsonfuncs.c:1971">each_worker_jsonb</a>(fcinfo, <span class="Constant">&quot;<a href="#L1965" title="utils/adt/jsonfuncs.c:1965">jsonb_each_text</a>&quot;</span>, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> Datum<br/></li>
<li><a id="L1971">&#x200c;</a><span class="linkable">each_worker_jsonb</span>(FunctionCallInfo fcinfo, <span class="Type">const</span> <span class="Type">char</span> *funcname, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> as_text)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Jsonb&nbsp; &nbsp; &nbsp;&nbsp; *jb = PG_GETARG_JSONB_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; ReturnSetInfo *rsi;<br/></li>
<li>&nbsp; &nbsp; MemoryContext old_cxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp_cxt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; skipNested = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; JsonbIterator *it;<br/></li>
<li>&nbsp; &nbsp; JsonbValue&nbsp; &nbsp; v;<br/></li>
<li>&nbsp; &nbsp; JsonbIteratorToken r;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!JB_ROOT_IS_OBJECT(jb))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot call </span><span class="Special">%s</span><span class="Constant"> on a non-object&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; funcname)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rsi = (ReturnSetInfo *) fcinfo-&gt;resultinfo;<br/></li>
<li>&nbsp; &nbsp; <a href="../fmgr/funcapi.c.html#L76" title="utils/fmgr/funcapi.c:76">InitMaterializedSRF</a>(fcinfo, MAT_SRF_BLESS);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tmp_cxt = AllocSetContextCreate(<a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;<a href="#L1953" title="utils/adt/jsonfuncs.c:1953">jsonb_each</a> temporary cxt&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; it = <a href="jsonb_util.c.html#L817" title="utils/adt/jsonb_util.c:817">JsonbIteratorInit</a>(&amp;jb-&gt;root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((r = <a href="jsonb_util.c.html#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a>(&amp;it, &amp;v, skipNested)) != WJB_DONE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; skipNested = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (r == WJB_KEY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *key;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">2</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">2</span>] = {<span class="Constant">false</span>, <span class="Constant">false</span>};<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Use the tmp context so we can clean up after each tuple is done */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_cxt = MemoryContextSwitchTo(tmp_cxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key = <a href="varlena.c.html#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(v.val.string.val, v.val.string.len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> thing the iterator fetches should be the value, no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * matter what shape it is.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r = <a href="jsonb_util.c.html#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a>(&amp;it, &amp;v, skipNested);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(r != WJB_DONE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">0</span>] = PointerGetDatum(key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (as_text)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (v.type == jbvNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* a json null is an sql null in text mode */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">1</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">1</span>] = (Datum) <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">1</span>] = PointerGetDatum(<a href="#L1802" title="utils/adt/jsonfuncs.c:1802">JsonbValueAsText</a>(&amp;v));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Not in text mode, just return the Jsonb */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Jsonb&nbsp; &nbsp; &nbsp;&nbsp; *val = <a href="jsonb_util.c.html#L92" title="utils/adt/jsonb_util.c:92">JsonbValueToJsonb</a>(&amp;v);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">1</span>] = PointerGetDatum(val);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../sort/tuplestore.c.html#L750" title="utils/sort/tuplestore.c:750">tuplestore_putvalues</a>(rsi-&gt;setResult, rsi-&gt;setDesc, <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, nulls);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* clean up and switch back */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(old_cxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(tmp_cxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(tmp_cxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">static</span> Datum<br/></li>
<li><a id="L2055">&#x200c;</a><span class="linkable">each_worker</span>(FunctionCallInfo fcinfo, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> as_text)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *json = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; JsonLexContext lex;<br/></li>
<li>&nbsp; &nbsp; JsonSemAction *sem;<br/></li>
<li>&nbsp; &nbsp; ReturnSetInfo *rsi;<br/></li>
<li>&nbsp; &nbsp; <a href="#L108" title="utils/adt/jsonfuncs.c:108">EachState</a>&nbsp; *state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L108" title="utils/adt/jsonfuncs.c:108">EachState</a>));<br/></li>
<li>&nbsp; &nbsp; sem = <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(JsonSemAction));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rsi = (ReturnSetInfo *) fcinfo-&gt;resultinfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../fmgr/funcapi.c.html#L76" title="utils/fmgr/funcapi.c:76">InitMaterializedSRF</a>(fcinfo, MAT_SRF_BLESS);<br/></li>
<li>&nbsp; &nbsp; state-&gt;tuple_store = rsi-&gt;setResult;<br/></li>
<li>&nbsp; &nbsp; state-&gt;ret_tdesc = rsi-&gt;setDesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sem-&gt;semstate = (<span class="Type">void</span> *) state;<br/></li>
<li>&nbsp; &nbsp; sem-&gt;array_start = <a href="#L2165" title="utils/adt/jsonfuncs.c:2165">each_array_start</a>;<br/></li>
<li>&nbsp; &nbsp; sem-&gt;scalar = <a href="#L2179" title="utils/adt/jsonfuncs.c:2179">each_scalar</a>;<br/></li>
<li>&nbsp; &nbsp; sem-&gt;object_field_start = <a href="#L2095" title="utils/adt/jsonfuncs.c:2095">each_object_field_start</a>;<br/></li>
<li>&nbsp; &nbsp; sem-&gt;object_field_end = <a href="#L2117" title="utils/adt/jsonfuncs.c:2117">each_object_field_end</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;normalize_results = as_text;<br/></li>
<li>&nbsp; &nbsp; state-&gt;next_scalar = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;lex = <a href="#L537" title="utils/adt/jsonfuncs.c:537">makeJsonLexContext</a>(&amp;lex, json, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; state-&gt;tmp_cxt = AllocSetContextCreate(<a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;<a href="#L1947" title="utils/adt/jsonfuncs.c:1947">json_each</a> temporary cxt&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pg_parse_json_or_ereport(&amp;lex, sem);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(state-&gt;tmp_cxt);<br/></li>
<li>&nbsp; &nbsp; freeJsonLexContext(&amp;lex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">static</span> JsonParseErrorType<br/></li>
<li><a id="L2095">&#x200c;</a><span class="linkable">each_object_field_start</span>(<span class="Type">void</span> *state, <span class="Type">char</span> *fname, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L108" title="utils/adt/jsonfuncs.c:108">EachState</a>&nbsp; *_state = (<a href="#L108" title="utils/adt/jsonfuncs.c:108">EachState</a> *) state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* save a pointer to where the value starts */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (_state-&gt;lex-&gt;lex_level == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * next_scalar will be reset in the object_field_end handler, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * since we know the value is a scalar there is no danger of it being<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * on while recursing down the tree.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (_state-&gt;normalize_results &amp;&amp; _state-&gt;lex-&gt;token_type == JSON_TOKEN_STRING)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;next_scalar = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;result_start = _state-&gt;lex-&gt;token_start;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> JsonParseErrorType<br/></li>
<li><a id="L2117">&#x200c;</a><span class="linkable">each_object_field_end</span>(<span class="Type">void</span> *state, <span class="Type">char</span> *fname, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L108" title="utils/adt/jsonfuncs.c:108">EachState</a>&nbsp; *_state = (<a href="#L108" title="utils/adt/jsonfuncs.c:108">EachState</a> *) state;<br/></li>
<li>&nbsp; &nbsp; MemoryContext old_cxt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *val;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">2</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">2</span>] = {<span class="Constant">false</span>, <span class="Constant">false</span>};<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> over nested objects */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (_state-&gt;lex-&gt;lex_level != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* use the tmp context so we can clean up after each tuple is done */<br/></li>
<li></span>&nbsp; &nbsp; old_cxt = MemoryContextSwitchTo(_state-&gt;tmp_cxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">0</span>] = CStringGetTextDatum(fname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isnull &amp;&amp; _state-&gt;normalize_results)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">1</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">1</span>] = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (_state-&gt;next_scalar)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">1</span>] = CStringGetTextDatum(_state-&gt;normalized_scalar);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;next_scalar = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len = _state-&gt;lex-&gt;prev_token_terminator - _state-&gt;result_start;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; val = <a href="varlena.c.html#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(_state-&gt;result_start, len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">1</span>] = PointerGetDatum(val);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = <a href="../../access/common/heaptuple.c.html#L1116" title="access/common/heaptuple.c:1116">heap_form_tuple</a>(_state-&gt;ret_tdesc, <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, nulls);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../sort/tuplestore.c.html#L730" title="utils/sort/tuplestore.c:730">tuplestore_puttuple</a>(_state-&gt;tuple_store, tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* clean up and switch back */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContextSwitchTo(old_cxt);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(_state-&gt;tmp_cxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> JsonParseErrorType<br/></li>
<li><a id="L2165">&#x200c;</a><span class="linkable">each_array_start</span>(<span class="Type">void</span> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L108" title="utils/adt/jsonfuncs.c:108">EachState</a>&nbsp; *_state = (<a href="#L108" title="utils/adt/jsonfuncs.c:108">EachState</a> *) state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* json structure check */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (_state-&gt;lex-&gt;lex_level == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot deconstruct an array as an object&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> JsonParseErrorType<br/></li>
<li><a id="L2179">&#x200c;</a><span class="linkable">each_scalar</span>(<span class="Type">void</span> *state, <span class="Type">char</span> *token, JsonTokenType tokentype)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L108" title="utils/adt/jsonfuncs.c:108">EachState</a>&nbsp; *_state = (<a href="#L108" title="utils/adt/jsonfuncs.c:108">EachState</a> *) state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* json structure check */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (_state-&gt;lex-&gt;lex_level == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot deconstruct a scalar&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* supply de-escaped value if required */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (_state-&gt;next_scalar)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;normalized_scalar = token;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * SQL <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> <a href="#L2293" title="utils/adt/jsonfuncs.c:2293">json_array_elements</a> and <a href="#L2299" title="utils/adt/jsonfuncs.c:2299">json_array_elements_text</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * get the elements from a json array<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * a lot of this processing is similar to the <a href="#L1947" title="utils/adt/jsonfuncs.c:1947">json_each</a>* <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L2205">&#x200c;</a><span class="linkable">jsonb_array_elements</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2217" title="utils/adt/jsonfuncs.c:2217">elements_worker_jsonb</a>(fcinfo, <span class="Constant">&quot;<a href="#L2205" title="utils/adt/jsonfuncs.c:2205">jsonb_array_elements</a>&quot;</span>, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2211">&#x200c;</a><span class="linkable">jsonb_array_elements_text</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2217" title="utils/adt/jsonfuncs.c:2217">elements_worker_jsonb</a>(fcinfo, <span class="Constant">&quot;<a href="#L2211" title="utils/adt/jsonfuncs.c:2211">jsonb_array_elements_text</a>&quot;</span>, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> Datum<br/></li>
<li><a id="L2217">&#x200c;</a><span class="linkable">elements_worker_jsonb</span>(FunctionCallInfo fcinfo, <span class="Type">const</span> <span class="Type">char</span> *funcname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> as_text)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Jsonb&nbsp; &nbsp; &nbsp;&nbsp; *jb = PG_GETARG_JSONB_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; ReturnSetInfo *rsi;<br/></li>
<li>&nbsp; &nbsp; MemoryContext old_cxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp_cxt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; skipNested = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; JsonbIterator *it;<br/></li>
<li>&nbsp; &nbsp; JsonbValue&nbsp; &nbsp; v;<br/></li>
<li>&nbsp; &nbsp; JsonbIteratorToken r;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (JB_ROOT_IS_SCALAR(jb))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot extract elements from a scalar&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!JB_ROOT_IS_ARRAY(jb))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot extract elements from an object&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rsi = (ReturnSetInfo *) fcinfo-&gt;resultinfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../fmgr/funcapi.c.html#L76" title="utils/fmgr/funcapi.c:76">InitMaterializedSRF</a>(fcinfo, MAT_SRF_USE_EXPECTED_DESC | MAT_SRF_BLESS);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tmp_cxt = AllocSetContextCreate(<a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;<a href="#L2205" title="utils/adt/jsonfuncs.c:2205">jsonb_array_elements</a> temporary cxt&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; it = <a href="jsonb_util.c.html#L817" title="utils/adt/jsonb_util.c:817">JsonbIteratorInit</a>(&amp;jb-&gt;root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((r = <a href="jsonb_util.c.html#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a>(&amp;it, &amp;v, skipNested)) != WJB_DONE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; skipNested = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (r == WJB_ELEM)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">1</span>] = {<span class="Constant">false</span>};<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* use the tmp context so we can clean up after each tuple is done */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_cxt = MemoryContextSwitchTo(tmp_cxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (as_text)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (v.type == jbvNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* a json null is an sql null in text mode */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">0</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">0</span>] = (Datum) <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">0</span>] = PointerGetDatum(<a href="#L1802" title="utils/adt/jsonfuncs.c:1802">JsonbValueAsText</a>(&amp;v));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Not in text mode, just return the Jsonb */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Jsonb&nbsp; &nbsp; &nbsp;&nbsp; *val = <a href="jsonb_util.c.html#L92" title="utils/adt/jsonb_util.c:92">JsonbValueToJsonb</a>(&amp;v);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">0</span>] = PointerGetDatum(val);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../sort/tuplestore.c.html#L750" title="utils/sort/tuplestore.c:750">tuplestore_putvalues</a>(rsi-&gt;setResult, rsi-&gt;setDesc, <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, nulls);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* clean up and switch back */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(old_cxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(tmp_cxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(tmp_cxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2293">&#x200c;</a><span class="linkable">json_array_elements</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2305" title="utils/adt/jsonfuncs.c:2305">elements_worker</a>(fcinfo, <span class="Constant">&quot;<a href="#L2293" title="utils/adt/jsonfuncs.c:2293">json_array_elements</a>&quot;</span>, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2299">&#x200c;</a><span class="linkable">json_array_elements_text</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2305" title="utils/adt/jsonfuncs.c:2305">elements_worker</a>(fcinfo, <span class="Constant">&quot;<a href="#L2299" title="utils/adt/jsonfuncs.c:2299">json_array_elements_text</a>&quot;</span>, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> Datum<br/></li>
<li><a id="L2305">&#x200c;</a><span class="linkable">elements_worker</span>(FunctionCallInfo fcinfo, <span class="Type">const</span> <span class="Type">char</span> *funcname, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> as_text)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *json = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; JsonLexContext lex;<br/></li>
<li>&nbsp; &nbsp; JsonSemAction *sem;<br/></li>
<li>&nbsp; &nbsp; ReturnSetInfo *rsi;<br/></li>
<li>&nbsp; &nbsp; <a href="#L121" title="utils/adt/jsonfuncs.c:121">ElementsState</a> *state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* elements only needs escaped strings when as_text */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L537" title="utils/adt/jsonfuncs.c:537">makeJsonLexContext</a>(&amp;lex, json, as_text);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L121" title="utils/adt/jsonfuncs.c:121">ElementsState</a>));<br/></li>
<li>&nbsp; &nbsp; sem = <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(JsonSemAction));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../fmgr/funcapi.c.html#L76" title="utils/fmgr/funcapi.c:76">InitMaterializedSRF</a>(fcinfo, MAT_SRF_USE_EXPECTED_DESC | MAT_SRF_BLESS);<br/></li>
<li>&nbsp; &nbsp; rsi = (ReturnSetInfo *) fcinfo-&gt;resultinfo;<br/></li>
<li>&nbsp; &nbsp; state-&gt;tuple_store = rsi-&gt;setResult;<br/></li>
<li>&nbsp; &nbsp; state-&gt;ret_tdesc = rsi-&gt;setDesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sem-&gt;semstate = (<span class="Type">void</span> *) state;<br/></li>
<li>&nbsp; &nbsp; sem-&gt;object_start = <a href="#L2415" title="utils/adt/jsonfuncs.c:2415">elements_object_start</a>;<br/></li>
<li>&nbsp; &nbsp; sem-&gt;scalar = <a href="#L2430" title="utils/adt/jsonfuncs.c:2430">elements_scalar</a>;<br/></li>
<li>&nbsp; &nbsp; sem-&gt;array_element_start = <a href="#L2347" title="utils/adt/jsonfuncs.c:2347">elements_array_element_start</a>;<br/></li>
<li>&nbsp; &nbsp; sem-&gt;array_element_end = <a href="#L2369" title="utils/adt/jsonfuncs.c:2369">elements_array_element_end</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;function_name = funcname;<br/></li>
<li>&nbsp; &nbsp; state-&gt;normalize_results = as_text;<br/></li>
<li>&nbsp; &nbsp; state-&gt;next_scalar = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;lex = &amp;lex;<br/></li>
<li>&nbsp; &nbsp; state-&gt;tmp_cxt = AllocSetContextCreate(<a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;<a href="#L2293" title="utils/adt/jsonfuncs.c:2293">json_array_elements</a> temporary cxt&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pg_parse_json_or_ereport(&amp;lex, sem);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(state-&gt;tmp_cxt);<br/></li>
<li>&nbsp; &nbsp; freeJsonLexContext(&amp;lex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> JsonParseErrorType<br/></li>
<li><a id="L2347">&#x200c;</a><span class="linkable">elements_array_element_start</span>(<span class="Type">void</span> *state, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L121" title="utils/adt/jsonfuncs.c:121">ElementsState</a> *_state = (<a href="#L121" title="utils/adt/jsonfuncs.c:121">ElementsState</a> *) state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* save a pointer to where the value starts */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (_state-&gt;lex-&gt;lex_level == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * next_scalar will be reset in the array_element_end handler, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * since we know the value is a scalar there is no danger of it being<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * on while recursing down the tree.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (_state-&gt;normalize_results &amp;&amp; _state-&gt;lex-&gt;token_type == JSON_TOKEN_STRING)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;next_scalar = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;result_start = _state-&gt;lex-&gt;token_start;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> JsonParseErrorType<br/></li>
<li><a id="L2369">&#x200c;</a><span class="linkable">elements_array_element_end</span>(<span class="Type">void</span> *state, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L121" title="utils/adt/jsonfuncs.c:121">ElementsState</a> *_state = (<a href="#L121" title="utils/adt/jsonfuncs.c:121">ElementsState</a> *) state;<br/></li>
<li>&nbsp; &nbsp; MemoryContext old_cxt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *val;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">1</span>] = {<span class="Constant">false</span>};<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> over nested objects */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (_state-&gt;lex-&gt;lex_level != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* use the tmp context so we can clean up after each tuple is done */<br/></li>
<li></span>&nbsp; &nbsp; old_cxt = MemoryContextSwitchTo(_state-&gt;tmp_cxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isnull &amp;&amp; _state-&gt;normalize_results)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">0</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">0</span>] = (Datum) <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (_state-&gt;next_scalar)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">0</span>] = CStringGetTextDatum(_state-&gt;normalized_scalar);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;next_scalar = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len = _state-&gt;lex-&gt;prev_token_terminator - _state-&gt;result_start;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; val = <a href="varlena.c.html#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(_state-&gt;result_start, len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">0</span>] = PointerGetDatum(val);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = <a href="../../access/common/heaptuple.c.html#L1116" title="access/common/heaptuple.c:1116">heap_form_tuple</a>(_state-&gt;ret_tdesc, <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, nulls);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../sort/tuplestore.c.html#L730" title="utils/sort/tuplestore.c:730">tuplestore_puttuple</a>(_state-&gt;tuple_store, tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* clean up and switch back */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContextSwitchTo(old_cxt);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(_state-&gt;tmp_cxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> JsonParseErrorType<br/></li>
<li><a id="L2415">&#x200c;</a><span class="linkable">elements_object_start</span>(<span class="Type">void</span> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L121" title="utils/adt/jsonfuncs.c:121">ElementsState</a> *_state = (<a href="#L121" title="utils/adt/jsonfuncs.c:121">ElementsState</a> *) state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* json structure check */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (_state-&gt;lex-&gt;lex_level == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot call </span><span class="Special">%s</span><span class="Constant"> on a non-array&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;function_name)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> JsonParseErrorType<br/></li>
<li><a id="L2430">&#x200c;</a><span class="linkable">elements_scalar</span>(<span class="Type">void</span> *state, <span class="Type">char</span> *token, JsonTokenType tokentype)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L121" title="utils/adt/jsonfuncs.c:121">ElementsState</a> *_state = (<a href="#L121" title="utils/adt/jsonfuncs.c:121">ElementsState</a> *) state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* json structure check */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (_state-&gt;lex-&gt;lex_level == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot call </span><span class="Special">%s</span><span class="Constant"> on a scalar&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;function_name)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* supply de-escaped value if required */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (_state-&gt;next_scalar)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;normalized_scalar = token;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * SQL function <a href="#L2492" title="utils/adt/jsonfuncs.c:2492">json_populate_record</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * set fields in a record from the argument json<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Code adapted shamelessly from hstore's <a href="#L3497" title="utils/adt/jsonfuncs.c:3497">populate_record</a><br/></li>
<li></span><span class="Comment"> * which is in turn partly adapted from <a href="rowtypes.c.html#L329" title="utils/adt/rowtypes.c:329">record_out</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The json is decomposed into a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table, in which each<br/></li>
<li></span><span class="Comment"> * field in the record is then looked up by name. For jsonb<br/></li>
<li></span><span class="Comment"> * we fetch the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> direct from the object.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2461">&#x200c;</a><span class="linkable">jsonb_populate_record</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L3675" title="utils/adt/jsonfuncs.c:3675">populate_record_worker</a>(fcinfo, <span class="Constant">&quot;<a href="#L2461" title="utils/adt/jsonfuncs.c:2461">jsonb_populate_record</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>, <span class="Constant">true</span>, <span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * SQL function that can be used for testing <a href="#L2492" title="utils/adt/jsonfuncs.c:2492">json_populate_record</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns false if <a href="#L2492" title="utils/adt/jsonfuncs.c:2492">json_populate_record</a>() encounters an error for the<br/></li>
<li></span><span class="Comment"> * provided input JSON object, true otherwise.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2474">&#x200c;</a><span class="linkable">jsonb_populate_record_valid</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ErrorSaveContext escontext = {T_ErrorSaveContext};<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L3675" title="utils/adt/jsonfuncs.c:3675">populate_record_worker</a>(fcinfo, <span class="Constant">&quot;<a href="#L2461" title="utils/adt/jsonfuncs.c:2461">jsonb_populate_record</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>, <span class="Constant">true</span>, (Node *) &amp;escontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> BoolGetDatum(!escontext.error_occurred);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2485">&#x200c;</a><span class="linkable">jsonb_to_record</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L3675" title="utils/adt/jsonfuncs.c:3675">populate_record_worker</a>(fcinfo, <span class="Constant">&quot;<a href="#L2485" title="utils/adt/jsonfuncs.c:2485">jsonb_to_record</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>, <span class="Constant">false</span>, <span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2492">&#x200c;</a><span class="linkable">json_populate_record</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L3675" title="utils/adt/jsonfuncs.c:3675">populate_record_worker</a>(fcinfo, <span class="Constant">&quot;<a href="#L2492" title="utils/adt/jsonfuncs.c:2492">json_populate_record</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>, <span class="Constant">true</span>, <span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2499">&#x200c;</a><span class="linkable">json_to_record</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L3675" title="utils/adt/jsonfuncs.c:3675">populate_record_worker</a>(fcinfo, <span class="Constant">&quot;<a href="#L2499" title="utils/adt/jsonfuncs.c:2499">json_to_record</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>, <span class="Constant">false</span>, <span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* helper function for diagnostics */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2507">&#x200c;</a></span><span class="linkable">populate_array_report_expected_array</span>(<a href="#L258" title="utils/adt/jsonfuncs.c:258">PopulateArrayContext</a> *ctx, <span class="Type">int</span> ndim)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ndim &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ctx-&gt;colname)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errsave(ctx-&gt;escontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;expected JSON array&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;See the value of key </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">.&quot;</span>, ctx-&gt;colname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errsave(ctx-&gt;escontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;expected JSON array&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; StringInfoData indices;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; initStringInfo(&amp;indices);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(ctx-&gt;ndims &gt; <span class="Constant">0</span> &amp;&amp; ndim &lt; ctx-&gt;ndims);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; ndim; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;indices, <span class="Constant">&quot;[</span><span class="Special">%d</span><span class="Constant">]&quot;</span>, ctx-&gt;sizes[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ctx-&gt;colname)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errsave(ctx-&gt;escontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;expected JSON array&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;See the array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> </span><span class="Special">%s</span><span class="Constant"> of key </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; indices.data, ctx-&gt;colname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errsave(ctx-&gt;escontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;expected JSON array&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;See the array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> </span><span class="Special">%s</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; indices.data)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Validate and set ndims for populating an array with some<br/></li>
<li></span><span class="Comment"> * populate_array_*() function.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns false if the input (ndims) is erroneous.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2557">&#x200c;</a></span><span class="linkable">populate_array_assign_ndims</span>(<a href="#L258" title="utils/adt/jsonfuncs.c:258">PopulateArrayContext</a> *ctx, <span class="Type">int</span> ndims)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(ctx-&gt;ndims &lt;= <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ndims &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2507" title="utils/adt/jsonfuncs.c:2507">populate_array_report_expected_array</a>(ctx, ndims);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Getting here means the error was reported softly. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(SOFT_ERROR_OCCURRED(ctx-&gt;escontext));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ctx-&gt;ndims = ndims;<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;dims = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>) * ndims);<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;sizes = <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>) * ndims);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; ndims; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ctx-&gt;dims[i] = -<span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* dimensions are unknown yet */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check the populated subarray dimension<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns false if the input (ndims) is erroneous.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2587">&#x200c;</a></span><span class="linkable">populate_array_check_dimension</span>(<a href="#L258" title="utils/adt/jsonfuncs.c:258">PopulateArrayContext</a> *ctx, <span class="Type">int</span> ndim)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dim = ctx-&gt;sizes[ndim]; <span class="Comment">/* current dimension counter */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ctx-&gt;dims[ndim] == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ctx-&gt;dims[ndim] = dim;&nbsp; &nbsp; <span class="Comment">/* assign dimension if not yet known */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (ctx-&gt;dims[ndim] != dim)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereturn(ctx-&gt;escontext, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;malformed JSON array&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Multidimensional arrays must have &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;sub-arrays with matching dimensions.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* reset the current array dimension size counter */<br/></li>
<li></span>&nbsp; &nbsp; ctx-&gt;sizes[ndim] = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* increment the parent dimension counter if it is a nested sub-array */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ndim &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ctx-&gt;sizes[ndim - <span class="Constant">1</span>]++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns true if the array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> value was successfully extracted from jsv<br/></li>
<li></span><span class="Comment"> * and added to ctx-&gt;astate.&nbsp; False if an error occurred when doing so.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2615">&#x200c;</a></span><span class="linkable">populate_array_element</span>(<a href="#L258" title="utils/adt/jsonfuncs.c:258">PopulateArrayContext</a> *ctx, <span class="Type">int</span> ndim, <a href="#L291" title="utils/adt/jsonfuncs.c:291">JsValue</a> *jsv)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; element_isnull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* populate the array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> = <a href="#L3384" title="utils/adt/jsonfuncs.c:3384">populate_record_field</a>(ctx-&gt;aio-&gt;element_info,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ctx-&gt;aio-&gt;element_type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ctx-&gt;aio-&gt;element_typmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, ctx-&gt;mcxt, PointerGetDatum(<span class="Constant">NULL</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jsv, &amp;element_isnull, ctx-&gt;escontext);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Nothing to do on an error. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (SOFT_ERROR_OCCURRED(ctx-&gt;escontext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="arrayfuncs.c.html#L5331" title="utils/adt/arrayfuncs.c:5331">accumArrayResult</a>(ctx-&gt;astate, <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>, element_isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ctx-&gt;aio-&gt;element_type, ctx-&gt;acxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(ndim &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;sizes[ndim - <span class="Constant">1</span>]++;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* increment current dimension counter */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* json object start handler for <a href="#L2785" title="utils/adt/jsonfuncs.c:2785">populate_array_json</a>() */<br/></li>
<li></span><span class="Type">static</span> JsonParseErrorType<br/></li>
<li><a id="L2641">&#x200c;</a><span class="linkable">populate_array_object_start</span>(<span class="Type">void</span> *_state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L272" title="utils/adt/jsonfuncs.c:272">PopulateArrayState</a> *state = (<a href="#L272" title="utils/adt/jsonfuncs.c:272">PopulateArrayState</a> *) _state;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndim = state-&gt;lex-&gt;lex_level;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;ctx-&gt;ndims &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L2557" title="utils/adt/jsonfuncs.c:2557">populate_array_assign_ndims</a>(state-&gt;ctx, ndim))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> JSON_SEM_ACTION_FAILED;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (ndim &lt; state-&gt;ctx-&gt;ndims)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2507" title="utils/adt/jsonfuncs.c:2507">populate_array_report_expected_array</a>(state-&gt;ctx, ndim);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Getting here means the error was reported softly. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(SOFT_ERROR_OCCURRED(state-&gt;ctx-&gt;escontext));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> JSON_SEM_ACTION_FAILED;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* json array end handler for <a href="#L2785" title="utils/adt/jsonfuncs.c:2785">populate_array_json</a>() */<br/></li>
<li></span><span class="Type">static</span> JsonParseErrorType<br/></li>
<li><a id="L2664">&#x200c;</a><span class="linkable">populate_array_array_end</span>(<span class="Type">void</span> *_state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L272" title="utils/adt/jsonfuncs.c:272">PopulateArrayState</a> *state = (<a href="#L272" title="utils/adt/jsonfuncs.c:272">PopulateArrayState</a> *) _state;<br/></li>
<li>&nbsp; &nbsp; <a href="#L258" title="utils/adt/jsonfuncs.c:258">PopulateArrayContext</a> *ctx = state-&gt;ctx;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndim = state-&gt;lex-&gt;lex_level;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ctx-&gt;ndims &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L2557" title="utils/adt/jsonfuncs.c:2557">populate_array_assign_ndims</a>(ctx, ndim + <span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> JSON_SEM_ACTION_FAILED;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ndim &lt; ctx-&gt;ndims)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Report if an error occurred. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L2587" title="utils/adt/jsonfuncs.c:2587">populate_array_check_dimension</a>(ctx, ndim))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> JSON_SEM_ACTION_FAILED;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* json array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> start handler for <a href="#L2785" title="utils/adt/jsonfuncs.c:2785">populate_array_json</a>() */<br/></li>
<li></span><span class="Type">static</span> JsonParseErrorType<br/></li>
<li><a id="L2688">&#x200c;</a><span class="linkable">populate_array_element_start</span>(<span class="Type">void</span> *_state, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L272" title="utils/adt/jsonfuncs.c:272">PopulateArrayState</a> *state = (<a href="#L272" title="utils/adt/jsonfuncs.c:272">PopulateArrayState</a> *) _state;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndim = state-&gt;lex-&gt;lex_level;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;ctx-&gt;ndims &lt;= <span class="Constant">0</span> || ndim == state-&gt;ctx-&gt;ndims)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* remember current array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> start */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;element_start = state-&gt;lex-&gt;token_start;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;element_type = state-&gt;lex-&gt;token_type;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;element_scalar = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* json array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> end handler for <a href="#L2785" title="utils/adt/jsonfuncs.c:2785">populate_array_json</a>() */<br/></li>
<li></span><span class="Type">static</span> JsonParseErrorType<br/></li>
<li><a id="L2706">&#x200c;</a><span class="linkable">populate_array_element_end</span>(<span class="Type">void</span> *_state, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L272" title="utils/adt/jsonfuncs.c:272">PopulateArrayState</a> *state = (<a href="#L272" title="utils/adt/jsonfuncs.c:272">PopulateArrayState</a> *) _state;<br/></li>
<li>&nbsp; &nbsp; <a href="#L258" title="utils/adt/jsonfuncs.c:258">PopulateArrayContext</a> *ctx = state-&gt;ctx;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndim = state-&gt;lex-&gt;lex_level;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(ctx-&gt;ndims &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ndim == ctx-&gt;ndims)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L291" title="utils/adt/jsonfuncs.c:291">JsValue</a>&nbsp; &nbsp; &nbsp; &nbsp; jsv;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; jsv.is_json = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; jsv.val.json.type = state-&gt;element_type;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(jsv.val.json.type == JSON_TOKEN_NULL);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jsv.val.json.str = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jsv.val.json.len = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (state-&gt;element_scalar)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jsv.val.json.str = state-&gt;element_scalar;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jsv.val.json.len = -<span class="Constant">1</span>;&nbsp; &nbsp; <span class="Comment">/* null-terminated */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jsv.val.json.str = state-&gt;element_start;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jsv.val.json.len = (state-&gt;lex-&gt;prev_token_terminator -<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;element_start) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">char</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Report if an error occurred. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L2615" title="utils/adt/jsonfuncs.c:2615">populate_array_element</a>(ctx, ndim, &amp;jsv))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> JSON_SEM_ACTION_FAILED;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* json scalar handler for <a href="#L2785" title="utils/adt/jsonfuncs.c:2785">populate_array_json</a>() */<br/></li>
<li></span><span class="Type">static</span> JsonParseErrorType<br/></li>
<li><a id="L2749">&#x200c;</a><span class="linkable">populate_array_scalar</span>(<span class="Type">void</span> *_state, <span class="Type">char</span> *token, JsonTokenType tokentype)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L272" title="utils/adt/jsonfuncs.c:272">PopulateArrayState</a> *state = (<a href="#L272" title="utils/adt/jsonfuncs.c:272">PopulateArrayState</a> *) _state;<br/></li>
<li>&nbsp; &nbsp; <a href="#L258" title="utils/adt/jsonfuncs.c:258">PopulateArrayContext</a> *ctx = state-&gt;ctx;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndim = state-&gt;lex-&gt;lex_level;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ctx-&gt;ndims &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L2557" title="utils/adt/jsonfuncs.c:2557">populate_array_assign_ndims</a>(ctx, ndim))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> JSON_SEM_ACTION_FAILED;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (ndim &lt; ctx-&gt;ndims)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2507" title="utils/adt/jsonfuncs.c:2507">populate_array_report_expected_array</a>(ctx, ndim);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Getting here means the error was reported softly. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(SOFT_ERROR_OCCURRED(ctx-&gt;escontext));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> JSON_SEM_ACTION_FAILED;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ndim == ctx-&gt;ndims)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* remember the scalar <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> token */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;element_scalar = token;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* element_type must already be set in <a href="#L2688" title="utils/adt/jsonfuncs.c:2688">populate_array_element_start</a>() */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(state-&gt;element_type == tokentype);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Parse a json array and populate array<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns false if an error occurs when parsing.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2785">&#x200c;</a></span><span class="linkable">populate_array_json</span>(<a href="#L258" title="utils/adt/jsonfuncs.c:258">PopulateArrayContext</a> *ctx, <span class="Type">char</span> *json, <span class="Type">int</span> len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L272" title="utils/adt/jsonfuncs.c:272">PopulateArrayState</a> state;<br/></li>
<li>&nbsp; &nbsp; JsonSemAction sem;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state.lex = makeJsonLexContextCstringLen(<span class="Constant">NULL</span>, json, len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../mb/mbutils.c.html#L1261" title="utils/mb/mbutils.c:1261">GetDatabaseEncoding</a>(), <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; state.ctx = ctx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memset(&amp;sem, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(sem));<br/></li>
<li>&nbsp; &nbsp; sem.semstate = (<span class="Type">void</span> *) &amp;state;<br/></li>
<li>&nbsp; &nbsp; sem.object_start = <a href="#L2641" title="utils/adt/jsonfuncs.c:2641">populate_array_object_start</a>;<br/></li>
<li>&nbsp; &nbsp; sem.array_end = <a href="#L2664" title="utils/adt/jsonfuncs.c:2664">populate_array_array_end</a>;<br/></li>
<li>&nbsp; &nbsp; sem.array_element_start = <a href="#L2688" title="utils/adt/jsonfuncs.c:2688">populate_array_element_start</a>;<br/></li>
<li>&nbsp; &nbsp; sem.array_element_end = <a href="#L2706" title="utils/adt/jsonfuncs.c:2706">populate_array_element_end</a>;<br/></li>
<li>&nbsp; &nbsp; sem.scalar = <a href="#L2749" title="utils/adt/jsonfuncs.c:2749">populate_array_scalar</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L516" title="utils/adt/jsonfuncs.c:516">pg_parse_json_or_errsave</a>(state.lex, &amp;sem, ctx-&gt;escontext))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* number of dimensions should be already known */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(ctx-&gt;ndims &gt; <span class="Constant">0</span> &amp;&amp; ctx-&gt;dims);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; freeJsonLexContext(state.lex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> !SOFT_ERROR_OCCURRED(ctx-&gt;escontext);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2821" title="utils/adt/jsonfuncs.c:2821">populate_array_dim_jsonb</a>() -- Iterate recursively through jsonb sub-array<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; elements and accumulate result using given ArrayBuildState.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns false if we return partway through because of an error in a<br/></li>
<li></span><span class="Comment"> * subroutine.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2821">&#x200c;</a></span><span class="linkable">populate_array_dim_jsonb</span>(<a href="#L258" title="utils/adt/jsonfuncs.c:258">PopulateArrayContext</a> *ctx, <span class="Comment">/* context */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; JsonbValue *jbv,&nbsp; &nbsp; <span class="Comment">/* jsonb sub-array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> ndim)&nbsp; &nbsp; <span class="Comment">/* current dimension */<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; JsonbContainer *jbc = jbv-&gt;val.binary.data;<br/></li>
<li>&nbsp; &nbsp; JsonbIterator *it;<br/></li>
<li>&nbsp; &nbsp; JsonbIteratorToken tok;<br/></li>
<li>&nbsp; &nbsp; JsonbValue&nbsp; &nbsp; val;<br/></li>
<li>&nbsp; &nbsp; <a href="#L291" title="utils/adt/jsonfuncs.c:291">JsValue</a>&nbsp; &nbsp; &nbsp; &nbsp; jsv;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Even scalars can end up here thanks to <a href="../../executor/execExprInterp.c.html#L4538" title="executor/execExprInterp.c:4538">ExecEvalJsonCoercion</a>(). */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (jbv-&gt;type != jbvBinary || !JsonContainerIsArray(jbc) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; JsonContainerIsScalar(jbc))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2507" title="utils/adt/jsonfuncs.c:2507">populate_array_report_expected_array</a>(ctx, ndim - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Getting here means the error was reported softly. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(SOFT_ERROR_OCCURRED(ctx-&gt;escontext));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; it = <a href="jsonb_util.c.html#L817" title="utils/adt/jsonb_util.c:817">JsonbIteratorInit</a>(jbc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tok = <a href="jsonb_util.c.html#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a>(&amp;it, &amp;val, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(tok == WJB_BEGIN_ARRAY);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tok = <a href="jsonb_util.c.html#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a>(&amp;it, &amp;val, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the number of dimensions is not yet known and we have found end of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the array, or the first child <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> is not an array, then assign the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * number of dimensions <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ctx-&gt;ndims &lt;= <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (tok == WJB_END_ARRAY ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (tok == WJB_ELEM &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (val.type != jbvBinary ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !JsonContainerIsArray(val.val.binary.data)))))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L2557" title="utils/adt/jsonfuncs.c:2557">populate_array_assign_ndims</a>(ctx, ndim))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; jsv.is_json = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; jsv.val.jsonb = &amp;val;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* process all the array elements */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (tok == WJB_ELEM)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Recurse only if the dimensions of dimensions is still unknown or if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it is not the innermost dimension.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ctx-&gt;ndims &gt; <span class="Constant">0</span> &amp;&amp; ndim &gt;= ctx-&gt;ndims)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L2615" title="utils/adt/jsonfuncs.c:2615">populate_array_element</a>(ctx, ndim, &amp;jsv))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* populate child sub-array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L2821" title="utils/adt/jsonfuncs.c:2821">populate_array_dim_jsonb</a>(ctx, &amp;val, ndim + <span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* number of dimensions should be already known */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(ctx-&gt;ndims &gt; <span class="Constant">0</span> &amp;&amp; ctx-&gt;dims);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L2587" title="utils/adt/jsonfuncs.c:2587">populate_array_check_dimension</a>(ctx, ndim))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tok = <a href="jsonb_util.c.html#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a>(&amp;it, &amp;val, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(tok == WJB_END_ARRAY);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* free iterator, iterating until WJB_DONE */<br/></li>
<li></span>&nbsp; &nbsp; tok = <a href="jsonb_util.c.html#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a>(&amp;it, &amp;val, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(tok == WJB_DONE &amp;&amp; !it);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Recursively populate an array from json/jsonb<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * *isnull is set to true if an error is reported during parsing.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Datum<br/></li>
<li><a id="L2911">&#x200c;</a><span class="linkable">populate_array</span>(<a href="#L165" title="utils/adt/jsonfuncs.c:165">ArrayIOData</a> *aio,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *colname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MemoryContext mcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L291" title="utils/adt/jsonfuncs.c:291">JsValue</a> *jsv,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Node *escontext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L258" title="utils/adt/jsonfuncs.c:258">PopulateArrayContext</a> ctx;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *lbs;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ctx.aio = aio;<br/></li>
<li>&nbsp; &nbsp; ctx.mcxt = mcxt;<br/></li>
<li>&nbsp; &nbsp; ctx.acxt = <a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li>&nbsp; &nbsp; ctx.astate = <a href="arrayfuncs.c.html#L5274" title="utils/adt/arrayfuncs.c:5274">initArrayResult</a>(aio-&gt;element_type, ctx.acxt, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; ctx.colname = colname;<br/></li>
<li>&nbsp; &nbsp; ctx.ndims = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* unknown yet */<br/></li>
<li></span>&nbsp; &nbsp; ctx.dims = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; ctx.sizes = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; ctx.escontext = escontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (jsv-&gt;is_json)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Return null if an error was found. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L2785" title="utils/adt/jsonfuncs.c:2785">populate_array_json</a>(&amp;ctx, jsv-&gt;val.json.str,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; jsv-&gt;val.json.len &gt;= <span class="Constant">0</span> ? jsv-&gt;val.json.len<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; : strlen(jsv-&gt;val.json.str)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *isnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Return null if an error was found. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L2821" title="utils/adt/jsonfuncs.c:2821">populate_array_dim_jsonb</a>(&amp;ctx, jsv-&gt;val.jsonb, <span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *isnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ctx.dims[<span class="Constant">0</span>] = ctx.sizes[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(ctx.ndims &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; lbs = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>) * ctx.ndims);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; ctx.ndims; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lbs[i] = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="arrayfuncs.c.html#L5433" title="utils/adt/arrayfuncs.c:5433">makeMdArrayResult</a>(ctx.astate, ctx.ndims, ctx.dims, lbs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ctx.acxt, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(ctx.dims);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(ctx.sizes);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(lbs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns false if an error occurs, provided escontext points to an<br/></li>
<li></span><span class="Comment"> * ErrorSaveContext.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2978">&#x200c;</a></span><span class="linkable">JsValueToJsObject</span>(<a href="#L291" title="utils/adt/jsonfuncs.c:291">JsValue</a> *jsv, <a href="#L307" title="utils/adt/jsonfuncs.c:307">JsObject</a> *jso, Node *escontext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; jso-&gt;is_json = jsv-&gt;is_json;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (jsv-&gt;is_json)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* convert plain-text json into a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; jso-&gt;val.json_hash =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3787" title="utils/adt/jsonfuncs.c:3787">get_json_object_as_hash</a>(jsv-&gt;val.json.str,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jsv-&gt;val.json.len &gt;= <span class="Constant">0<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ? jsv-&gt;val.json.len<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : strlen(jsv-&gt;val.json.str),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;<a href="#L3054" title="utils/adt/jsonfuncs.c:3054">populate_composite</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; escontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(jso-&gt;val.json_hash != <span class="Constant">NULL</span> || SOFT_ERROR_OCCURRED(escontext));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; JsonbValue *jbv = jsv-&gt;val.jsonb;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (jbv-&gt;type == jbvBinary &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JsonContainerIsObject(jbv-&gt;val.binary.data))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jso-&gt;val.jsonb_cont = jbv-&gt;val.binary.data;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_scalar;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is_scalar = IsAJsonbScalar(jbv) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jbv-&gt;type == jbvBinary &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; JsonContainerIsScalar(jbv-&gt;val.binary.data));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errsave(escontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; is_scalar<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ? <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot call </span><span class="Special">%s</span><span class="Constant"> on a scalar&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;<a href="#L3054" title="utils/adt/jsonfuncs.c:3054">populate_composite</a>&quot;</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; : <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot call </span><span class="Special">%s</span><span class="Constant"> on an array&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;<a href="#L3054" title="utils/adt/jsonfuncs.c:3054">populate_composite</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> !SOFT_ERROR_OCCURRED(escontext);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* acquire or update cached tuple descriptor for a composite type */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3025">&#x200c;</a></span><span class="linkable">update_cached_tupdesc</span>(<a href="#L173" title="utils/adt/jsonfuncs.c:173">CompositeIOData</a> *io, MemoryContext mcxt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!io-&gt;tupdesc ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; io-&gt;tupdesc-&gt;tdtypeid != io-&gt;base_typid ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; io-&gt;tupdesc-&gt;tdtypmod != io-&gt;base_typmod)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc = <a href="../cache/typcache.c.html#L1833" title="utils/cache/typcache.c:1833">lookup_rowtype_tupdesc</a>(io-&gt;base_typid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; io-&gt;base_typmod);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (io-&gt;tupdesc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/common/tupdesc.c.html#L331" title="access/common/tupdesc.c:331">FreeTupleDesc</a>(io-&gt;tupdesc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* copy tuple desc without constraints into cache memory context */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(mcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; io-&gt;tupdesc = <a href="../../access/common/tupdesc.c.html#L133" title="access/common/tupdesc.c:133">CreateTupleDescCopy</a>(tupdesc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ReleaseTupleDesc(tupdesc);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Recursively populate a composite (row type) value from json/jsonb<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns null if an error occurs in a subroutine, provided escontext points<br/></li>
<li></span><span class="Comment"> * to an ErrorSaveContext.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Datum<br/></li>
<li><a id="L3054">&#x200c;</a><span class="linkable">populate_composite</span>(<a href="#L173" title="utils/adt/jsonfuncs.c:173">CompositeIOData</a> *io,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid typid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *colname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MemoryContext mcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HeapTupleHeader defaultval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L291" title="utils/adt/jsonfuncs.c:291">JsValue</a> *jsv,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Node *escontext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* acquire/update cached tuple descriptor */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3025" title="utils/adt/jsonfuncs.c:3025">update_cached_tupdesc</a>(io, mcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeader tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L307" title="utils/adt/jsonfuncs.c:307">JsObject</a>&nbsp; &nbsp; jso;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* prepare input value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L2978" title="utils/adt/jsonfuncs.c:2978">JsValueToJsObject</a>(jsv, &amp;jso, escontext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *isnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* populate resulting record tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tuple = <a href="#L3497" title="utils/adt/jsonfuncs.c:3497">populate_record</a>(io-&gt;tupdesc, &amp;io-&gt;record_io,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; defaultval, mcxt, &amp;jso, escontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (SOFT_ERROR_OCCURRED(escontext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *isnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../executor/execTuples.c.html#L2311" title="executor/execTuples.c:2311">HeapTupleHeaderGetDatum</a>(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L333" title="utils/adt/jsonfuncs.c:333">JsObjectFree</a>(&amp;jso);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If it's domain over composite, check domain constraints.&nbsp; (This should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * probably get refactored so that we can see the TYPECAT value, but for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, we can tell by comparing typid to base_typid.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (typid != io-&gt;base_typid &amp;&amp; typid != RECORDOID)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="domains.c.html#L355" title="utils/adt/domains.c:355">domain_check_safe</a>(result, *isnull, typid, &amp;io-&gt;domain_info, mcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; escontext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *isnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Populate non-null scalar value from json/jsonb value.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns null if an error occurs during the call to type input function,<br/></li>
<li></span><span class="Comment"> * provided escontext is valid.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Datum<br/></li>
<li><a id="L3121">&#x200c;</a><span class="linkable">populate_scalar</span>(<a href="#L154" title="utils/adt/jsonfuncs.c:154">ScalarIOData</a> *io, Oid typid, int32 typmod, <a href="#L291" title="utils/adt/jsonfuncs.c:291">JsValue</a> *jsv,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull, Node *escontext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *str = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *json = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (jsv-&gt;is_json)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len = jsv-&gt;val.json.len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; json = jsv-&gt;val.json.str;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(json);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (len &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Need to copy non-null-terminated string */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(len + <span class="Constant">1</span> * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">char</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(str, json, len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str[len] = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = json;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* string is already null-terminated */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If converting to json/jsonb, make string into valid JSON literal */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((typid == JSONOID || typid == JSONBOID) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jsv-&gt;val.json.type == JSON_TOKEN_STRING)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StringInfoData buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; initStringInfo(&amp;buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="json.c.html#L1549" title="utils/adt/json.c:1549">escape_json</a>(&amp;buf, str);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* free temporary buffer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (str != json)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(str);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = buf.data;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; JsonbValue *jbv = jsv-&gt;val.jsonb;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typid == JSONBOID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Jsonb&nbsp; &nbsp; &nbsp;&nbsp; *jsonb = <a href="jsonb_util.c.html#L92" title="utils/adt/jsonb_util.c:92">JsonbValueToJsonb</a>(jbv); <span class="Comment">/* directly use jsonb */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> JsonbPGetDatum(jsonb);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* convert jsonb to string for typio call */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (typid == JSONOID &amp;&amp; jbv-&gt;type != jbvBinary)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Convert scalar jsonb (non-scalars are passed here as jbvBinary)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to json string, preserving quotes around top-level strings.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Jsonb&nbsp; &nbsp; &nbsp;&nbsp; *jsonb = <a href="jsonb_util.c.html#L92" title="utils/adt/jsonb_util.c:92">JsonbValueToJsonb</a>(jbv);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = <a href="jsonb.c.html#L473" title="utils/adt/jsonb.c:473">JsonbToCString</a>(<span class="Constant">NULL</span>, &amp;jsonb-&gt;root, VARSIZE(jsonb));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (jbv-&gt;type == jbvString)&nbsp; &nbsp; <span class="Comment">/* quotes are stripped */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = <a href="../mmgr/mcxt.c.html#L1706" title="utils/mmgr/mcxt.c:1706">pnstrdup</a>(jbv-&gt;val.string.val, jbv-&gt;val.string.len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (jbv-&gt;type == jbvBool)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(jbv-&gt;val.boolean ? <span class="Constant">&quot;true&quot;</span> : <span class="Constant">&quot;false&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (jbv-&gt;type == jbvNumeric)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = DatumGetCString(DirectFunctionCall1(<a href="numeric.c.html#L807" title="utils/adt/numeric.c:807">numeric_out</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(jbv-&gt;val.<a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (jbv-&gt;type == jbvBinary)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = <a href="jsonb.c.html#L473" title="utils/adt/jsonb.c:473">JsonbToCString</a>(<span class="Constant">NULL</span>, jbv-&gt;val.binary.data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; jbv-&gt;val.binary.len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized jsonb type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, (<span class="Type">int</span>) jbv-&gt;type);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../fmgr/fmgr.c.html#L1585" title="utils/fmgr/fmgr.c:1585">InputFunctionCallSafe</a>(&amp;io-&gt;typiofunc, str, io-&gt;typioparam, typmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; escontext, &amp;res))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *isnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* free temporary buffer */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (str != json)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(str);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> Datum<br/></li>
<li><a id="L3208">&#x200c;</a><span class="linkable">populate_domain</span>(<a href="#L189" title="utils/adt/jsonfuncs.c:189">DomainIOData</a> *io,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid typid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *colname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContext mcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L291" title="utils/adt/jsonfuncs.c:291">JsValue</a> *jsv,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node *escontext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res = <a href="#L3384" title="utils/adt/jsonfuncs.c:3384">populate_record_field</a>(io-&gt;base_io,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; io-&gt;base_typid, io-&gt;base_typmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colname, mcxt, PointerGetDatum(<span class="Constant">NULL</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jsv, isnull, escontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!*isnull || SOFT_ERROR_OCCURRED(escontext));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="domains.c.html#L355" title="utils/adt/domains.c:355">domain_check_safe</a>(res, *isnull, typid, &amp;io-&gt;domain_info, mcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; escontext))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *isnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* prepare column metadata cache for the given type */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3241">&#x200c;</a></span><span class="linkable">prepare_column_cache</span>(<a href="rowtypes.c.html#L34" title="utils/adt/rowtypes.c:34">ColumnIOData</a> *column,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid typid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; int32 typmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MemoryContext mcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> need_scalar)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tup;<br/></li>
<li>&nbsp; &nbsp; Form_pg_type type;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; column-&gt;typid = typid;<br/></li>
<li>&nbsp; &nbsp; column-&gt;typmod = typmod;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tup = <a href="../cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(TYPEOID, ObjectIdGetDatum(typid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for type </span><span class="Special">%u</span><span class="Constant">&quot;</span>, typid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; type = (Form_pg_type) GETSTRUCT(tup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (type-&gt;typtype == TYPTYPE_DOMAIN)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can move directly to the bottom base type; <a href="domains.c.html#L346" title="utils/adt/domains.c:346">domain_check</a>() will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * take care of checking all constraints for a stack of domains.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; base_typid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; base_typmod = typmod;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; base_typid = <a href="../cache/lsyscache.c.html#L2538" title="utils/cache/lsyscache.c:2538">getBaseTypeAndTypmod</a>(typid, &amp;base_typmod);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../cache/lsyscache.c.html#L2629" title="utils/cache/lsyscache.c:2629">get_typtype</a>(base_typid) == TYPTYPE_COMPOSITE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* domain over composite has its own code path */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column-&gt;typcat = TYPECAT_COMPOSITE_DOMAIN;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column-&gt;io.composite.record_io = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column-&gt;io.composite.tupdesc = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column-&gt;io.composite.base_typid = base_typid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column-&gt;io.composite.base_typmod = base_typmod;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column-&gt;io.composite.domain_info = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* domain over anything else */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column-&gt;typcat = TYPECAT_DOMAIN;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column-&gt;io.domain.base_typid = base_typid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column-&gt;io.domain.base_typmod = base_typmod;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column-&gt;io.domain.base_io =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1214" title="utils/mmgr/mcxt.c:1214">MemoryContextAllocZero</a>(mcxt, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="rowtypes.c.html#L34" title="utils/adt/rowtypes.c:34">ColumnIOData</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column-&gt;io.domain.domain_info = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (type-&gt;typtype == TYPTYPE_COMPOSITE || typid == RECORDOID)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; column-&gt;typcat = TYPECAT_COMPOSITE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; column-&gt;io.composite.record_io = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; column-&gt;io.composite.tupdesc = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; column-&gt;io.composite.base_typid = typid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; column-&gt;io.composite.base_typmod = typmod;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; column-&gt;io.composite.domain_info = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsTrueArrayType(type))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; column-&gt;typcat = TYPECAT_ARRAY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; column-&gt;io.array.element_info = <a href="../mmgr/mcxt.c.html#L1214" title="utils/mmgr/mcxt.c:1214">MemoryContextAllocZero</a>(mcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="rowtypes.c.html#L34" title="utils/adt/rowtypes.c:34">ColumnIOData</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; column-&gt;io.array.element_type = type-&gt;typelem;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> typemod stored in attribute's typmod */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; column-&gt;io.array.element_typmod = typmod;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; column-&gt;typcat = TYPECAT_SCALAR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; need_scalar = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* caller can force us to look up scalar_io info even for non-scalars */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (need_scalar)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typioproc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L2874" title="utils/cache/lsyscache.c:2874">getTypeInputInfo</a>(typid, &amp;typioproc, &amp;column-&gt;scalar_io.typioparam);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../fmgr/fmgr.c.html#L137" title="utils/fmgr/fmgr.c:137">fmgr_info_cxt</a>(typioproc, &amp;column-&gt;scalar_io.typiofunc, mcxt);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tup);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Populate and return the value of specified type from a given json/jsonb<br/></li>
<li></span><span class="Comment"> * value 'json_val'.&nbsp; 'cache' is caller-specified pointer to save the<br/></li>
<li></span><span class="Comment"> * <a href="rowtypes.c.html#L34" title="utils/adt/rowtypes.c:34">ColumnIOData</a> that will be initialized on the 1st call and then reused<br/></li>
<li></span><span class="Comment"> * during <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> subsequent calls.&nbsp; 'mcxt' gives the memory context to allocate<br/></li>
<li></span><span class="Comment"> * the <a href="rowtypes.c.html#L34" title="utils/adt/rowtypes.c:34">ColumnIOData</a> and <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other subsidiary memory in.&nbsp; 'escontext',<br/></li>
<li></span><span class="Comment"> * if not NULL, tells that <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> errors that occur should be handled softly.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3335">&#x200c;</a><span class="linkable">json_populate_type</span>(Datum json_val, Oid json_type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid typid, int32 typmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">void</span> **cache, MemoryContext mcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Node *escontext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L291" title="utils/adt/jsonfuncs.c:291">JsValue</a>&nbsp; &nbsp; &nbsp; &nbsp; jsv = {<span class="Constant">0</span>};<br/></li>
<li>&nbsp; &nbsp; JsonbValue&nbsp; &nbsp; jbv;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; jsv.is_json = json_type == JSONOID;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*isnull)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (jsv.is_json)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jsv.val.json.str = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jsv.val.jsonb = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (jsv.is_json)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *json = DatumGetTextPP(json_val);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; jsv.val.json.str = VARDATA_ANY(json);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; jsv.val.json.len = VARSIZE_ANY_EXHDR(json);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; jsv.val.json.type = JSON_TOKEN_INVALID; <span class="Comment">/* not used in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L3054" title="utils/adt/jsonfuncs.c:3054">populate_composite</a>() */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Jsonb&nbsp; &nbsp; &nbsp;&nbsp; *jsonb = DatumGetJsonbP(json_val);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; jsv.val.jsonb = &amp;jbv;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fill binary jsonb value pointing to jb */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; jbv.type = jbvBinary;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; jbv.val.binary.data = &amp;jsonb-&gt;root;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; jbv.val.binary.len = VARSIZE(jsonb) - VARHDRSZ;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*cache == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *cache = <a href="../mmgr/mcxt.c.html#L1214" title="utils/mmgr/mcxt.c:1214">MemoryContextAllocZero</a>(mcxt, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="rowtypes.c.html#L34" title="utils/adt/rowtypes.c:34">ColumnIOData</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L3384" title="utils/adt/jsonfuncs.c:3384">populate_record_field</a>(*cache, typid, typmod, <span class="Constant">NULL</span>, mcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PointerGetDatum(<span class="Constant">NULL</span>), &amp;jsv, isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; escontext);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* recursively populate a record field or an array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> from a json/jsonb value */<br/></li>
<li></span><span class="Type">static</span> Datum<br/></li>
<li><a id="L3384">&#x200c;</a><span class="linkable">populate_record_field</span>(<a href="rowtypes.c.html#L34" title="utils/adt/rowtypes.c:34">ColumnIOData</a> *col,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid typid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int32 typmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *colname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContext mcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum defaultval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L291" title="utils/adt/jsonfuncs.c:291">JsValue</a> *jsv,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node *escontext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L198" title="utils/adt/jsonfuncs.c:198">TypeCat</a>&nbsp; &nbsp; &nbsp; &nbsp; typcat;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Prepare column metadata cache for the given type.&nbsp; Force lookup of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scalar_io data so that the json string hack below will work.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (col-&gt;typid != typid || col-&gt;typmod != typmod)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3241" title="utils/adt/jsonfuncs.c:3241">prepare_column_cache</a>(col, typid, typmod, mcxt, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *isnull = <a href="#L318" title="utils/adt/jsonfuncs.c:318">JsValueIsNull</a>(jsv);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcat = col-&gt;typcat;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* try to convert json string to a non-scalar type through input function */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L323" title="utils/adt/jsonfuncs.c:323">JsValueIsString</a>(jsv) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (typcat == TYPECAT_ARRAY ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typcat == TYPECAT_COMPOSITE ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typcat == TYPECAT_COMPOSITE_DOMAIN))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typcat = TYPECAT_SCALAR;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we must perform domain checks for NULLs, otherwise exit immediately */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (*isnull &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typcat != TYPECAT_DOMAIN &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typcat != TYPECAT_COMPOSITE_DOMAIN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Datum) <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (typcat)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TYPECAT_SCALAR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L3121" title="utils/adt/jsonfuncs.c:3121">populate_scalar</a>(&amp;col-&gt;scalar_io, typid, typmod, jsv,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; isnull, escontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TYPECAT_ARRAY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2911" title="utils/adt/jsonfuncs.c:2911">populate_array</a>(&amp;col-&gt;io.array, colname, mcxt, jsv,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isnull, escontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TYPECAT_COMPOSITE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TYPECAT_COMPOSITE_DOMAIN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L3054" title="utils/adt/jsonfuncs.c:3054">populate_composite</a>(&amp;col-&gt;io.composite, typid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colname, mcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DatumGetPointer(defaultval)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ? DatumGetHeapTupleHeader(defaultval)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jsv, isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; escontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TYPECAT_DOMAIN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L3208" title="utils/adt/jsonfuncs.c:3208">populate_domain</a>(&amp;col-&gt;io.domain, typid, colname, mcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; jsv, isnull, escontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized type category '</span><span class="Special">%c</span><span class="Constant">'&quot;</span>, typcat);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <a href="rowtypes.c.html#L43" title="utils/adt/rowtypes.c:43">RecordIOData</a> *<br/></li>
<li><a id="L3453">&#x200c;</a><span class="linkable">allocate_record_info</span>(MemoryContext mcxt, <span class="Type">int</span> ncolumns)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="rowtypes.c.html#L43" title="utils/adt/rowtypes.c:43">RecordIOData</a> *data = (<a href="rowtypes.c.html#L43" title="utils/adt/rowtypes.c:43">RecordIOData</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(mcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offsetof(<a href="rowtypes.c.html#L43" title="utils/adt/rowtypes.c:43">RecordIOData</a>, columns) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ncolumns * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="rowtypes.c.html#L34" title="utils/adt/rowtypes.c:34">ColumnIOData</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; data-&gt;record_type = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; data-&gt;record_typmod = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; data-&gt;ncolumns = ncolumns;<br/></li>
<li>&nbsp; &nbsp; MemSet(data-&gt;columns, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="rowtypes.c.html#L34" title="utils/adt/rowtypes.c:34">ColumnIOData</a>) * ncolumns);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> data;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3469">&#x200c;</a></span><span class="linkable">JsObjectGetField</span>(<a href="#L307" title="utils/adt/jsonfuncs.c:307">JsObject</a> *obj, <span class="Type">char</span> *field, <a href="#L291" title="utils/adt/jsonfuncs.c:291">JsValue</a> *jsv)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; jsv-&gt;is_json = obj-&gt;is_json;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (jsv-&gt;is_json)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L146" title="utils/adt/jsonfuncs.c:146">JsonHashEntry</a> *hashentry = <a href="../hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(obj-&gt;val.json_hash, field,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_FIND, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; jsv-&gt;val.json.type = hashentry ? hashentry-&gt;type : JSON_TOKEN_NULL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; jsv-&gt;val.json.str = jsv-&gt;val.json.type == JSON_TOKEN_NULL ? <span class="Constant">NULL</span> :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hashentry-&gt;val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; jsv-&gt;val.json.len = jsv-&gt;val.json.str ? -<span class="Constant">1</span> : <span class="Constant">0</span>; <span class="Comment">/* null-terminated */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> hashentry != <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; jsv-&gt;val.jsonb = !obj-&gt;val.jsonb_cont ? <span class="Constant">NULL</span> :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="jsonb_util.c.html#L398" title="utils/adt/jsonb_util.c:398">getKeyJsonValueFromContainer</a>(obj-&gt;val.jsonb_cont, field, strlen(field),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> jsv-&gt;val.jsonb != <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* populate a record tuple from json/jsonb value */<br/></li>
<li></span><span class="Type">static</span> HeapTupleHeader<br/></li>
<li><a id="L3497">&#x200c;</a><span class="linkable">populate_record</span>(TupleDesc tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="rowtypes.c.html#L43" title="utils/adt/rowtypes.c:43">RecordIOData</a> **record_p,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeader defaultval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContext mcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L307" title="utils/adt/jsonfuncs.c:307">JsObject</a> *obj,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node *escontext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="rowtypes.c.html#L43" title="utils/adt/rowtypes.c:43">RecordIOData</a> *record = *record_p;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *nulls;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; res;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ncolumns = tupdesc-&gt;natts;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if the input json is empty, we can only <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the rest if we were passed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in a non-null record, since otherwise there may be issues with domain<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nulls.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (defaultval &amp;&amp; <a href="#L327" title="utils/adt/jsonfuncs.c:327">JsObjectIsEmpty</a>(obj))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> defaultval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* (re)allocate metadata cache */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (record == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; record-&gt;ncolumns != ncolumns)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *record_p = record = <a href="#L3453" title="utils/adt/jsonfuncs.c:3453">allocate_record_info</a>(mcxt, ncolumns);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* invalidate metadata cache if the record type has changed */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (record-&gt;record_type != tupdesc-&gt;tdtypeid ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; record-&gt;record_typmod != tupdesc-&gt;tdtypmod)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemSet(record, <span class="Constant">0</span>, offsetof(<a href="rowtypes.c.html#L43" title="utils/adt/rowtypes.c:43">RecordIOData</a>, columns) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ncolumns * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="rowtypes.c.html#L34" title="utils/adt/rowtypes.c:34">ColumnIOData</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; record-&gt;record_type = tupdesc-&gt;tdtypeid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; record-&gt;record_typmod = tupdesc-&gt;tdtypmod;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; record-&gt;ncolumns = ncolumns;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> = (Datum *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(ncolumns * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li>&nbsp; &nbsp; nulls = (<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(ncolumns * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (defaultval)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleData tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Build a temporary HeapTuple control structure */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tuple.t_len = HeapTupleHeaderGetDatumLength(defaultval);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemPointerSetInvalid(&amp;(tuple.t_self));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple.t_tableOid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple.t_data = defaultval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Break down the tuple into fields */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/common/heaptuple.c.html#L1345" title="access/common/heaptuple.c:1345">heap_deform_tuple</a>(&amp;tuple, tupdesc, <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, nulls);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; ncolumns; ++i)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i] = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[i] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; ncolumns; ++i)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att = TupleDescAttr(tupdesc, i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *colname = NameStr(att-&gt;attname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L291" title="utils/adt/jsonfuncs.c:291">JsValue</a>&nbsp; &nbsp; &nbsp; &nbsp; field = {<span class="Constant">0</span>};<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore dropped columns in datatype */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (att-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[i] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; found = <a href="#L3469" title="utils/adt/jsonfuncs.c:3469">JsObjectGetField</a>(obj, colname, &amp;field);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we can't just <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> here if the key wasn't found since we might have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a domain to deal with. If we were passed in a non-null record<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * datum, we assume that the existing <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are valid (if they're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not, then it's not our fault), but if we were passed in a null,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * then every field which we don't populate needs to be run through<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the input function just in case it's a domain type.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (defaultval &amp;&amp; !found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i] = <a href="#L3384" title="utils/adt/jsonfuncs.c:3384">populate_record_field</a>(&amp;record-&gt;columns[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; att-&gt;atttypid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; att-&gt;atttypmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[i] ? (Datum) <span class="Constant">0</span> : <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;field,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;nulls[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; escontext);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="../../access/common/heaptuple.c.html#L1116" title="access/common/heaptuple.c:1116">heap_form_tuple</a>(tupdesc, <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, nulls);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(nulls);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res-&gt;t_data;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Setup for json{b}_populate_record{set}: result type will be same as first<br/></li>
<li></span><span class="Comment"> * argument's type --- unless first argument is &quot;null::record&quot;, which we can't<br/></li>
<li></span><span class="Comment"> * extract type info from; we handle that later.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3612">&#x200c;</a></span><span class="linkable">get_record_type_from_argument</span>(FunctionCallInfo fcinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *funcname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L236" title="utils/adt/jsonfuncs.c:236">PopulateRecordCache</a> *cache)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; cache-&gt;argtype = <a href="../fmgr/fmgr.c.html#L1910" title="utils/fmgr/fmgr.c:1910">get_fn_expr_argtype</a>(fcinfo-&gt;flinfo, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L3241" title="utils/adt/jsonfuncs.c:3241">prepare_column_cache</a>(&amp;cache-&gt;c,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cache-&gt;argtype, -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cache-&gt;fn_mcxt, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cache-&gt;c.typcat != TYPECAT_COMPOSITE &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cache-&gt;c.typcat != TYPECAT_COMPOSITE_DOMAIN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: %s is a function name, eg <a href="#L2499" title="utils/adt/jsonfuncs.c:2499">json_to_record</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;first argument of </span><span class="Special">%s</span><span class="Constant"> must be a row type&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; funcname)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Setup for json{b}_to_record{set}: result type is specified by calling<br/></li>
<li></span><span class="Comment"> * query.&nbsp; We'll also use this code for json{b}_populate_record{set},<br/></li>
<li></span><span class="Comment"> * if we discover that the first argument is a null of type RECORD.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Here it is syntactically impossible to specify the target type<br/></li>
<li></span><span class="Comment"> * as domain-over-composite.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3638">&#x200c;</a></span><span class="linkable">get_record_type_from_query</span>(FunctionCallInfo fcinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *funcname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L236" title="utils/adt/jsonfuncs.c:236">PopulateRecordCache</a> *cache)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc;<br/></li>
<li>&nbsp; &nbsp; MemoryContext old_cxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../fmgr/funcapi.c.html#L276" title="utils/fmgr/funcapi.c:276">get_call_result_type</a>(fcinfo, <span class="Constant">NULL</span>, &amp;tupdesc) != TYPEFUNC_COMPOSITE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: %s is a function name, eg <a href="#L2499" title="utils/adt/jsonfuncs.c:2499">json_to_record</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not determine row type for result of </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; funcname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Provide a non-null record argument, &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;or call the function in the FROM clause &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;using a column definition list.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(tupdesc);<br/></li>
<li>&nbsp; &nbsp; cache-&gt;argtype = tupdesc-&gt;tdtypeid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we go through this more than once, avoid memory leak */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (cache-&gt;c.io.composite.tupdesc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/common/tupdesc.c.html#L331" title="access/common/tupdesc.c:331">FreeTupleDesc</a>(cache-&gt;c.io.composite.tupdesc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Save identified tupdesc */<br/></li>
<li></span>&nbsp; &nbsp; old_cxt = MemoryContextSwitchTo(cache-&gt;fn_mcxt);<br/></li>
<li>&nbsp; &nbsp; cache-&gt;c.io.composite.tupdesc = <a href="../../access/common/tupdesc.c.html#L133" title="access/common/tupdesc.c:133">CreateTupleDescCopy</a>(tupdesc);<br/></li>
<li>&nbsp; &nbsp; cache-&gt;c.io.composite.base_typid = tupdesc-&gt;tdtypeid;<br/></li>
<li>&nbsp; &nbsp; cache-&gt;c.io.composite.base_typmod = tupdesc-&gt;tdtypmod;<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(old_cxt);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * common worker for json{b}_populate_record() and json{b}_to_record()<br/></li>
<li></span><span class="Comment"> * is_json and have_record_arg identify the specific function<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Datum<br/></li>
<li><a id="L3675">&#x200c;</a><span class="linkable">populate_record_worker</span>(FunctionCallInfo fcinfo, <span class="Type">const</span> <span class="Type">char</span> *funcname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_json, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> have_record_arg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Node *escontext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; json_arg_num = have_record_arg ? <span class="Constant">1</span> : <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L291" title="utils/adt/jsonfuncs.c:291">JsValue</a>&nbsp; &nbsp; &nbsp; &nbsp; jsv = {<span class="Constant">0</span>};<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeader rec;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; rettuple;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li>&nbsp; &nbsp; JsonbValue&nbsp; &nbsp; jbv;<br/></li>
<li>&nbsp; &nbsp; MemoryContext fnmcxt = fcinfo-&gt;flinfo-&gt;fn_mcxt;<br/></li>
<li>&nbsp; &nbsp; <a href="#L236" title="utils/adt/jsonfuncs.c:236">PopulateRecordCache</a> *cache = fcinfo-&gt;flinfo-&gt;fn_extra;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If first time through, identify input/result record type.&nbsp; Note that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this stanza looks only at fcinfo context, which can't change during the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * query; so we may not be able to fully resolve a RECORD input type yet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!cache)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;flinfo-&gt;fn_extra = cache =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1214" title="utils/mmgr/mcxt.c:1214">MemoryContextAllocZero</a>(fnmcxt, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(*cache));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cache-&gt;fn_mcxt = fnmcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (have_record_arg)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3612" title="utils/adt/jsonfuncs.c:3612">get_record_type_from_argument</a>(fcinfo, funcname, cache);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3638" title="utils/adt/jsonfuncs.c:3638">get_record_type_from_query</a>(fcinfo, funcname, cache);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Collect record arg if we have one */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!have_record_arg)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rec = <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* it's json{b}_to_record() */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!PG_ARGISNULL(<span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rec = PG_GETARG_HEAPTUPLEHEADER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When declared arg type is RECORD, identify actual record type from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the tuple itself.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cache-&gt;argtype == RECORDOID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cache-&gt;c.io.composite.base_typid = HeapTupleHeaderGetTypeId(rec);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cache-&gt;c.io.composite.base_typmod = HeapTupleHeaderGetTypMod(rec);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rec = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When declared arg type is RECORD, identify actual record type from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * calling query, or fail if we can't.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cache-&gt;argtype == RECORDOID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3638" title="utils/adt/jsonfuncs.c:3638">get_record_type_from_query</a>(fcinfo, funcname, cache);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This can't change argtype, which is important for <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> time */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(cache-&gt;argtype == RECORDOID);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If no JSON argument, just return the record (if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>) unchanged */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PG_ARGISNULL(json_arg_num))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rec)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_POINTER(rec);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; jsv.is_json = is_json;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (is_json)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *json = PG_GETARG_TEXT_PP(json_arg_num);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; jsv.val.json.str = VARDATA_ANY(json);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; jsv.val.json.len = VARSIZE_ANY_EXHDR(json);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; jsv.val.json.type = JSON_TOKEN_INVALID; <span class="Comment">/* not used in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L3054" title="utils/adt/jsonfuncs.c:3054">populate_composite</a>() */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Jsonb&nbsp; &nbsp; &nbsp;&nbsp; *jb = PG_GETARG_JSONB_P(json_arg_num);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; jsv.val.jsonb = &amp;jbv;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fill binary jsonb value pointing to jb */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; jbv.type = jbvBinary;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; jbv.val.binary.data = &amp;jb-&gt;root;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; jbv.val.binary.len = VARSIZE(jb) - VARHDRSZ;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; rettuple = <a href="#L3054" title="utils/adt/jsonfuncs.c:3054">populate_composite</a>(&amp;cache-&gt;c.io.composite, cache-&gt;argtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, fnmcxt, rec, &amp;jsv, &amp;isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; escontext);<br/></li>
<li>&nbsp; &nbsp; Assert(!isnull || SOFT_ERROR_OCCURRED(escontext));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_DATUM(rettuple);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3787" title="utils/adt/jsonfuncs.c:3787">get_json_object_as_hash</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Decomposes a json object into a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table if the json is parsed successfully, NULL otherwise.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="../hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *<br/></li>
<li><a id="L3787">&#x200c;</a><span class="linkable">get_json_object_as_hash</span>(<span class="Type">char</span> *json, <span class="Type">int</span> len, <span class="Type">const</span> <span class="Type">char</span> *funcname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node *escontext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASHCTL&nbsp; &nbsp; &nbsp; &nbsp; ctl;<br/></li>
<li>&nbsp; &nbsp; <a href="../hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a>&nbsp; &nbsp; &nbsp;&nbsp; *tab;<br/></li>
<li>&nbsp; &nbsp; <a href="#L135" title="utils/adt/jsonfuncs.c:135">JHashState</a> *state;<br/></li>
<li>&nbsp; &nbsp; JsonSemAction *sem;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ctl.keysize = NAMEDATALEN;<br/></li>
<li>&nbsp; &nbsp; ctl.entrysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L146" title="utils/adt/jsonfuncs.c:146">JsonHashEntry</a>);<br/></li>
<li>&nbsp; &nbsp; ctl.hcxt = <a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li>&nbsp; &nbsp; tab = <a href="../hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(<span class="Constant">&quot;json object hashtable&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">100</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;ctl,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ELEM | HASH_STRINGS | HASH_CONTEXT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L135" title="utils/adt/jsonfuncs.c:135">JHashState</a>));<br/></li>
<li>&nbsp; &nbsp; sem = <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(JsonSemAction));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;function_name = funcname;<br/></li>
<li>&nbsp; &nbsp; state-&gt;<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> = tab;<br/></li>
<li>&nbsp; &nbsp; state-&gt;lex = makeJsonLexContextCstringLen(<span class="Constant">NULL</span>, json, len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mb/mbutils.c.html#L1261" title="utils/mb/mbutils.c:1261">GetDatabaseEncoding</a>(), <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sem-&gt;semstate = (<span class="Type">void</span> *) state;<br/></li>
<li>&nbsp; &nbsp; sem-&gt;array_start = <a href="#L3906" title="utils/adt/jsonfuncs.c:3906">hash_array_start</a>;<br/></li>
<li>&nbsp; &nbsp; sem-&gt;scalar = <a href="#L3919" title="utils/adt/jsonfuncs.c:3919">hash_scalar</a>;<br/></li>
<li>&nbsp; &nbsp; sem-&gt;object_field_start = <a href="#L3829" title="utils/adt/jsonfuncs.c:3829">hash_object_field_start</a>;<br/></li>
<li>&nbsp; &nbsp; sem-&gt;object_field_end = <a href="#L3855" title="utils/adt/jsonfuncs.c:3855">hash_object_field_end</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L516" title="utils/adt/jsonfuncs.c:516">pg_parse_json_or_errsave</a>(state-&gt;lex, sem, escontext))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../hash/dynahash.c.html#L865" title="utils/hash/dynahash.c:865">hash_destroy</a>(state-&gt;<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tab = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; freeJsonLexContext(state-&gt;lex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> tab;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> JsonParseErrorType<br/></li>
<li><a id="L3829">&#x200c;</a><span class="linkable">hash_object_field_start</span>(<span class="Type">void</span> *state, <span class="Type">char</span> *fname, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L135" title="utils/adt/jsonfuncs.c:135">JHashState</a> *_state = (<a href="#L135" title="utils/adt/jsonfuncs.c:135">JHashState</a> *) state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (_state-&gt;lex-&gt;lex_level &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* remember token type */<br/></li>
<li></span>&nbsp; &nbsp; _state-&gt;saved_token_type = _state-&gt;lex-&gt;token_type;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (_state-&gt;lex-&gt;token_type == JSON_TOKEN_ARRAY_START ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;lex-&gt;token_type == JSON_TOKEN_OBJECT_START)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* remember start position of the whole text of the subobject */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;save_json_start = _state-&gt;lex-&gt;token_start;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* must be a scalar */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;save_json_start = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> JsonParseErrorType<br/></li>
<li><a id="L3855">&#x200c;</a><span class="linkable">hash_object_field_end</span>(<span class="Type">void</span> *state, <span class="Type">char</span> *fname, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L135" title="utils/adt/jsonfuncs.c:135">JHashState</a> *_state = (<a href="#L135" title="utils/adt/jsonfuncs.c:135">JHashState</a> *) state;<br/></li>
<li>&nbsp; &nbsp; <a href="#L146" title="utils/adt/jsonfuncs.c:146">JsonHashEntry</a> *hashentry;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ignore nested fields.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (_state-&gt;lex-&gt;lex_level &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ignore field names &gt;= NAMEDATALEN - they can't match a record field.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (Note: without this test, the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> code would truncate the string at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NAMEDATALEN-1, and could then match against a similarly-truncated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * record field name.&nbsp; That would be a reasonable behavior, but this code<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * has previously insisted on exact equality, so we keep this behavior.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (strlen(fname) &gt;= NAMEDATALEN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; hashentry = <a href="../hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(_state-&gt;<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>, fname, HASH_ENTER, &amp;found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * found being true indicates a duplicate. We don't do anything about<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that, a later field with the same name overrides the earlier field.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; hashentry-&gt;type = _state-&gt;saved_token_type;<br/></li>
<li>&nbsp; &nbsp; Assert(isnull == (hashentry-&gt;type == JSON_TOKEN_NULL));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (_state-&gt;save_json_start != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len = _state-&gt;lex-&gt;prev_token_terminator - _state-&gt;save_json_start;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *val = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>((len + <span class="Constant">1</span>) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">char</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(val, _state-&gt;save_json_start, len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; val[len] = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hashentry-&gt;val = val;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* must have had a scalar instead */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; hashentry-&gt;val = _state-&gt;saved_scalar;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> JsonParseErrorType<br/></li>
<li><a id="L3906">&#x200c;</a><span class="linkable">hash_array_start</span>(<span class="Type">void</span> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L135" title="utils/adt/jsonfuncs.c:135">JHashState</a> *_state = (<a href="#L135" title="utils/adt/jsonfuncs.c:135">JHashState</a> *) state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (_state-&gt;lex-&gt;lex_level == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot call </span><span class="Special">%s</span><span class="Constant"> on an array&quot;</span>, _state-&gt;function_name)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> JsonParseErrorType<br/></li>
<li><a id="L3919">&#x200c;</a><span class="linkable">hash_scalar</span>(<span class="Type">void</span> *state, <span class="Type">char</span> *token, JsonTokenType tokentype)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L135" title="utils/adt/jsonfuncs.c:135">JHashState</a> *_state = (<a href="#L135" title="utils/adt/jsonfuncs.c:135">JHashState</a> *) state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (_state-&gt;lex-&gt;lex_level == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot call </span><span class="Special">%s</span><span class="Constant"> on a scalar&quot;</span>, _state-&gt;function_name)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (_state-&gt;lex-&gt;lex_level == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;saved_scalar = token;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* saved_token_type must already be set in <a href="#L3829" title="utils/adt/jsonfuncs.c:3829">hash_object_field_start</a>() */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(_state-&gt;saved_token_type == tokentype);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * SQL function <a href="#L3964" title="utils/adt/jsonfuncs.c:3964">json_populate_recordset</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * set fields in a set of <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> from the argument json,<br/></li>
<li></span><span class="Comment"> * which must be an array of objects.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * similar to <a href="#L2492" title="utils/adt/jsonfuncs.c:2492">json_populate_record</a>, but the tuple-building code<br/></li>
<li></span><span class="Comment"> * is pushed down into the semantic action handlers so it's done<br/></li>
<li></span><span class="Comment"> * per object in the array.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3950">&#x200c;</a><span class="linkable">jsonb_populate_recordset</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L4017" title="utils/adt/jsonfuncs.c:4017">populate_recordset_worker</a>(fcinfo, <span class="Constant">&quot;<a href="#L3950" title="utils/adt/jsonfuncs.c:3950">jsonb_populate_recordset</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3957">&#x200c;</a><span class="linkable">jsonb_to_recordset</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L4017" title="utils/adt/jsonfuncs.c:4017">populate_recordset_worker</a>(fcinfo, <span class="Constant">&quot;<a href="#L3957" title="utils/adt/jsonfuncs.c:3957">jsonb_to_recordset</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3964">&#x200c;</a><span class="linkable">json_populate_recordset</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L4017" title="utils/adt/jsonfuncs.c:4017">populate_recordset_worker</a>(fcinfo, <span class="Constant">&quot;<a href="#L3964" title="utils/adt/jsonfuncs.c:3964">json_populate_recordset</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3971">&#x200c;</a><span class="linkable">json_to_recordset</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L4017" title="utils/adt/jsonfuncs.c:4017">populate_recordset_worker</a>(fcinfo, <span class="Constant">&quot;<a href="#L3971" title="utils/adt/jsonfuncs.c:3971">json_to_recordset</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3978">&#x200c;</a></span><span class="linkable">populate_recordset_record</span>(<a href="#L244" title="utils/adt/jsonfuncs.c:244">PopulateRecordsetState</a> *state, <a href="#L307" title="utils/adt/jsonfuncs.c:307">JsObject</a> *obj)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L236" title="utils/adt/jsonfuncs.c:236">PopulateRecordCache</a> *cache = state-&gt;cache;<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeader tuphead;<br/></li>
<li>&nbsp; &nbsp; HeapTupleData tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* acquire/update cached tuple descriptor */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3025" title="utils/adt/jsonfuncs.c:3025">update_cached_tupdesc</a>(&amp;cache-&gt;c.io.composite, cache-&gt;fn_mcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* replace record fields from json */<br/></li>
<li></span>&nbsp; &nbsp; tuphead = <a href="#L3497" title="utils/adt/jsonfuncs.c:3497">populate_record</a>(cache-&gt;c.io.composite.tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;cache-&gt;c.io.composite.record_io,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;rec,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cache-&gt;fn_mcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; obj,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if it's domain over composite, check domain constraints */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (cache-&gt;c.typcat == TYPECAT_COMPOSITE_DOMAIN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="domains.c.html#L355" title="utils/adt/domains.c:355">domain_check_safe</a>(<a href="../../executor/execTuples.c.html#L2311" title="executor/execTuples.c:2311">HeapTupleHeaderGetDatum</a>(tuphead), <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cache-&gt;argtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;cache-&gt;c.io.composite.domain_info,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cache-&gt;fn_mcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ok, save into tuplestore */<br/></li>
<li></span>&nbsp; &nbsp; tuple.t_len = HeapTupleHeaderGetDatumLength(tuphead);<br/></li>
<li>&nbsp; &nbsp; ItemPointerSetInvalid(&amp;(tuple.t_self));<br/></li>
<li>&nbsp; &nbsp; tuple.t_tableOid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; tuple.t_data = tuphead;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../sort/tuplestore.c.html#L730" title="utils/sort/tuplestore.c:730">tuplestore_puttuple</a>(state-&gt;tuple_store, &amp;tuple);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * common worker for json{b}_populate_recordset() and json{b}_to_recordset()<br/></li>
<li></span><span class="Comment"> * is_json and have_record_arg identify the specific function<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Datum<br/></li>
<li><a id="L4017">&#x200c;</a><span class="linkable">populate_recordset_worker</span>(FunctionCallInfo fcinfo, <span class="Type">const</span> <span class="Type">char</span> *funcname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_json, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> have_record_arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; json_arg_num = have_record_arg ? <span class="Constant">1</span> : <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; ReturnSetInfo *rsi;<br/></li>
<li>&nbsp; &nbsp; MemoryContext old_cxt;<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeader rec;<br/></li>
<li>&nbsp; &nbsp; <a href="#L236" title="utils/adt/jsonfuncs.c:236">PopulateRecordCache</a> *cache = fcinfo-&gt;flinfo-&gt;fn_extra;<br/></li>
<li>&nbsp; &nbsp; <a href="#L244" title="utils/adt/jsonfuncs.c:244">PopulateRecordsetState</a> *state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rsi = (ReturnSetInfo *) fcinfo-&gt;resultinfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!rsi || !IsA(rsi, ReturnSetInfo))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;set-valued function called in context that cannot <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> a set&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!(rsi-&gt;allowedModes &amp; SFRM_Materialize))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;materialize mode required, but it is not allowed in this context&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rsi-&gt;returnMode = SFRM_Materialize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If first time through, identify input/result record type.&nbsp; Note that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this stanza looks only at fcinfo context, which can't change during the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * query; so we may not be able to fully resolve a RECORD input type yet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!cache)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;flinfo-&gt;fn_extra = cache =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1214" title="utils/mmgr/mcxt.c:1214">MemoryContextAllocZero</a>(fcinfo-&gt;flinfo-&gt;fn_mcxt, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(*cache));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cache-&gt;fn_mcxt = fcinfo-&gt;flinfo-&gt;fn_mcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (have_record_arg)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3612" title="utils/adt/jsonfuncs.c:3612">get_record_type_from_argument</a>(fcinfo, funcname, cache);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3638" title="utils/adt/jsonfuncs.c:3638">get_record_type_from_query</a>(fcinfo, funcname, cache);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Collect record arg if we have one */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!have_record_arg)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rec = <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* it's json{b}_to_recordset() */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!PG_ARGISNULL(<span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rec = PG_GETARG_HEAPTUPLEHEADER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When declared arg type is RECORD, identify actual record type from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the tuple itself.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cache-&gt;argtype == RECORDOID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cache-&gt;c.io.composite.base_typid = HeapTupleHeaderGetTypeId(rec);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cache-&gt;c.io.composite.base_typmod = HeapTupleHeaderGetTypMod(rec);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rec = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When declared arg type is RECORD, identify actual record type from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * calling query, or fail if we can't.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cache-&gt;argtype == RECORDOID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3638" title="utils/adt/jsonfuncs.c:3638">get_record_type_from_query</a>(fcinfo, funcname, cache);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This can't change argtype, which is important for <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> time */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(cache-&gt;argtype == RECORDOID);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if the json is null <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> back an empty set */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PG_ARGISNULL(json_arg_num))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Forcibly update the cached tupdesc, to ensure we have the right tupdesc<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to return even if the JSON contains no rows.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3025" title="utils/adt/jsonfuncs.c:3025">update_cached_tupdesc</a>(&amp;cache-&gt;c.io.composite, cache-&gt;fn_mcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L244" title="utils/adt/jsonfuncs.c:244">PopulateRecordsetState</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* make tuplestore in a sufficiently long-lived memory context */<br/></li>
<li></span>&nbsp; &nbsp; old_cxt = MemoryContextSwitchTo(rsi-&gt;econtext-&gt;ecxt_per_query_memory);<br/></li>
<li>&nbsp; &nbsp; state-&gt;tuple_store = <a href="../sort/tuplestore.c.html#L318" title="utils/sort/tuplestore.c:318">tuplestore_begin_heap</a>(rsi-&gt;allowedModes &amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; SFRM_Materialize_Random,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>, <a href="../init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a>);<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(old_cxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;function_name = funcname;<br/></li>
<li>&nbsp; &nbsp; state-&gt;cache = cache;<br/></li>
<li>&nbsp; &nbsp; state-&gt;rec = rec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (is_json)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *json = PG_GETARG_TEXT_PP(json_arg_num);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; JsonLexContext lex;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; JsonSemAction *sem;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sem = <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(JsonSemAction));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L537" title="utils/adt/jsonfuncs.c:537">makeJsonLexContext</a>(&amp;lex, json, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sem-&gt;semstate = (<span class="Type">void</span> *) state;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sem-&gt;array_start = <a href="#L4259" title="utils/adt/jsonfuncs.c:4259">populate_recordset_array_start</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sem-&gt;array_element_start = <a href="#L4244" title="utils/adt/jsonfuncs.c:4244">populate_recordset_array_element_start</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sem-&gt;scalar = <a href="#L4266" title="utils/adt/jsonfuncs.c:4266">populate_recordset_scalar</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sem-&gt;object_field_start = <a href="#L4283" title="utils/adt/jsonfuncs.c:4283">populate_recordset_object_field_start</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sem-&gt;object_field_end = <a href="#L4306" title="utils/adt/jsonfuncs.c:4306">populate_recordset_object_field_end</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sem-&gt;object_start = <a href="#L4191" title="utils/adt/jsonfuncs.c:4191">populate_recordset_object_start</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sem-&gt;object_end = <a href="#L4221" title="utils/adt/jsonfuncs.c:4221">populate_recordset_object_end</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;lex = &amp;lex;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_parse_json_or_ereport(&amp;lex, sem);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; freeJsonLexContext(&amp;lex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;lex = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Jsonb&nbsp; &nbsp; &nbsp;&nbsp; *jb = PG_GETARG_JSONB_P(json_arg_num);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; JsonbIterator *it;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; JsonbValue&nbsp; &nbsp; v;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; skipNested = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; JsonbIteratorToken r;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (JB_ROOT_IS_SCALAR(jb) || !JB_ROOT_IS_ARRAY(jb))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot call </span><span class="Special">%s</span><span class="Constant"> on a non-array&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; funcname)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; it = <a href="jsonb_util.c.html#L817" title="utils/adt/jsonb_util.c:817">JsonbIteratorInit</a>(&amp;jb-&gt;root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((r = <a href="jsonb_util.c.html#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a>(&amp;it, &amp;v, skipNested)) != WJB_DONE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; skipNested = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (r == WJB_ELEM)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L307" title="utils/adt/jsonfuncs.c:307">JsObject</a>&nbsp; &nbsp; obj;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (v.type != jbvBinary ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !JsonContainerIsObject(v.val.binary.data))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;argument of </span><span class="Special">%s</span><span class="Constant"> must be an array of objects&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; funcname)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; obj.is_json = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; obj.val.jsonb_cont = v.val.binary.data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3978" title="utils/adt/jsonfuncs.c:3978">populate_recordset_record</a>(state, &amp;obj);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: we must copy the cached tupdesc because the executor will free<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the passed-back setDesc, but we want to hang onto the cache in case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we're called again in the same query.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rsi-&gt;setResult = state-&gt;tuple_store;<br/></li>
<li>&nbsp; &nbsp; rsi-&gt;setDesc = <a href="../../access/common/tupdesc.c.html#L133" title="access/common/tupdesc.c:133">CreateTupleDescCopy</a>(cache-&gt;c.io.composite.tupdesc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> JsonParseErrorType<br/></li>
<li><a id="L4191">&#x200c;</a><span class="linkable">populate_recordset_object_start</span>(<span class="Type">void</span> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L244" title="utils/adt/jsonfuncs.c:244">PopulateRecordsetState</a> *_state = (<a href="#L244" title="utils/adt/jsonfuncs.c:244">PopulateRecordsetState</a> *) state;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lex_level = _state-&gt;lex-&gt;lex_level;<br/></li>
<li>&nbsp; &nbsp; HASHCTL&nbsp; &nbsp; &nbsp; &nbsp; ctl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reject object at top level: we must have an array at level 0 */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (lex_level == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot call </span><span class="Special">%s</span><span class="Constant"> on an object&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;function_name)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Nested objects require no special processing */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (lex_level &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Object at level 1: set up a new <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table for this object */<br/></li>
<li></span>&nbsp; &nbsp; ctl.keysize = NAMEDATALEN;<br/></li>
<li>&nbsp; &nbsp; ctl.entrysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L146" title="utils/adt/jsonfuncs.c:146">JsonHashEntry</a>);<br/></li>
<li>&nbsp; &nbsp; ctl.hcxt = <a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li>&nbsp; &nbsp; _state-&gt;json_hash = <a href="../hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(<span class="Constant">&quot;json object hashtable&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">100</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;ctl,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ELEM | HASH_STRINGS | HASH_CONTEXT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> JsonParseErrorType<br/></li>
<li><a id="L4221">&#x200c;</a><span class="linkable">populate_recordset_object_end</span>(<span class="Type">void</span> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L244" title="utils/adt/jsonfuncs.c:244">PopulateRecordsetState</a> *_state = (<a href="#L244" title="utils/adt/jsonfuncs.c:244">PopulateRecordsetState</a> *) state;<br/></li>
<li>&nbsp; &nbsp; <a href="#L307" title="utils/adt/jsonfuncs.c:307">JsObject</a>&nbsp; &nbsp; obj;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Nested objects require no special processing */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (_state-&gt;lex-&gt;lex_level &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; obj.is_json = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; obj.val.json_hash = _state-&gt;json_hash;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Otherwise, construct and return a tuple based on this level-1 object */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3978" title="utils/adt/jsonfuncs.c:3978">populate_recordset_record</a>(_state, &amp;obj);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Done with <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> for this object */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../hash/dynahash.c.html#L865" title="utils/hash/dynahash.c:865">hash_destroy</a>(_state-&gt;json_hash);<br/></li>
<li>&nbsp; &nbsp; _state-&gt;json_hash = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> JsonParseErrorType<br/></li>
<li><a id="L4244">&#x200c;</a><span class="linkable">populate_recordset_array_element_start</span>(<span class="Type">void</span> *state, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L244" title="utils/adt/jsonfuncs.c:244">PopulateRecordsetState</a> *_state = (<a href="#L244" title="utils/adt/jsonfuncs.c:244">PopulateRecordsetState</a> *) state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (_state-&gt;lex-&gt;lex_level == <span class="Constant">1</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;lex-&gt;token_type != JSON_TOKEN_OBJECT_START)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;argument of </span><span class="Special">%s</span><span class="Constant"> must be an array of objects&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;function_name)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> JsonParseErrorType<br/></li>
<li><a id="L4259">&#x200c;</a><span class="linkable">populate_recordset_array_start</span>(<span class="Type">void</span> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* nothing to do */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> JsonParseErrorType<br/></li>
<li><a id="L4266">&#x200c;</a><span class="linkable">populate_recordset_scalar</span>(<span class="Type">void</span> *state, <span class="Type">char</span> *token, JsonTokenType tokentype)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L244" title="utils/adt/jsonfuncs.c:244">PopulateRecordsetState</a> *_state = (<a href="#L244" title="utils/adt/jsonfuncs.c:244">PopulateRecordsetState</a> *) state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (_state-&gt;lex-&gt;lex_level == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot call </span><span class="Special">%s</span><span class="Constant"> on a scalar&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;function_name)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (_state-&gt;lex-&gt;lex_level == <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;saved_scalar = token;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> JsonParseErrorType<br/></li>
<li><a id="L4283">&#x200c;</a><span class="linkable">populate_recordset_object_field_start</span>(<span class="Type">void</span> *state, <span class="Type">char</span> *fname, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L244" title="utils/adt/jsonfuncs.c:244">PopulateRecordsetState</a> *_state = (<a href="#L244" title="utils/adt/jsonfuncs.c:244">PopulateRecordsetState</a> *) state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (_state-&gt;lex-&gt;lex_level &gt; <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; _state-&gt;saved_token_type = _state-&gt;lex-&gt;token_type;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (_state-&gt;lex-&gt;token_type == JSON_TOKEN_ARRAY_START ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;lex-&gt;token_type == JSON_TOKEN_OBJECT_START)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;save_json_start = _state-&gt;lex-&gt;token_start;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;save_json_start = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> JsonParseErrorType<br/></li>
<li><a id="L4306">&#x200c;</a><span class="linkable">populate_recordset_object_field_end</span>(<span class="Type">void</span> *state, <span class="Type">char</span> *fname, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L244" title="utils/adt/jsonfuncs.c:244">PopulateRecordsetState</a> *_state = (<a href="#L244" title="utils/adt/jsonfuncs.c:244">PopulateRecordsetState</a> *) state;<br/></li>
<li>&nbsp; &nbsp; <a href="#L146" title="utils/adt/jsonfuncs.c:146">JsonHashEntry</a> *hashentry;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ignore nested fields.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (_state-&gt;lex-&gt;lex_level &gt; <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ignore field names &gt;= NAMEDATALEN - they can't match a record field.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (Note: without this test, the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> code would truncate the string at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NAMEDATALEN-1, and could then match against a similarly-truncated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * record field name.&nbsp; That would be a reasonable behavior, but this code<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * has previously insisted on exact equality, so we keep this behavior.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (strlen(fname) &gt;= NAMEDATALEN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; hashentry = <a href="../hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(_state-&gt;json_hash, fname, HASH_ENTER, &amp;found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * found being true indicates a duplicate. We don't do anything about<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that, a later field with the same name overrides the earlier field.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; hashentry-&gt;type = _state-&gt;saved_token_type;<br/></li>
<li>&nbsp; &nbsp; Assert(isnull == (hashentry-&gt;type == JSON_TOKEN_NULL));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (_state-&gt;save_json_start != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len = _state-&gt;lex-&gt;prev_token_terminator - _state-&gt;save_json_start;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *val = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>((len + <span class="Constant">1</span>) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">char</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(val, _state-&gt;save_json_start, len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; val[len] = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hashentry-&gt;val = val;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* must have had a scalar instead */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; hashentry-&gt;val = _state-&gt;saved_scalar;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Semantic actions for <a href="#L4470" title="utils/adt/jsonfuncs.c:4470">json_strip_nulls</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Simply <a href="../../regex/regcomp.c.html#L1584" title="regex/regcomp.c:1584">repeat</a> the input on the output unless we encounter<br/></li>
<li></span><span class="Comment"> * a null object field. State for this is set when the field<br/></li>
<li></span><span class="Comment"> * is started and reset when the scalar action (which must be <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li></span><span class="Comment"> * is called.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> JsonParseErrorType<br/></li>
<li><a id="L4366">&#x200c;</a><span class="linkable">sn_object_start</span>(<span class="Type">void</span> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L283" title="utils/adt/jsonfuncs.c:283">StripnullState</a> *_state = (<a href="#L283" title="utils/adt/jsonfuncs.c:283">StripnullState</a> *) state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfoCharMacro(_state-&gt;strval, <span class="Constant">'{'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> JsonParseErrorType<br/></li>
<li><a id="L4376">&#x200c;</a><span class="linkable">sn_object_end</span>(<span class="Type">void</span> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L283" title="utils/adt/jsonfuncs.c:283">StripnullState</a> *_state = (<a href="#L283" title="utils/adt/jsonfuncs.c:283">StripnullState</a> *) state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfoCharMacro(_state-&gt;strval, <span class="Constant">'}'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> JsonParseErrorType<br/></li>
<li><a id="L4386">&#x200c;</a><span class="linkable">sn_array_start</span>(<span class="Type">void</span> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L283" title="utils/adt/jsonfuncs.c:283">StripnullState</a> *_state = (<a href="#L283" title="utils/adt/jsonfuncs.c:283">StripnullState</a> *) state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfoCharMacro(_state-&gt;strval, <span class="Constant">'['</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> JsonParseErrorType<br/></li>
<li><a id="L4396">&#x200c;</a><span class="linkable">sn_array_end</span>(<span class="Type">void</span> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L283" title="utils/adt/jsonfuncs.c:283">StripnullState</a> *_state = (<a href="#L283" title="utils/adt/jsonfuncs.c:283">StripnullState</a> *) state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfoCharMacro(_state-&gt;strval, <span class="Constant">']'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> JsonParseErrorType<br/></li>
<li><a id="L4406">&#x200c;</a><span class="linkable">sn_object_field_start</span>(<span class="Type">void</span> *state, <span class="Type">char</span> *fname, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L283" title="utils/adt/jsonfuncs.c:283">StripnullState</a> *_state = (<a href="#L283" title="utils/adt/jsonfuncs.c:283">StripnullState</a> *) state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isnull)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> thing must be a scalar or isnull couldn't be true, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there is no danger of this state being carried down into a nested<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * object or array. The flag will be reset in the scalar action.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;skip_next_null = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (_state-&gt;strval-&gt;data[_state-&gt;strval-&gt;len - <span class="Constant">1</span>] != <span class="Constant">'{'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoCharMacro(_state-&gt;strval, <span class="Constant">','</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Unfortunately we don't have the quoted and escaped string <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> more, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we have to re-escape it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="json.c.html#L1549" title="utils/adt/json.c:1549">escape_json</a>(_state-&gt;strval, fname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfoCharMacro(_state-&gt;strval, <span class="Constant">':'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> JsonParseErrorType<br/></li>
<li><a id="L4436">&#x200c;</a><span class="linkable">sn_array_element_start</span>(<span class="Type">void</span> *state, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L283" title="utils/adt/jsonfuncs.c:283">StripnullState</a> *_state = (<a href="#L283" title="utils/adt/jsonfuncs.c:283">StripnullState</a> *) state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (_state-&gt;strval-&gt;data[_state-&gt;strval-&gt;len - <span class="Constant">1</span>] != <span class="Constant">'['</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoCharMacro(_state-&gt;strval, <span class="Constant">','</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> JsonParseErrorType<br/></li>
<li><a id="L4447">&#x200c;</a><span class="linkable">sn_scalar</span>(<span class="Type">void</span> *state, <span class="Type">char</span> *token, JsonTokenType tokentype)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L283" title="utils/adt/jsonfuncs.c:283">StripnullState</a> *_state = (<a href="#L283" title="utils/adt/jsonfuncs.c:283">StripnullState</a> *) state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (_state-&gt;skip_next_null)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(tokentype == JSON_TOKEN_NULL);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;skip_next_null = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tokentype == JSON_TOKEN_STRING)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="json.c.html#L1549" title="utils/adt/json.c:1549">escape_json</a>(_state-&gt;strval, token);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(_state-&gt;strval, token);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * SQL function <a href="#L4470" title="utils/adt/jsonfuncs.c:4470">json_strip_nulls</a>(json) -&gt; json<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4470">&#x200c;</a><span class="linkable">json_strip_nulls</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *json = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L283" title="utils/adt/jsonfuncs.c:283">StripnullState</a> *state;<br/></li>
<li>&nbsp; &nbsp; JsonLexContext lex;<br/></li>
<li>&nbsp; &nbsp; JsonSemAction *sem;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L283" title="utils/adt/jsonfuncs.c:283">StripnullState</a>));<br/></li>
<li>&nbsp; &nbsp; sem = <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(JsonSemAction));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;lex = <a href="#L537" title="utils/adt/jsonfuncs.c:537">makeJsonLexContext</a>(&amp;lex, json, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; state-&gt;strval = makeStringInfo();<br/></li>
<li>&nbsp; &nbsp; state-&gt;skip_next_null = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sem-&gt;semstate = (<span class="Type">void</span> *) state;<br/></li>
<li>&nbsp; &nbsp; sem-&gt;object_start = <a href="#L4366" title="utils/adt/jsonfuncs.c:4366">sn_object_start</a>;<br/></li>
<li>&nbsp; &nbsp; sem-&gt;object_end = <a href="#L4376" title="utils/adt/jsonfuncs.c:4376">sn_object_end</a>;<br/></li>
<li>&nbsp; &nbsp; sem-&gt;array_start = <a href="#L4386" title="utils/adt/jsonfuncs.c:4386">sn_array_start</a>;<br/></li>
<li>&nbsp; &nbsp; sem-&gt;array_end = <a href="#L4396" title="utils/adt/jsonfuncs.c:4396">sn_array_end</a>;<br/></li>
<li>&nbsp; &nbsp; sem-&gt;scalar = <a href="#L4447" title="utils/adt/jsonfuncs.c:4447">sn_scalar</a>;<br/></li>
<li>&nbsp; &nbsp; sem-&gt;array_element_start = <a href="#L4436" title="utils/adt/jsonfuncs.c:4436">sn_array_element_start</a>;<br/></li>
<li>&nbsp; &nbsp; sem-&gt;object_field_start = <a href="#L4406" title="utils/adt/jsonfuncs.c:4406">sn_object_field_start</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pg_parse_json_or_ereport(&amp;lex, sem);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(<a href="varlena.c.html#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(state-&gt;strval-&gt;data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;strval-&gt;len));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * SQL function <a href="#L4503" title="utils/adt/jsonfuncs.c:4503">jsonb_strip_nulls</a>(jsonb) -&gt; jsonb<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4503">&#x200c;</a><span class="linkable">jsonb_strip_nulls</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Jsonb&nbsp; &nbsp; &nbsp;&nbsp; *jb = PG_GETARG_JSONB_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; JsonbIterator *it;<br/></li>
<li>&nbsp; &nbsp; JsonbParseState *parseState = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; JsonbValue *res = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; JsonbValue&nbsp; &nbsp; v,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; k;<br/></li>
<li>&nbsp; &nbsp; JsonbIteratorToken type;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; last_was_key = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (JB_ROOT_IS_SCALAR(jb))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_POINTER(jb);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; it = <a href="jsonb_util.c.html#L817" title="utils/adt/jsonb_util.c:817">JsonbIteratorInit</a>(&amp;jb-&gt;root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((type = <a href="jsonb_util.c.html#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a>(&amp;it, &amp;v, <span class="Constant">false</span>)) != WJB_DONE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!(type == WJB_KEY &amp;&amp; last_was_key));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (type == WJB_KEY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* stash the key until we know if it has a null value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; k = v;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last_was_key = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (last_was_key)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if the last <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> was a key this one can't be */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last_was_key = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> this field if value is null */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (type == WJB_VALUE &amp;&amp; v.type == jbvNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* otherwise, do a delayed <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> of the key */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="jsonb_util.c.html#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(&amp;parseState, WJB_KEY, &amp;k);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (type == WJB_VALUE || type == WJB_ELEM)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <a href="jsonb_util.c.html#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(&amp;parseState, type, &amp;v);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <a href="jsonb_util.c.html#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(&amp;parseState, type, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(res != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(<a href="jsonb_util.c.html#L92" title="utils/adt/jsonb_util.c:92">JsonbValueToJsonb</a>(res));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * SQL function <a href="#L4561" title="utils/adt/jsonfuncs.c:4561">jsonb_pretty</a> (jsonb)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Pretty-printed text for the jsonb<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4561">&#x200c;</a><span class="linkable">jsonb_pretty</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Jsonb&nbsp; &nbsp; &nbsp;&nbsp; *jb = PG_GETARG_JSONB_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; str = makeStringInfo();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="jsonb.c.html#L482" title="utils/adt/jsonb.c:482">JsonbToCStringIndent</a>(str, &amp;jb-&gt;root, VARSIZE(jb));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(<a href="varlena.c.html#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(str-&gt;data, str-&gt;len));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * SQL function <a href="#L4577" title="utils/adt/jsonfuncs.c:4577">jsonb_concat</a> (jsonb, jsonb)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * function for || operator<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4577">&#x200c;</a><span class="linkable">jsonb_concat</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Jsonb&nbsp; &nbsp; &nbsp;&nbsp; *jb1 = PG_GETARG_JSONB_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Jsonb&nbsp; &nbsp; &nbsp;&nbsp; *jb2 = PG_GETARG_JSONB_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; JsonbParseState *state = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; JsonbValue *res;<br/></li>
<li>&nbsp; &nbsp; JsonbIterator *it1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *it2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If one of the jsonb is empty, just return the other if it's not scalar<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and both are of the same kind.&nbsp; If it's a scalar or they are of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * different kinds we need to perform the concatenation even if one is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * empty.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (JB_ROOT_IS_OBJECT(jb1) == JB_ROOT_IS_OBJECT(jb2))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (JB_ROOT_COUNT(jb1) == <span class="Constant">0</span> &amp;&amp; !JB_ROOT_IS_SCALAR(jb2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_JSONB_P(jb2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (JB_ROOT_COUNT(jb2) == <span class="Constant">0</span> &amp;&amp; !JB_ROOT_IS_SCALAR(jb1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_JSONB_P(jb1);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; it1 = <a href="jsonb_util.c.html#L817" title="utils/adt/jsonb_util.c:817">JsonbIteratorInit</a>(&amp;jb1-&gt;root);<br/></li>
<li>&nbsp; &nbsp; it2 = <a href="jsonb_util.c.html#L817" title="utils/adt/jsonb_util.c:817">JsonbIteratorInit</a>(&amp;jb2-&gt;root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="#L5030" title="utils/adt/jsonfuncs.c:5030">IteratorConcat</a>(&amp;it1, &amp;it2, &amp;state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(res != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_JSONB_P(<a href="jsonb_util.c.html#L92" title="utils/adt/jsonb_util.c:92">JsonbValueToJsonb</a>(res));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * SQL function <a href="#L4618" title="utils/adt/jsonfuncs.c:4618">jsonb_delete</a> (jsonb, text)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * return a copy of the jsonb with the indicated item<br/></li>
<li></span><span class="Comment"> * removed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4618">&#x200c;</a><span class="linkable">jsonb_delete</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Jsonb&nbsp; &nbsp; &nbsp;&nbsp; *in = PG_GETARG_JSONB_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *key = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *keyptr = VARDATA_ANY(key);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keylen = VARSIZE_ANY_EXHDR(key);<br/></li>
<li>&nbsp; &nbsp; JsonbParseState *state = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; JsonbIterator *it;<br/></li>
<li>&nbsp; &nbsp; JsonbValue&nbsp; &nbsp; v,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *res = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; skipNested = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; JsonbIteratorToken r;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (JB_ROOT_IS_SCALAR(in))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot delete from scalar&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (JB_ROOT_COUNT(in) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_JSONB_P(in);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; it = <a href="jsonb_util.c.html#L817" title="utils/adt/jsonb_util.c:817">JsonbIteratorInit</a>(&amp;in-&gt;root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((r = <a href="jsonb_util.c.html#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a>(&amp;it, &amp;v, skipNested)) != WJB_DONE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; skipNested = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((r == WJB_ELEM || r == WJB_KEY) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (v.type == jbvString &amp;&amp; keylen == v.val.string.len &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; memcmp(keyptr, v.val.string.val, keylen) == <span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> corresponding value as well */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (r == WJB_KEY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="jsonb_util.c.html#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a>(&amp;it, &amp;v, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res = <a href="jsonb_util.c.html#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(&amp;state, r, r &lt; WJB_BEGIN_ARRAY ? &amp;v : <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(res != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_JSONB_P(<a href="jsonb_util.c.html#L92" title="utils/adt/jsonb_util.c:92">JsonbValueToJsonb</a>(res));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * SQL function <a href="#L4618" title="utils/adt/jsonfuncs.c:4618">jsonb_delete</a> (jsonb, variadic text[])<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * return a copy of the jsonb with the indicated items<br/></li>
<li></span><span class="Comment"> * removed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4671">&#x200c;</a><span class="linkable">jsonb_delete_array</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Jsonb&nbsp; &nbsp; &nbsp;&nbsp; *in = PG_GETARG_JSONB_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *keys = PG_GETARG_ARRAYTYPE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *keys_elems;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *keys_nulls;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keys_len;<br/></li>
<li>&nbsp; &nbsp; JsonbParseState *state = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; JsonbIterator *it;<br/></li>
<li>&nbsp; &nbsp; JsonbValue&nbsp; &nbsp; v,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *res = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; skipNested = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; JsonbIteratorToken r;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ARR_NDIM(keys) &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ARRAY_SUBSCRIPT_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;wrong number of array subscripts&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (JB_ROOT_IS_SCALAR(in))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot delete from scalar&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (JB_ROOT_COUNT(in) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_JSONB_P(in);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="arrayfuncs.c.html#L3678" title="utils/adt/arrayfuncs.c:3678">deconstruct_array_builtin</a>(keys, TEXTOID, &amp;keys_elems, &amp;keys_nulls, &amp;keys_len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (keys_len == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_JSONB_P(in);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; it = <a href="jsonb_util.c.html#L817" title="utils/adt/jsonb_util.c:817">JsonbIteratorInit</a>(&amp;in-&gt;root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((r = <a href="jsonb_util.c.html#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a>(&amp;it, &amp;v, skipNested)) != WJB_DONE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; skipNested = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((r == WJB_ELEM || r == WJB_KEY) &amp;&amp; v.type == jbvString)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; keys_len; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *keyptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keylen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (keys_nulls[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We rely on the array elements not being toasted */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keyptr = VARDATA_ANY(keys_elems[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keylen = VARSIZE_ANY_EXHDR(keys_elems[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (keylen == v.val.string.len &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcmp(keyptr, v.val.string.val, keylen) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> corresponding value as well */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (r == WJB_KEY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="jsonb_util.c.html#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a>(&amp;it, &amp;v, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res = <a href="jsonb_util.c.html#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(&amp;state, r, r &lt; WJB_BEGIN_ARRAY ? &amp;v : <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(res != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_JSONB_P(<a href="jsonb_util.c.html#L92" title="utils/adt/jsonb_util.c:92">JsonbValueToJsonb</a>(res));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * SQL function <a href="#L4618" title="utils/adt/jsonfuncs.c:4618">jsonb_delete</a> (jsonb, int)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * return a copy of the jsonb with the indicated item<br/></li>
<li></span><span class="Comment"> * removed. Negative int means count back from the<br/></li>
<li></span><span class="Comment"> * end of the items.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4758">&#x200c;</a><span class="linkable">jsonb_delete_idx</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Jsonb&nbsp; &nbsp; &nbsp;&nbsp; *in = PG_GETARG_JSONB_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idx = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; JsonbParseState *state = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; JsonbIterator *it;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; i = <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n;<br/></li>
<li>&nbsp; &nbsp; JsonbValue&nbsp; &nbsp; v,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *res = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; JsonbIteratorToken r;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (JB_ROOT_IS_SCALAR(in))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot delete from scalar&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (JB_ROOT_IS_OBJECT(in))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot delete from object using integer index&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (JB_ROOT_COUNT(in) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_JSONB_P(in);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; it = <a href="jsonb_util.c.html#L817" title="utils/adt/jsonb_util.c:817">JsonbIteratorInit</a>(&amp;in-&gt;root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; r = <a href="jsonb_util.c.html#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a>(&amp;it, &amp;v, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(r == WJB_BEGIN_ARRAY);<br/></li>
<li>&nbsp; &nbsp; n = v.val.array.nElems;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (idx &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (-idx &gt; n)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idx = n;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idx = n + idx;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (idx &gt;= n)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_JSONB_P(in);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="jsonb_util.c.html#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(&amp;state, r, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((r = <a href="jsonb_util.c.html#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a>(&amp;it, &amp;v, <span class="Constant">true</span>)) != WJB_DONE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (r == WJB_ELEM)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i++ == idx)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res = <a href="jsonb_util.c.html#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(&amp;state, r, r &lt; WJB_BEGIN_ARRAY ? &amp;v : <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(res != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_JSONB_P(<a href="jsonb_util.c.html#L92" title="utils/adt/jsonb_util.c:92">JsonbValueToJsonb</a>(res));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * SQL function <a href="#L4822" title="utils/adt/jsonfuncs.c:4822">jsonb_set</a>(jsonb, text[], jsonb, boolean)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4822">&#x200c;</a><span class="linkable">jsonb_set</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Jsonb&nbsp; &nbsp; &nbsp;&nbsp; *in = PG_GETARG_JSONB_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *path = PG_GETARG_ARRAYTYPE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Jsonb&nbsp; &nbsp; &nbsp;&nbsp; *newjsonb = PG_GETARG_JSONB_P(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; JsonbValue&nbsp; &nbsp; <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; create = PG_GETARG_BOOL(<span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; JsonbValue *res = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *path_elems;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *path_nulls;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path_len;<br/></li>
<li>&nbsp; &nbsp; JsonbIterator *it;<br/></li>
<li>&nbsp; &nbsp; JsonbParseState *st = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="jsonb_util.c.html#L72" title="utils/adt/jsonb_util.c:72">JsonbToJsonbValue</a>(newjsonb, &amp;<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ARR_NDIM(path) &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ARRAY_SUBSCRIPT_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;wrong number of array subscripts&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (JB_ROOT_IS_SCALAR(in))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot set path in scalar&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (JB_ROOT_COUNT(in) == <span class="Constant">0</span> &amp;&amp; !create)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_JSONB_P(in);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="arrayfuncs.c.html#L3678" title="utils/adt/arrayfuncs.c:3678">deconstruct_array_builtin</a>(path, TEXTOID, &amp;path_elems, &amp;path_nulls, &amp;path_len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (path_len == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_JSONB_P(in);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; it = <a href="jsonb_util.c.html#L817" title="utils/adt/jsonb_util.c:817">JsonbIteratorInit</a>(&amp;in-&gt;root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="#L5158" title="utils/adt/jsonfuncs.c:5158">setPath</a>(&amp;it, path_elems, path_nulls, path_len, &amp;st,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>, &amp;<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, create ? <a href="#L43" title="utils/adt/jsonfuncs.c:43">JB_PATH_CREATE</a> : <a href="#L45" title="utils/adt/jsonfuncs.c:45">JB_PATH_REPLACE</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(res != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_JSONB_P(<a href="jsonb_util.c.html#L92" title="utils/adt/jsonb_util.c:92">JsonbValueToJsonb</a>(res));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * SQL function <a href="#L4871" title="utils/adt/jsonfuncs.c:4871">jsonb_set_lax</a>(jsonb, text[], jsonb, boolean, text)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4871">&#x200c;</a><span class="linkable">jsonb_set_lax</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Jsonb&nbsp; &nbsp; &nbsp;&nbsp; *in = PG_GETARG_JSONB_P(0); */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* ArrayType&nbsp; *path = PG_GETARG_ARRAYTYPE_P(1); */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Jsonb&nbsp; &nbsp; &nbsp; *<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> = PG_GETARG_JSONB_P(2); */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* <a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a>&nbsp; &nbsp; &nbsp; &nbsp; create = PG_GETARG_BOOL(3); */<br/></li>
<li></span>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *handle_null;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *handle_val;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PG_ARGISNULL(<span class="Constant">0</span>) || PG_ARGISNULL(<span class="Constant">1</span>) || PG_ARGISNULL(<span class="Constant">3</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* could happen if they pass in an explicit NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PG_ARGISNULL(<span class="Constant">4</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;null_value_treatment must be </span><span class="Special">\&quot;</span><span class="Constant">delete_key</span><span class="Special">\&quot;</span><span class="Constant">, </span><span class="Special">\&quot;</span><span class="Constant">return_target</span><span class="Special">\&quot;</span><span class="Constant">, </span><span class="Special">\&quot;</span><span class="Constant">use_json_null</span><span class="Special">\&quot;</span><span class="Constant">, or </span><span class="Special">\&quot;</span><span class="Constant">raise_exception</span><span class="Special">\&quot;</span><span class="Constant">&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if the new value isn't an SQL NULL just call <a href="#L4822" title="utils/adt/jsonfuncs.c:4822">jsonb_set</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!PG_ARGISNULL(<span class="Constant">2</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L4822" title="utils/adt/jsonfuncs.c:4822">jsonb_set</a>(fcinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; handle_null = PG_GETARG_TEXT_P(<span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; handle_val = <a href="varlena.c.html#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>(handle_null);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (strcmp(handle_val, <span class="Constant">&quot;raise_exception&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NULL_VALUE_NOT_ALLOWED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;JSON value must not be null&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Exception was raised because null_value_treatment is </span><span class="Special">\&quot;</span><span class="Constant">raise_exception</span><span class="Special">\&quot;</span><span class="Constant">.&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;To avoid, either change the null_value_treatment argument or ensure that an SQL NULL is not passed.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Datum) <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* silence stupider compilers */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(handle_val, <span class="Constant">&quot;use_json_null&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> = DirectFunctionCall1(<a href="jsonb.c.html#L73" title="utils/adt/jsonb.c:73">jsonb_in</a>, CStringGetDatum(<span class="Constant">&quot;null&quot;</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">2</span>].value = <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">2</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L4822" title="utils/adt/jsonfuncs.c:4822">jsonb_set</a>(fcinfo);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(handle_val, <span class="Constant">&quot;delete_key&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L4938" title="utils/adt/jsonfuncs.c:4938">jsonb_delete_path</a>(fcinfo);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(handle_val, <span class="Constant">&quot;return_target&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Jsonb&nbsp; &nbsp; &nbsp;&nbsp; *in = PG_GETARG_JSONB_P(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_JSONB_P(in);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;null_value_treatment must be </span><span class="Special">\&quot;</span><span class="Constant">delete_key</span><span class="Special">\&quot;</span><span class="Constant">, </span><span class="Special">\&quot;</span><span class="Constant">return_target</span><span class="Special">\&quot;</span><span class="Constant">, </span><span class="Special">\&quot;</span><span class="Constant">use_json_null</span><span class="Special">\&quot;</span><span class="Constant">, or </span><span class="Special">\&quot;</span><span class="Constant">raise_exception</span><span class="Special">\&quot;</span><span class="Constant">&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Datum) <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* silence stupider compilers */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * SQL function <a href="#L4938" title="utils/adt/jsonfuncs.c:4938">jsonb_delete_path</a>(jsonb, text[])<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4938">&#x200c;</a><span class="linkable">jsonb_delete_path</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Jsonb&nbsp; &nbsp; &nbsp;&nbsp; *in = PG_GETARG_JSONB_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *path = PG_GETARG_ARRAYTYPE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; JsonbValue *res = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *path_elems;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *path_nulls;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path_len;<br/></li>
<li>&nbsp; &nbsp; JsonbIterator *it;<br/></li>
<li>&nbsp; &nbsp; JsonbParseState *st = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ARR_NDIM(path) &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ARRAY_SUBSCRIPT_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;wrong number of array subscripts&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (JB_ROOT_IS_SCALAR(in))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot delete path in scalar&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (JB_ROOT_COUNT(in) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_JSONB_P(in);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="arrayfuncs.c.html#L3678" title="utils/adt/arrayfuncs.c:3678">deconstruct_array_builtin</a>(path, TEXTOID, &amp;path_elems, &amp;path_nulls, &amp;path_len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (path_len == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_JSONB_P(in);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; it = <a href="jsonb_util.c.html#L817" title="utils/adt/jsonb_util.c:817">JsonbIteratorInit</a>(&amp;in-&gt;root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="#L5158" title="utils/adt/jsonfuncs.c:5158">setPath</a>(&amp;it, path_elems, path_nulls, path_len, &amp;st,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>, <span class="Constant">NULL</span>, <a href="#L44" title="utils/adt/jsonfuncs.c:44">JB_PATH_DELETE</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(res != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_JSONB_P(<a href="jsonb_util.c.html#L92" title="utils/adt/jsonb_util.c:92">JsonbValueToJsonb</a>(res));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * SQL function <a href="#L4981" title="utils/adt/jsonfuncs.c:4981">jsonb_insert</a>(jsonb, text[], jsonb, boolean)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4981">&#x200c;</a><span class="linkable">jsonb_insert</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Jsonb&nbsp; &nbsp; &nbsp;&nbsp; *in = PG_GETARG_JSONB_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *path = PG_GETARG_ARRAYTYPE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Jsonb&nbsp; &nbsp; &nbsp;&nbsp; *newjsonb = PG_GETARG_JSONB_P(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; JsonbValue&nbsp; &nbsp; <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; after = PG_GETARG_BOOL(<span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; JsonbValue *res = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *path_elems;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *path_nulls;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path_len;<br/></li>
<li>&nbsp; &nbsp; JsonbIterator *it;<br/></li>
<li>&nbsp; &nbsp; JsonbParseState *st = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="jsonb_util.c.html#L72" title="utils/adt/jsonb_util.c:72">JsonbToJsonbValue</a>(newjsonb, &amp;<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ARR_NDIM(path) &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ARRAY_SUBSCRIPT_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;wrong number of array subscripts&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (JB_ROOT_IS_SCALAR(in))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot set path in scalar&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="arrayfuncs.c.html#L3678" title="utils/adt/arrayfuncs.c:3678">deconstruct_array_builtin</a>(path, TEXTOID, &amp;path_elems, &amp;path_nulls, &amp;path_len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (path_len == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_JSONB_P(in);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; it = <a href="jsonb_util.c.html#L817" title="utils/adt/jsonb_util.c:817">JsonbIteratorInit</a>(&amp;in-&gt;root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="#L5158" title="utils/adt/jsonfuncs.c:5158">setPath</a>(&amp;it, path_elems, path_nulls, path_len, &amp;st, <span class="Constant">0</span>, &amp;<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; after ? <a href="#L47" title="utils/adt/jsonfuncs.c:47">JB_PATH_INSERT_AFTER</a> : <a href="#L46" title="utils/adt/jsonfuncs.c:46">JB_PATH_INSERT_BEFORE</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(res != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_JSONB_P(<a href="jsonb_util.c.html#L92" title="utils/adt/jsonb_util.c:92">JsonbValueToJsonb</a>(res));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Iterate over all jsonb objects and <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> them into one.<br/></li>
<li></span><span class="Comment"> * The logic of this function copied from the same hstore function,<br/></li>
<li></span><span class="Comment"> * except the case, when it1 &amp; it2 represents jbvObject.<br/></li>
<li></span><span class="Comment"> * In that case we just append the content of it2 to it1 without <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * verifications.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> JsonbValue *<br/></li>
<li><a id="L5030">&#x200c;</a><span class="linkable">IteratorConcat</span>(JsonbIterator **it1, JsonbIterator **it2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; JsonbParseState **state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JsonbValue&nbsp; &nbsp; v1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *res = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; JsonbIteratorToken r1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rk1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rk2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rk1 = <a href="jsonb_util.c.html#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a>(it1, &amp;v1, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; rk2 = <a href="jsonb_util.c.html#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a>(it2, &amp;v2, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="jsonb_util.c.html#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a> reports raw scalars as if they were single-<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * arrays; hence we only need consider &quot;object&quot; and &quot;array&quot; cases here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rk1 == WJB_BEGIN_OBJECT &amp;&amp; rk2 == WJB_BEGIN_OBJECT)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Both inputs are objects.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Append all the tokens from v1 to res, except last WJB_END_OBJECT<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (because res will not be finished yet).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="jsonb_util.c.html#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(state, rk1, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((r1 = <a href="jsonb_util.c.html#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a>(it1, &amp;v1, <span class="Constant">true</span>)) != WJB_END_OBJECT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="jsonb_util.c.html#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(state, r1, &amp;v1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Append all the tokens from v2 to res, including last WJB_END_OBJECT<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (the concatenation will be completed).&nbsp; Any duplicate keys will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * automatically override the value from the first object.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((r2 = <a href="jsonb_util.c.html#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a>(it2, &amp;v2, <span class="Constant">true</span>)) != WJB_DONE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <a href="jsonb_util.c.html#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(state, r2, r2 != WJB_END_OBJECT ? &amp;v2 : <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (rk1 == WJB_BEGIN_ARRAY &amp;&amp; rk2 == WJB_BEGIN_ARRAY)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Both inputs are arrays.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="jsonb_util.c.html#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(state, rk1, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((r1 = <a href="jsonb_util.c.html#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a>(it1, &amp;v1, <span class="Constant">true</span>)) != WJB_END_ARRAY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(r1 == WJB_ELEM);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="jsonb_util.c.html#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(state, r1, &amp;v1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((r2 = <a href="jsonb_util.c.html#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a>(it2, &amp;v2, <span class="Constant">true</span>)) != WJB_END_ARRAY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(r2 == WJB_ELEM);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="jsonb_util.c.html#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(state, WJB_ELEM, &amp;v2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res = <a href="jsonb_util.c.html#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(state, WJB_END_ARRAY, <span class="Constant">NULL</span> <span class="Comment">/* signal to sort */</span> );<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (rk1 == WJB_BEGIN_OBJECT)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have object || array.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(rk2 == WJB_BEGIN_ARRAY);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="jsonb_util.c.html#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(state, WJB_BEGIN_ARRAY, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="jsonb_util.c.html#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(state, WJB_BEGIN_OBJECT, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((r1 = <a href="jsonb_util.c.html#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a>(it1, &amp;v1, <span class="Constant">true</span>)) != WJB_DONE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="jsonb_util.c.html#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(state, r1, r1 != WJB_END_OBJECT ? &amp;v1 : <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((r2 = <a href="jsonb_util.c.html#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a>(it2, &amp;v2, <span class="Constant">true</span>)) != WJB_DONE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <a href="jsonb_util.c.html#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(state, r2, r2 != WJB_END_ARRAY ? &amp;v2 : <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have array || object.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(rk1 == WJB_BEGIN_ARRAY);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(rk2 == WJB_BEGIN_OBJECT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="jsonb_util.c.html#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(state, WJB_BEGIN_ARRAY, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((r1 = <a href="jsonb_util.c.html#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a>(it1, &amp;v1, <span class="Constant">true</span>)) != WJB_END_ARRAY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="jsonb_util.c.html#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(state, r1, &amp;v1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="jsonb_util.c.html#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(state, WJB_BEGIN_OBJECT, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((r2 = <a href="jsonb_util.c.html#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a>(it2, &amp;v2, <span class="Constant">true</span>)) != WJB_DONE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="jsonb_util.c.html#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(state, r2, r2 != WJB_END_OBJECT ? &amp;v2 : <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res = <a href="jsonb_util.c.html#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(state, WJB_END_ARRAY, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Do most of the heavy work for <a href="#L4822" title="utils/adt/jsonfuncs.c:4822">jsonb_set</a>/<a href="#L4981" title="utils/adt/jsonfuncs.c:4981">jsonb_insert</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If <a href="#L44" title="utils/adt/jsonfuncs.c:44">JB_PATH_DELETE</a> <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> is set in op_type, the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> is to be removed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> mentioned in <a href="#L48" title="utils/adt/jsonfuncs.c:48">JB_PATH_CREATE_OR_INSERT</a> is set in op_type,<br/></li>
<li></span><span class="Comment"> * we create the new value if the key or array index does not exist.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Bits <a href="#L46" title="utils/adt/jsonfuncs.c:46">JB_PATH_INSERT_BEFORE</a> and <a href="#L47" title="utils/adt/jsonfuncs.c:47">JB_PATH_INSERT_AFTER</a> in op_type<br/></li>
<li></span><span class="Comment"> * behave as <a href="#L43" title="utils/adt/jsonfuncs.c:43">JB_PATH_CREATE</a> if new value is inserted in JsonbObject.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If <a href="#L50" title="utils/adt/jsonfuncs.c:50">JB_PATH_FILL_GAPS</a> <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> is set, this will change an assignment logic in<br/></li>
<li></span><span class="Comment"> * case if target is an array. The assignment index will not be restricted by<br/></li>
<li></span><span class="Comment"> * number of elements in the array, and if there are <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> empty slots between<br/></li>
<li></span><span class="Comment"> * last <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> of the array and a new one they will be filled with nulls. If<br/></li>
<li></span><span class="Comment"> * the index is negative, it still will be considered an index from the end<br/></li>
<li></span><span class="Comment"> * of the array. Of a part of the path is not present and this part is more<br/></li>
<li></span><span class="Comment"> * than just one last <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>, this flag will instruct to create the whole<br/></li>
<li></span><span class="Comment"> * chain of corresponding objects and insert the value.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L51" title="utils/adt/jsonfuncs.c:51">JB_PATH_CONSISTENT_POSITION</a> for an array indicates that the caller wants to<br/></li>
<li></span><span class="Comment"> * keep <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> with fixed indices. Indices for existing elements could be<br/></li>
<li></span><span class="Comment"> * changed (shifted forward) in case if the array is prepended with a new value<br/></li>
<li></span><span class="Comment"> * and a negative index out of the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, so this behavior will be prevented<br/></li>
<li></span><span class="Comment"> * and return an error.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * All path elements <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the last must already exist<br/></li>
<li></span><span class="Comment"> * whatever bits in op_type are set, or nothing is done.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> JsonbValue *<br/></li>
<li><a id="L5158">&#x200c;</a><span class="linkable">setPath</span>(JsonbIterator **it, Datum *path_elems,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *path_nulls, <span class="Type">int</span> path_len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; JsonbParseState **st, <span class="Type">int</span> level, JsonbValue *<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">int</span> op_type)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JsonbValue&nbsp; &nbsp; v;<br/></li>
<li>&nbsp; &nbsp; JsonbIteratorToken r;<br/></li>
<li>&nbsp; &nbsp; JsonbValue *res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (path_nulls[level])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NULL_VALUE_NOT_ALLOWED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;path <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> at position </span><span class="Special">%d</span><span class="Constant"> is null&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; level + <span class="Constant">1</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; r = <a href="jsonb_util.c.html#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a>(it, &amp;v, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (r)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WJB_BEGIN_ARRAY:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If instructed complain about attempts to replace within a raw<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * scalar value. This happens even when current level is <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * path_len, because the last path key should also correspond to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * an object or an array, not raw scalar.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((op_type &amp; <a href="#L50" title="utils/adt/jsonfuncs.c:50">JB_PATH_FILL_GAPS</a>) &amp;&amp; (level &lt;= path_len - <span class="Constant">1</span>) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v.val.array.rawScalar)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot replace existing key&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;The path assumes key is a composite object, &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;but it is a scalar value.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="jsonb_util.c.html#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(st, r, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5379" title="utils/adt/jsonfuncs.c:5379">setPathArray</a>(it, path_elems, path_nulls, path_len, st, level,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, v.val.array.nElems, op_type);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r = <a href="jsonb_util.c.html#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a>(it, &amp;v, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(r == WJB_END_ARRAY);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <a href="jsonb_util.c.html#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(st, r, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WJB_BEGIN_OBJECT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="jsonb_util.c.html#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(st, r, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5240" title="utils/adt/jsonfuncs.c:5240">setPathObject</a>(it, path_elems, path_nulls, path_len, st, level,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, v.val.object.nPairs, op_type);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r = <a href="jsonb_util.c.html#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a>(it, &amp;v, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(r == WJB_END_OBJECT);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <a href="jsonb_util.c.html#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(st, r, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WJB_ELEM:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WJB_VALUE:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If instructed complain about attempts to replace within a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * scalar value. This happens even when current level is <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * path_len, because the last path key should also correspond to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * an object or an array, not an <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> or value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((op_type &amp; <a href="#L50" title="utils/adt/jsonfuncs.c:50">JB_PATH_FILL_GAPS</a>) &amp;&amp; (level &lt;= path_len - <span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot replace existing key&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;The path assumes key is a composite object, &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;but it is a scalar value.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <a href="jsonb_util.c.html#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(st, r, &amp;v);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized iterator result: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, (<span class="Type">int</span>) r);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Object walker for <a href="#L5158" title="utils/adt/jsonfuncs.c:5158">setPath</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L5240">&#x200c;</a></span><span class="linkable">setPathObject</span>(JsonbIterator **it, Datum *path_elems, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *path_nulls,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> path_len, JsonbParseState **st, <span class="Type">int</span> level,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JsonbValue *<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, uint32 npairs, <span class="Type">int</span> op_type)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *pathelem = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; JsonbValue&nbsp; &nbsp; k,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; done = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (level &gt;= path_len || path_nulls[level])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; done = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The path Datum could be toasted, in which case we must detoast it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pathelem = DatumGetTextPP(path_elems[level]);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* empty object is a special case for create */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((npairs == <span class="Constant">0</span>) &amp;&amp; (op_type &amp; <a href="#L48" title="utils/adt/jsonfuncs.c:48">JB_PATH_CREATE_OR_INSERT</a>) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (level == path_len - <span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; JsonbValue&nbsp; &nbsp; newkey;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newkey.type = jbvString;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newkey.val.string.val = VARDATA_ANY(pathelem);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newkey.val.string.len = VARSIZE_ANY_EXHDR(pathelem);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="jsonb_util.c.html#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(st, WJB_KEY, &amp;newkey);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="jsonb_util.c.html#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(st, WJB_VALUE, <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; npairs; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; JsonbIteratorToken r = <a href="jsonb_util.c.html#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a>(it, &amp;k, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(r == WJB_KEY);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!done &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; k.val.string.len == VARSIZE_ANY_EXHDR(pathelem) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcmp(k.val.string.val, VARDATA_ANY(pathelem),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; k.val.string.len) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; done = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (level == path_len - <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * called from <a href="#L4981" title="utils/adt/jsonfuncs.c:4981">jsonb_insert</a>(), it forbids redefining an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * existing value<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (op_type &amp; (<a href="#L46" title="utils/adt/jsonfuncs.c:46">JB_PATH_INSERT_BEFORE</a> | <a href="#L47" title="utils/adt/jsonfuncs.c:47">JB_PATH_INSERT_AFTER</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot replace existing key&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Try using the function <a href="#L4822" title="utils/adt/jsonfuncs.c:4822">jsonb_set</a> &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;to replace key value.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r = <a href="jsonb_util.c.html#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a>(it, &amp;v, <span class="Constant">true</span>);&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!(op_type &amp; <a href="#L44" title="utils/adt/jsonfuncs.c:44">JB_PATH_DELETE</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="jsonb_util.c.html#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(st, WJB_KEY, &amp;k);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="jsonb_util.c.html#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(st, WJB_VALUE, <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="jsonb_util.c.html#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(st, r, &amp;k);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5158" title="utils/adt/jsonfuncs.c:5158">setPath</a>(it, path_elems, path_nulls, path_len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; st, level + <span class="Constant">1</span>, <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, op_type);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((op_type &amp; <a href="#L48" title="utils/adt/jsonfuncs.c:48">JB_PATH_CREATE_OR_INSERT</a>) &amp;&amp; !done &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; level == path_len - <span class="Constant">1</span> &amp;&amp; i == npairs - <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JsonbValue&nbsp; &nbsp; newkey;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newkey.type = jbvString;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newkey.val.string.val = VARDATA_ANY(pathelem);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newkey.val.string.len = VARSIZE_ANY_EXHDR(pathelem);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="jsonb_util.c.html#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(st, WJB_KEY, &amp;newkey);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="jsonb_util.c.html#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(st, WJB_VALUE, <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="jsonb_util.c.html#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(st, r, &amp;k);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r = <a href="jsonb_util.c.html#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a>(it, &amp;v, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="jsonb_util.c.html#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(st, r, r &lt; WJB_BEGIN_ARRAY ? &amp;v : <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (r == WJB_BEGIN_ARRAY || r == WJB_BEGIN_OBJECT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; walking_level = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (walking_level != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r = <a href="jsonb_util.c.html#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a>(it, &amp;v, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (r == WJB_BEGIN_ARRAY || r == WJB_BEGIN_OBJECT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ++walking_level;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (r == WJB_END_ARRAY || r == WJB_END_OBJECT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; --walking_level;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="jsonb_util.c.html#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(st, r, r &lt; WJB_BEGIN_ARRAY ? &amp;v : <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*--<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we got here there are only few possibilities:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * - no target path was found, and an open object with some keys/<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> was<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp;&nbsp; pushed into the state<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * - an object is empty, only WJB_BEGIN_OBJECT is pushed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In both cases if instructed to create the path when not present,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * generate the whole chain of empty objects and insert the new value<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!done &amp;&amp; (op_type &amp; <a href="#L50" title="utils/adt/jsonfuncs.c:50">JB_PATH_FILL_GAPS</a>) &amp;&amp; (level &lt; path_len - <span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; JsonbValue&nbsp; &nbsp; newkey;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newkey.type = jbvString;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newkey.val.string.val = VARDATA_ANY(pathelem);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newkey.val.string.len = VARSIZE_ANY_EXHDR(pathelem);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="jsonb_util.c.html#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(st, WJB_KEY, &amp;newkey);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L1718" title="utils/adt/jsonfuncs.c:1718">push_path</a>(st, level, path_elems, path_nulls,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; path_len, <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Result is closed with WJB_END_OBJECT outside of this function */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Array walker for <a href="#L5158" title="utils/adt/jsonfuncs.c:5158">setPath</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L5379">&#x200c;</a></span><span class="linkable">setPathArray</span>(JsonbIterator **it, Datum *path_elems, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *path_nulls,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> path_len, JsonbParseState **st, <span class="Type">int</span> level,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; JsonbValue *<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, uint32 nelems, <span class="Type">int</span> op_type)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JsonbValue&nbsp; &nbsp; v;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; done = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* pick correct index */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (level &lt; path_len &amp;&amp; !path_nulls[level])<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *c = TextDatumGetCString(path_elems[level]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *badp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; idx = strtoint(c, &amp;badp, <span class="Constant">10</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (badp == c || *badp != <span class="Special">'\0'</span> || errno != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;path <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> at position </span><span class="Special">%d</span><span class="Constant"> is not an integer: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; level + <span class="Constant">1</span>, c)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; idx = nelems;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (idx &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (-idx &gt; nelems)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If asked to keep elements position consistent, it's not allowed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to prepend the array.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (op_type &amp; <a href="#L51" title="utils/adt/jsonfuncs.c:51">JB_PATH_CONSISTENT_POSITION</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;path <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> at position </span><span class="Special">%d</span><span class="Constant"> is out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; level + <span class="Constant">1</span>, idx)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idx = <span class="Constant">INT_MIN</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idx = nelems + idx;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Filling the gaps means there are no limits on the positive index are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * imposed, we can set <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>. Otherwise limit the index by nelems.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!(op_type &amp; <a href="#L50" title="utils/adt/jsonfuncs.c:50">JB_PATH_FILL_GAPS</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (idx &gt; <span class="Constant">0</span> &amp;&amp; idx &gt; nelems)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idx = nelems;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if we're creating, and idx == INT_MIN, we prepend the new value to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * array also if the array is empty - in which case we don't really care<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * what the idx value is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((idx == <span class="Constant">INT_MIN</span> || nelems == <span class="Constant">0</span>) &amp;&amp; (level == path_len - <span class="Constant">1</span>) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (op_type &amp; <a href="#L48" title="utils/adt/jsonfuncs.c:48">JB_PATH_CREATE_OR_INSERT</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (op_type &amp; <a href="#L50" title="utils/adt/jsonfuncs.c:50">JB_PATH_FILL_GAPS</a> &amp;&amp; nelems == <span class="Constant">0</span> &amp;&amp; idx &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1699" title="utils/adt/jsonfuncs.c:1699">push_null_elements</a>(st, idx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="jsonb_util.c.html#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(st, WJB_ELEM, <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; done = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* iterate over the array elements */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nelems; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; JsonbIteratorToken r;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i == idx &amp;&amp; level &lt; path_len)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; done = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (level == path_len - <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r = <a href="jsonb_util.c.html#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a>(it, &amp;v, <span class="Constant">true</span>);&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (op_type &amp; (<a href="#L46" title="utils/adt/jsonfuncs.c:46">JB_PATH_INSERT_BEFORE</a> | <a href="#L43" title="utils/adt/jsonfuncs.c:43">JB_PATH_CREATE</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="jsonb_util.c.html#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(st, WJB_ELEM, <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We should keep current value only in case of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L46" title="utils/adt/jsonfuncs.c:46">JB_PATH_INSERT_BEFORE</a> or <a href="#L47" title="utils/adt/jsonfuncs.c:47">JB_PATH_INSERT_AFTER</a> because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * otherwise it should be deleted or replaced<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (op_type &amp; (<a href="#L47" title="utils/adt/jsonfuncs.c:47">JB_PATH_INSERT_AFTER</a> | <a href="#L46" title="utils/adt/jsonfuncs.c:46">JB_PATH_INSERT_BEFORE</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="jsonb_util.c.html#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(st, r, &amp;v);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (op_type &amp; (<a href="#L47" title="utils/adt/jsonfuncs.c:47">JB_PATH_INSERT_AFTER</a> | <a href="#L45" title="utils/adt/jsonfuncs.c:45">JB_PATH_REPLACE</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="jsonb_util.c.html#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(st, WJB_ELEM, <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L5158" title="utils/adt/jsonfuncs.c:5158">setPath</a>(it, path_elems, path_nulls, path_len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; st, level + <span class="Constant">1</span>, <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, op_type);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r = <a href="jsonb_util.c.html#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a>(it, &amp;v, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="jsonb_util.c.html#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(st, r, r &lt; WJB_BEGIN_ARRAY ? &amp;v : <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (r == WJB_BEGIN_ARRAY || r == WJB_BEGIN_OBJECT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; walking_level = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (walking_level != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r = <a href="jsonb_util.c.html#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a>(it, &amp;v, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (r == WJB_BEGIN_ARRAY || r == WJB_BEGIN_OBJECT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ++walking_level;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (r == WJB_END_ARRAY || r == WJB_END_OBJECT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; --walking_level;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="jsonb_util.c.html#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(st, r, r &lt; WJB_BEGIN_ARRAY ? &amp;v : <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((op_type &amp; <a href="#L48" title="utils/adt/jsonfuncs.c:48">JB_PATH_CREATE_OR_INSERT</a>) &amp;&amp; !done &amp;&amp; level == path_len - <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If asked to fill the gaps, idx could be bigger than nelems, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * prepend the new <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> with nulls if that's the case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (op_type &amp; <a href="#L50" title="utils/adt/jsonfuncs.c:50">JB_PATH_FILL_GAPS</a> &amp;&amp; idx &gt; nelems)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1699" title="utils/adt/jsonfuncs.c:1699">push_null_elements</a>(st, idx - nelems);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="jsonb_util.c.html#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(st, WJB_ELEM, <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; done = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*--<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we got here there are only few possibilities:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * - no target path was found, and an open array with some keys/<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> was<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp;&nbsp; pushed into the state<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * - an array is empty, only WJB_BEGIN_ARRAY is pushed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In both cases if instructed to create the path when not present,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * generate the whole chain of empty objects and insert the new value<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!done &amp;&amp; (op_type &amp; <a href="#L50" title="utils/adt/jsonfuncs.c:50">JB_PATH_FILL_GAPS</a>) &amp;&amp; (level &lt; path_len - <span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (idx &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1699" title="utils/adt/jsonfuncs.c:1699">push_null_elements</a>(st, idx - nelems);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L1718" title="utils/adt/jsonfuncs.c:1718">push_path</a>(st, level, path_elems, path_nulls,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; path_len, <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Result is closed with WJB_END_OBJECT outside of this function */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Parse information about what elements of a jsonb document we want to iterate<br/></li>
<li></span><span class="Comment"> * in <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> iterate_json(b)_values. This information is presented in jsonb<br/></li>
<li></span><span class="Comment"> * format, so that it can be easily extended in the future.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>uint32<br/></li>
<li><a id="L5550">&#x200c;</a><span class="linkable">parse_jsonb_index_flags</span>(Jsonb *jb)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JsonbIterator *it;<br/></li>
<li>&nbsp; &nbsp; JsonbValue&nbsp; &nbsp; v;<br/></li>
<li>&nbsp; &nbsp; JsonbIteratorToken type;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; flags = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; it = <a href="jsonb_util.c.html#L817" title="utils/adt/jsonb_util.c:817">JsonbIteratorInit</a>(&amp;jb-&gt;root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; type = <a href="jsonb_util.c.html#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a>(&amp;it, &amp;v, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We iterate over array (scalar internally is represented as array, so,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we will <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> it too) to check all its elements.&nbsp; Flag names are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * chosen the same as <a href="jsonb.c.html#L229" title="utils/adt/jsonb.c:229">jsonb_typeof</a> uses.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (type != WJB_BEGIN_ARRAY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR, (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;wrong flag type, only arrays and scalars are allowed&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((type = <a href="jsonb_util.c.html#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a>(&amp;it, &amp;v, <span class="Constant">false</span>)) == WJB_ELEM)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (v.type != jbvString)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;flag array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> is not a string&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Possible <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are: </span><span class="Special">\&quot;</span><span class="Constant">string</span><span class="Special">\&quot;</span><span class="Constant">, </span><span class="Special">\&quot;</span><span class="Constant"><a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a></span><span class="Special">\&quot;</span><span class="Constant">, </span><span class="Special">\&quot;</span><span class="Constant">boolean</span><span class="Special">\&quot;</span><span class="Constant">, </span><span class="Special">\&quot;</span><span class="Constant">key</span><span class="Special">\&quot;</span><span class="Constant">, and </span><span class="Special">\&quot;</span><span class="Constant">all</span><span class="Special">\&quot;</span><span class="Constant">.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (v.val.string.len == <span class="Constant">3</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_strncasecmp(v.val.string.val, <span class="Constant">&quot;all&quot;</span>, <span class="Constant">3</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags |= jtiAll;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (v.val.string.len == <span class="Constant">3</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pg_strncasecmp(v.val.string.val, <span class="Constant">&quot;key&quot;</span>, <span class="Constant">3</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags |= jtiKey;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (v.val.string.len == <span class="Constant">6</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pg_strncasecmp(v.val.string.val, <span class="Constant">&quot;string&quot;</span>, <span class="Constant">6</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags |= jtiString;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (v.val.string.len == <span class="Constant">7</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pg_strncasecmp(v.val.string.val, <span class="Constant">&quot;<a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a>&quot;</span>, <span class="Constant">7</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags |= jtiNumeric;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (v.val.string.len == <span class="Constant">7</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pg_strncasecmp(v.val.string.val, <span class="Constant">&quot;boolean&quot;</span>, <span class="Constant">7</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags |= jtiBool;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;wrong flag in flag array: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1706" title="utils/mmgr/mcxt.c:1706">pnstrdup</a>(v.val.string.val, v.val.string.len)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Possible <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are: </span><span class="Special">\&quot;</span><span class="Constant">string</span><span class="Special">\&quot;</span><span class="Constant">, </span><span class="Special">\&quot;</span><span class="Constant"><a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a></span><span class="Special">\&quot;</span><span class="Constant">, </span><span class="Special">\&quot;</span><span class="Constant">boolean</span><span class="Special">\&quot;</span><span class="Constant">, </span><span class="Special">\&quot;</span><span class="Constant">key</span><span class="Special">\&quot;</span><span class="Constant">, and </span><span class="Special">\&quot;</span><span class="Constant">all</span><span class="Special">\&quot;</span><span class="Constant">.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* expect end of array <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (type != WJB_END_ARRAY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected end of flag array&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* get final WJB_DONE and free iterator */<br/></li>
<li></span>&nbsp; &nbsp; type = <a href="jsonb_util.c.html#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a>(&amp;it, &amp;v, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (type != WJB_DONE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected end of flag array&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> flags;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Iterate over jsonb <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> or elements, specified by flags, and pass them<br/></li>
<li></span><span class="Comment"> * together with an iteration state to a specified JsonIterateStringValuesAction.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L5618">&#x200c;</a></span><span class="linkable">iterate_jsonb_values</span>(Jsonb *jb, uint32 flags, <span class="Type">void</span> *state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; JsonIterateStringValuesAction action)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JsonbIterator *it;<br/></li>
<li>&nbsp; &nbsp; JsonbValue&nbsp; &nbsp; v;<br/></li>
<li>&nbsp; &nbsp; JsonbIteratorToken type;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; it = <a href="jsonb_util.c.html#L817" title="utils/adt/jsonb_util.c:817">JsonbIteratorInit</a>(&amp;jb-&gt;root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Just recursively iterating over jsonb and call callback on all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * corresponding elements<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> ((type = <a href="jsonb_util.c.html#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a>(&amp;it, &amp;v, <span class="Constant">false</span>)) != WJB_DONE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (type == WJB_KEY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (flags &amp; jtiKey)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; action(state, v.val.string.val, v.val.string.len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!(type == WJB_VALUE || type == WJB_ELEM))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* do not call callback for composite JsonbValue */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* JsonbValue is a value of object or <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> of array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (v.type)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jbvString:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (flags &amp; jtiString)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; action(state, v.val.string.val, v.val.string.len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jbvNumeric:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (flags &amp; jtiNumeric)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *val;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val = DatumGetCString(DirectFunctionCall1(<a href="numeric.c.html#L807" title="utils/adt/numeric.c:807">numeric_out</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NumericGetDatum(v.val.<a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; action(state, val, strlen(val));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(val);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jbvBool:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (flags &amp; jtiBool)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (v.val.boolean)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; action(state, <span class="Constant">&quot;true&quot;</span>, <span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; action(state, <span class="Constant">&quot;false&quot;</span>, <span class="Constant">5</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* do not call callback for composite JsonbValue */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Iterate over json <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> and elements, specified by flags, and pass them<br/></li>
<li></span><span class="Comment"> * together with an iteration state to a specified JsonIterateStringValuesAction.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L5686">&#x200c;</a></span><span class="linkable">iterate_json_values</span>(text *json, uint32 flags, <span class="Type">void</span> *action_state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JsonIterateStringValuesAction action)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JsonLexContext lex;<br/></li>
<li>&nbsp; &nbsp; JsonSemAction *sem = <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(JsonSemAction));<br/></li>
<li>&nbsp; &nbsp; <a href="#L64" title="utils/adt/jsonfuncs.c:64">IterateJsonStringValuesState</a> *state = <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L64" title="utils/adt/jsonfuncs.c:64">IterateJsonStringValuesState</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;lex = <a href="#L537" title="utils/adt/jsonfuncs.c:537">makeJsonLexContext</a>(&amp;lex, json, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; state-&gt;action = action;<br/></li>
<li>&nbsp; &nbsp; state-&gt;action_state = action_state;<br/></li>
<li>&nbsp; &nbsp; state-&gt;flags = flags;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sem-&gt;semstate = (<span class="Type">void</span> *) state;<br/></li>
<li>&nbsp; &nbsp; sem-&gt;scalar = <a href="#L5711" title="utils/adt/jsonfuncs.c:5711">iterate_values_scalar</a>;<br/></li>
<li>&nbsp; &nbsp; sem-&gt;object_field_start = <a href="#L5739" title="utils/adt/jsonfuncs.c:5739">iterate_values_object_field_start</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pg_parse_json_or_ereport(&amp;lex, sem);<br/></li>
<li>&nbsp; &nbsp; freeJsonLexContext(&amp;lex);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * An auxiliary function for <a href="#L5686" title="utils/adt/jsonfuncs.c:5686">iterate_json_values</a> to invoke a specified<br/></li>
<li></span><span class="Comment"> * JsonIterateStringValuesAction for specified <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> JsonParseErrorType<br/></li>
<li><a id="L5711">&#x200c;</a><span class="linkable">iterate_values_scalar</span>(<span class="Type">void</span> *state, <span class="Type">char</span> *token, JsonTokenType tokentype)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L64" title="utils/adt/jsonfuncs.c:64">IterateJsonStringValuesState</a> *_state = (<a href="#L64" title="utils/adt/jsonfuncs.c:64">IterateJsonStringValuesState</a> *) state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (tokentype)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JSON_TOKEN_STRING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (_state-&gt;flags &amp; jtiString)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;action(_state-&gt;action_state, token, strlen(token));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JSON_TOKEN_NUMBER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (_state-&gt;flags &amp; jtiNumeric)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;action(_state-&gt;action_state, token, strlen(token));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JSON_TOKEN_TRUE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JSON_TOKEN_FALSE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (_state-&gt;flags &amp; jtiBool)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;action(_state-&gt;action_state, token, strlen(token));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* do not call callback for <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other token */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> JsonParseErrorType<br/></li>
<li><a id="L5739">&#x200c;</a><span class="linkable">iterate_values_object_field_start</span>(<span class="Type">void</span> *state, <span class="Type">char</span> *fname, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L64" title="utils/adt/jsonfuncs.c:64">IterateJsonStringValuesState</a> *_state = (<a href="#L64" title="utils/adt/jsonfuncs.c:64">IterateJsonStringValuesState</a> *) state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (_state-&gt;flags &amp; jtiKey)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *val = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(fname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; _state-&gt;action(_state-&gt;action_state, val, strlen(val));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Iterate over a jsonb, and apply a specified JsonTransformStringValuesAction<br/></li>
<li></span><span class="Comment"> * to every string value or <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>. Any necessary context for a<br/></li>
<li></span><span class="Comment"> * JsonTransformStringValuesAction can be passed in the action_state variable.<br/></li>
<li></span><span class="Comment"> * Function returns a copy of an original jsonb object with transformed <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Jsonb *<br/></li>
<li><a id="L5760">&#x200c;</a><span class="linkable">transform_jsonb_string_values</span>(Jsonb *jsonb, <span class="Type">void</span> *action_state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JsonTransformStringValuesAction transform_action)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JsonbIterator *it;<br/></li>
<li>&nbsp; &nbsp; JsonbValue&nbsp; &nbsp; v,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *res = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; JsonbIteratorToken type;<br/></li>
<li>&nbsp; &nbsp; JsonbParseState *st = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *out;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_scalar = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; it = <a href="jsonb_util.c.html#L817" title="utils/adt/jsonb_util.c:817">JsonbIteratorInit</a>(&amp;jsonb-&gt;root);<br/></li>
<li>&nbsp; &nbsp; is_scalar = it-&gt;isScalar;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((type = <a href="jsonb_util.c.html#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a>(&amp;it, &amp;v, <span class="Constant">false</span>)) != WJB_DONE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((type == WJB_VALUE || type == WJB_ELEM) &amp;&amp; v.type == jbvString)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; out = transform_action(action_state, v.val.string.val, v.val.string.len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* out is probably not toasted, but let's be sure */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; out = <a href="../fmgr/fmgr.c.html#L1864" title="utils/fmgr/fmgr.c:1864">pg_detoast_datum_packed</a>(out);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v.val.string.val = VARDATA_ANY(out);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v.val.string.len = VARSIZE_ANY_EXHDR(out);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <a href="jsonb_util.c.html#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(&amp;st, type, type &lt; WJB_BEGIN_ARRAY ? &amp;v : <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <a href="jsonb_util.c.html#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(&amp;st, type, (type == WJB_KEY ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; type == WJB_VALUE ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; type == WJB_ELEM) ? &amp;v : <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (res-&gt;type == jbvArray)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res-&gt;val.array.rawScalar = is_scalar;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="jsonb_util.c.html#L92" title="utils/adt/jsonb_util.c:92">JsonbValueToJsonb</a>(res);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Iterate over a json, and apply a specified JsonTransformStringValuesAction<br/></li>
<li></span><span class="Comment"> * to every string value or <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>. Any necessary context for a<br/></li>
<li></span><span class="Comment"> * JsonTransformStringValuesAction can be passed in the action_state variable.<br/></li>
<li></span><span class="Comment"> * Function returns a StringInfo, which is a copy of an original json with<br/></li>
<li></span><span class="Comment"> * transformed <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>text *<br/></li>
<li><a id="L5807">&#x200c;</a><span class="linkable">transform_json_string_values</span>(text *json, <span class="Type">void</span> *action_state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; JsonTransformStringValuesAction transform_action)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JsonLexContext lex;<br/></li>
<li>&nbsp; &nbsp; JsonSemAction *sem = <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(JsonSemAction));<br/></li>
<li>&nbsp; &nbsp; <a href="#L75" title="utils/adt/jsonfuncs.c:75">TransformJsonStringValuesState</a> *state = <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L75" title="utils/adt/jsonfuncs.c:75">TransformJsonStringValuesState</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;lex = <a href="#L537" title="utils/adt/jsonfuncs.c:537">makeJsonLexContext</a>(&amp;lex, json, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; state-&gt;strval = makeStringInfo();<br/></li>
<li>&nbsp; &nbsp; state-&gt;action = transform_action;<br/></li>
<li>&nbsp; &nbsp; state-&gt;action_state = action_state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sem-&gt;semstate = (<span class="Type">void</span> *) state;<br/></li>
<li>&nbsp; &nbsp; sem-&gt;object_start = <a href="#L5840" title="utils/adt/jsonfuncs.c:5840">transform_string_values_object_start</a>;<br/></li>
<li>&nbsp; &nbsp; sem-&gt;object_end = <a href="#L5850" title="utils/adt/jsonfuncs.c:5850">transform_string_values_object_end</a>;<br/></li>
<li>&nbsp; &nbsp; sem-&gt;array_start = <a href="#L5860" title="utils/adt/jsonfuncs.c:5860">transform_string_values_array_start</a>;<br/></li>
<li>&nbsp; &nbsp; sem-&gt;array_end = <a href="#L5870" title="utils/adt/jsonfuncs.c:5870">transform_string_values_array_end</a>;<br/></li>
<li>&nbsp; &nbsp; sem-&gt;scalar = <a href="#L5909" title="utils/adt/jsonfuncs.c:5909">transform_string_values_scalar</a>;<br/></li>
<li>&nbsp; &nbsp; sem-&gt;array_element_start = <a href="#L5898" title="utils/adt/jsonfuncs.c:5898">transform_string_values_array_element_start</a>;<br/></li>
<li>&nbsp; &nbsp; sem-&gt;object_field_start = <a href="#L5880" title="utils/adt/jsonfuncs.c:5880">transform_string_values_object_field_start</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pg_parse_json_or_ereport(&amp;lex, sem);<br/></li>
<li>&nbsp; &nbsp; freeJsonLexContext(&amp;lex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="varlena.c.html#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(state-&gt;strval-&gt;data, state-&gt;strval-&gt;len);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Set of auxiliary <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for <a href="#L5807" title="utils/adt/jsonfuncs.c:5807">transform_json_string_values</a> to invoke a<br/></li>
<li></span><span class="Comment"> * specified JsonTransformStringValuesAction for all <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> and left everything<br/></li>
<li></span><span class="Comment"> * else untouched.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> JsonParseErrorType<br/></li>
<li><a id="L5840">&#x200c;</a><span class="linkable">transform_string_values_object_start</span>(<span class="Type">void</span> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L75" title="utils/adt/jsonfuncs.c:75">TransformJsonStringValuesState</a> *_state = (<a href="#L75" title="utils/adt/jsonfuncs.c:75">TransformJsonStringValuesState</a> *) state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfoCharMacro(_state-&gt;strval, <span class="Constant">'{'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> JsonParseErrorType<br/></li>
<li><a id="L5850">&#x200c;</a><span class="linkable">transform_string_values_object_end</span>(<span class="Type">void</span> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L75" title="utils/adt/jsonfuncs.c:75">TransformJsonStringValuesState</a> *_state = (<a href="#L75" title="utils/adt/jsonfuncs.c:75">TransformJsonStringValuesState</a> *) state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfoCharMacro(_state-&gt;strval, <span class="Constant">'}'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> JsonParseErrorType<br/></li>
<li><a id="L5860">&#x200c;</a><span class="linkable">transform_string_values_array_start</span>(<span class="Type">void</span> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L75" title="utils/adt/jsonfuncs.c:75">TransformJsonStringValuesState</a> *_state = (<a href="#L75" title="utils/adt/jsonfuncs.c:75">TransformJsonStringValuesState</a> *) state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfoCharMacro(_state-&gt;strval, <span class="Constant">'['</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> JsonParseErrorType<br/></li>
<li><a id="L5870">&#x200c;</a><span class="linkable">transform_string_values_array_end</span>(<span class="Type">void</span> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L75" title="utils/adt/jsonfuncs.c:75">TransformJsonStringValuesState</a> *_state = (<a href="#L75" title="utils/adt/jsonfuncs.c:75">TransformJsonStringValuesState</a> *) state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfoCharMacro(_state-&gt;strval, <span class="Constant">']'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> JsonParseErrorType<br/></li>
<li><a id="L5880">&#x200c;</a><span class="linkable">transform_string_values_object_field_start</span>(<span class="Type">void</span> *state, <span class="Type">char</span> *fname, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L75" title="utils/adt/jsonfuncs.c:75">TransformJsonStringValuesState</a> *_state = (<a href="#L75" title="utils/adt/jsonfuncs.c:75">TransformJsonStringValuesState</a> *) state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (_state-&gt;strval-&gt;data[_state-&gt;strval-&gt;len - <span class="Constant">1</span>] != <span class="Constant">'{'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoCharMacro(_state-&gt;strval, <span class="Constant">','</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Unfortunately we don't have the quoted and escaped string <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> more, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we have to re-escape it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="json.c.html#L1549" title="utils/adt/json.c:1549">escape_json</a>(_state-&gt;strval, fname);<br/></li>
<li>&nbsp; &nbsp; appendStringInfoCharMacro(_state-&gt;strval, <span class="Constant">':'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> JsonParseErrorType<br/></li>
<li><a id="L5898">&#x200c;</a><span class="linkable">transform_string_values_array_element_start</span>(<span class="Type">void</span> *state, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L75" title="utils/adt/jsonfuncs.c:75">TransformJsonStringValuesState</a> *_state = (<a href="#L75" title="utils/adt/jsonfuncs.c:75">TransformJsonStringValuesState</a> *) state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (_state-&gt;strval-&gt;data[_state-&gt;strval-&gt;len - <span class="Constant">1</span>] != <span class="Constant">'['</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoCharMacro(_state-&gt;strval, <span class="Constant">','</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> JsonParseErrorType<br/></li>
<li><a id="L5909">&#x200c;</a><span class="linkable">transform_string_values_scalar</span>(<span class="Type">void</span> *state, <span class="Type">char</span> *token, JsonTokenType tokentype)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L75" title="utils/adt/jsonfuncs.c:75">TransformJsonStringValuesState</a> *_state = (<a href="#L75" title="utils/adt/jsonfuncs.c:75">TransformJsonStringValuesState</a> *) state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tokentype == JSON_TOKEN_STRING)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *out = _state-&gt;action(_state-&gt;action_state, token, strlen(token));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="json.c.html#L1549" title="utils/adt/json.c:1549">escape_json</a>(_state-&gt;strval, <a href="varlena.c.html#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>(out));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(_state-&gt;strval, token);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>JsonTokenType<br/></li>
<li><a id="L5926">&#x200c;</a><span class="linkable">json_get_first_token</span>(text *json, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> throw_error)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JsonLexContext lex;<br/></li>
<li>&nbsp; &nbsp; JsonParseErrorType result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L537" title="utils/adt/jsonfuncs.c:537">makeJsonLexContext</a>(&amp;lex, json, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Lex exactly one token from the input and check its type. */<br/></li>
<li></span>&nbsp; &nbsp; result = json_lex(&amp;lex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result == JSON_SUCCESS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> lex.token_type;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (throw_error)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L638" title="utils/adt/jsonfuncs.c:638">json_errsave_error</a>(result, &amp;lex, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> JSON_TOKEN_INVALID;&nbsp; &nbsp; <span class="Comment">/* invalid json */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Determine how we want to <a href="../../nodes/print.c.html#L36" title="nodes/print.c:36">print</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of a given type in <a href="json.c.html#L754" title="utils/adt/json.c:754">datum_to_json</a>(b).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Given the datatype OID, return its JsonTypeCategory, as well as the type's<br/></li>
<li></span><span class="Comment"> * output function OID.&nbsp; If the returned category is JSONTYPE_CAST, we return<br/></li>
<li></span><span class="Comment"> * the OID of the type-&gt;JSON cast function instead.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L5953">&#x200c;</a></span><span class="linkable">json_categorize_type</span>(Oid typoid, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_jsonb,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; JsonTypeCategory *tcategory, Oid *outfuncoid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; typisvarlena;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Look through <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> domain */<br/></li>
<li></span>&nbsp; &nbsp; typoid = <a href="../cache/lsyscache.c.html#L2521" title="utils/cache/lsyscache.c:2521">getBaseType</a>(typoid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *outfuncoid = InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (typoid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BOOLOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *outfuncoid = F_BOOLOUT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *tcategory = JSONTYPE_BOOL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INT2OID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INT4OID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INT8OID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> FLOAT4OID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> FLOAT8OID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> NUMERICOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L2907" title="utils/cache/lsyscache.c:2907">getTypeOutputInfo</a>(typoid, outfuncoid, &amp;typisvarlena);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *tcategory = JSONTYPE_NUMERIC;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DATEOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *outfuncoid = F_DATE_OUT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *tcategory = JSONTYPE_DATE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TIMESTAMPOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *outfuncoid = F_TIMESTAMP_OUT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *tcategory = JSONTYPE_TIMESTAMP;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TIMESTAMPTZOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *outfuncoid = F_TIMESTAMPTZ_OUT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *tcategory = JSONTYPE_TIMESTAMPTZ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JSONOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L2907" title="utils/cache/lsyscache.c:2907">getTypeOutputInfo</a>(typoid, outfuncoid, &amp;typisvarlena);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *tcategory = JSONTYPE_JSON;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JSONBOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L2907" title="utils/cache/lsyscache.c:2907">getTypeOutputInfo</a>(typoid, outfuncoid, &amp;typisvarlena);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *tcategory = is_jsonb ? JSONTYPE_JSONB : JSONTYPE_JSON;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check for arrays and composites */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(<a href="../cache/lsyscache.c.html#L2759" title="utils/cache/lsyscache.c:2759">get_element_type</a>(typoid)) || typoid == ANYARRAYOID<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || typoid == ANYCOMPATIBLEARRAYOID || typoid == RECORDARRAYOID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *outfuncoid = F_ARRAY_OUT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *tcategory = JSONTYPE_ARRAY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../cache/lsyscache.c.html#L2655" title="utils/cache/lsyscache.c:2655">type_is_rowtype</a>(typoid))&nbsp; &nbsp; <span class="Comment">/* includes RECORDOID */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *outfuncoid = F_RECORD_OUT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *tcategory = JSONTYPE_COMPOSITE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It's probably the general case.&nbsp; But let's look for a cast<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to json (note: not to jsonb even if is_jsonb is true), if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it's not built-in.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *tcategory = JSONTYPE_OTHER;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typoid &gt;= FirstNormalObjectId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; castfunc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CoercionPathType ctype;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ctype = <a href="../../parser/parse_coerce.c.html#L3118" title="parser/parse_coerce.c:3118">find_coercion_pathway</a>(JSONOID, typoid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; COERCION_EXPLICIT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;castfunc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ctype == COERCION_PATH_FUNC &amp;&amp; OidIsValid(castfunc))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *outfuncoid = castfunc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *tcategory = JSONTYPE_CAST;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* non builtin type with no cast */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L2907" title="utils/cache/lsyscache.c:2907">getTypeOutputInfo</a>(typoid, outfuncoid, &amp;typisvarlena);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other builtin type */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L2907" title="utils/cache/lsyscache.c:2907">getTypeOutputInfo</a>(typoid, outfuncoid, &amp;typisvarlena);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
