<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/adt/tsquery_util.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/adt/tsquery_util.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L316">QTN2QTState</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L25">QT2QTN</a></li>
<li><a href="#L363">QTN2QT</a></li>
<li><a href="#L250">QTNBinary</a></li>
<li><a href="#L434">QTNClearFlags</a></li>
<li><a href="#L396">QTNCopy</a></li>
<li><a href="#L183">QTNEq</a></li>
<li><a href="#L64">QTNFree</a></li>
<li><a href="#L163">QTNSort</a></li>
<li><a href="#L201">QTNTernary</a></li>
<li><a href="#L97">QTNodeCompare</a></li>
<li><a href="#L153">cmpQTN</a></li>
<li><a href="#L292">cntsize</a></li>
<li><a href="#L323">fillQT</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * tsquery_util.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Utilities for tsquery datatype<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/adt/tsquery_util.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;tsearch/ts_utils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;varatt.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Build QTNode tree for a tsquery given in QueryItem array format.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>QTNode *<br/></li>
<li><a id="L25">&#x200c;</a><span class="linkable">QT2QTN</span>(QueryItem *in, <span class="Type">char</span> *operand)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; QTNode&nbsp; &nbsp; &nbsp;&nbsp; *node = (QTNode *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(QTNode));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* since this function recurses, it could be driven to stack overflow. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; node-&gt;valnode = in;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (in-&gt;type == QI_OPR)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; node-&gt;child = (QTNode **) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(QTNode *) * <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; node-&gt;child[<span class="Constant">0</span>] = <a href="#L25" title="utils/adt/tsquery_util.c:25">QT2QTN</a>(in + <span class="Constant">1</span>, operand);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; node-&gt;sign = node-&gt;child[<span class="Constant">0</span>]-&gt;sign;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (in-&gt;qoperator.<a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a> == OP_NOT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;nchild = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;nchild = <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;child[<span class="Constant">1</span>] = <a href="#L25" title="utils/adt/tsquery_util.c:25">QT2QTN</a>(in + in-&gt;qoperator.left, operand);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;sign |= node-&gt;child[<span class="Constant">1</span>]-&gt;sign;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (operand)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; node-&gt;<a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> = operand + in-&gt;qoperand.distance;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; node-&gt;sign = ((uint32) <span class="Constant">1</span>) &lt;&lt; (((<span class="Type">unsigned</span> <span class="Type">int</span>) in-&gt;qoperand.valcrc) % <span class="Constant">32</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> node;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Free a QTNode tree.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Referenced &quot;<a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a>&quot; and &quot;valnode&quot; items are freed if marked as transient<br/></li>
<li></span><span class="Comment"> * by flags.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L64">&#x200c;</a></span><span class="linkable">QTNFree</span>(QTNode *in)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!in)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* since this function recurses, it could be driven to stack overflow. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (in-&gt;valnode-&gt;type == QI_VAL &amp;&amp; in-&gt;<a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> &amp;&amp; (in-&gt;flags &amp; QTN_WORDFREE) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(in-&gt;<a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (in-&gt;valnode-&gt;type == QI_OPR)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; in-&gt;nchild; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L64" title="utils/adt/tsquery_util.c:64">QTNFree</a>(in-&gt;child[i]);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (in-&gt;child)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(in-&gt;child);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (in-&gt;flags &amp; QTN_NEEDFREE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(in-&gt;valnode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(in);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Sort comparator for QTNodes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The sort order is somewhat arbitrary.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L97">&#x200c;</a></span><span class="linkable">QTNodeCompare</span>(QTNode *an, QTNode *bn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* since this function recurses, it could be driven to stack overflow. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (an-&gt;valnode-&gt;type != bn-&gt;valnode-&gt;type)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (an-&gt;valnode-&gt;type &gt; bn-&gt;valnode-&gt;type) ? -<span class="Constant">1</span> : <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (an-&gt;valnode-&gt;type == QI_OPR)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; QueryOperator *ao = &amp;an-&gt;valnode-&gt;qoperator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; QueryOperator *bo = &amp;bn-&gt;valnode-&gt;qoperator;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ao-&gt;<a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a> != bo-&gt;<a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (ao-&gt;<a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a> &gt; bo-&gt;<a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a>) ? -<span class="Constant">1</span> : <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (an-&gt;nchild != bn-&gt;nchild)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (an-&gt;nchild &gt; bn-&gt;nchild) ? -<span class="Constant">1</span> : <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; an-&gt;nchild; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((res = <a href="#L97" title="utils/adt/tsquery_util.c:97">QTNodeCompare</a>(an-&gt;child[i], bn-&gt;child[i])) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ao-&gt;<a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a> == OP_PHRASE &amp;&amp; ao-&gt;distance != bo-&gt;distance)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (ao-&gt;distance &gt; bo-&gt;distance) ? -<span class="Constant">1</span> : <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (an-&gt;valnode-&gt;type == QI_VAL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; QueryOperand *ao = &amp;an-&gt;valnode-&gt;qoperand;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; QueryOperand *bo = &amp;bn-&gt;valnode-&gt;qoperand;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ao-&gt;valcrc != bo-&gt;valcrc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (ao-&gt;valcrc &gt; bo-&gt;valcrc) ? -<span class="Constant">1</span> : <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="tsvector_op.c.html#L1152" title="utils/adt/tsvector_op.c:1152">tsCompareString</a>(an-&gt;<a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a>, ao-&gt;length, bn-&gt;<a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a>, bo-&gt;length, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized QueryItem type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, an-&gt;valnode-&gt;type);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * qsort comparator for QTNode pointers.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L153">&#x200c;</a></span><span class="linkable">cmpQTN</span>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L97" title="utils/adt/tsquery_util.c:97">QTNodeCompare</a>(*(QTNode *<span class="Type">const</span> *) a, *(QTNode *<span class="Type">const</span> *) b);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Canonicalize a QTNode tree by sorting the children of AND/OR nodes<br/></li>
<li></span><span class="Comment"> * into an arbitrary but well-defined order.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L163">&#x200c;</a></span><span class="linkable">QTNSort</span>(QTNode *in)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* since this function recurses, it could be driven to stack overflow. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (in-&gt;valnode-&gt;type != QI_OPR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; in-&gt;nchild; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L163" title="utils/adt/tsquery_util.c:163">QTNSort</a>(in-&gt;child[i]);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (in-&gt;nchild &gt; <span class="Constant">1</span> &amp;&amp; in-&gt;valnode-&gt;qoperator.<a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a> != OP_PHRASE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qsort(in-&gt;child, in-&gt;nchild, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(QTNode *), <a href="#L153" title="utils/adt/tsquery_util.c:153">cmpQTN</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Are two QTNode trees <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> according to <a href="#L97" title="utils/adt/tsquery_util.c:97">QTNodeCompare</a>?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L183">&#x200c;</a></span><span class="linkable">QTNEq</span>(QTNode *a, QTNode *b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; sign = a-&gt;sign &amp; b-&gt;sign;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!(sign == a-&gt;sign &amp;&amp; sign == b-&gt;sign))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (<a href="#L97" title="utils/adt/tsquery_util.c:97">QTNodeCompare</a>(a, b) == <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Remove unnecessary intermediate nodes. For example:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; OR&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OR<br/></li>
<li></span><span class="Comment"> * a&nbsp; OR&nbsp; &nbsp; -&gt; a b c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; b&nbsp; &nbsp; c<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L201">&#x200c;</a></span><span class="linkable">QTNTernary</span>(QTNode *in)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* since this function recurses, it could be driven to stack overflow. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (in-&gt;valnode-&gt;type != QI_OPR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; in-&gt;nchild; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L201" title="utils/adt/tsquery_util.c:201">QTNTernary</a>(in-&gt;child[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Only AND and OR are associative, so don't flatten other node types */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (in-&gt;valnode-&gt;qoperator.<a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a> != OP_AND &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; in-&gt;valnode-&gt;qoperator.<a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a> != OP_OR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; in-&gt;nchild; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; QTNode&nbsp; &nbsp; &nbsp;&nbsp; *cc = in-&gt;child[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cc-&gt;valnode-&gt;type == QI_OPR &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in-&gt;valnode-&gt;qoperator.<a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a> == cc-&gt;valnode-&gt;qoperator.<a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldnchild = in-&gt;nchild;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in-&gt;nchild += cc-&gt;nchild - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in-&gt;child = (QTNode **) <a href="../mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(in-&gt;child, in-&gt;nchild * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(QTNode *));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i + <span class="Constant">1</span> != oldnchild)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memmove(in-&gt;child + i + cc-&gt;nchild, in-&gt;child + i + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (oldnchild - i - <span class="Constant">1</span>) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(QTNode *));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(in-&gt;child + i, cc-&gt;child, cc-&gt;nchild * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(QTNode *));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i += cc-&gt;nchild - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cc-&gt;flags &amp; QTN_NEEDFREE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(cc-&gt;valnode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(cc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert a tree to binary tree by inserting intermediate nodes.<br/></li>
<li></span><span class="Comment"> * (Opposite of <a href="#L201" title="utils/adt/tsquery_util.c:201">QTNTernary</a>)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L250">&#x200c;</a></span><span class="linkable">QTNBinary</span>(QTNode *in)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* since this function recurses, it could be driven to stack overflow. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (in-&gt;valnode-&gt;type != QI_OPR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; in-&gt;nchild; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L250" title="utils/adt/tsquery_util.c:250">QTNBinary</a>(in-&gt;child[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (in-&gt;nchild &gt; <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; QTNode&nbsp; &nbsp; &nbsp;&nbsp; *nn = (QTNode *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(QTNode));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nn-&gt;valnode = (QueryItem *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(QueryItem));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nn-&gt;child = (QTNode **) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(QTNode *) * <span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nn-&gt;nchild = <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nn-&gt;flags = QTN_NEEDFREE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nn-&gt;child[<span class="Constant">0</span>] = in-&gt;child[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nn-&gt;child[<span class="Constant">1</span>] = in-&gt;child[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nn-&gt;sign = nn-&gt;child[<span class="Constant">0</span>]-&gt;sign | nn-&gt;child[<span class="Constant">1</span>]-&gt;sign;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nn-&gt;valnode-&gt;type = in-&gt;valnode-&gt;type;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nn-&gt;valnode-&gt;qoperator.<a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a> = in-&gt;valnode-&gt;qoperator.<a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; in-&gt;child[<span class="Constant">0</span>] = nn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; in-&gt;child[<span class="Constant">1</span>] = in-&gt;child[in-&gt;nchild - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; in-&gt;nchild--;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Count the total length of operand strings in tree (including '\0'-<br/></li>
<li></span><span class="Comment"> * terminators) and the total number of nodes.<br/></li>
<li></span><span class="Comment"> * Caller must <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> *sumlen and *nnode to zeroes.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L292">&#x200c;</a></span><span class="linkable">cntsize</span>(QTNode *in, <span class="Type">int</span> *sumlen, <span class="Type">int</span> *nnode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* since this function recurses, it could be driven to stack overflow. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *nnode += <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (in-&gt;valnode-&gt;type == QI_OPR)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; in-&gt;nchild; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L292" title="utils/adt/tsquery_util.c:292">cntsize</a>(in-&gt;child[i], sumlen, nnode);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *sumlen += in-&gt;valnode-&gt;qoperand.length + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; QueryItem&nbsp; *curitem;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *operand;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *curoperand;<br/></li>
<li><a id="L316">&#x200c;</a>} <span class="linkable">QTN2QTState</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Recursively convert a QTNode tree into flat tsquery format.<br/></li>
<li></span><span class="Comment"> * Caller must have allocated arrays of the correct size.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L323">&#x200c;</a></span><span class="linkable">fillQT</span>(<a href="#L316" title="utils/adt/tsquery_util.c:316">QTN2QTState</a> *state, QTNode *in)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* since this function recurses, it could be driven to stack overflow. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (in-&gt;valnode-&gt;type == QI_VAL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(state-&gt;curitem, in-&gt;valnode, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(QueryOperand));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(state-&gt;curoperand, in-&gt;<a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a>, in-&gt;valnode-&gt;qoperand.length);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;curitem-&gt;qoperand.distance = state-&gt;curoperand - state-&gt;operand;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;curoperand[in-&gt;valnode-&gt;qoperand.length] = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;curoperand += in-&gt;valnode-&gt;qoperand.length + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;curitem++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; QueryItem&nbsp; *curitem = state-&gt;curitem;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(in-&gt;valnode-&gt;type == QI_OPR);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(state-&gt;curitem, in-&gt;valnode, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(QueryOperator));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(in-&gt;nchild &lt;= <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;curitem++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L323" title="utils/adt/tsquery_util.c:323">fillQT</a>(state, in-&gt;child[<span class="Constant">0</span>]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (in-&gt;nchild == <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curitem-&gt;qoperator.left = state-&gt;curitem - curitem;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L323" title="utils/adt/tsquery_util.c:323">fillQT</a>(state, in-&gt;child[<span class="Constant">1</span>]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Build flat tsquery from a QTNode tree.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TSQuery<br/></li>
<li><a id="L363">&#x200c;</a><span class="linkable">QTN2QT</span>(QTNode *in)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TSQuery&nbsp; &nbsp; &nbsp; &nbsp; out;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sumlen = <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nnode = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L316" title="utils/adt/tsquery_util.c:316">QTN2QTState</a> state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L292" title="utils/adt/tsquery_util.c:292">cntsize</a>(in, &amp;sumlen, &amp;nnode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (TSQUERY_TOO_BIG(nnode, sumlen))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;tsquery is too large&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; len = COMPUTESIZE(nnode, sumlen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; out = (TSQuery) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(len);<br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(out, len);<br/></li>
<li>&nbsp; &nbsp; out-&gt;size = nnode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state.curitem = GETQUERY(out);<br/></li>
<li>&nbsp; &nbsp; state.operand = state.curoperand = GETOPERAND(out);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L323" title="utils/adt/tsquery_util.c:323">fillQT</a>(&amp;state, in);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> out;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Copy a QTNode tree.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Modifiable copies of the words and valnodes are made, too.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>QTNode *<br/></li>
<li><a id="L396">&#x200c;</a><span class="linkable">QTNCopy</span>(QTNode *in)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; QTNode&nbsp; &nbsp; &nbsp;&nbsp; *out;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* since this function recurses, it could be driven to stack overflow. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; out = (QTNode *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(QTNode));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *out = *in;<br/></li>
<li>&nbsp; &nbsp; out-&gt;valnode = (QueryItem *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(QueryItem));<br/></li>
<li>&nbsp; &nbsp; *(out-&gt;valnode) = *(in-&gt;valnode);<br/></li>
<li>&nbsp; &nbsp; out-&gt;flags |= QTN_NEEDFREE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (in-&gt;valnode-&gt;type == QI_VAL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; out-&gt;<a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(in-&gt;valnode-&gt;qoperand.length + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(out-&gt;<a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a>, in-&gt;<a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a>, in-&gt;valnode-&gt;qoperand.length);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; out-&gt;<a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a>[in-&gt;valnode-&gt;qoperand.length] = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; out-&gt;flags |= QTN_WORDFREE;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; out-&gt;child = (QTNode **) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(QTNode *) * in-&gt;nchild);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; in-&gt;nchild; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; out-&gt;child[i] = <a href="#L396" title="utils/adt/tsquery_util.c:396">QTNCopy</a>(in-&gt;child[i]);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> out;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Clear the specified flag <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>(s) in all nodes of a QTNode tree.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L434">&#x200c;</a></span><span class="linkable">QTNClearFlags</span>(QTNode *in, uint32 flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* since this function recurses, it could be driven to stack overflow. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; in-&gt;flags &amp;= ~flags;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (in-&gt;valnode-&gt;type != QI_VAL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; in-&gt;nchild; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L434" title="utils/adt/tsquery_util.c:434">QTNClearFlags</a>(in-&gt;child[i], flags);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
