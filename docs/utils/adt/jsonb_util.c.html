<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/adt/jsonb_util.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/adt/jsonb_util.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L1062">JsonbDeepContains</a></li>
<li><a href="#L1316">JsonbHashScalarValue</a></li>
<li><a href="#L1359">JsonbHashScalarValueExtended</a></li>
<li><a href="#L817">JsonbIteratorInit</a></li>
<li><a href="#L853">JsonbIteratorNext</a></li>
<li><a href="#L72">JsonbToJsonbValue</a></li>
<li><a href="#L92">JsonbValueToJsonb</a></li>
<li><a href="#L788">appendElement</a></li>
<li><a href="#L746">appendKey</a></li>
<li><a href="#L1513">appendToBuffer</a></li>
<li><a href="#L775">appendValue</a></li>
<li><a href="#L191">compareJsonbContainers</a></li>
<li><a href="#L1433">compareJsonbScalarValue</a></li>
<li><a href="#L1615">convertJsonbArray</a></li>
<li><a href="#L1699">convertJsonbObject</a></li>
<li><a href="#L1815">convertJsonbScalar</a></li>
<li><a href="#L1590">convertJsonbValue</a></li>
<li><a href="#L1548">convertToJsonb</a></li>
<li><a href="#L1504">copyToBuffer</a></li>
<li><a href="#L1401">equalsJsonbScalarValue</a></li>
<li><a href="#L505">fillJsonbValue</a></li>
<li><a href="#L344">findJsonbValueFromContainer</a></li>
<li><a href="#L1041">freeAndGetParent</a></li>
<li><a href="#L468">getIthJsonbValueFromContainer</a></li>
<li><a href="#L159">getJsonbLength</a></li>
<li><a href="#L134">getJsonbOffset</a></li>
<li><a href="#L398">getKeyJsonValueFromContainer</a></li>
<li><a href="#L999">iteratorFromContainer</a></li>
<li><a href="#L1919">lengthCompareJsonbPair</a></li>
<li><a href="#L1899">lengthCompareJsonbString</a></li>
<li><a href="#L1880">lengthCompareJsonbStringValue</a></li>
<li><a href="#L1527">padBufferToInt</a></li>
<li><a href="#L566">pushJsonbValue</a></li>
<li><a href="#L640">pushJsonbValueScalar</a></li>
<li><a href="#L731">pushState</a></li>
<li><a href="#L1478">reserveFromBuffer</a></li>
<li><a href="#L1943">uniqueifyJsonbObject</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L36">JSONB_MAX_ELEMS</a></li>
<li><a href="#L37">JSONB_MAX_PAIRS</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * jsonb_util.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; converting between Jsonb and JsonbValues, and iterating.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Copyright (c) 2014-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/adt/jsonb_util.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_collation.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/hashfn.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;port/pg_bitutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/datetime.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgrprotos.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/json.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/jsonb.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/varlena.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Maximum number of elements in an array (or key/value pairs in an object).<br/></li>
<li></span><span class="Comment"> * This is limited by two things: the size of the JEntry array must fit<br/></li>
<li></span><span class="Comment"> * in MaxAllocSize, and the number of elements (or pairs) must fit in the bits<br/></li>
<li></span><span class="Comment"> * reserved for that in the JsonbContainer.header field.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * (The total size of an array's or object's elements is also limited by<br/></li>
<li></span><span class="Comment"> * JENTRY_OFFLENMASK, but we're not concerned about that here.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L36">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">JSONB_MAX_ELEMS</span> (<a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(MaxAllocSize / </span><span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(JsonbValue), JB_CMASK))<br/></li>
<li><a id="L37">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">JSONB_MAX_PAIRS</span> (<a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(MaxAllocSize / </span><span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(JsonbPair), JB_CMASK))<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L505" title="utils/adt/jsonb_util.c:505">fillJsonbValue</a>(JsonbContainer *container, <span class="Type">int</span> index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">char</span> *base_addr, uint32 offset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; JsonbValue *result);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1401" title="utils/adt/jsonb_util.c:1401">equalsJsonbScalarValue</a>(JsonbValue *a, JsonbValue *b);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1433" title="utils/adt/jsonb_util.c:1433">compareJsonbScalarValue</a>(JsonbValue *a, JsonbValue *b);<br/></li>
<li><span class="Type">static</span> Jsonb *<a href="#L1548" title="utils/adt/jsonb_util.c:1548">convertToJsonb</a>(JsonbValue *val);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1590" title="utils/adt/jsonb_util.c:1590">convertJsonbValue</a>(StringInfo buffer, JEntry *header, JsonbValue *val, <span class="Type">int</span> level);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1615" title="utils/adt/jsonb_util.c:1615">convertJsonbArray</a>(StringInfo buffer, JEntry *header, JsonbValue *val, <span class="Type">int</span> level);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1699" title="utils/adt/jsonb_util.c:1699">convertJsonbObject</a>(StringInfo buffer, JEntry *header, JsonbValue *val, <span class="Type">int</span> level);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1815" title="utils/adt/jsonb_util.c:1815">convertJsonbScalar</a>(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1478" title="utils/adt/jsonb_util.c:1478">reserveFromBuffer</a>(StringInfo buffer, <span class="Type">int</span> len);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1513" title="utils/adt/jsonb_util.c:1513">appendToBuffer</a>(StringInfo buffer, <span class="Type">const</span> <span class="Type">char</span> *data, <span class="Type">int</span> len);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1504" title="utils/adt/jsonb_util.c:1504">copyToBuffer</a>(StringInfo buffer, <span class="Type">int</span> offset, <span class="Type">const</span> <span class="Type">char</span> *data, <span class="Type">int</span> len);<br/></li>
<li><span class="Type">static</span> <span class="Type">short</span> <a href="#L1527" title="utils/adt/jsonb_util.c:1527">padBufferToInt</a>(StringInfo buffer);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> JsonbIterator *<a href="#L999" title="utils/adt/jsonb_util.c:999">iteratorFromContainer</a>(JsonbContainer *container, JsonbIterator *parent);<br/></li>
<li><span class="Type">static</span> JsonbIterator *<a href="#L1041" title="utils/adt/jsonb_util.c:1041">freeAndGetParent</a>(JsonbIterator *it);<br/></li>
<li><span class="Type">static</span> JsonbParseState *<a href="#L731" title="utils/adt/jsonb_util.c:731">pushState</a>(JsonbParseState **pstate);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L746" title="utils/adt/jsonb_util.c:746">appendKey</a>(JsonbParseState *pstate, JsonbValue *string);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L775" title="utils/adt/jsonb_util.c:775">appendValue</a>(JsonbParseState *pstate, JsonbValue *scalarVal);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L788" title="utils/adt/jsonb_util.c:788">appendElement</a>(JsonbParseState *pstate, JsonbValue *scalarVal);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1880" title="utils/adt/jsonb_util.c:1880">lengthCompareJsonbStringValue</a>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1899" title="utils/adt/jsonb_util.c:1899">lengthCompareJsonbString</a>(<span class="Type">const</span> <span class="Type">char</span> *val1, <span class="Type">int</span> len1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *val2, <span class="Type">int</span> len2);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1919" title="utils/adt/jsonb_util.c:1919">lengthCompareJsonbPair</a>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b, <span class="Type">void</span> *binequal);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1943" title="utils/adt/jsonb_util.c:1943">uniqueifyJsonbObject</a>(JsonbValue *object, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> unique_keys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> skip_nulls);<br/></li>
<li><span class="Type">static</span> JsonbValue *<a href="#L640" title="utils/adt/jsonb_util.c:640">pushJsonbValueScalar</a>(JsonbParseState **pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JsonbIteratorToken seq,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JsonbValue *scalarVal);<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L72">&#x200c;</a></span><span class="linkable">JsonbToJsonbValue</span>(Jsonb *jsonb, JsonbValue *val)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; val-&gt;type = jbvBinary;<br/></li>
<li>&nbsp; &nbsp; val-&gt;val.binary.data = &amp;jsonb-&gt;root;<br/></li>
<li>&nbsp; &nbsp; val-&gt;val.binary.len = VARSIZE(jsonb) - VARHDRSZ;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Turn an in-memory JsonbValue into a Jsonb for on-disk storage.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Generally we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> it more convenient to directly iterate through the Jsonb<br/></li>
<li></span><span class="Comment"> * representation and only really convert nested scalar <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> * <a href="#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a>() does this, so that clients of the iteration code don't<br/></li>
<li></span><span class="Comment"> * have to directly deal with the binary representation (<a href="#L1062" title="utils/adt/jsonb_util.c:1062">JsonbDeepContains</a>() is<br/></li>
<li></span><span class="Comment"> * a notable exception, although all exceptions are <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> to this module).<br/></li>
<li></span><span class="Comment"> * In general, <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> that <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> a JsonbValue argument are concerned with<br/></li>
<li></span><span class="Comment"> * the manipulation of scalar <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, or simple containers of scalar <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>,<br/></li>
<li></span><span class="Comment"> * where it would be inconvenient to deal with a great amount of other state.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Jsonb *<br/></li>
<li><a id="L92">&#x200c;</a><span class="linkable">JsonbValueToJsonb</span>(JsonbValue *val)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Jsonb&nbsp; &nbsp; &nbsp;&nbsp; *out;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsAJsonbScalar(val))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Scalar value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; JsonbParseState *pstate = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; JsonbValue *res;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; JsonbValue&nbsp; &nbsp; scalarArray;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scalarArray.type = jbvArray;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scalarArray.val.array.rawScalar = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scalarArray.val.array.nElems = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(&amp;pstate, WJB_BEGIN_ARRAY, &amp;scalarArray);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(&amp;pstate, WJB_ELEM, val);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res = <a href="#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(&amp;pstate, WJB_END_ARRAY, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; out = <a href="#L1548" title="utils/adt/jsonb_util.c:1548">convertToJsonb</a>(res);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (val-&gt;type == jbvObject || val-&gt;type == jbvArray)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; out = <a href="#L1548" title="utils/adt/jsonb_util.c:1548">convertToJsonb</a>(val);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(val-&gt;type == jbvBinary);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; out = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(VARHDRSZ + val-&gt;val.binary.len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SET_VARSIZE(out, VARHDRSZ + val-&gt;val.binary.len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(VARDATA(out), val-&gt;val.binary.data, val-&gt;val.binary.len);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> out;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get the offset of the variable-length portion of a Jsonb node within<br/></li>
<li></span><span class="Comment"> * the variable-length-data part of its container.&nbsp; The node is identified<br/></li>
<li></span><span class="Comment"> * by index within the container's JEntry array.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>uint32<br/></li>
<li><a id="L134">&#x200c;</a><span class="linkable">getJsonbOffset</span>(<span class="Type">const</span> JsonbContainer *jc, <span class="Type">int</span> index)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; offset = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Start offset of this entry is <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to the end offset of the previous<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * entry.&nbsp; Walk backwards to the most recent entry stored as an end<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * offset, returning that offset plus <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> lengths in between.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = index - <span class="Constant">1</span>; i &gt;= <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; offset += JBE_OFFLENFLD(jc-&gt;children[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (JBE_HAS_OFF(jc-&gt;children[i]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> offset;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get the length of the variable-length portion of a Jsonb node.<br/></li>
<li></span><span class="Comment"> * The node is identified by index within the container's JEntry array.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>uint32<br/></li>
<li><a id="L159">&#x200c;</a><span class="linkable">getJsonbLength</span>(<span class="Type">const</span> JsonbContainer *jc, <span class="Type">int</span> index)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; off;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the length is stored directly in the JEntry, just return it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Otherwise, get the begin offset of the entry, and subtract that from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the stored end+1 offset.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (JBE_HAS_OFF(jc-&gt;children[index]))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; off = <a href="#L134" title="utils/adt/jsonb_util.c:134">getJsonbOffset</a>(jc, index);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len = JBE_OFFLENFLD(jc-&gt;children[index]) - off;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; len = JBE_OFFLENFLD(jc-&gt;children[index]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> len;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * BT comparator worker function.&nbsp; Returns an integer less than, <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to, or<br/></li>
<li></span><span class="Comment"> * greater than zero, indicating whether a is less than, <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to, or greater<br/></li>
<li></span><span class="Comment"> * than b.&nbsp; Consistent with the requirements for a B-Tree operator class<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Strings are compared lexically, in contrast with other places where we use a<br/></li>
<li></span><span class="Comment"> * much simpler comparator logic for searching through Strings.&nbsp; Since this is<br/></li>
<li></span><span class="Comment"> * called from B-Tree support function 1, we're careful about not leaking<br/></li>
<li></span><span class="Comment"> * memory here.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L191">&#x200c;</a></span><span class="linkable">compareJsonbContainers</span>(JsonbContainer *a, JsonbContainer *b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JsonbIterator *ita,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *itb;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ita = <a href="#L817" title="utils/adt/jsonb_util.c:817">JsonbIteratorInit</a>(a);<br/></li>
<li>&nbsp; &nbsp; itb = <a href="#L817" title="utils/adt/jsonb_util.c:817">JsonbIteratorInit</a>(b);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; JsonbValue&nbsp; &nbsp; va,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vb;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; JsonbIteratorToken ra,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rb;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ra = <a href="#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a>(&amp;ita, &amp;va, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rb = <a href="#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a>(&amp;itb, &amp;vb, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ra == rb)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ra == WJB_DONE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Decisively <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ra == WJB_END_ARRAY || ra == WJB_END_OBJECT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There is no array or object to <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> at this stage of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * processing.&nbsp; jbvArray/jbvObject <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are compared<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * initially, at the WJB_BEGIN_ARRAY and WJB_BEGIN_OBJECT<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tokens.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (va.type == vb.type)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (va.type)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jbvString:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jbvNull:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jbvNumeric:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jbvBool:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <a href="#L1433" title="utils/adt/jsonb_util.c:1433">compareJsonbScalarValue</a>(&amp;va, &amp;vb);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jbvArray:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This could be a &quot;raw scalar&quot; pseudo array.&nbsp; That's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a special case here though, since we still want the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * general type-based comparisons to apply, and as far<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * as we're concerned a pseudo array is just a scalar.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (va.val.array.rawScalar != vb.val.array.rawScalar)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = (va.val.array.rawScalar) ? -<span class="Constant">1</span> : <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (va.val.array.nElems != vb.val.array.nElems)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = (va.val.array.nElems &gt; vb.val.array.nElems) ? <span class="Constant">1</span> : -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jbvObject:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (va.val.object.nPairs != vb.val.object.nPairs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = (va.val.object.nPairs &gt; vb.val.object.nPairs) ? <span class="Constant">1</span> : -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jbvBinary:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected jbvBinary value&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jbvDatetime:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected jbvDatetime value&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Type-defined order */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = (va.type &gt; vb.type) ? <span class="Constant">1</span> : -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It's safe to assume that the types differed, and that the va<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and vb <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> passed were set.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the two <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> were of the same container type, then there'd<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have been a chance to observe the variation in the number of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * elements/pairs (when processing WJB_BEGIN_OBJECT, say). They're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * either two heterogeneously-typed containers, or a container and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * some scalar type.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't have to consider the WJB_END_ARRAY and WJB_END_OBJECT<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cases here, because we would have seen the corresponding<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * WJB_BEGIN_ARRAY and WJB_BEGIN_OBJECT tokens first, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * concluded that they don't match.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(ra != WJB_END_ARRAY &amp;&amp; ra != WJB_END_OBJECT);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(rb != WJB_END_ARRAY &amp;&amp; rb != WJB_END_OBJECT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(va.type != vb.type);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(va.type != jbvBinary);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(vb.type != jbvBinary);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Type-defined order */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = (va.type &gt; vb.type) ? <span class="Constant">1</span> : -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (res == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (ita != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; JsonbIterator *i = ita-&gt;parent;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(ita);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ita = i;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (itb != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; JsonbIterator *i = itb-&gt;parent;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(itb);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itb = i;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Find value in object (i.e. the &quot;value&quot; part of some key/value pair in an<br/></li>
<li></span><span class="Comment"> * object), or <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a matching <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> if we're looking through an array.&nbsp; Do<br/></li>
<li></span><span class="Comment"> * so on the basis of equality of the object keys only, or alternatively<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> only, with a caller-supplied value &quot;key&quot;.&nbsp; The &quot;flags&quot;<br/></li>
<li></span><span class="Comment"> * argument allows the caller to specify which container types are of interest.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This exported utility function exists to facilitate various cases concerned<br/></li>
<li></span><span class="Comment"> * with &quot;containment&quot;.&nbsp; If asked to look through an object, the caller had<br/></li>
<li></span><span class="Comment"> * better pass a Jsonb String, because their keys can only be strings.<br/></li>
<li></span><span class="Comment"> * Otherwise, for an array, <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> type of JsonbValue will do.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In order to proceed with the search, it is necessary for callers to have<br/></li>
<li></span><span class="Comment"> * both specified an interest in exactly one particular container type with an<br/></li>
<li></span><span class="Comment"> * appropriate flag, as well as having the pointed-to Jsonb container be of<br/></li>
<li></span><span class="Comment"> * one of those same container types at the top level. (Actually, we just do<br/></li>
<li></span><span class="Comment"> * whichever makes sense to save callers the trouble of figuring it out - at<br/></li>
<li></span><span class="Comment"> * most one can make sense, because the container either points to an array<br/></li>
<li></span><span class="Comment"> * (possibly a &quot;raw scalar&quot; pseudo array) or an object.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that we can return a jbvBinary JsonbValue if this is called on an<br/></li>
<li></span><span class="Comment"> * object, but we never do so on an array.&nbsp; If the caller asks to look through<br/></li>
<li></span><span class="Comment"> * a container type that is not of the type pointed to by the container,<br/></li>
<li></span><span class="Comment"> * immediately fall through and return NULL.&nbsp; If we cannot <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the value,<br/></li>
<li></span><span class="Comment"> * return NULL.&nbsp; Otherwise, return <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>()'d copy of value.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>JsonbValue *<br/></li>
<li><a id="L344">&#x200c;</a><span class="linkable">findJsonbValueFromContainer</span>(JsonbContainer *container, uint32 flags,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JsonbValue *key)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JEntry&nbsp; &nbsp; &nbsp;&nbsp; *children = container-&gt;children;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count = JsonContainerSize(container);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert((flags &amp; ~(JB_FARRAY | JB_FOBJECT)) == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Quick out without a <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a> cycle if object/array is empty */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (count &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((flags &amp; JB_FARRAY) &amp;&amp; JsonContainerIsArray(container))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; JsonbValue *result = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(JsonbValue));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *base_addr = (<span class="Type">char</span> *) (children + count);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; offset = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; count; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L505" title="utils/adt/jsonb_util.c:505">fillJsonbValue</a>(container, i, base_addr, offset, result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (key-&gt;type == result-&gt;type)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1401" title="utils/adt/jsonb_util.c:1401">equalsJsonbScalarValue</a>(key, result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JBE_ADVANCE_OFFSET(offset, children[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(result);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> ((flags &amp; JB_FOBJECT) &amp;&amp; JsonContainerIsObject(container))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Object key passed by caller must be a string */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(key-&gt;type == jbvString);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L398" title="utils/adt/jsonb_util.c:398">getKeyJsonValueFromContainer</a>(container, key-&gt;val.string.val,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key-&gt;val.string.len, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Not found */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Find value by key in Jsonb object and fetch it into 'res', which is also<br/></li>
<li></span><span class="Comment"> * returned.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'res' can be passed in as NULL, in which case it's newly <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'ed here.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>JsonbValue *<br/></li>
<li><a id="L398">&#x200c;</a><span class="linkable">getKeyJsonValueFromContainer</span>(JsonbContainer *container,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *keyVal, <span class="Type">int</span> keyLen, JsonbValue *res)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JEntry&nbsp; &nbsp; &nbsp;&nbsp; *children = container-&gt;children;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count = JsonContainerSize(container);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *baseAddr;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; stopLow,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stopHigh;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(JsonContainerIsObject(container));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Quick out without a <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a> cycle if object is empty */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (count &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Binary search the container. Since we know this is an object, account<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for *Pairs* of Jentrys<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; baseAddr = (<span class="Type">char</span> *) (children + count * <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; stopLow = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; stopHigh = count;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (stopLow &lt; stopHigh)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; stopMiddle;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; difference;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *candidateVal;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; candidateLen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stopMiddle = stopLow + (stopHigh - stopLow) / <span class="Constant">2</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; candidateVal = baseAddr + <a href="#L134" title="utils/adt/jsonb_util.c:134">getJsonbOffset</a>(container, stopMiddle);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; candidateLen = <a href="#L159" title="utils/adt/jsonb_util.c:159">getJsonbLength</a>(container, stopMiddle);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; difference = <a href="#L1899" title="utils/adt/jsonb_util.c:1899">lengthCompareJsonbString</a>(candidateVal, candidateLen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keyVal, keyLen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (difference == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Found our key, return corresponding value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index = stopMiddle + count;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!res)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(JsonbValue));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L505" title="utils/adt/jsonb_util.c:505">fillJsonbValue</a>(container, index, baseAddr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L134" title="utils/adt/jsonb_util.c:134">getJsonbOffset</a>(container, index),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; res);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (difference &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stopLow = stopMiddle + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stopHigh = stopMiddle;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Not found */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get i-th value of a Jsonb array.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>()'d copy of the value, or NULL if it does not exist.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>JsonbValue *<br/></li>
<li><a id="L468">&#x200c;</a><span class="linkable">getIthJsonbValueFromContainer</span>(JsonbContainer *container, uint32 i)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JsonbValue *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *base_addr;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; nelements;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!JsonContainerIsArray(container))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;not a jsonb array&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nelements = JsonContainerSize(container);<br/></li>
<li>&nbsp; &nbsp; base_addr = (<span class="Type">char</span> *) &amp;container-&gt;children[nelements];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (i &gt;= nelements)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(JsonbValue));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L505" title="utils/adt/jsonb_util.c:505">fillJsonbValue</a>(container, i, base_addr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L134" title="utils/adt/jsonb_util.c:134">getJsonbOffset</a>(container, i),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * A helper function to fill in a JsonbValue to represent an <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> of an<br/></li>
<li></span><span class="Comment"> * array, or a key or value of an object.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The node's JEntry is at container-&gt;children[index], and its variable-length<br/></li>
<li></span><span class="Comment"> * data is at base_addr + offset.&nbsp; We make the caller determine the offset<br/></li>
<li></span><span class="Comment"> * since in many cases the caller can amortize that work across multiple<br/></li>
<li></span><span class="Comment"> * children.&nbsp; When it can't, it can just call <a href="#L134" title="utils/adt/jsonb_util.c:134">getJsonbOffset</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A nested array or object will be returned as jbvBinary, ie. it won't be<br/></li>
<li></span><span class="Comment"> * expanded.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L505">&#x200c;</a></span><span class="linkable">fillJsonbValue</span>(JsonbContainer *container, <span class="Type">int</span> index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">char</span> *base_addr, uint32 offset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; JsonbValue *result)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JEntry&nbsp; &nbsp; &nbsp; &nbsp; entry = container-&gt;children[index];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (JBE_ISNULL(entry))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;type = jbvNull;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (JBE_ISSTRING(entry))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;type = jbvString;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;val.string.val = base_addr + offset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;val.string.len = <a href="#L159" title="utils/adt/jsonb_util.c:159">getJsonbLength</a>(container, index);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(result-&gt;val.string.len &gt;= <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (JBE_ISNUMERIC(entry))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;type = jbvNumeric;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;val.<a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> = (Numeric) (base_addr + INTALIGN(offset));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (JBE_ISBOOL_TRUE(entry))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;type = jbvBool;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;val.boolean = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (JBE_ISBOOL_FALSE(entry))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;type = jbvBool;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;val.boolean = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(JBE_ISCONTAINER(entry));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;type = jbvBinary;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Remove alignment padding from data pointer and length */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;val.binary.data = (JsonbContainer *) (base_addr + INTALIGN(offset));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;val.binary.len = <a href="#L159" title="utils/adt/jsonb_util.c:159">getJsonbLength</a>(container, index) -<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (INTALIGN(offset) - offset);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Push JsonbValue into JsonbParseState.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Used when parsing JSON tokens to form Jsonb, or when converting an in-memory<br/></li>
<li></span><span class="Comment"> * JsonbValue to a Jsonb.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Initial state of *JsonbParseState is NULL, since it'll be allocated here<br/></li>
<li></span><span class="Comment"> * originally (caller will get JsonbParseState back by reference).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Only sequential tokens pertaining to non-container types should pass a<br/></li>
<li></span><span class="Comment"> * JsonbValue.&nbsp; There is one exception -- WJB_BEGIN_ARRAY callers may pass a<br/></li>
<li></span><span class="Comment"> * &quot;raw scalar&quot; pseudo array to append it - the actual scalar should be passed<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> and it will be added as the only member of the array.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Values of type jbvBinary, which are rolled up arrays and objects,<br/></li>
<li></span><span class="Comment"> * are unpacked <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> being added to the result.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>JsonbValue *<br/></li>
<li><a id="L566">&#x200c;</a><span class="linkable">pushJsonbValue</span>(JsonbParseState **pstate, JsonbIteratorToken seq,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; JsonbValue *jbval)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JsonbIterator *it;<br/></li>
<li>&nbsp; &nbsp; JsonbValue *res = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; JsonbValue&nbsp; &nbsp; v;<br/></li>
<li>&nbsp; &nbsp; JsonbIteratorToken tok;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (jbval &amp;&amp; (seq == WJB_ELEM || seq == WJB_VALUE) &amp;&amp; jbval-&gt;type == jbvObject)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(pstate, WJB_BEGIN_OBJECT, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; jbval-&gt;val.object.nPairs; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(pstate, WJB_KEY, &amp;jbval-&gt;val.object.pairs[i].key);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(pstate, WJB_VALUE, &amp;jbval-&gt;val.object.pairs[i].value);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(pstate, WJB_END_OBJECT, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (jbval &amp;&amp; (seq == WJB_ELEM || seq == WJB_VALUE) &amp;&amp; jbval-&gt;type == jbvArray)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(pstate, WJB_BEGIN_ARRAY, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; jbval-&gt;val.array.nElems; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(pstate, WJB_ELEM, &amp;jbval-&gt;val.array.elems[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>(pstate, WJB_END_ARRAY, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!jbval || (seq != WJB_ELEM &amp;&amp; seq != WJB_VALUE) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; jbval-&gt;type != jbvBinary)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* drop through */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L640" title="utils/adt/jsonb_util.c:640">pushJsonbValueScalar</a>(pstate, seq, jbval);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* unpack the binary and add each piece to the pstate */<br/></li>
<li></span>&nbsp; &nbsp; it = <a href="#L817" title="utils/adt/jsonb_util.c:817">JsonbIteratorInit</a>(jbval-&gt;val.binary.data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((jbval-&gt;val.binary.data-&gt;header &amp; JB_FSCALAR) &amp;&amp; *pstate)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tok = <a href="#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a>(&amp;it, &amp;v, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(tok == WJB_BEGIN_ARRAY);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(v.type == jbvArray &amp;&amp; v.val.array.rawScalar);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tok = <a href="#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a>(&amp;it, &amp;v, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(tok == WJB_ELEM);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res = <a href="#L640" title="utils/adt/jsonb_util.c:640">pushJsonbValueScalar</a>(pstate, seq, &amp;v);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tok = <a href="#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a>(&amp;it, &amp;v, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(tok == WJB_END_ARRAY);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(it == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((tok = <a href="#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a>(&amp;it, &amp;v, <span class="Constant">false</span>)) != WJB_DONE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res = <a href="#L640" title="utils/adt/jsonb_util.c:640">pushJsonbValueScalar</a>(pstate, tok,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tok &lt; WJB_BEGIN_ARRAY ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (tok == WJB_BEGIN_ARRAY &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v.val.array.rawScalar) ? &amp;v : <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Do the actual pushing, with only scalar or pseudo-scalar-array <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment"> * accepted.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> JsonbValue *<br/></li>
<li><a id="L640">&#x200c;</a><span class="linkable">pushJsonbValueScalar</span>(JsonbParseState **pstate, JsonbIteratorToken seq,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; JsonbValue *scalarVal)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JsonbValue *result = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (seq)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WJB_BEGIN_ARRAY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!scalarVal || scalarVal-&gt;val.array.rawScalar);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *pstate = <a href="#L731" title="utils/adt/jsonb_util.c:731">pushState</a>(pstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = &amp;(*pstate)-&gt;contVal;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (*pstate)-&gt;contVal.type = jbvArray;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (*pstate)-&gt;contVal.val.array.nElems = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (*pstate)-&gt;contVal.val.array.rawScalar = (scalarVal &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scalarVal-&gt;val.array.rawScalar);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (scalarVal &amp;&amp; scalarVal-&gt;val.array.nElems &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Assume that this array is still really a scalar */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(scalarVal-&gt;type == jbvArray);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (*pstate)-&gt;size = scalarVal-&gt;val.array.nElems;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (*pstate)-&gt;size = <span class="Constant">4</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (*pstate)-&gt;contVal.val.array.elems = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(JsonbValue) *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (*pstate)-&gt;size);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WJB_BEGIN_OBJECT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!scalarVal);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *pstate = <a href="#L731" title="utils/adt/jsonb_util.c:731">pushState</a>(pstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = &amp;(*pstate)-&gt;contVal;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (*pstate)-&gt;contVal.type = jbvObject;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (*pstate)-&gt;contVal.val.object.nPairs = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (*pstate)-&gt;size = <span class="Constant">4</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (*pstate)-&gt;contVal.val.object.pairs = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(JsonbPair) *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (*pstate)-&gt;size);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WJB_KEY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(scalarVal-&gt;type == jbvString);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L746" title="utils/adt/jsonb_util.c:746">appendKey</a>(*pstate, scalarVal);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WJB_VALUE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(IsAJsonbScalar(scalarVal));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L775" title="utils/adt/jsonb_util.c:775">appendValue</a>(*pstate, scalarVal);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WJB_ELEM:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(IsAJsonbScalar(scalarVal));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L788" title="utils/adt/jsonb_util.c:788">appendElement</a>(*pstate, scalarVal);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WJB_END_OBJECT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1943" title="utils/adt/jsonb_util.c:1943">uniqueifyJsonbObject</a>(&amp;(*pstate)-&gt;contVal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (*pstate)-&gt;unique_keys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (*pstate)-&gt;skip_nulls);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fall through! */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WJB_END_ARRAY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Steps here common to WJB_END_OBJECT case */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!scalarVal);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = &amp;(*pstate)-&gt;contVal;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Pop stack and <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> current array/object as value in parent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * array/object<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *pstate = (*pstate)-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*pstate)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> ((*pstate)-&gt;contVal.type)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jbvArray:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L788" title="utils/adt/jsonb_util.c:788">appendElement</a>(*pstate, result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jbvObject:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L775" title="utils/adt/jsonb_util.c:775">appendValue</a>(*pstate, result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid jsonb container type&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized jsonb sequential processing token&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>() worker:&nbsp; Iteration-like forming of Jsonb<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> JsonbParseState *<br/></li>
<li><a id="L731">&#x200c;</a><span class="linkable">pushState</span>(JsonbParseState **pstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JsonbParseState *ns = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(JsonbParseState));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ns-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = *pstate;<br/></li>
<li>&nbsp; &nbsp; ns-&gt;unique_keys = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; ns-&gt;skip_nulls = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ns;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>() worker:&nbsp; Append a pair key to state when generating a Jsonb<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L746">&#x200c;</a></span><span class="linkable">appendKey</span>(JsonbParseState *pstate, JsonbValue *string)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JsonbValue *object = &amp;pstate-&gt;contVal;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(object-&gt;type == jbvObject);<br/></li>
<li>&nbsp; &nbsp; Assert(string-&gt;type == jbvString);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (object-&gt;val.object.nPairs &gt;= <a href="#L37" title="utils/adt/jsonb_util.c:37">JSONB_MAX_PAIRS</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;number of jsonb object pairs exceeds the maximum allowed (</span><span class="Special">%zu</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L37" title="utils/adt/jsonb_util.c:37">JSONB_MAX_PAIRS</a>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (object-&gt;val.object.nPairs &gt;= pstate-&gt;size)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pstate-&gt;size *= <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; object-&gt;val.object.pairs = <a href="../mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(object-&gt;val.object.pairs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(JsonbPair) * pstate-&gt;size);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; object-&gt;val.object.pairs[object-&gt;val.object.nPairs].key = *string;<br/></li>
<li>&nbsp; &nbsp; object-&gt;val.object.pairs[object-&gt;val.object.nPairs].order = object-&gt;val.object.nPairs;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>() worker:&nbsp; Append a pair value to state when generating a<br/></li>
<li></span><span class="Comment"> * Jsonb<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L775">&#x200c;</a></span><span class="linkable">appendValue</span>(JsonbParseState *pstate, JsonbValue *scalarVal)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JsonbValue *object = &amp;pstate-&gt;contVal;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(object-&gt;type == jbvObject);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; object-&gt;val.object.pairs[object-&gt;val.object.nPairs++].value = *scalarVal;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L566" title="utils/adt/jsonb_util.c:566">pushJsonbValue</a>() worker:&nbsp; Append an <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> to state when generating a Jsonb<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L788">&#x200c;</a></span><span class="linkable">appendElement</span>(JsonbParseState *pstate, JsonbValue *scalarVal)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JsonbValue *array = &amp;pstate-&gt;contVal;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(array-&gt;type == jbvArray);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (array-&gt;val.array.nElems &gt;= <a href="#L36" title="utils/adt/jsonb_util.c:36">JSONB_MAX_ELEMS</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;number of jsonb array elements exceeds the maximum allowed (</span><span class="Special">%zu</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L36" title="utils/adt/jsonb_util.c:36">JSONB_MAX_ELEMS</a>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (array-&gt;val.array.nElems &gt;= pstate-&gt;size)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pstate-&gt;size *= <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; array-&gt;val.array.elems = <a href="../mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(array-&gt;val.array.elems,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(JsonbValue) * pstate-&gt;size);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; array-&gt;val.array.elems[array-&gt;val.array.nElems++] = *scalarVal;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Given a JsonbContainer, expand to JsonbIterator to iterate over items<br/></li>
<li></span><span class="Comment"> * fully expanded to in-memory representation for manipulation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See <a href="#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a>() for notes on memory management.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>JsonbIterator *<br/></li>
<li><a id="L817">&#x200c;</a><span class="linkable">JsonbIteratorInit</span>(JsonbContainer *container)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L999" title="utils/adt/jsonb_util.c:999">iteratorFromContainer</a>(container, <span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> JsonbValue while iterating<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller should initially pass their own, original iterator.&nbsp; They may get<br/></li>
<li></span><span class="Comment"> * back a child iterator <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>()'d here instead.&nbsp; The function can be relied<br/></li>
<li></span><span class="Comment"> * on to free those child iterators, lest the memory allocated for highly<br/></li>
<li></span><span class="Comment"> * nested objects become unreasonable, but only if callers don't end iteration<br/></li>
<li></span><span class="Comment"> * early (by breaking upon having found something in a search, for example).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Callers in such a scenario, that are particularly sensitive to leaking<br/></li>
<li></span><span class="Comment"> * memory in a long-lived context may walk the ancestral tree from the final<br/></li>
<li></span><span class="Comment"> * iterator we left them with to its oldest ancestor, <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>()ing as they go.<br/></li>
<li></span><span class="Comment"> * They do not have to free <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other memory previously allocated for iterators<br/></li>
<li></span><span class="Comment"> * but not accessible as direct ancestors of the iterator they're last passed<br/></li>
<li></span><span class="Comment"> * back.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns &quot;Jsonb sequential processing&quot; token value.&nbsp; Iterator &quot;state&quot;<br/></li>
<li></span><span class="Comment"> * reflects the current stage of the process in a less granular fashion, and is<br/></li>
<li></span><span class="Comment"> * mostly used here to track things internally with respect to particular<br/></li>
<li></span><span class="Comment"> * iterators.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Clients of this function should not have to handle <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> jbvBinary <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment"> * (since recursive calls will deal with this), provided skipNested is false.<br/></li>
<li></span><span class="Comment"> * It is our job to expand the jbvBinary representation without bothering them<br/></li>
<li></span><span class="Comment"> * with it.&nbsp; However, clients should not take it upon themselves to touch array<br/></li>
<li></span><span class="Comment"> * or Object <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>/pair buffers, since their <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>/pair pointers are<br/></li>
<li></span><span class="Comment"> * garbage.&nbsp; Also, *val will not be set when returning WJB_END_ARRAY or<br/></li>
<li></span><span class="Comment"> * WJB_END_OBJECT, on the assumption that it's only useful to access <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment"> * when recursing in.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>JsonbIteratorToken<br/></li>
<li><a id="L853">&#x200c;</a><span class="linkable">JsonbIteratorNext</span>(JsonbIterator **it, JsonbValue *val, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> skipNested)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*it == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> WJB_DONE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When stepping into a nested container, we jump back here to start<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * processing the child. We will not recurse further in one call, because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * processing the child will always begin in JBI_ARRAY_START or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * JBI_OBJECT_START state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="Statement">recurse</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> ((*it)-&gt;state)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JBI_ARRAY_START:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set v to array on first array call */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val-&gt;type = jbvArray;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val-&gt;val.array.nElems = (*it)-&gt;nElems;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * v-&gt;val.array.elems is not actually set, because we aren't doing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a full conversion<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val-&gt;val.array.rawScalar = (*it)-&gt;isScalar;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (*it)-&gt;curIndex = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (*it)-&gt;curDataOffset = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (*it)-&gt;curValueOffset = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* not actually used */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set state for <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> call */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (*it)-&gt;state = JBI_ARRAY_ELEM;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> WJB_BEGIN_ARRAY;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JBI_ARRAY_ELEM:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((*it)-&gt;curIndex &gt;= (*it)-&gt;nElems)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * All elements within array already processed.&nbsp; Report this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to caller, and give it back original parent iterator (which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * independently tracks iteration progress at its level of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * nesting).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *it = <a href="#L1041" title="utils/adt/jsonb_util.c:1041">freeAndGetParent</a>(*it);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> WJB_END_ARRAY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L505" title="utils/adt/jsonb_util.c:505">fillJsonbValue</a>((*it)-&gt;container, (*it)-&gt;curIndex,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (*it)-&gt;dataProper, (*it)-&gt;curDataOffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; val);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JBE_ADVANCE_OFFSET((*it)-&gt;curDataOffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (*it)-&gt;children[(*it)-&gt;curIndex]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (*it)-&gt;curIndex++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!IsAJsonbScalar(val) &amp;&amp; !skipNested)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Recurse into container. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *it = <a href="#L999" title="utils/adt/jsonb_util.c:999">iteratorFromContainer</a>(val-&gt;val.binary.data, *it);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> recurse;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Scalar item in array, or a container and caller didn't want<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * us to recurse into it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> WJB_ELEM;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JBI_OBJECT_START:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set v to object on first object call */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val-&gt;type = jbvObject;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val-&gt;val.object.nPairs = (*it)-&gt;nElems;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * v-&gt;val.object.pairs is not actually set, because we aren't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * doing a full conversion<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (*it)-&gt;curIndex = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (*it)-&gt;curDataOffset = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (*it)-&gt;curValueOffset = <a href="#L134" title="utils/adt/jsonb_util.c:134">getJsonbOffset</a>((*it)-&gt;container,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (*it)-&gt;nElems);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set state for <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> call */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (*it)-&gt;state = JBI_OBJECT_KEY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> WJB_BEGIN_OBJECT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JBI_OBJECT_KEY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((*it)-&gt;curIndex &gt;= (*it)-&gt;nElems)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * All pairs within object already processed.&nbsp; Report this to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * caller, and give it back original containing iterator<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (which independently tracks iteration progress at its level<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of nesting).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *it = <a href="#L1041" title="utils/adt/jsonb_util.c:1041">freeAndGetParent</a>(*it);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> WJB_END_OBJECT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Return key of a key/value pair.&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L505" title="utils/adt/jsonb_util.c:505">fillJsonbValue</a>((*it)-&gt;container, (*it)-&gt;curIndex,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (*it)-&gt;dataProper, (*it)-&gt;curDataOffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; val);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (val-&gt;type != jbvString)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected jsonb type as object key&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set state for <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> call */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (*it)-&gt;state = JBI_OBJECT_VALUE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> WJB_KEY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JBI_OBJECT_VALUE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set state for <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> call */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (*it)-&gt;state = JBI_OBJECT_KEY;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L505" title="utils/adt/jsonb_util.c:505">fillJsonbValue</a>((*it)-&gt;container, (*it)-&gt;curIndex + (*it)-&gt;nElems,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (*it)-&gt;dataProper, (*it)-&gt;curValueOffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; val);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JBE_ADVANCE_OFFSET((*it)-&gt;curDataOffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (*it)-&gt;children[(*it)-&gt;curIndex]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JBE_ADVANCE_OFFSET((*it)-&gt;curValueOffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (*it)-&gt;children[(*it)-&gt;curIndex + (*it)-&gt;nElems]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (*it)-&gt;curIndex++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Value may be a container, in which case we recurse with new,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * child iterator (unless the caller asked not to, by passing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * skipNested).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!IsAJsonbScalar(val) &amp;&amp; !skipNested)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *it = <a href="#L999" title="utils/adt/jsonb_util.c:999">iteratorFromContainer</a>(val-&gt;val.binary.data, *it);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> recurse;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> WJB_VALUE;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid iterator state&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize an iterator for iterating all elements in a container.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> JsonbIterator *<br/></li>
<li><a id="L999">&#x200c;</a><span class="linkable">iteratorFromContainer</span>(JsonbContainer *container, JsonbIterator *parent)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JsonbIterator *it;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; it = <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(JsonbIterator));<br/></li>
<li>&nbsp; &nbsp; it-&gt;container = container;<br/></li>
<li>&nbsp; &nbsp; it-&gt;parent = parent;<br/></li>
<li>&nbsp; &nbsp; it-&gt;nElems = JsonContainerSize(container);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Array starts just after header */<br/></li>
<li></span>&nbsp; &nbsp; it-&gt;children = container-&gt;children;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (container-&gt;header &amp; (JB_FARRAY | JB_FOBJECT))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JB_FARRAY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; it-&gt;dataProper =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">char</span> *) it-&gt;children + it-&gt;nElems * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(JEntry);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; it-&gt;isScalar = JsonContainerIsScalar(container);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This is either a &quot;raw scalar&quot;, or an array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!it-&gt;isScalar || it-&gt;nElems == <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; it-&gt;state = JBI_ARRAY_START;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JB_FOBJECT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; it-&gt;dataProper =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">char</span> *) it-&gt;children + it-&gt;nElems * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(JEntry) * <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; it-&gt;state = JBI_OBJECT_START;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unknown type of jsonb container&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> it;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a>() worker:&nbsp; &nbsp; Return parent, while freeing memory for current<br/></li>
<li></span><span class="Comment"> * iterator<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> JsonbIterator *<br/></li>
<li><a id="L1041">&#x200c;</a><span class="linkable">freeAndGetParent</span>(JsonbIterator *it)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JsonbIterator *v = it-&gt;parent;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(it);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> v;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Worker for &quot;contains&quot; operator's function<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Formally speaking, containment is top-down, unordered subtree isomorphism.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Takes iterators that belong to some container type.&nbsp; These iterators<br/></li>
<li></span><span class="Comment"> * &quot;belong&quot; to those <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in the sense that they've just been initialized in<br/></li>
<li></span><span class="Comment"> * respect of them by the caller (perhaps in a nested fashion).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * &quot;val&quot; is lhs Jsonb, and mContained is rhs Jsonb when called from top level.<br/></li>
<li></span><span class="Comment"> * We determine if mContained is contained within val.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1062">&#x200c;</a></span><span class="linkable">JsonbDeepContains</span>(JsonbIterator **val, JsonbIterator **mContained)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JsonbValue&nbsp; &nbsp; vval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vcontained;<br/></li>
<li>&nbsp; &nbsp; JsonbIteratorToken rval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rcont;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Guard against stack overflow due to overly complex Jsonb.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Functions called here independently take this precaution, but that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might not be sufficient since this is also a recursive function.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rval = <a href="#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a>(val, &amp;vval, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; rcont = <a href="#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a>(mContained, &amp;vcontained, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rval != rcont)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The differing return <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> can immediately be taken as indicating<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * two differing container types at this nesting level, which is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sufficient reason to give up entirely (but it should be the case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that they're both some container type).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(rval == WJB_BEGIN_OBJECT || rval == WJB_BEGIN_ARRAY);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(rcont == WJB_BEGIN_OBJECT || rcont == WJB_BEGIN_ARRAY);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (rcont == WJB_BEGIN_OBJECT)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(vval.type == jbvObject);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(vcontained.type == jbvObject);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the lhs has fewer pairs than the rhs, it can't possibly contain<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the rhs.&nbsp; (This conclusion is safe only because we de-duplicate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * keys in all Jsonb objects; thus there can be no corresponding<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * optimization in the array case.)&nbsp; The case probably won't arise<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * often, but since it's such a cheap check we may as well make it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (vval.val.object.nPairs &lt; vcontained.val.object.nPairs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Work through rhs &quot;is it contained within?&quot; object */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JsonbValue *lhsVal; <span class="Comment">/* lhsVal is from pair in lhs object */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JsonbValue&nbsp; &nbsp; lhsValBuf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rcont = <a href="#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a>(mContained, &amp;vcontained, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When we get through caller's rhs &quot;is it contained within?&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * object without failing to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> one of its <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * contained.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rcont == WJB_END_OBJECT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(rcont == WJB_KEY);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(vcontained.type == jbvString);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* First, <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> value by key... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lhsVal =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L398" title="utils/adt/jsonb_util.c:398">getKeyJsonValueFromContainer</a>((*val)-&gt;container,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; vcontained.val.string.val,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; vcontained.val.string.len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;lhsValBuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!lhsVal)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ...at this stage it is apparent that there is at least a key<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * match for this rhs pair.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rcont = <a href="#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a>(mContained, &amp;vcontained, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(rcont == WJB_VALUE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Compare rhs pair's value with lhs pair's value just found using<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * key<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lhsVal-&gt;type != vcontained.type)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsAJsonbScalar(lhsVal))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L1401" title="utils/adt/jsonb_util.c:1401">equalsJsonbScalarValue</a>(lhsVal, &amp;vcontained))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Nested container value (object or array) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JsonbIterator *nestval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *nestContained;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(lhsVal-&gt;type == jbvBinary);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(vcontained.type == jbvBinary);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nestval = <a href="#L817" title="utils/adt/jsonb_util.c:817">JsonbIteratorInit</a>(lhsVal-&gt;val.binary.data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nestContained = <a href="#L817" title="utils/adt/jsonb_util.c:817">JsonbIteratorInit</a>(vcontained.val.binary.data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Match &quot;value&quot; side of rhs datum object's pair recursively.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It's a nested structure.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that nesting still has to &quot;match up&quot; at the right<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * nesting sub-levels.&nbsp; However, there need only be zero or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * more matching pairs (or elements) at each nesting level<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (provided the *rhs* pairs/elements *all* match on each<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * level), which enables searching nested structures for a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * single String or other primitive type sub-datum quite<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * effectively (provided the user constructed the rhs nested<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * structure such that we &quot;know where to look&quot;).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In other words, the mapping of container nodes in the rhs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * &quot;vcontained&quot; Jsonb to <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> nodes on the lhs is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * injective, and parent-child edges on the rhs must be mapped<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to parent-child edges on the lhs to satisfy the condition<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of containment (plus of course the mapped nodes must be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L1062" title="utils/adt/jsonb_util.c:1062">JsonbDeepContains</a>(&amp;nestval, &amp;nestContained))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (rcont == WJB_BEGIN_ARRAY)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; JsonbValue *lhsConts = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; nLhsElems = vval.val.array.nElems;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(vval.type == jbvArray);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(vcontained.type == jbvArray);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Handle distinction between &quot;raw scalar&quot; pseudo arrays, and real<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * arrays.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * A raw scalar may contain another raw scalar, and an array may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * contain a raw scalar, but a raw scalar may not contain an array. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't do something like this for the object case, since objects can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * only contain pairs, never raw scalars (a pair is represented by an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rhs object argument with a single contained pair).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (vval.val.array.rawScalar &amp;&amp; !vcontained.val.array.rawScalar)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Work through rhs &quot;is it contained within?&quot; array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rcont = <a href="#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a>(mContained, &amp;vcontained, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When we get through caller's rhs &quot;is it contained within?&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * array without failing to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> one of its <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * contained.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rcont == WJB_END_ARRAY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(rcont == WJB_ELEM);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsAJsonbScalar(&amp;vcontained))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L344" title="utils/adt/jsonb_util.c:344">findJsonbValueFromContainer</a>((*val)-&gt;container,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; JB_FARRAY,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;vcontained))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this is first container found in rhs array (at this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * depth), <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> temp lhs array of containers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lhsConts == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; j = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make room for all possible <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lhsConts = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(JsonbValue) * nLhsElems);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nLhsElems; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Store all lhs elements in temp array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rcont = <a href="#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a>(val, &amp;vval, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(rcont == WJB_ELEM);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (vval.type == jbvBinary)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lhsConts[j++] = vval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No container elements in temp array, so give up <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (j == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We may have only partially filled array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nLhsElems = j;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">XXX</span><span class="Comment">: Nested array containment is O(N^2) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nLhsElems; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Nested container value (object or array) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JsonbIterator *nestval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *nestContained;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; contains;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nestval = <a href="#L817" title="utils/adt/jsonb_util.c:817">JsonbIteratorInit</a>(lhsConts[i].val.binary.data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nestContained = <a href="#L817" title="utils/adt/jsonb_util.c:817">JsonbIteratorInit</a>(vcontained.val.binary.data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; contains = <a href="#L1062" title="utils/adt/jsonb_util.c:1062">JsonbDeepContains</a>(&amp;nestval, &amp;nestContained);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nestval)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(nestval);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nestContained)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(nestContained);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (contains)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Report rhs container value is not contained if couldn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * match rhs container to *some* lhs cont<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i == nLhsElems)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid jsonb container type&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpectedly fell off end of jsonb container&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Hash a JsonbValue scalar value, mixing the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> value into an existing<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> provided by the caller.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Some callers may wish to independently XOR in JB_FOBJECT and JB_FARRAY<br/></li>
<li></span><span class="Comment"> * flags.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1316">&#x200c;</a></span><span class="linkable">JsonbHashScalarValue</span>(<span class="Type">const</span> JsonbValue *scalarVal, uint32 *<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; tmp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Compute <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> value for scalarVal */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (scalarVal-&gt;type)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jbvNull:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp = <span class="Constant">0x01</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jbvString:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp = DatumGetUInt32(hash_any((<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">char</span> *) scalarVal-&gt;val.string.val,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scalarVal-&gt;val.string.len));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jbvNumeric:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> numerics to <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> codes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp = DatumGetUInt32(DirectFunctionCall1(<a href="numeric.c.html#L2697" title="utils/adt/numeric.c:2697">hash_numeric</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NumericGetDatum(scalarVal-&gt;val.<a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jbvBool:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp = scalarVal-&gt;val.boolean ? <span class="Constant">0x02</span> : <span class="Constant">0x04</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid jsonb scalar type&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Combine <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of successive keys, <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> and elements by rotating<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the previous value left 1 <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>, then XOR'ing in the new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * key/value/<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>'s <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; *<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> = pg_rotate_left32(*<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; *<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> ^= tmp;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Hash a value to a 64-<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> value, with a seed. Otherwise, similar to<br/></li>
<li></span><span class="Comment"> * <a href="#L1316" title="utils/adt/jsonb_util.c:1316">JsonbHashScalarValue</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1359">&#x200c;</a></span><span class="linkable">JsonbHashScalarValueExtended</span>(<span class="Type">const</span> JsonbValue *scalarVal, uint64 *<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; uint64 seed)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; tmp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (scalarVal-&gt;type)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jbvNull:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp = seed + <span class="Constant">0x01</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jbvString:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp = DatumGetUInt64(hash_any_extended((<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">char</span> *) scalarVal-&gt;val.string.val,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; scalarVal-&gt;val.string.len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; seed));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jbvNumeric:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp = DatumGetUInt64(DirectFunctionCall2(<a href="numeric.c.html#L2777" title="utils/adt/numeric.c:2777">hash_numeric_extended</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NumericGetDatum(scalarVal-&gt;val.<a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; UInt64GetDatum(seed)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jbvBool:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (seed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp = DatumGetUInt64(DirectFunctionCall2(<a href="../../access/hash/hashfunc.c.html#L53" title="access/hash/hashfunc.c:53">hashcharextended</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BoolGetDatum(scalarVal-&gt;val.boolean),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; UInt64GetDatum(seed)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp = scalarVal-&gt;val.boolean ? <span class="Constant">0x02</span> : <span class="Constant">0x04</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid jsonb scalar type&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> = ROTATE_HIGH_AND_LOW_32BITS(*<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>);<br/></li>
<li>&nbsp; &nbsp; *<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> ^= tmp;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Are two scalar JsonbValues of the same type a and b <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1401">&#x200c;</a></span><span class="linkable">equalsJsonbScalarValue</span>(JsonbValue *a, JsonbValue *b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;type == b-&gt;type)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (a-&gt;type)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jbvNull:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jbvString:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1880" title="utils/adt/jsonb_util.c:1880">lengthCompareJsonbStringValue</a>(a, b) == <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jbvNumeric:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DatumGetBool(DirectFunctionCall2(<a href="numeric.c.html#L2415" title="utils/adt/numeric.c:2415">numeric_eq</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(a-&gt;val.<a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(b-&gt;val.<a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jbvBool:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> a-&gt;val.boolean == b-&gt;val.boolean;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid jsonb scalar type&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;jsonb scalar type mismatch&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compare two scalar JsonbValues, returning -1, 0, or 1.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Strings are compared using the default collation.&nbsp; Used by B-tree<br/></li>
<li></span><span class="Comment"> * operators, where a lexical sort order is generally expected.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1433">&#x200c;</a></span><span class="linkable">compareJsonbScalarValue</span>(JsonbValue *a, JsonbValue *b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;type == b-&gt;type)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (a-&gt;type)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jbvNull:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jbvString:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="varlena.c.html#L1539" title="utils/adt/varlena.c:1539">varstr_cmp</a>(a-&gt;val.string.val,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a-&gt;val.string.len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b-&gt;val.string.val,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b-&gt;val.string.len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DEFAULT_COLLATION_OID);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jbvNumeric:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DatumGetInt32(DirectFunctionCall2(<a href="numeric.c.html#L2399" title="utils/adt/numeric.c:2399">numeric_cmp</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PointerGetDatum(a-&gt;val.<a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PointerGetDatum(b-&gt;val.<a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jbvBool:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;val.boolean == b-&gt;val.boolean)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (a-&gt;val.boolean &gt; b-&gt;val.boolean)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid jsonb scalar type&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;jsonb scalar type mismatch&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Functions for manipulating the resizable buffer used by convertJsonb and<br/></li>
<li></span><span class="Comment"> * its subroutines.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Reserve 'len' bytes, at the end of the buffer, enlarging it if necessary.<br/></li>
<li></span><span class="Comment"> * Returns the offset to the reserved area. The caller is expected to fill<br/></li>
<li></span><span class="Comment"> * the reserved area later with <a href="#L1504" title="utils/adt/jsonb_util.c:1504">copyToBuffer</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1478">&#x200c;</a></span><span class="linkable">reserveFromBuffer</span>(StringInfo buffer, <span class="Type">int</span> len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make more room if needed */<br/></li>
<li></span>&nbsp; &nbsp; enlargeStringInfo(buffer, len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* remember current offset */<br/></li>
<li></span>&nbsp; &nbsp; offset = buffer-&gt;len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* reserve the space */<br/></li>
<li></span>&nbsp; &nbsp; buffer-&gt;len += len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Keep a trailing null in place, even though it's not useful for us; it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * seems best to preserve the invariants of StringInfos.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; buffer-&gt;data[buffer-&gt;len] = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> offset;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Copy 'len' bytes to a previously reserved area in buffer.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1504">&#x200c;</a></span><span class="linkable">copyToBuffer</span>(StringInfo buffer, <span class="Type">int</span> offset, <span class="Type">const</span> <span class="Type">char</span> *data, <span class="Type">int</span> len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; memcpy(buffer-&gt;data + offset, data, len);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * A shorthand for <a href="#L1478" title="utils/adt/jsonb_util.c:1478">reserveFromBuffer</a> + <a href="#L1504" title="utils/adt/jsonb_util.c:1504">copyToBuffer</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1513">&#x200c;</a></span><span class="linkable">appendToBuffer</span>(StringInfo buffer, <span class="Type">const</span> <span class="Type">char</span> *data, <span class="Type">int</span> len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; offset = <a href="#L1478" title="utils/adt/jsonb_util.c:1478">reserveFromBuffer</a>(buffer, len);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1504" title="utils/adt/jsonb_util.c:1504">copyToBuffer</a>(buffer, offset, data, len);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Append padding, so that the length of the StringInfo is int-aligned.<br/></li>
<li></span><span class="Comment"> * Returns the number of padding bytes appended.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">short<br/></li>
<li><a id="L1527">&#x200c;</a></span><span class="linkable">padBufferToInt</span>(StringInfo buffer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; padlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; padlen = INTALIGN(buffer-&gt;len) - buffer-&gt;len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; offset = <a href="#L1478" title="utils/adt/jsonb_util.c:1478">reserveFromBuffer</a>(buffer, padlen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* padlen must be small, so this is probably faster than a memset */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (p = <span class="Constant">0</span>; p &lt; padlen; p++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buffer-&gt;data[offset + p] = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> padlen;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Given a JsonbValue, convert to Jsonb. The result is <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Jsonb *<br/></li>
<li><a id="L1548">&#x200c;</a><span class="linkable">convertToJsonb</span>(JsonbValue *val)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfoData buffer;<br/></li>
<li>&nbsp; &nbsp; JEntry&nbsp; &nbsp; &nbsp; &nbsp; jentry;<br/></li>
<li>&nbsp; &nbsp; Jsonb&nbsp; &nbsp; &nbsp;&nbsp; *res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Should not already have binary representation */<br/></li>
<li></span>&nbsp; &nbsp; Assert(val-&gt;type != jbvBinary);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allocate an output buffer. It will be enlarged as needed */<br/></li>
<li></span>&nbsp; &nbsp; initStringInfo(&amp;buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make room for the varlena header */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1478" title="utils/adt/jsonb_util.c:1478">reserveFromBuffer</a>(&amp;buffer, VARHDRSZ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1590" title="utils/adt/jsonb_util.c:1590">convertJsonbValue</a>(&amp;buffer, &amp;jentry, val, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: the JEntry of the root is discarded. Therefore the root<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * JsonbContainer struct must contain enough information to tell what kind<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of value it is.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; res = (Jsonb *) buffer.data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(res, buffer.len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Subroutine of convertJsonb: serialize a single JsonbValue into buffer.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The JEntry header for this node is returned in *header.&nbsp; It is filled in<br/></li>
<li></span><span class="Comment"> * with the length of this value and appropriate type bits.&nbsp; If we wish to<br/></li>
<li></span><span class="Comment"> * store an end offset rather than a length, it is the caller's responsibility<br/></li>
<li></span><span class="Comment"> * to adjust for that.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the value is an array or an object, this recurses. 'level' is only used<br/></li>
<li></span><span class="Comment"> * for debugging purposes.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1590">&#x200c;</a></span><span class="linkable">convertJsonbValue</span>(StringInfo buffer, JEntry *header, JsonbValue *val, <span class="Type">int</span> level)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!val)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * A JsonbValue passed as val should never have a type of jbvBinary, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * neither should <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of its sub-components. Those <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> will be produced<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * by <a href="#L1615" title="utils/adt/jsonb_util.c:1615">convertJsonbArray</a> and <a href="#L1699" title="utils/adt/jsonb_util.c:1699">convertJsonbObject</a>, the results of which will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not be passed back to this function as an argument.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsAJsonbScalar(val))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1815" title="utils/adt/jsonb_util.c:1815">convertJsonbScalar</a>(buffer, header, val);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (val-&gt;type == jbvArray)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1615" title="utils/adt/jsonb_util.c:1615">convertJsonbArray</a>(buffer, header, val, level);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (val-&gt;type == jbvObject)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1699" title="utils/adt/jsonb_util.c:1699">convertJsonbObject</a>(buffer, header, val, level);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unknown type of jsonb container to convert&quot;</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1615">&#x200c;</a></span><span class="linkable">convertJsonbArray</span>(StringInfo buffer, JEntry *header, JsonbValue *val, <span class="Type">int</span> level)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; base_offset;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jentry_offset;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; totallen;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; containerhead;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nElems = val-&gt;val.array.nElems;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Remember where in the buffer this array starts. */<br/></li>
<li></span>&nbsp; &nbsp; base_offset = buffer-&gt;len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Align to 4-byte boundary (<a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> padding counts as part of my data) */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1527" title="utils/adt/jsonb_util.c:1527">padBufferToInt</a>(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Construct the header Jentry and store it in the beginning of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * variable-length payload.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; containerhead = nElems | JB_FARRAY;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (val-&gt;val.array.rawScalar)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(nElems == <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(level == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; containerhead |= JB_FSCALAR;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1513" title="utils/adt/jsonb_util.c:1513">appendToBuffer</a>(buffer, (<span class="Type">char</span> *) &amp;containerhead, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reserve space for the JEntries of the elements. */<br/></li>
<li></span>&nbsp; &nbsp; jentry_offset = <a href="#L1478" title="utils/adt/jsonb_util.c:1478">reserveFromBuffer</a>(buffer, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(JEntry) * nElems);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; totallen = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nElems; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; JsonbValue *elem = &amp;val-&gt;val.array.elems[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; JEntry&nbsp; &nbsp; &nbsp; &nbsp; meta;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Convert <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>, producing a JEntry and appending its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * variable-length data to buffer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1590" title="utils/adt/jsonb_util.c:1590">convertJsonbValue</a>(buffer, &amp;meta, elem, level + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len = JBE_OFFLENFLD(meta);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; totallen += len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Bail out if total variable-length data exceeds what will fit in a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * JEntry length field.&nbsp; We check this in each iteration, not just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * once at the end, to forestall possible integer overflow.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (totallen &gt; JENTRY_OFFLENMASK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;total size of jsonb array elements exceeds the maximum of </span><span class="Special">%d</span><span class="Constant"> bytes&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JENTRY_OFFLENMASK)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Convert each JB_OFFSET_STRIDE'th length to an offset.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((i % JB_OFFSET_STRIDE) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; meta = (meta &amp; JENTRY_TYPEMASK) | totallen | JENTRY_HAS_OFF;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1504" title="utils/adt/jsonb_util.c:1504">copyToBuffer</a>(buffer, jentry_offset, (<span class="Type">char</span> *) &amp;meta, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(JEntry));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; jentry_offset += <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(JEntry);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Total data size is everything we've appended to buffer */<br/></li>
<li></span>&nbsp; &nbsp; totallen = buffer-&gt;len - base_offset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check length again, since we didn't include the metadata above */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (totallen &gt; JENTRY_OFFLENMASK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;total size of jsonb array elements exceeds the maximum of </span><span class="Special">%d</span><span class="Constant"> bytes&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JENTRY_OFFLENMASK)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize the header of this node in the container's JEntry array */<br/></li>
<li></span>&nbsp; &nbsp; *header = JENTRY_ISCONTAINER | totallen;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1699">&#x200c;</a></span><span class="linkable">convertJsonbObject</span>(StringInfo buffer, JEntry *header, JsonbValue *val, <span class="Type">int</span> level)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; base_offset;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jentry_offset;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; totallen;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; containerheader;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nPairs = val-&gt;val.object.nPairs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Remember where in the buffer this object starts. */<br/></li>
<li></span>&nbsp; &nbsp; base_offset = buffer-&gt;len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Align to 4-byte boundary (<a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> padding counts as part of my data) */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1527" title="utils/adt/jsonb_util.c:1527">padBufferToInt</a>(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Construct the header Jentry and store it in the beginning of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * variable-length payload.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; containerheader = nPairs | JB_FOBJECT;<br/></li>
<li>&nbsp; &nbsp; <a href="#L1513" title="utils/adt/jsonb_util.c:1513">appendToBuffer</a>(buffer, (<span class="Type">char</span> *) &amp;containerheader, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reserve space for the JEntries of the keys and <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>. */<br/></li>
<li></span>&nbsp; &nbsp; jentry_offset = <a href="#L1478" title="utils/adt/jsonb_util.c:1478">reserveFromBuffer</a>(buffer, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(JEntry) * nPairs * <span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Iterate over the keys, then over the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, since that is the ordering<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we want in the on-disk representation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; totallen = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nPairs; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; JsonbPair&nbsp; *pair = &amp;val-&gt;val.object.pairs[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; JEntry&nbsp; &nbsp; &nbsp; &nbsp; meta;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Convert key, producing a JEntry and appending its variable-length<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * data to buffer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1815" title="utils/adt/jsonb_util.c:1815">convertJsonbScalar</a>(buffer, &amp;meta, &amp;pair-&gt;key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len = JBE_OFFLENFLD(meta);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; totallen += len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Bail out if total variable-length data exceeds what will fit in a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * JEntry length field.&nbsp; We check this in each iteration, not just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * once at the end, to forestall possible integer overflow.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (totallen &gt; JENTRY_OFFLENMASK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;total size of jsonb object elements exceeds the maximum of </span><span class="Special">%d</span><span class="Constant"> bytes&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JENTRY_OFFLENMASK)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Convert each JB_OFFSET_STRIDE'th length to an offset.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((i % JB_OFFSET_STRIDE) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; meta = (meta &amp; JENTRY_TYPEMASK) | totallen | JENTRY_HAS_OFF;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1504" title="utils/adt/jsonb_util.c:1504">copyToBuffer</a>(buffer, jentry_offset, (<span class="Type">char</span> *) &amp;meta, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(JEntry));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; jentry_offset += <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(JEntry);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nPairs; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; JsonbPair&nbsp; *pair = &amp;val-&gt;val.object.pairs[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; JEntry&nbsp; &nbsp; &nbsp; &nbsp; meta;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Convert value, producing a JEntry and appending its variable-length<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * data to buffer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1590" title="utils/adt/jsonb_util.c:1590">convertJsonbValue</a>(buffer, &amp;meta, &amp;pair-&gt;value, level + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len = JBE_OFFLENFLD(meta);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; totallen += len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Bail out if total variable-length data exceeds what will fit in a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * JEntry length field.&nbsp; We check this in each iteration, not just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * once at the end, to forestall possible integer overflow.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (totallen &gt; JENTRY_OFFLENMASK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;total size of jsonb object elements exceeds the maximum of </span><span class="Special">%d</span><span class="Constant"> bytes&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JENTRY_OFFLENMASK)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Convert each JB_OFFSET_STRIDE'th length to an offset.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (((i + nPairs) % JB_OFFSET_STRIDE) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; meta = (meta &amp; JENTRY_TYPEMASK) | totallen | JENTRY_HAS_OFF;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1504" title="utils/adt/jsonb_util.c:1504">copyToBuffer</a>(buffer, jentry_offset, (<span class="Type">char</span> *) &amp;meta, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(JEntry));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; jentry_offset += <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(JEntry);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Total data size is everything we've appended to buffer */<br/></li>
<li></span>&nbsp; &nbsp; totallen = buffer-&gt;len - base_offset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check length again, since we didn't include the metadata above */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (totallen &gt; JENTRY_OFFLENMASK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;total size of jsonb object elements exceeds the maximum of </span><span class="Special">%d</span><span class="Constant"> bytes&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JENTRY_OFFLENMASK)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize the header of this node in the container's JEntry array */<br/></li>
<li></span>&nbsp; &nbsp; *header = JENTRY_ISCONTAINER | totallen;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1815">&#x200c;</a></span><span class="linkable">convertJsonbScalar</span>(StringInfo buffer, JEntry *header, JsonbValue *scalarVal)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">short</span>&nbsp; &nbsp; &nbsp; &nbsp; padlen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (scalarVal-&gt;type)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jbvNull:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *header = JENTRY_ISNULL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jbvString:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1513" title="utils/adt/jsonb_util.c:1513">appendToBuffer</a>(buffer, scalarVal-&gt;val.string.val, scalarVal-&gt;val.string.len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *header = scalarVal-&gt;val.string.len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jbvNumeric:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numlen = VARSIZE_ANY(scalarVal-&gt;val.<a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; padlen = <a href="#L1527" title="utils/adt/jsonb_util.c:1527">padBufferToInt</a>(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1513" title="utils/adt/jsonb_util.c:1513">appendToBuffer</a>(buffer, (<span class="Type">char</span> *) scalarVal-&gt;val.<a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a>, numlen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *header = JENTRY_ISNUMERIC | (padlen + numlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jbvBool:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *header = (scalarVal-&gt;val.boolean) ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JENTRY_ISBOOL_TRUE : JENTRY_ISBOOL_FALSE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jbvDatetime:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; buf[MAXDATELEN + <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="json.c.html#L301" title="utils/adt/json.c:301">JsonEncodeDateTime</a>(buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; scalarVal-&gt;val.datetime.value,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; scalarVal-&gt;val.datetime.typid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;scalarVal-&gt;val.datetime.tz);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len = strlen(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1513" title="utils/adt/jsonb_util.c:1513">appendToBuffer</a>(buffer, buf, len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *header = len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid jsonb scalar type&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compare two jbvString JsonbValue <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, a and b.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is a special qsort() comparator used to sort strings in certain<br/></li>
<li></span><span class="Comment"> * <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> contexts where it is sufficient to have a well-defined sort order.<br/></li>
<li></span><span class="Comment"> * In particular, object pair keys are sorted according to this criteria to<br/></li>
<li></span><span class="Comment"> * facilitate cheap binary searches where we don't care about lexical sort<br/></li>
<li></span><span class="Comment"> * order.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * a and b are first sorted based on their length.&nbsp; If a tie-breaker is<br/></li>
<li></span><span class="Comment"> * required, only then do we consider string binary equality.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1880">&#x200c;</a></span><span class="linkable">lengthCompareJsonbStringValue</span>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> JsonbValue *va = (<span class="Type">const</span> JsonbValue *) a;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> JsonbValue *vb = (<span class="Type">const</span> JsonbValue *) b;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(va-&gt;type == jbvString);<br/></li>
<li>&nbsp; &nbsp; Assert(vb-&gt;type == jbvString);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1899" title="utils/adt/jsonb_util.c:1899">lengthCompareJsonbString</a>(va-&gt;val.string.val, va-&gt;val.string.len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vb-&gt;val.string.val, vb-&gt;val.string.len);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Subroutine for <a href="#L1880" title="utils/adt/jsonb_util.c:1880">lengthCompareJsonbStringValue</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is also useful separately to implement binary search on<br/></li>
<li></span><span class="Comment"> * JsonbContainers.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1899">&#x200c;</a></span><span class="linkable">lengthCompareJsonbString</span>(<span class="Type">const</span> <span class="Type">char</span> *val1, <span class="Type">int</span> len1, <span class="Type">const</span> <span class="Type">char</span> *val2, <span class="Type">int</span> len2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (len1 == len2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> memcmp(val1, val2, len1);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> len1 &gt; len2 ? <span class="Constant">1</span> : -<span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * qsort_arg() comparator to <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> JsonbPair <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Third argument 'binequal' may point to a <a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a>. If it's set, *binequal is set<br/></li>
<li></span><span class="Comment"> * to true iff a and b have full binary equality, since some callers have an<br/></li>
<li></span><span class="Comment"> * interest in whether the two <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> or merely equivalent.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * N.B: String comparisons here are &quot;length-wise&quot;<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Pairs with equals keys are ordered such that the order field is respected.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1919">&#x200c;</a></span><span class="linkable">lengthCompareJsonbPair</span>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b, <span class="Type">void</span> *binequal)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> JsonbPair *pa = (<span class="Type">const</span> JsonbPair *) a;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> JsonbPair *pb = (<span class="Type">const</span> JsonbPair *) b;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="#L1880" title="utils/adt/jsonb_util.c:1880">lengthCompareJsonbStringValue</a>(&amp;pa-&gt;key, &amp;pb-&gt;key);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (res == <span class="Constant">0</span> &amp;&amp; binequal)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *((<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) binequal) = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Guarantee keeping order of <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> pair.&nbsp; Unique algorithm will prefer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * first <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> as value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (res == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res = (pa-&gt;order &gt; pb-&gt;order) ? -<span class="Constant">1</span> : <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Sort and unique-ify pairs in JsonbValue object<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1943">&#x200c;</a></span><span class="linkable">uniqueifyJsonbObject</span>(JsonbValue *object, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> unique_keys, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> skip_nulls)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; hasNonUniq = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(object-&gt;type == jbvObject);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (object-&gt;val.object.nPairs &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qsort_arg(object-&gt;val.object.pairs, object-&gt;val.object.nPairs, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(JsonbPair),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1919" title="utils/adt/jsonb_util.c:1919">lengthCompareJsonbPair</a>, &amp;hasNonUniq);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (hasNonUniq &amp;&amp; unique_keys)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DUPLICATE_JSON_OBJECT_KEY_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;duplicate JSON object key value&quot;</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (hasNonUniq || skip_nulls)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; JsonbPair&nbsp; *ptr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (skip_nulls &amp;&amp; object-&gt;val.object.nPairs &gt; <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; object-&gt;val.object.pairs-&gt;value.type == jbvNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If skip_nulls is true, remove leading items with null */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; object-&gt;val.object.pairs++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; object-&gt;val.object.nPairs--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (object-&gt;val.object.nPairs &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr = object-&gt;val.object.pairs + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = object-&gt;val.object.pairs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (ptr - object-&gt;val.object.pairs &lt; object-&gt;val.object.nPairs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Avoid copying over duplicate or null */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1880" title="utils/adt/jsonb_util.c:1880">lengthCompareJsonbStringValue</a>(ptr, res) != <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (!skip_nulls || ptr-&gt;value.type != jbvNull))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ptr != res)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(res, ptr, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(JsonbPair));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; object-&gt;val.object.nPairs = res + <span class="Constant">1</span> - object-&gt;val.object.pairs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
