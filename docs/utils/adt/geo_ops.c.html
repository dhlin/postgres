<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/adt/geo_ops.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/adt/geo_ops.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L73">path_delim</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L658">box_above</a></li>
<li><a href="#L731">box_above_eq</a></li>
<li><a href="#L4231">box_add</a></li>
<li><a href="#L863">box_ar</a></li>
<li><a href="#L796">box_area</a></li>
<li><a href="#L635">box_below</a></li>
<li><a href="#L722">box_below_eq</a></li>
<li><a href="#L849">box_center</a></li>
<li><a href="#L5208">box_circle</a></li>
<li><a href="#L3013">box_closept_lseg</a></li>
<li><a href="#L2878">box_closept_point</a></li>
<li><a href="#L872">box_cn</a></li>
<li><a href="#L518">box_construct</a></li>
<li><a href="#L692">box_contain</a></li>
<li><a href="#L704">box_contain_box</a></li>
<li><a href="#L3217">box_contain_lseg</a></li>
<li><a href="#L3130">box_contain_point</a></li>
<li><a href="#L3146">box_contain_pt</a></li>
<li><a href="#L681">box_contained</a></li>
<li><a href="#L933">box_diagonal</a></li>
<li><a href="#L832">box_distance</a></li>
<li><a href="#L4280">box_div</a></li>
<li><a href="#L762">box_eq</a></li>
<li><a href="#L780">box_ge</a></li>
<li><a href="#L753">box_gt</a></li>
<li><a href="#L820">box_height</a></li>
<li><a href="#L893">box_ht</a></li>
<li><a href="#L422">box_in</a></li>
<li><a href="#L3263">box_interpt_lseg</a></li>
<li><a href="#L908">box_intersect</a></li>
<li><a href="#L771">box_le</a></li>
<li><a href="#L583">box_left</a></li>
<li><a href="#L744">box_lt</a></li>
<li><a href="#L4261">box_mul</a></li>
<li><a href="#L455">box_out</a></li>
<li><a href="#L572">box_ov</a></li>
<li><a href="#L670">box_overabove</a></li>
<li><a href="#L647">box_overbelow</a></li>
<li><a href="#L563">box_overlap</a></li>
<li><a href="#L598">box_overleft</a></li>
<li><a href="#L624">box_overright</a></li>
<li><a href="#L4535">box_poly</a></li>
<li><a href="#L466">box_recv</a></li>
<li><a href="#L609">box_right</a></li>
<li><a href="#L551">box_same</a></li>
<li><a href="#L501">box_send</a></li>
<li><a href="#L4246">box_sub</a></li>
<li><a href="#L883">box_wd</a></li>
<li><a href="#L808">box_width</a></li>
<li><a href="#L4321">boxes_bound_box</a></li>
<li><a href="#L4863">circle_above</a></li>
<li><a href="#L4965">circle_add_pt</a></li>
<li><a href="#L5159">circle_ar</a></li>
<li><a href="#L5032">circle_area</a></li>
<li><a href="#L4851">circle_below</a></li>
<li><a href="#L5186">circle_box</a></li>
<li><a href="#L5143">circle_center</a></li>
<li><a href="#L4838">circle_contain</a></li>
<li><a href="#L5082">circle_contain_pt</a></li>
<li><a href="#L4826">circle_contained</a></li>
<li><a href="#L5043">circle_diameter</a></li>
<li><a href="#L5066">circle_distance</a></li>
<li><a href="#L5014">circle_div_pt</a></li>
<li><a href="#L4903">circle_eq</a></li>
<li><a href="#L4948">circle_ge</a></li>
<li><a href="#L4930">circle_gt</a></li>
<li><a href="#L4611">circle_in</a></li>
<li><a href="#L4939">circle_le</a></li>
<li><a href="#L4789">circle_left</a></li>
<li><a href="#L4921">circle_lt</a></li>
<li><a href="#L4999">circle_mul_pt</a></li>
<li><a href="#L4912">circle_ne</a></li>
<li><a href="#L4681">circle_out</a></li>
<li><a href="#L4889">circle_overabove</a></li>
<li><a href="#L4876">circle_overbelow</a></li>
<li><a href="#L4764">circle_overlap</a></li>
<li><a href="#L4777">circle_overleft</a></li>
<li><a href="#L4814">circle_overright</a></li>
<li><a href="#L5225">circle_poly</a></li>
<li><a href="#L5054">circle_radius</a></li>
<li><a href="#L4703">circle_recv</a></li>
<li><a href="#L4801">circle_right</a></li>
<li><a href="#L4751">circle_same</a></li>
<li><a href="#L4727">circle_send</a></li>
<li><a href="#L4980">circle_sub_pt</a></li>
<li><a href="#L2988">close_ls</a></li>
<li><a href="#L2853">close_lseg</a></li>
<li><a href="#L2933">close_pb</a></li>
<li><a href="#L2750">close_pl</a></li>
<li><a href="#L2791">close_ps</a></li>
<li><a href="#L3063">close_sb</a></li>
<li><a href="#L4096">construct_point</a></li>
<li><a href="#L5170">cr_circle</a></li>
<li><a href="#L2514">dist_bp</a></li>
<li><a href="#L2562">dist_bs</a></li>
<li><a href="#L5127">dist_cpoint</a></li>
<li><a href="#L2588">dist_cpoly</a></li>
<li><a href="#L2571">dist_cpoly_internal</a></li>
<li><a href="#L2402">dist_lp</a></li>
<li><a href="#L2538">dist_ls</a></li>
<li><a href="#L2490">dist_pathp</a></li>
<li><a href="#L2502">dist_pb</a></li>
<li><a href="#L5109">dist_pc</a></li>
<li><a href="#L2390">dist_pl</a></li>
<li><a href="#L2600">dist_polyc</a></li>
<li><a href="#L2621">dist_polyp</a></li>
<li><a href="#L2478">dist_ppath</a></li>
<li><a href="#L2435">dist_ppath_internal</a></li>
<li><a href="#L2612">dist_ppoly</a></li>
<li><a href="#L2630">dist_ppoly_internal</a></li>
<li><a href="#L2414">dist_ps</a></li>
<li><a href="#L2550">dist_sb</a></li>
<li><a href="#L2526">dist_sl</a></li>
<li><a href="#L2426">dist_sp</a></li>
<li><a href="#L3328">inter_lb</a></li>
<li><a href="#L3315">inter_sb</a></li>
<li><a href="#L3238">inter_sl</a></li>
<li><a href="#L2724">line_closept_point</a></li>
<li><a href="#L1083">line_construct</a></li>
<li><a href="#L1115">line_construct_pp</a></li>
<li><a href="#L3087">line_contain_point</a></li>
<li><a href="#L950">line_decode</a></li>
<li><a href="#L1261">line_distance</a></li>
<li><a href="#L1194">line_eq</a></li>
<li><a href="#L1182">line_horizontal</a></li>
<li><a href="#L979">line_in</a></li>
<li><a href="#L1286">line_interpt</a></li>
<li><a href="#L1314">line_interpt_line</a></li>
<li><a href="#L1137">line_intersect</a></li>
<li><a href="#L1247">line_invsl</a></li>
<li><a href="#L1023">line_out</a></li>
<li><a href="#L1146">line_parallel</a></li>
<li><a href="#L1155">line_perp</a></li>
<li><a href="#L1038">line_recv</a></li>
<li><a href="#L1061">line_send</a></li>
<li><a href="#L1233">line_sl</a></li>
<li><a href="#L1174">line_vertical</a></li>
<li><a href="#L2316">lseg_center</a></li>
<li><a href="#L2960">lseg_closept_line</a></li>
<li><a href="#L2810">lseg_closept_lseg</a></li>
<li><a href="#L2772">lseg_closept_point</a></li>
<li><a href="#L2129">lseg_construct</a></li>
<li><a href="#L3109">lseg_contain_point</a></li>
<li><a href="#L5397">lseg_crossing</a></li>
<li><a href="#L2306">lseg_distance</a></li>
<li><a href="#L2236">lseg_eq</a></li>
<li><a href="#L2286">lseg_ge</a></li>
<li><a href="#L2276">lseg_gt</a></li>
<li><a href="#L2227">lseg_horizontal</a></li>
<li><a href="#L2065">lseg_in</a></li>
<li><a href="#L3866">lseg_inside_poly</a></li>
<li><a href="#L2361">lseg_interpt</a></li>
<li><a href="#L2675">lseg_interpt_line</a></li>
<li><a href="#L2338">lseg_interpt_lseg</a></li>
<li><a href="#L2188">lseg_intersect</a></li>
<li><a href="#L2165">lseg_invsl</a></li>
<li><a href="#L2266">lseg_le</a></li>
<li><a href="#L2172">lseg_length</a></li>
<li><a href="#L2256">lseg_lt</a></li>
<li><a href="#L2246">lseg_ne</a></li>
<li><a href="#L2081">lseg_out</a></li>
<li><a href="#L2198">lseg_parallel</a></li>
<li><a href="#L2210">lseg_perp</a></li>
<li><a href="#L2092">lseg_recv</a></li>
<li><a href="#L2111">lseg_send</a></li>
<li><a href="#L2155">lseg_sl</a></li>
<li><a href="#L2219">lseg_vertical</a></li>
<li><a href="#L3376">make_bound_box</a></li>
<li><a href="#L3137">on_pb</a></li>
<li><a href="#L3095">on_pl</a></li>
<li><a href="#L3166">on_ppath</a></li>
<li><a href="#L3117">on_ps</a></li>
<li><a href="#L3224">on_sb</a></li>
<li><a href="#L3201">on_sl</a></li>
<li><a href="#L392">pair_count</a></li>
<li><a href="#L212">pair_decode</a></li>
<li><a href="#L255">pair_encode</a></li>
<li><a href="#L4348">path_add</a></li>
<li><a href="#L4396">path_add_pt</a></li>
<li><a href="#L1380">path_area</a></li>
<li><a href="#L1627">path_close</a></li>
<li><a href="#L266">path_decode</a></li>
<li><a href="#L1730">path_distance</a></li>
<li><a href="#L4438">path_div_pt</a></li>
<li><a href="#L340">path_encode</a></li>
<li><a href="#L1402">path_in</a></li>
<li><a href="#L1653">path_inter</a></li>
<li><a href="#L1602">path_isclosed</a></li>
<li><a href="#L1610">path_isopen</a></li>
<li><a href="#L1792">path_length</a></li>
<li><a href="#L4425">path_mul_pt</a></li>
<li><a href="#L1571">path_n_eq</a></li>
<li><a href="#L1589">path_n_ge</a></li>
<li><a href="#L1562">path_n_gt</a></li>
<li><a href="#L1580">path_n_le</a></li>
<li><a href="#L1553">path_n_lt</a></li>
<li><a href="#L1618">path_npoints</a></li>
<li><a href="#L1637">path_open</a></li>
<li><a href="#L1474">path_out</a></li>
<li><a href="#L4452">path_poly</a></li>
<li><a href="#L1488">path_recv</a></li>
<li><a href="#L1526">path_send</a></li>
<li><a href="#L4409">path_sub_pt</a></li>
<li><a href="#L5519">pg_hypot</a></li>
<li><a href="#L5457">plist_same</a></li>
<li><a href="#L1919">point_above</a></li>
<li><a href="#L4119">point_add</a></li>
<li><a href="#L4111">point_add_point</a></li>
<li><a href="#L1928">point_below</a></li>
<li><a href="#L4302">point_box</a></li>
<li><a href="#L1884">point_construct</a></li>
<li><a href="#L1993">point_distance</a></li>
<li><a href="#L4196">point_div</a></li>
<li><a href="#L4182">point_div_point</a></li>
<li><a href="#L2002">point_dt</a></li>
<li><a href="#L1955">point_eq</a></li>
<li><a href="#L1977">point_eq_point</a></li>
<li><a href="#L1946">point_horiz</a></li>
<li><a href="#L1831">point_in</a></li>
<li><a href="#L5340">point_inside</a></li>
<li><a href="#L2039">point_invsl</a></li>
<li><a href="#L1901">point_left</a></li>
<li><a href="#L4167">point_mul</a></li>
<li><a href="#L4157">point_mul_point</a></li>
<li><a href="#L1964">point_ne</a></li>
<li><a href="#L1842">point_out</a></li>
<li><a href="#L1853">point_recv</a></li>
<li><a href="#L1910">point_right</a></li>
<li><a href="#L1868">point_send</a></li>
<li><a href="#L2023">point_sl</a></li>
<li><a href="#L2008">point_slope</a></li>
<li><a href="#L4142">point_sub</a></li>
<li><a href="#L4134">point_sub_point</a></li>
<li><a href="#L1937">point_vert</a></li>
<li><a href="#L4217">points_box</a></li>
<li><a href="#L3671">poly_above</a></li>
<li><a href="#L3625">poly_below</a></li>
<li><a href="#L4519">poly_box</a></li>
<li><a href="#L4503">poly_center</a></li>
<li><a href="#L5307">poly_circle</a></li>
<li><a href="#L3966">poly_contain</a></li>
<li><a href="#L3938">poly_contain_poly</a></li>
<li><a href="#L4008">poly_contain_pt</a></li>
<li><a href="#L3988">poly_contained</a></li>
<li><a href="#L4027">poly_distance</a></li>
<li><a href="#L3415">poly_in</a></li>
<li><a href="#L3533">poly_left</a></li>
<li><a href="#L4494">poly_npoints</a></li>
<li><a href="#L3459">poly_out</a></li>
<li><a href="#L3694">poly_overabove</a></li>
<li><a href="#L3648">poly_overbelow</a></li>
<li><a href="#L3801">poly_overlap</a></li>
<li><a href="#L3744">poly_overlap_internal</a></li>
<li><a href="#L3556">poly_overleft</a></li>
<li><a href="#L3602">poly_overright</a></li>
<li><a href="#L4564">poly_path</a></li>
<li><a href="#L3475">poly_recv</a></li>
<li><a href="#L3579">poly_right</a></li>
<li><a href="#L3720">poly_same</a></li>
<li><a href="#L3510">poly_send</a></li>
<li><a href="#L5285">poly_to_circle</a></li>
<li><a href="#L5094">pt_contained_circle</a></li>
<li><a href="#L4017">pt_contained_poly</a></li>
<li><a href="#L194">single_decode</a></li>
<li><a href="#L203">single_encode</a></li>
<li><a href="#L2142">statlseg_construct</a></li>
<li><a href="#L3830">touched_lseg_inside_poly</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L159">DELIM</a></li>
<li><a href="#L157">LDELIM</a></li>
<li><a href="#L162">LDELIM_C</a></li>
<li><a href="#L160">LDELIM_EP</a></li>
<li><a href="#L164">LDELIM_L</a></li>
<li><a href="#L5337">POINT_ON_POLYGON</a></li>
<li><a href="#L158">RDELIM</a></li>
<li><a href="#L163">RDELIM_C</a></li>
<li><a href="#L161">RDELIM_EP</a></li>
<li><a href="#L165">RDELIM_L</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * geo_ops.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; 2D geometric operations<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This module implements the geometric <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> and operators.&nbsp; The<br/></li>
<li></span><span class="Comment"> * geometric types are (from simple to more complicated):<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * - point<br/></li>
<li></span><span class="Comment"> * - line<br/></li>
<li></span><span class="Comment"> * - line segment<br/></li>
<li></span><span class="Comment"> * - box<br/></li>
<li></span><span class="Comment"> * - circle<br/></li>
<li></span><span class="Comment"> * - polygon<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/adt/geo_ops.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;math.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;limits.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;float.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;ctype.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;libpq/pqformat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/miscnodes.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/float.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgrprotos.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/geo_decls.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;varatt.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * * Type constructors have this form:<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; void type_construct(Type *result, ...);<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * * Operators commonly have signatures such as<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; void type1_operator_type2(Type *result, Type1 *obj1, Type2 *obj2);<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Common operators are:<br/></li>
<li></span><span class="Comment"> * * Intersection point:<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; <a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a> type1_interpt_type2(Point *result, Type1 *obj1, Type2 *obj2);<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Return whether the two objects intersect. If *result is not NULL,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; it is set to the intersection point.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * * Containment:<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; <a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a> type1_contain_type2(Type1 *obj1, Type2 *obj2);<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Return whether obj1 contains obj2.<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; <a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a> type1_contain_type2(Type1 *contains_obj, Type1 *contained_obj);<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Return whether obj1 contains obj2 (used when types are the same)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * * Distance of closest point in or on obj1 to obj2:<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; float8 type1_closept_type2(Point *result, Type1 *obj1, Type2 *obj2);<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns the <a href="../../regex/rege_dfa.c.html#L204" title="regex/rege_dfa.c:204">shortest</a> distance between two objects.&nbsp; If *result is not<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; NULL, it is set to the closest point in or on obj1 to obj2.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * These <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> may be used to implement multiple SQL-level operators.&nbsp; For<br/></li>
<li></span><span class="Comment"> * example, determining whether two lines are parallel is done by checking<br/></li>
<li></span><span class="Comment"> * whether they don't intersect.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Internal routines<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><a id="L73">&#x200c;</a><span class="Type">enum</span> <span class="linkable">path_delim</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PATH_NONE, PATH_OPEN, PATH_CLOSED<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><span class="Comment">/* Routines for points */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void</span> <a href="#L1884" title="utils/adt/geo_ops.c:1884">point_construct</a>(Point *result, float8 x, float8 y);<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void</span> <a href="#L4111" title="utils/adt/geo_ops.c:4111">point_add_point</a>(Point *result, Point *pt1, Point *pt2);<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void</span> <a href="#L4134" title="utils/adt/geo_ops.c:4134">point_sub_point</a>(Point *result, Point *pt1, Point *pt2);<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void</span> <a href="#L4157" title="utils/adt/geo_ops.c:4157">point_mul_point</a>(Point *result, Point *pt1, Point *pt2);<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void</span> <a href="#L4182" title="utils/adt/geo_ops.c:4182">point_div_point</a>(Point *result, Point *pt1, Point *pt2);<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1977" title="utils/adt/geo_ops.c:1977">point_eq_point</a>(Point *pt1, Point *pt2);<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> float8 <a href="#L2002" title="utils/adt/geo_ops.c:2002">point_dt</a>(Point *pt1, Point *pt2);<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> float8 <a href="#L2023" title="utils/adt/geo_ops.c:2023">point_sl</a>(Point *pt1, Point *pt2);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L5340" title="utils/adt/geo_ops.c:5340">point_inside</a>(Point *p, <span class="Type">int</span> npts, Point *plist);<br/></li>
<li><br/></li>
<li><span class="Comment">/* Routines for lines */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void</span> <a href="#L1083" title="utils/adt/geo_ops.c:1083">line_construct</a>(LINE *result, Point *pt, float8 m);<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> float8 <a href="#L1233" title="utils/adt/geo_ops.c:1233">line_sl</a>(LINE *line);<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> float8 <a href="#L1247" title="utils/adt/geo_ops.c:1247">line_invsl</a>(LINE *line);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1314" title="utils/adt/geo_ops.c:1314">line_interpt_line</a>(Point *result, LINE *l1, LINE *l2);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L3087" title="utils/adt/geo_ops.c:3087">line_contain_point</a>(LINE *line, Point *point);<br/></li>
<li><span class="Type">static</span> float8 <a href="#L2724" title="utils/adt/geo_ops.c:2724">line_closept_point</a>(Point *result, LINE *line, Point *point);<br/></li>
<li><br/></li>
<li><span class="Comment">/* Routines for line segments */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void</span> <a href="#L2142" title="utils/adt/geo_ops.c:2142">statlseg_construct</a>(LSEG *lseg, Point *pt1, Point *pt2);<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> float8 <a href="#L2155" title="utils/adt/geo_ops.c:2155">lseg_sl</a>(LSEG *lseg);<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> float8 <a href="#L2165" title="utils/adt/geo_ops.c:2165">lseg_invsl</a>(LSEG *lseg);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2675" title="utils/adt/geo_ops.c:2675">lseg_interpt_line</a>(Point *result, LSEG *lseg, LINE *line);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2338" title="utils/adt/geo_ops.c:2338">lseg_interpt_lseg</a>(Point *result, LSEG *l1, LSEG *l2);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L5397" title="utils/adt/geo_ops.c:5397">lseg_crossing</a>(float8 x, float8 y, float8 prev_x, float8 prev_y);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L3109" title="utils/adt/geo_ops.c:3109">lseg_contain_point</a>(LSEG *lseg, Point *pt);<br/></li>
<li><span class="Type">static</span> float8 <a href="#L2772" title="utils/adt/geo_ops.c:2772">lseg_closept_point</a>(Point *result, LSEG *lseg, Point *pt);<br/></li>
<li><span class="Type">static</span> float8 <a href="#L2960" title="utils/adt/geo_ops.c:2960">lseg_closept_line</a>(Point *result, LSEG *lseg, LINE *line);<br/></li>
<li><span class="Type">static</span> float8 <a href="#L2810" title="utils/adt/geo_ops.c:2810">lseg_closept_lseg</a>(Point *result, LSEG *on_lseg, LSEG *to_lseg);<br/></li>
<li><br/></li>
<li><span class="Comment">/* Routines for boxes */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void</span> <a href="#L518" title="utils/adt/geo_ops.c:518">box_construct</a>(BOX *result, Point *pt1, Point *pt2);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L872" title="utils/adt/geo_ops.c:872">box_cn</a>(Point *center, BOX *box);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L572" title="utils/adt/geo_ops.c:572">box_ov</a>(BOX *box1, BOX *box2);<br/></li>
<li><span class="Type">static</span> float8 <a href="#L863" title="utils/adt/geo_ops.c:863">box_ar</a>(BOX *box);<br/></li>
<li><span class="Type">static</span> float8 <a href="#L893" title="utils/adt/geo_ops.c:893">box_ht</a>(BOX *box);<br/></li>
<li><span class="Type">static</span> float8 <a href="#L883" title="utils/adt/geo_ops.c:883">box_wd</a>(BOX *box);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L3130" title="utils/adt/geo_ops.c:3130">box_contain_point</a>(BOX *box, Point *point);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L704" title="utils/adt/geo_ops.c:704">box_contain_box</a>(BOX *contains_box, BOX *contained_box);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L3217" title="utils/adt/geo_ops.c:3217">box_contain_lseg</a>(BOX *box, LSEG *lseg);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L3263" title="utils/adt/geo_ops.c:3263">box_interpt_lseg</a>(Point *result, BOX *box, LSEG *lseg);<br/></li>
<li><span class="Type">static</span> float8 <a href="#L2878" title="utils/adt/geo_ops.c:2878">box_closept_point</a>(Point *result, BOX *box, Point *pt);<br/></li>
<li><span class="Type">static</span> float8 <a href="#L3013" title="utils/adt/geo_ops.c:3013">box_closept_lseg</a>(Point *result, BOX *box, LSEG *lseg);<br/></li>
<li><br/></li>
<li><span class="Comment">/* Routines for circles */<br/></li>
<li></span><span class="Type">static</span> float8 <a href="#L5159" title="utils/adt/geo_ops.c:5159">circle_ar</a>(CIRCLE *circle);<br/></li>
<li><br/></li>
<li><span class="Comment">/* Routines for polygons */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L3376" title="utils/adt/geo_ops.c:3376">make_bound_box</a>(POLYGON *poly);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L5285" title="utils/adt/geo_ops.c:5285">poly_to_circle</a>(CIRCLE *result, POLYGON *poly);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L3866" title="utils/adt/geo_ops.c:3866">lseg_inside_poly</a>(Point *a, Point *b, POLYGON *poly, <span class="Type">int</span> start);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L3938" title="utils/adt/geo_ops.c:3938">poly_contain_poly</a>(POLYGON *contains_poly, POLYGON *contained_poly);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L5457" title="utils/adt/geo_ops.c:5457">plist_same</a>(<span class="Type">int</span> npts, Point *p1, Point *p2);<br/></li>
<li><span class="Type">static</span> float8 <a href="#L2630" title="utils/adt/geo_ops.c:2630">dist_ppoly_internal</a>(Point *pt, POLYGON *poly);<br/></li>
<li><br/></li>
<li><span class="Comment">/* Routines for encoding and decoding */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L194" title="utils/adt/geo_ops.c:194">single_decode</a>(<span class="Type">char</span> *num, float8 *x, <span class="Type">char</span> **endptr_p,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *type_name, <span class="Type">const</span> <span class="Type">char</span> *orig_string,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node *escontext);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L203" title="utils/adt/geo_ops.c:203">single_encode</a>(float8 x, StringInfo str);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L212" title="utils/adt/geo_ops.c:212">pair_decode</a>(<span class="Type">char</span> *str, float8 *x, float8 *y, <span class="Type">char</span> **endptr_p,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *type_name, <span class="Type">const</span> <span class="Type">char</span> *orig_string,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node *escontext);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L255" title="utils/adt/geo_ops.c:255">pair_encode</a>(float8 x, float8 y, StringInfo str);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L392" title="utils/adt/geo_ops.c:392">pair_count</a>(<span class="Type">char</span> *s, <span class="Type">char</span> delim);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L266" title="utils/adt/geo_ops.c:266">path_decode</a>(<span class="Type">char</span> *str, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> opentype, <span class="Type">int</span> npts, Point *p,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isopen, <span class="Type">char</span> **endptr_p,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *type_name, <span class="Type">const</span> <span class="Type">char</span> *orig_string,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node *escontext);<br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<a href="#L340" title="utils/adt/geo_ops.c:340">path_encode</a>(<span class="Type">enum</span> <a href="#L73" title="utils/adt/geo_ops.c:73">path_delim</a> <a href="#L73" title="utils/adt/geo_ops.c:73">path_delim</a>, <span class="Type">int</span> npts, Point *pt);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Delimiters for input and output strings.<br/></li>
<li></span><span class="Comment"> * <a href="#L157" title="utils/adt/geo_ops.c:157">LDELIM</a>, <a href="#L158" title="utils/adt/geo_ops.c:158">RDELIM</a>, and <a href="#L159" title="utils/adt/geo_ops.c:159">DELIM</a> are left, right, and separator delimiters, respectively.<br/></li>
<li></span><span class="Comment"> * <a href="#L160" title="utils/adt/geo_ops.c:160">LDELIM_EP</a>, <a href="#L161" title="utils/adt/geo_ops.c:161">RDELIM_EP</a> are left and right delimiters for paths with endpoints.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><a id="L157">&#x200c;</a><span class="PreProc">#define <span class="linkable">LDELIM</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">'('<br/></li>
<li><a id="L158">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RDELIM</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">')'<br/></li>
<li><a id="L159">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">DELIM</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">','<br/></li>
<li><a id="L160">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">LDELIM_EP</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">'['<br/></li>
<li><a id="L161">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RDELIM_EP</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">']'<br/></li>
<li><a id="L162">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">LDELIM_C</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">'&lt;'<br/></li>
<li><a id="L163">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RDELIM_C</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">'&gt;'<br/></li>
<li><a id="L164">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">LDELIM_L</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">'{'<br/></li>
<li><a id="L165">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RDELIM_L</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">'}'<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Geometric data types are composed of points.<br/></li>
<li></span><span class="Comment"> * This code tries to support a common format throughout the data types,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; to allow for more predictable usage and data type conversion.<br/></li>
<li></span><span class="Comment"> * The fundamental unit is the point. Other units are line segments,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; open paths, boxes, closed paths, and polygons (which should be considered<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; non-intersecting closed paths).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Data representation is as follows:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; point:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (x,y)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; line segment:&nbsp; &nbsp; &nbsp; &nbsp; [(x1,y1),(x2,y2)]<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; box:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (x1,y1),(x2,y2)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; open path:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [(x1,y1),...,(xn,yn)]<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; closed path:&nbsp; &nbsp; &nbsp; &nbsp; ((x1,y1),...,(xn,yn))<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; polygon:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((x1,y1),...,(xn,yn))<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For boxes, the points are opposite corners with the first point at the top right.<br/></li>
<li></span><span class="Comment"> * For closed paths and polygons, the points should be reordered to allow<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; fast and correct equality comparisons.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment"> perhaps points in complex shapes should be reordered internally<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; to allow faster <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> operations, but should keep track of input order<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; and restore that order for text output - tgl 97/01/16<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L194">&#x200c;</a></span><span class="linkable">single_decode</span>(<span class="Type">char</span> *num, float8 *x, <span class="Type">char</span> **endptr_p,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *type_name, <span class="Type">const</span> <span class="Type">char</span> *orig_string,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node *escontext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; *x = <a href="float.c.html#L388" title="utils/adt/float.c:388">float8in_internal</a>(num, endptr_p, type_name, orig_string, escontext);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (!SOFT_ERROR_OCCURRED(escontext));<br/></li>
<li>}&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L194" title="utils/adt/geo_ops.c:194">single_decode</a>() */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L203">&#x200c;</a></span><span class="linkable">single_encode</span>(float8 x, StringInfo str)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *xstr = <a href="float.c.html#L530" title="utils/adt/float.c:530">float8out_internal</a>(x);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfoString(str, xstr);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(xstr);<br/></li>
<li>}&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L203" title="utils/adt/geo_ops.c:203">single_encode</a>() */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L212">&#x200c;</a></span><span class="linkable">pair_decode</span>(<span class="Type">char</span> *str, float8 *x, float8 *y, <span class="Type">char</span> **endptr_p,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *type_name, <span class="Type">const</span> <span class="Type">char</span> *orig_string,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node *escontext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; has_delim;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (isspace((<span class="Type">unsigned</span> <span class="Type">char</span>) *str))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; str++;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((has_delim = (*str == <a href="#L157" title="utils/adt/geo_ops.c:157">LDELIM</a>)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; str++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L194" title="utils/adt/geo_ops.c:194">single_decode</a>(str, x, &amp;str, type_name, orig_string, escontext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*str++ != <a href="#L159" title="utils/adt/geo_ops.c:159">DELIM</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> fail;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L194" title="utils/adt/geo_ops.c:194">single_decode</a>(str, y, &amp;str, type_name, orig_string, escontext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (has_delim)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*str++ != <a href="#L158" title="utils/adt/geo_ops.c:158">RDELIM</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> fail;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (isspace((<span class="Type">unsigned</span> <span class="Type">char</span>) *str))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* report stopping point if wanted, else complain if not end of string */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (endptr_p)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *endptr_p = str;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*str != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> fail;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li><span class="Statement">fail</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; ereturn(escontext, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid input syntax for type </span><span class="Special">%s</span><span class="Constant">: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type_name, orig_string)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L255">&#x200c;</a></span><span class="linkable">pair_encode</span>(float8 x, float8 y, StringInfo str)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *xstr = <a href="float.c.html#L530" title="utils/adt/float.c:530">float8out_internal</a>(x);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ystr = <a href="float.c.html#L530" title="utils/adt/float.c:530">float8out_internal</a>(y);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfo(str, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">,</span><span class="Special">%s</span><span class="Constant">&quot;</span>, xstr, ystr);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(xstr);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(ystr);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L266">&#x200c;</a></span><span class="linkable">path_decode</span>(<span class="Type">char</span> *str, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> opentype, <span class="Type">int</span> npts, Point *p,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isopen, <span class="Type">char</span> **endptr_p,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *type_name, <span class="Type">const</span> <span class="Type">char</span> *orig_string,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node *escontext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; depth = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *cp;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (isspace((<span class="Type">unsigned</span> <span class="Type">char</span>) *str))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; str++;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((*isopen = (*str == <a href="#L160" title="utils/adt/geo_ops.c:160">LDELIM_EP</a>)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no open delimiter allowed? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!opentype)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> fail;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; depth++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; str++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*str == <a href="#L157" title="utils/adt/geo_ops.c:157">LDELIM</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cp = (str + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (isspace((<span class="Type">unsigned</span> <span class="Type">char</span>) *cp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cp++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*cp == <a href="#L157" title="utils/adt/geo_ops.c:157">LDELIM</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; depth++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = cp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strrchr(str, <a href="#L157" title="utils/adt/geo_ops.c:157">LDELIM</a>) == str)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; depth++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = cp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; npts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L212" title="utils/adt/geo_ops.c:212">pair_decode</a>(str, &amp;(p-&gt;x), &amp;(p-&gt;y), &amp;str, type_name, orig_string,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; escontext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*str == <a href="#L159" title="utils/adt/geo_ops.c:159">DELIM</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; p++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (depth &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*str == <a href="#L158" title="utils/adt/geo_ops.c:158">RDELIM</a> || (*str == <a href="#L161" title="utils/adt/geo_ops.c:161">RDELIM_EP</a> &amp;&amp; *isopen &amp;&amp; depth == <span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; depth--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (isspace((<span class="Type">unsigned</span> <span class="Type">char</span>) *str))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> fail;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* report stopping point if wanted, else complain if not end of string */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (endptr_p)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *endptr_p = str;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*str != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> fail;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li><span class="Statement">fail</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; ereturn(escontext, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid input syntax for type </span><span class="Special">%s</span><span class="Constant">: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type_name, orig_string)));<br/></li>
<li>}&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L266" title="utils/adt/geo_ops.c:266">path_decode</a>() */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L340">&#x200c;</a><span class="linkable">path_encode</span>(<span class="Type">enum</span> <a href="#L73" title="utils/adt/geo_ops.c:73">path_delim</a> <a href="#L73" title="utils/adt/geo_ops.c:73">path_delim</a>, <span class="Type">int</span> npts, Point *pt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfoData str;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;str);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (<a href="#L73" title="utils/adt/geo_ops.c:73">path_delim</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PATH_CLOSED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(&amp;str, <a href="#L157" title="utils/adt/geo_ops.c:157">LDELIM</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PATH_OPEN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(&amp;str, <a href="#L160" title="utils/adt/geo_ops.c:160">LDELIM_EP</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PATH_NONE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; npts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(&amp;str, <a href="#L159" title="utils/adt/geo_ops.c:159">DELIM</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(&amp;str, <a href="#L157" title="utils/adt/geo_ops.c:157">LDELIM</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L255" title="utils/adt/geo_ops.c:255">pair_encode</a>(pt-&gt;x, pt-&gt;y, &amp;str);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(&amp;str, <a href="#L158" title="utils/adt/geo_ops.c:158">RDELIM</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pt++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (<a href="#L73" title="utils/adt/geo_ops.c:73">path_delim</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PATH_CLOSED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(&amp;str, <a href="#L158" title="utils/adt/geo_ops.c:158">RDELIM</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PATH_OPEN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(&amp;str, <a href="#L161" title="utils/adt/geo_ops.c:161">RDELIM_EP</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PATH_NONE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> str.data;<br/></li>
<li>}&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L340" title="utils/adt/geo_ops.c:340">path_encode</a>() */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*-------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * <a href="#L392" title="utils/adt/geo_ops.c:392">pair_count</a> - count the number of points<br/></li>
<li></span><span class="Comment"> * allow the following notation:<br/></li>
<li></span><span class="Comment"> * '((1,2),(3,4))'<br/></li>
<li></span><span class="Comment"> * '(1,3,2,4)'<br/></li>
<li></span><span class="Comment"> * require an odd number of delim characters in the string<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------*/<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L392">&#x200c;</a></span><span class="linkable">pair_count</span>(<span class="Type">char</span> *s, <span class="Type">char</span> delim)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndelim = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((s = strchr(s, delim)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ndelim++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (ndelim % <span class="Constant">2</span>) ? ((ndelim + <span class="Constant">1</span>) / <span class="Constant">2</span>) : -<span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/***********************************************************************<br/></li>
<li></span><span class="Comment"> **<br/></li>
<li></span><span class="Comment"> **&nbsp; &nbsp; &nbsp; &nbsp; Routines for two-dimensional boxes.<br/></li>
<li></span><span class="Comment"> **<br/></li>
<li></span><span class="Comment"> ***********************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*----------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * Formatting and conversion routines.<br/></li>
<li></span><span class="Comment"> *---------------------------------------------------------*/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L422" title="utils/adt/geo_ops.c:422">box_in</a>&nbsp; &nbsp; -&nbsp; &nbsp; &nbsp; &nbsp; convert a string to <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> form.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; External format: (two corners of box)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;(f8, f8), (f8, f8)&quot;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; also supports the older style &quot;(f8, f8, f8, f8)&quot;<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L422">&#x200c;</a><span class="linkable">box_in</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *str = PG_GETARG_CSTRING(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *escontext = fcinfo-&gt;context;<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box = (BOX *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BOX));<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isopen;<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; x,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; y;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L266" title="utils/adt/geo_ops.c:266">path_decode</a>(str, <span class="Constant">false</span>, <span class="Constant">2</span>, &amp;(box-&gt;high), &amp;isopen, <span class="Constant">NULL</span>, <span class="Constant">&quot;box&quot;</span>, str,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; escontext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* reorder corners if necessary... */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (float8_lt(box-&gt;high.x, box-&gt;low.x))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; x = box-&gt;high.x;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; box-&gt;high.x = box-&gt;low.x;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; box-&gt;low.x = x;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (float8_lt(box-&gt;high.y, box-&gt;low.y))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; y = box-&gt;high.y;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; box-&gt;high.y = box-&gt;low.y;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; box-&gt;low.y = y;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOX_P(box);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L455" title="utils/adt/geo_ops.c:455">box_out</a> -&nbsp; &nbsp; &nbsp; &nbsp; convert a box to external form.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L455">&#x200c;</a><span class="linkable">box_out</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box = PG_GETARG_BOX_P(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CSTRING(<a href="#L340" title="utils/adt/geo_ops.c:340">path_encode</a>(PATH_NONE, <span class="Constant">2</span>, &amp;(box-&gt;high)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L466" title="utils/adt/geo_ops.c:466">box_recv</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts external binary format to box<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L466">&#x200c;</a><span class="linkable">box_recv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; buf = (StringInfo) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box;<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; x,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; y;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; box = (BOX *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BOX));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; box-&gt;high.x = <a href="../../libpq/pqformat.c.html#L488" title="libpq/pqformat.c:488">pq_getmsgfloat8</a>(buf);<br/></li>
<li>&nbsp; &nbsp; box-&gt;high.y = <a href="../../libpq/pqformat.c.html#L488" title="libpq/pqformat.c:488">pq_getmsgfloat8</a>(buf);<br/></li>
<li>&nbsp; &nbsp; box-&gt;low.x = <a href="../../libpq/pqformat.c.html#L488" title="libpq/pqformat.c:488">pq_getmsgfloat8</a>(buf);<br/></li>
<li>&nbsp; &nbsp; box-&gt;low.y = <a href="../../libpq/pqformat.c.html#L488" title="libpq/pqformat.c:488">pq_getmsgfloat8</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* reorder corners if necessary... */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (float8_lt(box-&gt;high.x, box-&gt;low.x))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; x = box-&gt;high.x;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; box-&gt;high.x = box-&gt;low.x;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; box-&gt;low.x = x;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (float8_lt(box-&gt;high.y, box-&gt;low.y))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; y = box-&gt;high.y;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; box-&gt;high.y = box-&gt;low.y;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; box-&gt;low.y = y;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOX_P(box);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L501" title="utils/adt/geo_ops.c:501">box_send</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts box to binary format<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L501">&#x200c;</a><span class="linkable">box_send</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box = PG_GETARG_BOX_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L326" title="libpq/pqformat.c:326">pq_begintypsend</a>(&amp;buf);<br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L276" title="libpq/pqformat.c:276">pq_sendfloat8</a>(&amp;buf, box-&gt;high.x);<br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L276" title="libpq/pqformat.c:276">pq_sendfloat8</a>(&amp;buf, box-&gt;high.y);<br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L276" title="libpq/pqformat.c:276">pq_sendfloat8</a>(&amp;buf, box-&gt;low.x);<br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L276" title="libpq/pqformat.c:276">pq_sendfloat8</a>(&amp;buf, box-&gt;low.y);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BYTEA_P(<a href="../../libpq/pqformat.c.html#L346" title="libpq/pqformat.c:346">pq_endtypsend</a>(&amp;buf));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L518" title="utils/adt/geo_ops.c:518">box_construct</a>&nbsp; &nbsp; -&nbsp; &nbsp; &nbsp; &nbsp; fill in a new box.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L518">&#x200c;</a></span><span class="linkable">box_construct</span>(BOX *result, Point *pt1, Point *pt2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (float8_gt(pt1-&gt;x, pt2-&gt;x))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;high.x = pt1-&gt;x;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;low.x = pt2-&gt;x;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;high.x = pt2-&gt;x;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;low.x = pt1-&gt;x;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (float8_gt(pt1-&gt;y, pt2-&gt;y))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;high.y = pt1-&gt;y;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;low.y = pt2-&gt;y;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;high.y = pt2-&gt;y;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;low.y = pt1-&gt;y;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*----------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Relational operators for BOXes.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &lt;, &gt;, &lt;=, &gt;=, and == are based on box area.<br/></li>
<li></span><span class="Comment"> *---------------------------------------------------------*/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L551" title="utils/adt/geo_ops.c:551">box_same</a>&nbsp; &nbsp; &nbsp; &nbsp; -&nbsp; &nbsp; &nbsp; &nbsp; are two boxes identical?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L551">&#x200c;</a><span class="linkable">box_same</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box1 = PG_GETARG_BOX_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box2 = PG_GETARG_BOX_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L1977" title="utils/adt/geo_ops.c:1977">point_eq_point</a>(&amp;box1-&gt;high, &amp;box2-&gt;high) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L1977" title="utils/adt/geo_ops.c:1977">point_eq_point</a>(&amp;box1-&gt;low, &amp;box2-&gt;low));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L563" title="utils/adt/geo_ops.c:563">box_overlap</a>&nbsp; &nbsp; &nbsp; &nbsp; -&nbsp; &nbsp; &nbsp; &nbsp; does box1 overlap box2?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L563">&#x200c;</a><span class="linkable">box_overlap</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box1 = PG_GETARG_BOX_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box2 = PG_GETARG_BOX_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L572" title="utils/adt/geo_ops.c:572">box_ov</a>(box1, box2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L572">&#x200c;</a></span><span class="linkable">box_ov</span>(BOX *box1, BOX *box2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (FPle(box1-&gt;low.x, box2-&gt;high.x) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FPle(box2-&gt;low.x, box1-&gt;high.x) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FPle(box1-&gt;low.y, box2-&gt;high.y) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FPle(box2-&gt;low.y, box1-&gt;high.y));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L583" title="utils/adt/geo_ops.c:583">box_left</a>&nbsp; &nbsp; &nbsp; &nbsp; -&nbsp; &nbsp; &nbsp; &nbsp; is box1 strictly left of box2?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L583">&#x200c;</a><span class="linkable">box_left</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box1 = PG_GETARG_BOX_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box2 = PG_GETARG_BOX_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(FPlt(box1-&gt;high.x, box2-&gt;low.x));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L598" title="utils/adt/geo_ops.c:598">box_overleft</a>&nbsp; &nbsp; -&nbsp; &nbsp; &nbsp; &nbsp; is the right edge of box1 at or left of<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the right edge of box2?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This is &quot;less than or <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>&quot; for the end of a time <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; when time ranges are stored as rectangles.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L598">&#x200c;</a><span class="linkable">box_overleft</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box1 = PG_GETARG_BOX_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box2 = PG_GETARG_BOX_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(FPle(box1-&gt;high.x, box2-&gt;high.x));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L609" title="utils/adt/geo_ops.c:609">box_right</a>&nbsp; &nbsp; &nbsp; &nbsp; -&nbsp; &nbsp; &nbsp; &nbsp; is box1 strictly right of box2?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L609">&#x200c;</a><span class="linkable">box_right</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box1 = PG_GETARG_BOX_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box2 = PG_GETARG_BOX_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(FPgt(box1-&gt;low.x, box2-&gt;high.x));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L624" title="utils/adt/geo_ops.c:624">box_overright</a>&nbsp; &nbsp; -&nbsp; &nbsp; &nbsp; &nbsp; is the left edge of box1 at or right of<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the left edge of box2?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This is &quot;greater than or <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>&quot; for time ranges, when time ranges<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; are stored as rectangles.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L624">&#x200c;</a><span class="linkable">box_overright</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box1 = PG_GETARG_BOX_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box2 = PG_GETARG_BOX_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(FPge(box1-&gt;low.x, box2-&gt;low.x));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L635" title="utils/adt/geo_ops.c:635">box_below</a>&nbsp; &nbsp; &nbsp; &nbsp; -&nbsp; &nbsp; &nbsp; &nbsp; is box1 strictly below box2?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L635">&#x200c;</a><span class="linkable">box_below</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box1 = PG_GETARG_BOX_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box2 = PG_GETARG_BOX_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(FPlt(box1-&gt;high.y, box2-&gt;low.y));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L647" title="utils/adt/geo_ops.c:647">box_overbelow</a>&nbsp; &nbsp; -&nbsp; &nbsp; &nbsp; &nbsp; is the <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> edge of box1 at or below<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> edge of box2?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L647">&#x200c;</a><span class="linkable">box_overbelow</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box1 = PG_GETARG_BOX_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box2 = PG_GETARG_BOX_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(FPle(box1-&gt;high.y, box2-&gt;high.y));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L658" title="utils/adt/geo_ops.c:658">box_above</a>&nbsp; &nbsp; &nbsp; &nbsp; -&nbsp; &nbsp; &nbsp; &nbsp; is box1 strictly above box2?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L658">&#x200c;</a><span class="linkable">box_above</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box1 = PG_GETARG_BOX_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box2 = PG_GETARG_BOX_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(FPgt(box1-&gt;low.y, box2-&gt;high.y));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L670" title="utils/adt/geo_ops.c:670">box_overabove</a>&nbsp; &nbsp; -&nbsp; &nbsp; &nbsp; &nbsp; is the <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> edge of box1 at or above<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> edge of box2?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L670">&#x200c;</a><span class="linkable">box_overabove</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box1 = PG_GETARG_BOX_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box2 = PG_GETARG_BOX_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(FPge(box1-&gt;low.y, box2-&gt;low.y));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L681" title="utils/adt/geo_ops.c:681">box_contained</a>&nbsp; &nbsp; -&nbsp; &nbsp; &nbsp; &nbsp; is box1 contained by box2?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L681">&#x200c;</a><span class="linkable">box_contained</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box1 = PG_GETARG_BOX_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box2 = PG_GETARG_BOX_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L704" title="utils/adt/geo_ops.c:704">box_contain_box</a>(box2, box1));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L692" title="utils/adt/geo_ops.c:692">box_contain</a>&nbsp; &nbsp; &nbsp; &nbsp; -&nbsp; &nbsp; &nbsp; &nbsp; does box1 contain box2?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L692">&#x200c;</a><span class="linkable">box_contain</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box1 = PG_GETARG_BOX_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box2 = PG_GETARG_BOX_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L704" title="utils/adt/geo_ops.c:704">box_contain_box</a>(box1, box2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check whether the second box is in the first box or on its border<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L704">&#x200c;</a></span><span class="linkable">box_contain_box</span>(BOX *contains_box, BOX *contained_box)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> FPge(contains_box-&gt;high.x, contained_box-&gt;high.x) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FPle(contains_box-&gt;low.x, contained_box-&gt;low.x) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FPge(contains_box-&gt;high.y, contained_box-&gt;high.y) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FPle(contains_box-&gt;low.y, contained_box-&gt;low.y);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; box_positionop&nbsp; &nbsp; -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is box1 entirely {above,below} box2?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L722" title="utils/adt/geo_ops.c:722">box_below_eq</a> and <a href="#L731" title="utils/adt/geo_ops.c:731">box_above_eq</a> are obsolete versions that (probably<br/></li>
<li></span><span class="Comment"> * erroneously) <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> the <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>-boundaries case.&nbsp; Since these are not<br/></li>
<li></span><span class="Comment"> * in sync with the <a href="#L583" title="utils/adt/geo_ops.c:583">box_left</a> and <a href="#L609" title="utils/adt/geo_ops.c:609">box_right</a> code, they are deprecated and<br/></li>
<li></span><span class="Comment"> * not supported in the PG 8.1 rtree operator class extension.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L722">&#x200c;</a><span class="linkable">box_below_eq</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box1 = PG_GETARG_BOX_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box2 = PG_GETARG_BOX_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(FPle(box1-&gt;high.y, box2-&gt;low.y));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L731">&#x200c;</a><span class="linkable">box_above_eq</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box1 = PG_GETARG_BOX_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box2 = PG_GETARG_BOX_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(FPge(box1-&gt;low.y, box2-&gt;high.y));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; box_relop&nbsp; &nbsp; &nbsp; &nbsp; -&nbsp; &nbsp; &nbsp; &nbsp; is area(box1) relop area(box2), within<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; our accuracy constraint?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L744">&#x200c;</a><span class="linkable">box_lt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box1 = PG_GETARG_BOX_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box2 = PG_GETARG_BOX_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(FPlt(<a href="#L863" title="utils/adt/geo_ops.c:863">box_ar</a>(box1), <a href="#L863" title="utils/adt/geo_ops.c:863">box_ar</a>(box2)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L753">&#x200c;</a><span class="linkable">box_gt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box1 = PG_GETARG_BOX_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box2 = PG_GETARG_BOX_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(FPgt(<a href="#L863" title="utils/adt/geo_ops.c:863">box_ar</a>(box1), <a href="#L863" title="utils/adt/geo_ops.c:863">box_ar</a>(box2)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L762">&#x200c;</a><span class="linkable">box_eq</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box1 = PG_GETARG_BOX_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box2 = PG_GETARG_BOX_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(FPeq(<a href="#L863" title="utils/adt/geo_ops.c:863">box_ar</a>(box1), <a href="#L863" title="utils/adt/geo_ops.c:863">box_ar</a>(box2)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L771">&#x200c;</a><span class="linkable">box_le</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box1 = PG_GETARG_BOX_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box2 = PG_GETARG_BOX_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(FPle(<a href="#L863" title="utils/adt/geo_ops.c:863">box_ar</a>(box1), <a href="#L863" title="utils/adt/geo_ops.c:863">box_ar</a>(box2)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L780">&#x200c;</a><span class="linkable">box_ge</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box1 = PG_GETARG_BOX_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box2 = PG_GETARG_BOX_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(FPge(<a href="#L863" title="utils/adt/geo_ops.c:863">box_ar</a>(box1), <a href="#L863" title="utils/adt/geo_ops.c:863">box_ar</a>(box2)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*----------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &quot;Arithmetic&quot; operators on boxes.<br/></li>
<li></span><span class="Comment"> *---------------------------------------------------------*/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L796" title="utils/adt/geo_ops.c:796">box_area</a>&nbsp; &nbsp; &nbsp; &nbsp; -&nbsp; &nbsp; &nbsp; &nbsp; returns the area of the box.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L796">&#x200c;</a><span class="linkable">box_area</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box = PG_GETARG_BOX_P(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(<a href="#L863" title="utils/adt/geo_ops.c:863">box_ar</a>(box));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L808" title="utils/adt/geo_ops.c:808">box_width</a>&nbsp; &nbsp; &nbsp; &nbsp; -&nbsp; &nbsp; &nbsp; &nbsp; returns the width of the box<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (horizontal magnitude).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L808">&#x200c;</a><span class="linkable">box_width</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box = PG_GETARG_BOX_P(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(<a href="#L883" title="utils/adt/geo_ops.c:883">box_wd</a>(box));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L820" title="utils/adt/geo_ops.c:820">box_height</a>&nbsp; &nbsp; &nbsp; &nbsp; -&nbsp; &nbsp; &nbsp; &nbsp; returns the height of the box<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (vertical magnitude).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L820">&#x200c;</a><span class="linkable">box_height</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box = PG_GETARG_BOX_P(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(<a href="#L893" title="utils/adt/geo_ops.c:893">box_ht</a>(box));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L832" title="utils/adt/geo_ops.c:832">box_distance</a>&nbsp; &nbsp; -&nbsp; &nbsp; &nbsp; &nbsp; returns the distance between the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; center points of two boxes.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L832">&#x200c;</a><span class="linkable">box_distance</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box1 = PG_GETARG_BOX_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box2 = PG_GETARG_BOX_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp; &nbsp; a,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L872" title="utils/adt/geo_ops.c:872">box_cn</a>(&amp;a, box1);<br/></li>
<li>&nbsp; &nbsp; <a href="#L872" title="utils/adt/geo_ops.c:872">box_cn</a>(&amp;b, box2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(<a href="#L2002" title="utils/adt/geo_ops.c:2002">point_dt</a>(&amp;a, &amp;b));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L849" title="utils/adt/geo_ops.c:849">box_center</a>&nbsp; &nbsp; &nbsp; &nbsp; -&nbsp; &nbsp; &nbsp; &nbsp; returns the center point of the box.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L849">&#x200c;</a><span class="linkable">box_center</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box = PG_GETARG_BOX_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *result = (Point *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Point));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L872" title="utils/adt/geo_ops.c:872">box_cn</a>(result, box);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L863" title="utils/adt/geo_ops.c:863">box_ar</a>&nbsp; &nbsp; -&nbsp; &nbsp; &nbsp; &nbsp; returns the area of the box.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> float8<br/></li>
<li><a id="L863">&#x200c;</a><span class="linkable">box_ar</span>(BOX *box)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> float8_mul(<a href="#L883" title="utils/adt/geo_ops.c:883">box_wd</a>(box), <a href="#L893" title="utils/adt/geo_ops.c:893">box_ht</a>(box));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L872" title="utils/adt/geo_ops.c:872">box_cn</a>&nbsp; &nbsp; -&nbsp; &nbsp; &nbsp; &nbsp; stores the centerpoint of the box into *center.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L872">&#x200c;</a></span><span class="linkable">box_cn</span>(Point *center, BOX *box)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; center-&gt;x = float8_div(float8_pl(box-&gt;high.x, box-&gt;low.x), <span class="Constant">2.0</span>);<br/></li>
<li>&nbsp; &nbsp; center-&gt;y = float8_div(float8_pl(box-&gt;high.y, box-&gt;low.y), <span class="Constant">2.0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L883" title="utils/adt/geo_ops.c:883">box_wd</a>&nbsp; &nbsp; -&nbsp; &nbsp; &nbsp; &nbsp; returns the width (length) of the box<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (horizontal magnitude).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> float8<br/></li>
<li><a id="L883">&#x200c;</a><span class="linkable">box_wd</span>(BOX *box)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> float8_mi(box-&gt;high.x, box-&gt;low.x);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L893" title="utils/adt/geo_ops.c:893">box_ht</a>&nbsp; &nbsp; -&nbsp; &nbsp; &nbsp; &nbsp; returns the height of the box<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (vertical magnitude).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> float8<br/></li>
<li><a id="L893">&#x200c;</a><span class="linkable">box_ht</span>(BOX *box)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> float8_mi(box-&gt;high.y, box-&gt;low.y);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*----------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Funky operations.<br/></li>
<li></span><span class="Comment"> *---------------------------------------------------------*/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L908" title="utils/adt/geo_ops.c:908">box_intersect</a>&nbsp; &nbsp; -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; returns the overlapping portion of two boxes,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; or NULL if they do not intersect.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L908">&#x200c;</a><span class="linkable">box_intersect</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box1 = PG_GETARG_BOX_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box2 = PG_GETARG_BOX_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L572" title="utils/adt/geo_ops.c:572">box_ov</a>(box1, box2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (BOX *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BOX));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result-&gt;high.x = float8_min(box1-&gt;high.x, box2-&gt;high.x);<br/></li>
<li>&nbsp; &nbsp; result-&gt;low.x = float8_max(box1-&gt;low.x, box2-&gt;low.x);<br/></li>
<li>&nbsp; &nbsp; result-&gt;high.y = float8_min(box1-&gt;high.y, box2-&gt;high.y);<br/></li>
<li>&nbsp; &nbsp; result-&gt;low.y = float8_max(box1-&gt;low.y, box2-&gt;low.y);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOX_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L933" title="utils/adt/geo_ops.c:933">box_diagonal</a>&nbsp; &nbsp; -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; returns a line segment which happens to be the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; positive-slope diagonal of &quot;box&quot;.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L933">&#x200c;</a><span class="linkable">box_diagonal</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box = PG_GETARG_BOX_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp;&nbsp; *result = (LSEG *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(LSEG));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2142" title="utils/adt/geo_ops.c:2142">statlseg_construct</a>(result, &amp;box-&gt;high, &amp;box-&gt;low);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_LSEG_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/***********************************************************************<br/></li>
<li></span><span class="Comment"> **<br/></li>
<li></span><span class="Comment"> **&nbsp; &nbsp; &nbsp; &nbsp; Routines for 2D lines.<br/></li>
<li></span><span class="Comment"> **<br/></li>
<li></span><span class="Comment"> ***********************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L950">&#x200c;</a></span><span class="linkable">line_decode</span>(<span class="Type">char</span> *s, <span class="Type">const</span> <span class="Type">char</span> *str, LINE *line, Node *escontext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* s was already advanced over leading '{' */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L194" title="utils/adt/geo_ops.c:194">single_decode</a>(s, &amp;line-&gt;A, &amp;s, <span class="Constant">&quot;line&quot;</span>, str, escontext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*s++ != <a href="#L159" title="utils/adt/geo_ops.c:159">DELIM</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> fail;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L194" title="utils/adt/geo_ops.c:194">single_decode</a>(s, &amp;line-&gt;B, &amp;s, <span class="Constant">&quot;line&quot;</span>, str, escontext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*s++ != <a href="#L159" title="utils/adt/geo_ops.c:159">DELIM</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> fail;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L194" title="utils/adt/geo_ops.c:194">single_decode</a>(s, &amp;line-&gt;C, &amp;s, <span class="Constant">&quot;line&quot;</span>, str, escontext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*s++ != <a href="#L165" title="utils/adt/geo_ops.c:165">RDELIM_L</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> fail;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (isspace((<span class="Type">unsigned</span> <span class="Type">char</span>) *s))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s++;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*s != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> fail;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li><span class="Statement">fail</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; ereturn(escontext, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid input syntax for type </span><span class="Special">%s</span><span class="Constant">: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;line&quot;</span>, str)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L979">&#x200c;</a><span class="linkable">line_in</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *str = PG_GETARG_CSTRING(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *escontext = fcinfo-&gt;context;<br/></li>
<li>&nbsp; &nbsp; LINE&nbsp; &nbsp; &nbsp;&nbsp; *line = (LINE *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(LINE));<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp; &nbsp; lseg;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isopen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *s;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; s = str;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (isspace((<span class="Type">unsigned</span> <span class="Type">char</span>) *s))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s++;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*s == <a href="#L164" title="utils/adt/geo_ops.c:164">LDELIM_L</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L950" title="utils/adt/geo_ops.c:950">line_decode</a>(s + <span class="Constant">1</span>, str, line, escontext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (FPzero(line-&gt;A) &amp;&amp; FPzero(line-&gt;B))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid line specification: A and B cannot both be zero&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L266" title="utils/adt/geo_ops.c:266">path_decode</a>(s, <span class="Constant">true</span>, <span class="Constant">2</span>, &amp;lseg.p[<span class="Constant">0</span>], &amp;isopen, <span class="Constant">NULL</span>, <span class="Constant">&quot;line&quot;</span>, str,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; escontext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1977" title="utils/adt/geo_ops.c:1977">point_eq_point</a>(&amp;lseg.p[<span class="Constant">0</span>], &amp;lseg.p[<span class="Constant">1</span>]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid line specification: must be two distinct points&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> <a href="#L2155" title="utils/adt/geo_ops.c:2155">lseg_sl</a>() and <a href="#L1083" title="utils/adt/geo_ops.c:1083">line_construct</a>() can throw overflow/underflow<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * errors.&nbsp; Eventually we should allow those to be soft, but the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * notational pain seems to outweigh the value for <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1083" title="utils/adt/geo_ops.c:1083">line_construct</a>(line, &amp;lseg.p[<span class="Constant">0</span>], <a href="#L2155" title="utils/adt/geo_ops.c:2155">lseg_sl</a>(&amp;lseg));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_LINE_P(line);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1023">&#x200c;</a><span class="linkable">line_out</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LINE&nbsp; &nbsp; &nbsp;&nbsp; *line = PG_GETARG_LINE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *astr = <a href="float.c.html#L530" title="utils/adt/float.c:530">float8out_internal</a>(line-&gt;A);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *bstr = <a href="float.c.html#L530" title="utils/adt/float.c:530">float8out_internal</a>(line-&gt;B);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *cstr = <a href="float.c.html#L530" title="utils/adt/float.c:530">float8out_internal</a>(line-&gt;C);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CSTRING(psprintf(<span class="Constant">&quot;</span><span class="Special">%c%s%c%s%c%s%c</span><span class="Constant">&quot;</span>, <a href="#L164" title="utils/adt/geo_ops.c:164">LDELIM_L</a>, astr, <a href="#L159" title="utils/adt/geo_ops.c:159">DELIM</a>, bstr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L159" title="utils/adt/geo_ops.c:159">DELIM</a>, cstr, <a href="#L165" title="utils/adt/geo_ops.c:165">RDELIM_L</a>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1038" title="utils/adt/geo_ops.c:1038">line_recv</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts external binary format to line<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1038">&#x200c;</a><span class="linkable">line_recv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; buf = (StringInfo) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; LINE&nbsp; &nbsp; &nbsp;&nbsp; *line;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; line = (LINE *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(LINE));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; line-&gt;A = <a href="../../libpq/pqformat.c.html#L488" title="libpq/pqformat.c:488">pq_getmsgfloat8</a>(buf);<br/></li>
<li>&nbsp; &nbsp; line-&gt;B = <a href="../../libpq/pqformat.c.html#L488" title="libpq/pqformat.c:488">pq_getmsgfloat8</a>(buf);<br/></li>
<li>&nbsp; &nbsp; line-&gt;C = <a href="../../libpq/pqformat.c.html#L488" title="libpq/pqformat.c:488">pq_getmsgfloat8</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (FPzero(line-&gt;A) &amp;&amp; FPzero(line-&gt;B))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_BINARY_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid line specification: A and B cannot both be zero&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_LINE_P(line);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1061" title="utils/adt/geo_ops.c:1061">line_send</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts line to binary format<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1061">&#x200c;</a><span class="linkable">line_send</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LINE&nbsp; &nbsp; &nbsp;&nbsp; *line = PG_GETARG_LINE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L326" title="libpq/pqformat.c:326">pq_begintypsend</a>(&amp;buf);<br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L276" title="libpq/pqformat.c:276">pq_sendfloat8</a>(&amp;buf, line-&gt;A);<br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L276" title="libpq/pqformat.c:276">pq_sendfloat8</a>(&amp;buf, line-&gt;B);<br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L276" title="libpq/pqformat.c:276">pq_sendfloat8</a>(&amp;buf, line-&gt;C);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BYTEA_P(<a href="../../libpq/pqformat.c.html#L346" title="libpq/pqformat.c:346">pq_endtypsend</a>(&amp;buf));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*----------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Conversion routines from one line formula to <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a>.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Internal form:&nbsp; &nbsp; Ax+By+C=0<br/></li>
<li></span><span class="Comment"> *---------------------------------------------------------*/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Fill already-allocated LINE struct from the point and the slope<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L1083">&#x200c;</a></span><span class="linkable">line_construct</span>(LINE *result, Point *pt, float8 m)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isinf(m))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* vertical - use &quot;x = C&quot; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;A = -<span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;B = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;C = pt-&gt;x;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (m == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* horizontal - use &quot;y = C&quot; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;A = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;B = -<span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;C = pt-&gt;y;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* use &quot;mx - y + yinter = 0&quot; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;A = m;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;B = -<span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;C = float8_mi(pt-&gt;y, float8_mul(m, pt-&gt;x));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* on some platforms, the preceding expression tends to produce -0 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result-&gt;C == <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result-&gt;C = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L1115" title="utils/adt/geo_ops.c:1115">line_construct_pp</a>()<br/></li>
<li></span><span class="Comment"> * two points<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1115">&#x200c;</a><span class="linkable">line_construct_pp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *pt1 = PG_GETARG_POINT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *pt2 = PG_GETARG_POINT_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; LINE&nbsp; &nbsp; &nbsp;&nbsp; *result = (LINE *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(LINE));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1977" title="utils/adt/geo_ops.c:1977">point_eq_point</a>(pt1, pt2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid line specification: must be two distinct points&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1083" title="utils/adt/geo_ops.c:1083">line_construct</a>(result, pt1, <a href="#L2023" title="utils/adt/geo_ops.c:2023">point_sl</a>(pt1, pt2));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_LINE_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*----------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Relative position routines.<br/></li>
<li></span><span class="Comment"> *---------------------------------------------------------*/<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L1137">&#x200c;</a><span class="linkable">line_intersect</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LINE&nbsp; &nbsp; &nbsp;&nbsp; *l1 = PG_GETARG_LINE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; LINE&nbsp; &nbsp; &nbsp;&nbsp; *l2 = PG_GETARG_LINE_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L1314" title="utils/adt/geo_ops.c:1314">line_interpt_line</a>(<span class="Constant">NULL</span>, l1, l2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1146">&#x200c;</a><span class="linkable">line_parallel</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LINE&nbsp; &nbsp; &nbsp;&nbsp; *l1 = PG_GETARG_LINE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; LINE&nbsp; &nbsp; &nbsp;&nbsp; *l2 = PG_GETARG_LINE_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(!<a href="#L1314" title="utils/adt/geo_ops.c:1314">line_interpt_line</a>(<span class="Constant">NULL</span>, l1, l2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1155">&#x200c;</a><span class="linkable">line_perp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LINE&nbsp; &nbsp; &nbsp;&nbsp; *l1 = PG_GETARG_LINE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; LINE&nbsp; &nbsp; &nbsp;&nbsp; *l2 = PG_GETARG_LINE_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (FPzero(l1-&gt;A))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(FPzero(l2-&gt;B));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (FPzero(l2-&gt;A))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(FPzero(l1-&gt;B));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (FPzero(l1-&gt;B))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(FPzero(l2-&gt;A));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (FPzero(l2-&gt;B))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(FPzero(l1-&gt;A));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(FPeq(float8_div(float8_mul(l1-&gt;A, l2-&gt;A),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; float8_mul(l1-&gt;B, l2-&gt;B)), -<span class="Constant">1.0</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1174">&#x200c;</a><span class="linkable">line_vertical</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LINE&nbsp; &nbsp; &nbsp;&nbsp; *line = PG_GETARG_LINE_P(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(FPzero(line-&gt;B));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1182">&#x200c;</a><span class="linkable">line_horizontal</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LINE&nbsp; &nbsp; &nbsp;&nbsp; *line = PG_GETARG_LINE_P(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(FPzero(line-&gt;A));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check whether the two lines are the same<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1194">&#x200c;</a><span class="linkable">line_eq</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LINE&nbsp; &nbsp; &nbsp;&nbsp; *l1 = PG_GETARG_LINE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; LINE&nbsp; &nbsp; &nbsp;&nbsp; *l2 = PG_GETARG_LINE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; ratio;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> NaNs are involved, insist on exact equality */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(isnan(l1-&gt;A) || isnan(l1-&gt;B) || isnan(l1-&gt;C) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; isnan(l2-&gt;A) || isnan(l2-&gt;B) || isnan(l2-&gt;C)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(float8_eq(l1-&gt;A, l2-&gt;A) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; float8_eq(l1-&gt;B, l2-&gt;B) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; float8_eq(l1-&gt;C, l2-&gt;C));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Otherwise, lines whose parameters are proportional are the same */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!FPzero(l2-&gt;A))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ratio = float8_div(l1-&gt;A, l2-&gt;A);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!FPzero(l2-&gt;B))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ratio = float8_div(l1-&gt;B, l2-&gt;B);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!FPzero(l2-&gt;C))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ratio = float8_div(l1-&gt;C, l2-&gt;C);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ratio = <span class="Constant">1.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(FPeq(l1-&gt;A, float8_mul(ratio, l2-&gt;A)) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; FPeq(l1-&gt;B, float8_mul(ratio, l2-&gt;B)) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; FPeq(l1-&gt;C, float8_mul(ratio, l2-&gt;C)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*----------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Line arithmetic routines.<br/></li>
<li></span><span class="Comment"> *---------------------------------------------------------*/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return slope of the line<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> float8<br/></li>
<li><a id="L1233">&#x200c;</a><span class="linkable">line_sl</span>(LINE *line)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (FPzero(line-&gt;A))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (FPzero(line-&gt;B))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> get_float8_infinity();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> float8_div(line-&gt;A, -line-&gt;B);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return inverse slope of the line<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> float8<br/></li>
<li><a id="L1247">&#x200c;</a><span class="linkable">line_invsl</span>(LINE *line)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (FPzero(line-&gt;A))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> get_float8_infinity();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (FPzero(line-&gt;B))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> float8_div(line-&gt;B, line-&gt;A);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L1261" title="utils/adt/geo_ops.c:1261">line_distance</a>()<br/></li>
<li></span><span class="Comment"> * Distance between two lines.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1261">&#x200c;</a><span class="linkable">line_distance</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LINE&nbsp; &nbsp; &nbsp;&nbsp; *l1 = PG_GETARG_LINE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; LINE&nbsp; &nbsp; &nbsp;&nbsp; *l2 = PG_GETARG_LINE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; ratio;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1314" title="utils/adt/geo_ops.c:1314">line_interpt_line</a>(<span class="Constant">NULL</span>, l1, l2))&nbsp; &nbsp; <span class="Comment">/* intersecting? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(<span class="Constant">0.0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!FPzero(l1-&gt;A) &amp;&amp; !isnan(l1-&gt;A) &amp;&amp; !FPzero(l2-&gt;A) &amp;&amp; !isnan(l2-&gt;A))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ratio = float8_div(l1-&gt;A, l2-&gt;A);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!FPzero(l1-&gt;B) &amp;&amp; !isnan(l1-&gt;B) &amp;&amp; !FPzero(l2-&gt;B) &amp;&amp; !isnan(l2-&gt;B))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ratio = float8_div(l1-&gt;B, l2-&gt;B);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ratio = <span class="Constant">1.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(float8_div(fabs(float8_mi(l1-&gt;C,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; float8_mul(ratio, l2-&gt;C))),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HYPOT(l1-&gt;A, l1-&gt;B)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L1286" title="utils/adt/geo_ops.c:1286">line_interpt</a>()<br/></li>
<li></span><span class="Comment"> * Point where two lines l1, l2 intersect (if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1286">&#x200c;</a><span class="linkable">line_interpt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LINE&nbsp; &nbsp; &nbsp;&nbsp; *l1 = PG_GETARG_LINE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; LINE&nbsp; &nbsp; &nbsp;&nbsp; *l2 = PG_GETARG_LINE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (Point *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Point));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L1314" title="utils/adt/geo_ops.c:1314">line_interpt_line</a>(result, l1, l2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Internal version of <a href="#L1286" title="utils/adt/geo_ops.c:1286">line_interpt</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return whether two lines intersect. If *result is not NULL, it is set to<br/></li>
<li></span><span class="Comment"> * the intersection point.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: If the lines are identical then we will <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> they are parallel<br/></li>
<li></span><span class="Comment"> * and report &quot;no intersection&quot;.&nbsp; This is a little weird, but since<br/></li>
<li></span><span class="Comment"> * there's no *unique* intersection, maybe it's appropriate behavior.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the lines have NaN constants, we will return true, and the intersection<br/></li>
<li></span><span class="Comment"> * point would have NaN coordinates.&nbsp; We shouldn't return false in this case<br/></li>
<li></span><span class="Comment"> * because that would mean the lines are parallel.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1314">&#x200c;</a></span><span class="linkable">line_interpt_line</span>(Point *result, LINE *l1, LINE *l2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; x,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; y;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!FPzero(l1-&gt;B))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (FPeq(l2-&gt;A, float8_mul(l1-&gt;A, float8_div(l2-&gt;B, l1-&gt;B))))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; x = float8_div(float8_mi(float8_mul(l1-&gt;B, l2-&gt;C),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; float8_mul(l2-&gt;B, l1-&gt;C)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; float8_mi(float8_mul(l1-&gt;A, l2-&gt;B),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; float8_mul(l2-&gt;A, l1-&gt;B)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; y = float8_div(-float8_pl(float8_mul(l1-&gt;A, x), l1-&gt;C), l1-&gt;B);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!FPzero(l2-&gt;B))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (FPeq(l1-&gt;A, float8_mul(l2-&gt;A, float8_div(l1-&gt;B, l2-&gt;B))))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; x = float8_div(float8_mi(float8_mul(l2-&gt;B, l1-&gt;C),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; float8_mul(l1-&gt;B, l2-&gt;C)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; float8_mi(float8_mul(l2-&gt;A, l1-&gt;B),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; float8_mul(l1-&gt;A, l2-&gt;B)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; y = float8_div(-float8_pl(float8_mul(l2-&gt;A, x), l2-&gt;C), l2-&gt;B);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* On some platforms, the preceding expressions tend to produce -0. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (x == <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; x = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (y == <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; y = <span class="Constant">0.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1884" title="utils/adt/geo_ops.c:1884">point_construct</a>(result, x, y);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/***********************************************************************<br/></li>
<li></span><span class="Comment"> **<br/></li>
<li></span><span class="Comment"> **&nbsp; &nbsp; &nbsp; &nbsp; Routines for 2D paths (sequences of line segments, also<br/></li>
<li></span><span class="Comment"> **&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; called `polylines').<br/></li>
<li></span><span class="Comment"> **<br/></li>
<li></span><span class="Comment"> **&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; This is not a general package for geometric paths,<br/></li>
<li></span><span class="Comment"> **&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; which of course include polygons; the emphasis here<br/></li>
<li></span><span class="Comment"> **&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is on (for example) usefulness in wire layout.<br/></li>
<li></span><span class="Comment"> **<br/></li>
<li></span><span class="Comment"> ***********************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*----------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; String to path / path to string conversion.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; External format:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;((xcoord, ycoord),... )&quot;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;[(xcoord, ycoord),... ]&quot;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;(xcoord, ycoord),... &quot;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;[xcoord, ycoord,... ]&quot;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Also support older format:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;(closed, npts, xcoord, ycoord,... )&quot;<br/></li>
<li></span><span class="Comment"> *---------------------------------------------------------*/<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L1380">&#x200c;</a><span class="linkable">path_area</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PATH&nbsp; &nbsp; &nbsp;&nbsp; *path = PG_GETARG_PATH_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; area = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!path-&gt;closed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; path-&gt;npts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; j = (i + <span class="Constant">1</span>) % path-&gt;npts;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; area = float8_pl(area, float8_mul(path-&gt;p[i].x, path-&gt;p[j].y));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; area = float8_mi(area, float8_mul(path-&gt;p[i].y, path-&gt;p[j].x));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(float8_div(fabs(area), <span class="Constant">2.0</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1402">&#x200c;</a><span class="linkable">path_in</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *str = PG_GETARG_CSTRING(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *escontext = fcinfo-&gt;context;<br/></li>
<li>&nbsp; &nbsp; PATH&nbsp; &nbsp; &nbsp;&nbsp; *path;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isopen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *s;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; npts;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; base_size;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; depth = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((npts = <a href="#L392" title="utils/adt/geo_ops.c:392">pair_count</a>(str, <span class="Constant">','</span>)) &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid input syntax for type </span><span class="Special">%s</span><span class="Constant">: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;path&quot;</span>, str)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; s = str;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (isspace((<span class="Type">unsigned</span> <span class="Type">char</span>) *s))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> single leading paren */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((*s == <a href="#L157" title="utils/adt/geo_ops.c:157">LDELIM</a>) &amp;&amp; (strrchr(s, <a href="#L157" title="utils/adt/geo_ops.c:157">LDELIM</a>) == s))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; depth++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; base_size = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(path-&gt;p[<span class="Constant">0</span>]) * npts;<br/></li>
<li>&nbsp; &nbsp; size = offsetof(PATH, p) + base_size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for integer overflow */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (base_size / npts != <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(path-&gt;p[<span class="Constant">0</span>]) || size &lt;= base_size)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;too many points requested&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; path = (PATH *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(path, size);<br/></li>
<li>&nbsp; &nbsp; path-&gt;npts = npts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L266" title="utils/adt/geo_ops.c:266">path_decode</a>(s, <span class="Constant">true</span>, npts, &amp;(path-&gt;p[<span class="Constant">0</span>]), &amp;isopen, &amp;s, <span class="Constant">&quot;path&quot;</span>, str,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; escontext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (depth &gt;= <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*s++ != <a href="#L158" title="utils/adt/geo_ops.c:158">RDELIM</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid input syntax for type </span><span class="Special">%s</span><span class="Constant">: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;path&quot;</span>, str)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (isspace((<span class="Type">unsigned</span> <span class="Type">char</span>) *s))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*s != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid input syntax for type </span><span class="Special">%s</span><span class="Constant">: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;path&quot;</span>, str)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; path-&gt;closed = (!isopen);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* prevent instability in unused pad bytes */<br/></li>
<li></span>&nbsp; &nbsp; path-&gt;dummy = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_PATH_P(path);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1474">&#x200c;</a><span class="linkable">path_out</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PATH&nbsp; &nbsp; &nbsp;&nbsp; *path = PG_GETARG_PATH_P(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CSTRING(<a href="#L340" title="utils/adt/geo_ops.c:340">path_encode</a>(path-&gt;closed ? PATH_CLOSED : PATH_OPEN, path-&gt;npts, path-&gt;p));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1488" title="utils/adt/geo_ops.c:1488">path_recv</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts external binary format to path<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * External representation is closed flag (a boolean byte), int32 number<br/></li>
<li></span><span class="Comment"> * of points, and the points.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1488">&#x200c;</a><span class="linkable">path_recv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; buf = (StringInfo) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PATH&nbsp; &nbsp; &nbsp;&nbsp; *path;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; closed;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; npts;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; closed = <a href="../../libpq/pqformat.c.html#L399" title="libpq/pqformat.c:399">pq_getmsgbyte</a>(buf);<br/></li>
<li>&nbsp; &nbsp; npts = <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(buf, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int32));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (npts &lt;= <span class="Constant">0</span> || npts &gt;= (int32) ((<span class="Constant">INT_MAX</span> - offsetof(PATH, p)) / <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Point)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_BINARY_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid number of points in external </span><span class="Special">\&quot;</span><span class="Constant">path</span><span class="Special">\&quot;</span><span class="Constant"> value&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; size = offsetof(PATH, p) + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(path-&gt;p[<span class="Constant">0</span>]) * npts;<br/></li>
<li>&nbsp; &nbsp; path = (PATH *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(path, size);<br/></li>
<li>&nbsp; &nbsp; path-&gt;npts = npts;<br/></li>
<li>&nbsp; &nbsp; path-&gt;closed = (closed ? <span class="Constant">1</span> : <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* prevent instability in unused pad bytes */<br/></li>
<li></span>&nbsp; &nbsp; path-&gt;dummy = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; npts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;p[i].x = <a href="../../libpq/pqformat.c.html#L488" title="libpq/pqformat.c:488">pq_getmsgfloat8</a>(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;p[i].y = <a href="../../libpq/pqformat.c.html#L488" title="libpq/pqformat.c:488">pq_getmsgfloat8</a>(buf);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_PATH_P(path);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1526" title="utils/adt/geo_ops.c:1526">path_send</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts path to binary format<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1526">&#x200c;</a><span class="linkable">path_send</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PATH&nbsp; &nbsp; &nbsp;&nbsp; *path = PG_GETARG_PATH_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L326" title="libpq/pqformat.c:326">pq_begintypsend</a>(&amp;buf);<br/></li>
<li>&nbsp; &nbsp; pq_sendbyte(&amp;buf, path-&gt;closed ? <span class="Constant">1</span> : <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; pq_sendint32(&amp;buf, path-&gt;npts);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; path-&gt;npts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L276" title="libpq/pqformat.c:276">pq_sendfloat8</a>(&amp;buf, path-&gt;p[i].x);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L276" title="libpq/pqformat.c:276">pq_sendfloat8</a>(&amp;buf, path-&gt;p[i].y);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BYTEA_P(<a href="../../libpq/pqformat.c.html#L346" title="libpq/pqformat.c:346">pq_endtypsend</a>(&amp;buf));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*----------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Relational operators.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; These are based on the path cardinality,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; as stupid as that sounds.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Better relops and access methods coming soon.<br/></li>
<li></span><span class="Comment"> *---------------------------------------------------------*/<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L1553">&#x200c;</a><span class="linkable">path_n_lt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PATH&nbsp; &nbsp; &nbsp;&nbsp; *p1 = PG_GETARG_PATH_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PATH&nbsp; &nbsp; &nbsp;&nbsp; *p2 = PG_GETARG_PATH_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(p1-&gt;npts &lt; p2-&gt;npts);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1562">&#x200c;</a><span class="linkable">path_n_gt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PATH&nbsp; &nbsp; &nbsp;&nbsp; *p1 = PG_GETARG_PATH_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PATH&nbsp; &nbsp; &nbsp;&nbsp; *p2 = PG_GETARG_PATH_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(p1-&gt;npts &gt; p2-&gt;npts);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1571">&#x200c;</a><span class="linkable">path_n_eq</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PATH&nbsp; &nbsp; &nbsp;&nbsp; *p1 = PG_GETARG_PATH_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PATH&nbsp; &nbsp; &nbsp;&nbsp; *p2 = PG_GETARG_PATH_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(p1-&gt;npts == p2-&gt;npts);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1580">&#x200c;</a><span class="linkable">path_n_le</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PATH&nbsp; &nbsp; &nbsp;&nbsp; *p1 = PG_GETARG_PATH_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PATH&nbsp; &nbsp; &nbsp;&nbsp; *p2 = PG_GETARG_PATH_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(p1-&gt;npts &lt;= p2-&gt;npts);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1589">&#x200c;</a><span class="linkable">path_n_ge</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PATH&nbsp; &nbsp; &nbsp;&nbsp; *p1 = PG_GETARG_PATH_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PATH&nbsp; &nbsp; &nbsp;&nbsp; *p2 = PG_GETARG_PATH_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(p1-&gt;npts &gt;= p2-&gt;npts);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*----------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * Conversion operators.<br/></li>
<li></span><span class="Comment"> *---------------------------------------------------------*/<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L1602">&#x200c;</a><span class="linkable">path_isclosed</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PATH&nbsp; &nbsp; &nbsp;&nbsp; *path = PG_GETARG_PATH_P(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(path-&gt;closed);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1610">&#x200c;</a><span class="linkable">path_isopen</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PATH&nbsp; &nbsp; &nbsp;&nbsp; *path = PG_GETARG_PATH_P(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(!path-&gt;closed);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1618">&#x200c;</a><span class="linkable">path_npoints</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PATH&nbsp; &nbsp; &nbsp;&nbsp; *path = PG_GETARG_PATH_P(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(path-&gt;npts);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1627">&#x200c;</a><span class="linkable">path_close</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PATH&nbsp; &nbsp; &nbsp;&nbsp; *path = PG_GETARG_PATH_P_COPY(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; path-&gt;closed = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_PATH_P(path);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1637">&#x200c;</a><span class="linkable">path_open</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PATH&nbsp; &nbsp; &nbsp;&nbsp; *path = PG_GETARG_PATH_P_COPY(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; path-&gt;closed = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_PATH_P(path);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L1653" title="utils/adt/geo_ops.c:1653">path_inter</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Does p1 intersect p2 at <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> point?<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Use bounding boxes for a quick (O(n)) check, then do a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; O(n^2) iterative edge check.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1653">&#x200c;</a><span class="linkable">path_inter</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PATH&nbsp; &nbsp; &nbsp;&nbsp; *p1 = PG_GETARG_PATH_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PATH&nbsp; &nbsp; &nbsp;&nbsp; *p2 = PG_GETARG_PATH_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp; &nbsp; seg1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seg2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(p1-&gt;npts &gt; <span class="Constant">0</span> &amp;&amp; p2-&gt;npts &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; b1.high.x = b1.low.x = p1-&gt;p[<span class="Constant">0</span>].x;<br/></li>
<li>&nbsp; &nbsp; b1.high.y = b1.low.y = p1-&gt;p[<span class="Constant">0</span>].y;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt; p1-&gt;npts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; b1.high.x = float8_max(p1-&gt;p[i].x, b1.high.x);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; b1.high.y = float8_max(p1-&gt;p[i].y, b1.high.y);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; b1.low.x = float8_min(p1-&gt;p[i].x, b1.low.x);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; b1.low.y = float8_min(p1-&gt;p[i].y, b1.low.y);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; b2.high.x = b2.low.x = p2-&gt;p[<span class="Constant">0</span>].x;<br/></li>
<li>&nbsp; &nbsp; b2.high.y = b2.low.y = p2-&gt;p[<span class="Constant">0</span>].y;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt; p2-&gt;npts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; b2.high.x = float8_max(p2-&gt;p[i].x, b2.high.x);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; b2.high.y = float8_max(p2-&gt;p[i].y, b2.high.y);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; b2.low.x = float8_min(p2-&gt;p[i].x, b2.low.x);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; b2.low.y = float8_min(p2-&gt;p[i].y, b2.low.y);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L572" title="utils/adt/geo_ops.c:572">box_ov</a>(&amp;b1, &amp;b2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* pairwise check lseg intersections */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; p1-&gt;npts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iprev;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iprev = i - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!p1-&gt;closed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iprev = p1-&gt;npts - <span class="Constant">1</span>;&nbsp; &nbsp; <span class="Comment">/* include the closure segment */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = <span class="Constant">0</span>; j &lt; p2-&gt;npts; j++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jprev;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (j &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jprev = j - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!p2-&gt;closed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jprev = p2-&gt;npts - <span class="Constant">1</span>;&nbsp; &nbsp; <span class="Comment">/* include the closure segment */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2142" title="utils/adt/geo_ops.c:2142">statlseg_construct</a>(&amp;seg1, &amp;p1-&gt;p[iprev], &amp;p1-&gt;p[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2142" title="utils/adt/geo_ops.c:2142">statlseg_construct</a>(&amp;seg2, &amp;p2-&gt;p[jprev], &amp;p2-&gt;p[j]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2338" title="utils/adt/geo_ops.c:2338">lseg_interpt_lseg</a>(<span class="Constant">NULL</span>, &amp;seg1, &amp;seg2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if we dropped through, no two segs intersected */<br/></li>
<li></span>&nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L1730" title="utils/adt/geo_ops.c:1730">path_distance</a>()<br/></li>
<li></span><span class="Comment"> * This essentially does a cartesian product of the lsegs in the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; two paths, and finds the min distance between <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> two lsegs<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1730">&#x200c;</a><span class="linkable">path_distance</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PATH&nbsp; &nbsp; &nbsp;&nbsp; *p1 = PG_GETARG_PATH_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PATH&nbsp; &nbsp; &nbsp;&nbsp; *p2 = PG_GETARG_PATH_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; min = <span class="Constant">0.0</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> to keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; have_min = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; tmp;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp; &nbsp; seg1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seg2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; p1-&gt;npts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iprev;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iprev = i - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!p1-&gt;closed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iprev = p1-&gt;npts - <span class="Constant">1</span>;&nbsp; &nbsp; <span class="Comment">/* include the closure segment */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = <span class="Constant">0</span>; j &lt; p2-&gt;npts; j++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jprev;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (j &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jprev = j - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!p2-&gt;closed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jprev = p2-&gt;npts - <span class="Constant">1</span>;&nbsp; &nbsp; <span class="Comment">/* include the closure segment */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2142" title="utils/adt/geo_ops.c:2142">statlseg_construct</a>(&amp;seg1, &amp;p1-&gt;p[iprev], &amp;p1-&gt;p[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2142" title="utils/adt/geo_ops.c:2142">statlseg_construct</a>(&amp;seg2, &amp;p2-&gt;p[jprev], &amp;p2-&gt;p[j]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp = <a href="#L2810" title="utils/adt/geo_ops.c:2810">lseg_closept_lseg</a>(<span class="Constant">NULL</span>, &amp;seg1, &amp;seg2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!have_min || float8_lt(tmp, min))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min = tmp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; have_min = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!have_min)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(min);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*----------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &quot;Arithmetic&quot; operations.<br/></li>
<li></span><span class="Comment"> *---------------------------------------------------------*/<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L1792">&#x200c;</a><span class="linkable">path_length</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PATH&nbsp; &nbsp; &nbsp;&nbsp; *path = PG_GETARG_PATH_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; path-&gt;npts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iprev;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iprev = i - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!path-&gt;closed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iprev = path-&gt;npts - <span class="Constant">1</span>; <span class="Comment">/* include the closure segment */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = float8_pl(result, <a href="#L2002" title="utils/adt/geo_ops.c:2002">point_dt</a>(&amp;path-&gt;p[iprev], &amp;path-&gt;p[i]));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/***********************************************************************<br/></li>
<li></span><span class="Comment"> **<br/></li>
<li></span><span class="Comment"> **&nbsp; &nbsp; &nbsp; &nbsp; Routines for 2D points.<br/></li>
<li></span><span class="Comment"> **<br/></li>
<li></span><span class="Comment"> ***********************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*----------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; String to point, point to string conversion.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; External format:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;(x,y)&quot;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;x,y&quot;<br/></li>
<li></span><span class="Comment"> *---------------------------------------------------------*/<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L1831">&#x200c;</a><span class="linkable">point_in</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *str = PG_GETARG_CSTRING(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *point = (Point *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Point));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Ignore failure from <a href="#L212" title="utils/adt/geo_ops.c:212">pair_decode</a>, since our return value won't matter */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L212" title="utils/adt/geo_ops.c:212">pair_decode</a>(str, &amp;point-&gt;x, &amp;point-&gt;y, <span class="Constant">NULL</span>, <span class="Constant">&quot;point&quot;</span>, str, fcinfo-&gt;context);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINT_P(point);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1842">&#x200c;</a><span class="linkable">point_out</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *pt = PG_GETARG_POINT_P(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CSTRING(<a href="#L340" title="utils/adt/geo_ops.c:340">path_encode</a>(PATH_NONE, <span class="Constant">1</span>, pt));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1853" title="utils/adt/geo_ops.c:1853">point_recv</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts external binary format to point<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1853">&#x200c;</a><span class="linkable">point_recv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; buf = (StringInfo) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *point;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; point = (Point *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Point));<br/></li>
<li>&nbsp; &nbsp; point-&gt;x = <a href="../../libpq/pqformat.c.html#L488" title="libpq/pqformat.c:488">pq_getmsgfloat8</a>(buf);<br/></li>
<li>&nbsp; &nbsp; point-&gt;y = <a href="../../libpq/pqformat.c.html#L488" title="libpq/pqformat.c:488">pq_getmsgfloat8</a>(buf);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINT_P(point);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1868" title="utils/adt/geo_ops.c:1868">point_send</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts point to binary format<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1868">&#x200c;</a><span class="linkable">point_send</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *pt = PG_GETARG_POINT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L326" title="libpq/pqformat.c:326">pq_begintypsend</a>(&amp;buf);<br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L276" title="libpq/pqformat.c:276">pq_sendfloat8</a>(&amp;buf, pt-&gt;x);<br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L276" title="libpq/pqformat.c:276">pq_sendfloat8</a>(&amp;buf, pt-&gt;y);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BYTEA_P(<a href="../../libpq/pqformat.c.html#L346" title="libpq/pqformat.c:346">pq_endtypsend</a>(&amp;buf));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize a point<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L1884">&#x200c;</a></span><span class="linkable">point_construct</span>(Point *result, float8 x, float8 y)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; result-&gt;x = x;<br/></li>
<li>&nbsp; &nbsp; result-&gt;y = y;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*----------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Relational operators for Points.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Since we do have a sense of coordinates being<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &quot;<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>&quot; to a given accuracy (<a href="#L1937" title="utils/adt/geo_ops.c:1937">point_vert</a>, <a href="#L1946" title="utils/adt/geo_ops.c:1946">point_horiz</a>),<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; the other ops must preserve that sense.&nbsp; This means<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; that results may, strictly speaking, be a lie (unless<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; EPSILON = 0.0).<br/></li>
<li></span><span class="Comment"> *---------------------------------------------------------*/<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L1901">&#x200c;</a><span class="linkable">point_left</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *pt1 = PG_GETARG_POINT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *pt2 = PG_GETARG_POINT_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(FPlt(pt1-&gt;x, pt2-&gt;x));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1910">&#x200c;</a><span class="linkable">point_right</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *pt1 = PG_GETARG_POINT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *pt2 = PG_GETARG_POINT_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(FPgt(pt1-&gt;x, pt2-&gt;x));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1919">&#x200c;</a><span class="linkable">point_above</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *pt1 = PG_GETARG_POINT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *pt2 = PG_GETARG_POINT_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(FPgt(pt1-&gt;y, pt2-&gt;y));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1928">&#x200c;</a><span class="linkable">point_below</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *pt1 = PG_GETARG_POINT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *pt2 = PG_GETARG_POINT_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(FPlt(pt1-&gt;y, pt2-&gt;y));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1937">&#x200c;</a><span class="linkable">point_vert</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *pt1 = PG_GETARG_POINT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *pt2 = PG_GETARG_POINT_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(FPeq(pt1-&gt;x, pt2-&gt;x));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1946">&#x200c;</a><span class="linkable">point_horiz</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *pt1 = PG_GETARG_POINT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *pt2 = PG_GETARG_POINT_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(FPeq(pt1-&gt;y, pt2-&gt;y));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1955">&#x200c;</a><span class="linkable">point_eq</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *pt1 = PG_GETARG_POINT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *pt2 = PG_GETARG_POINT_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L1977" title="utils/adt/geo_ops.c:1977">point_eq_point</a>(pt1, pt2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1964">&#x200c;</a><span class="linkable">point_ne</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *pt1 = PG_GETARG_POINT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *pt2 = PG_GETARG_POINT_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(!<a href="#L1977" title="utils/adt/geo_ops.c:1977">point_eq_point</a>(pt1, pt2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check whether the two points are the same<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1977">&#x200c;</a></span><span class="linkable">point_eq_point</span>(Point *pt1, Point *pt2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> NaNs are involved, insist on exact equality */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(isnan(pt1-&gt;x) || isnan(pt1-&gt;y) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; isnan(pt2-&gt;x) || isnan(pt2-&gt;y)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (float8_eq(pt1-&gt;x, pt2-&gt;x) &amp;&amp; float8_eq(pt1-&gt;y, pt2-&gt;y));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (FPeq(pt1-&gt;x, pt2-&gt;x) &amp;&amp; FPeq(pt1-&gt;y, pt2-&gt;y));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*----------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &quot;Arithmetic&quot; operators on points.<br/></li>
<li></span><span class="Comment"> *---------------------------------------------------------*/<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L1993">&#x200c;</a><span class="linkable">point_distance</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *pt1 = PG_GETARG_POINT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *pt2 = PG_GETARG_POINT_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(<a href="#L2002" title="utils/adt/geo_ops.c:2002">point_dt</a>(pt1, pt2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> float8<br/></li>
<li><a id="L2002">&#x200c;</a><span class="linkable">point_dt</span>(Point *pt1, Point *pt2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> HYPOT(float8_mi(pt1-&gt;x, pt2-&gt;x), float8_mi(pt1-&gt;y, pt2-&gt;y));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2008">&#x200c;</a><span class="linkable">point_slope</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *pt1 = PG_GETARG_POINT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *pt2 = PG_GETARG_POINT_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(<a href="#L2023" title="utils/adt/geo_ops.c:2023">point_sl</a>(pt1, pt2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return slope of two points<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that this function returns Inf when the points are the same.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> float8<br/></li>
<li><a id="L2023">&#x200c;</a><span class="linkable">point_sl</span>(Point *pt1, Point *pt2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (FPeq(pt1-&gt;x, pt2-&gt;x))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> get_float8_infinity();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (FPeq(pt1-&gt;y, pt2-&gt;y))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> float8_div(float8_mi(pt1-&gt;y, pt2-&gt;y), float8_mi(pt1-&gt;x, pt2-&gt;x));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return inverse slope of two points<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that this function returns 0.0 when the points are the same.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> float8<br/></li>
<li><a id="L2039">&#x200c;</a><span class="linkable">point_invsl</span>(Point *pt1, Point *pt2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (FPeq(pt1-&gt;x, pt2-&gt;x))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (FPeq(pt1-&gt;y, pt2-&gt;y))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> get_float8_infinity();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> float8_div(float8_mi(pt1-&gt;x, pt2-&gt;x), float8_mi(pt2-&gt;y, pt1-&gt;y));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/***********************************************************************<br/></li>
<li></span><span class="Comment"> **<br/></li>
<li></span><span class="Comment"> **&nbsp; &nbsp; &nbsp; &nbsp; Routines for 2D line segments.<br/></li>
<li></span><span class="Comment"> **<br/></li>
<li></span><span class="Comment"> ***********************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*----------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; String to lseg, lseg to string conversion.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; External forms: &quot;[(x1, y1), (x2, y2)]&quot;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;(x1, y1), (x2, y2)&quot;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;x1, y1, x2, y2&quot;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; closed form ok&nbsp; &nbsp; &quot;((x1, y1), (x2, y2))&quot;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; (old form)&nbsp; &nbsp; &nbsp; &nbsp; &quot;(x1, y1, x2, y2)&quot;<br/></li>
<li></span><span class="Comment"> *---------------------------------------------------------*/<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L2065">&#x200c;</a><span class="linkable">lseg_in</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *str = PG_GETARG_CSTRING(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *escontext = fcinfo-&gt;context;<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp;&nbsp; *lseg = (LSEG *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(LSEG));<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isopen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L266" title="utils/adt/geo_ops.c:266">path_decode</a>(str, <span class="Constant">true</span>, <span class="Constant">2</span>, &amp;lseg-&gt;p[<span class="Constant">0</span>], &amp;isopen, <span class="Constant">NULL</span>, <span class="Constant">&quot;lseg&quot;</span>, str,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; escontext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_LSEG_P(lseg);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2081">&#x200c;</a><span class="linkable">lseg_out</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp;&nbsp; *ls = PG_GETARG_LSEG_P(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CSTRING(<a href="#L340" title="utils/adt/geo_ops.c:340">path_encode</a>(PATH_OPEN, <span class="Constant">2</span>, &amp;ls-&gt;p[<span class="Constant">0</span>]));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2092" title="utils/adt/geo_ops.c:2092">lseg_recv</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts external binary format to lseg<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2092">&#x200c;</a><span class="linkable">lseg_recv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; buf = (StringInfo) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp;&nbsp; *lseg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; lseg = (LSEG *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(LSEG));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; lseg-&gt;p[<span class="Constant">0</span>].x = <a href="../../libpq/pqformat.c.html#L488" title="libpq/pqformat.c:488">pq_getmsgfloat8</a>(buf);<br/></li>
<li>&nbsp; &nbsp; lseg-&gt;p[<span class="Constant">0</span>].y = <a href="../../libpq/pqformat.c.html#L488" title="libpq/pqformat.c:488">pq_getmsgfloat8</a>(buf);<br/></li>
<li>&nbsp; &nbsp; lseg-&gt;p[<span class="Constant">1</span>].x = <a href="../../libpq/pqformat.c.html#L488" title="libpq/pqformat.c:488">pq_getmsgfloat8</a>(buf);<br/></li>
<li>&nbsp; &nbsp; lseg-&gt;p[<span class="Constant">1</span>].y = <a href="../../libpq/pqformat.c.html#L488" title="libpq/pqformat.c:488">pq_getmsgfloat8</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_LSEG_P(lseg);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2111" title="utils/adt/geo_ops.c:2111">lseg_send</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts lseg to binary format<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2111">&#x200c;</a><span class="linkable">lseg_send</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp;&nbsp; *ls = PG_GETARG_LSEG_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L326" title="libpq/pqformat.c:326">pq_begintypsend</a>(&amp;buf);<br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L276" title="libpq/pqformat.c:276">pq_sendfloat8</a>(&amp;buf, ls-&gt;p[<span class="Constant">0</span>].x);<br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L276" title="libpq/pqformat.c:276">pq_sendfloat8</a>(&amp;buf, ls-&gt;p[<span class="Constant">0</span>].y);<br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L276" title="libpq/pqformat.c:276">pq_sendfloat8</a>(&amp;buf, ls-&gt;p[<span class="Constant">1</span>].x);<br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L276" title="libpq/pqformat.c:276">pq_sendfloat8</a>(&amp;buf, ls-&gt;p[<span class="Constant">1</span>].y);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BYTEA_P(<a href="../../libpq/pqformat.c.html#L346" title="libpq/pqformat.c:346">pq_endtypsend</a>(&amp;buf));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L2129" title="utils/adt/geo_ops.c:2129">lseg_construct</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; form a LSEG from two Points.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2129">&#x200c;</a><span class="linkable">lseg_construct</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *pt1 = PG_GETARG_POINT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *pt2 = PG_GETARG_POINT_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp;&nbsp; *result = (LSEG *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(LSEG));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2142" title="utils/adt/geo_ops.c:2142">statlseg_construct</a>(result, pt1, pt2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_LSEG_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* like <a href="#L2129" title="utils/adt/geo_ops.c:2129">lseg_construct</a>, but assume space already allocated */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L2142">&#x200c;</a></span><span class="linkable">statlseg_construct</span>(LSEG *lseg, Point *pt1, Point *pt2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; lseg-&gt;p[<span class="Constant">0</span>].x = pt1-&gt;x;<br/></li>
<li>&nbsp; &nbsp; lseg-&gt;p[<span class="Constant">0</span>].y = pt1-&gt;y;<br/></li>
<li>&nbsp; &nbsp; lseg-&gt;p[<span class="Constant">1</span>].x = pt2-&gt;x;<br/></li>
<li>&nbsp; &nbsp; lseg-&gt;p[<span class="Constant">1</span>].y = pt2-&gt;y;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return slope of the line segment<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> float8<br/></li>
<li><a id="L2155">&#x200c;</a><span class="linkable">lseg_sl</span>(LSEG *lseg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2023" title="utils/adt/geo_ops.c:2023">point_sl</a>(&amp;lseg-&gt;p[<span class="Constant">0</span>], &amp;lseg-&gt;p[<span class="Constant">1</span>]);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return inverse slope of the line segment<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> float8<br/></li>
<li><a id="L2165">&#x200c;</a><span class="linkable">lseg_invsl</span>(LSEG *lseg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2039" title="utils/adt/geo_ops.c:2039">point_invsl</a>(&amp;lseg-&gt;p[<span class="Constant">0</span>], &amp;lseg-&gt;p[<span class="Constant">1</span>]);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2172">&#x200c;</a><span class="linkable">lseg_length</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp;&nbsp; *lseg = PG_GETARG_LSEG_P(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(<a href="#L2002" title="utils/adt/geo_ops.c:2002">point_dt</a>(&amp;lseg-&gt;p[<span class="Constant">0</span>], &amp;lseg-&gt;p[<span class="Constant">1</span>]));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*----------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Relative position routines.<br/></li>
<li></span><span class="Comment"> *---------------------------------------------------------*/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> **&nbsp; <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> intersection of the two lines, and see if it falls on<br/></li>
<li></span><span class="Comment"> **&nbsp; both segments.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2188">&#x200c;</a><span class="linkable">lseg_intersect</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp;&nbsp; *l1 = PG_GETARG_LSEG_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp;&nbsp; *l2 = PG_GETARG_LSEG_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2338" title="utils/adt/geo_ops.c:2338">lseg_interpt_lseg</a>(<span class="Constant">NULL</span>, l1, l2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2198">&#x200c;</a><span class="linkable">lseg_parallel</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp;&nbsp; *l1 = PG_GETARG_LSEG_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp;&nbsp; *l2 = PG_GETARG_LSEG_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(FPeq(<a href="#L2155" title="utils/adt/geo_ops.c:2155">lseg_sl</a>(l1), <a href="#L2155" title="utils/adt/geo_ops.c:2155">lseg_sl</a>(l2)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Determine if two line segments are perpendicular.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2210">&#x200c;</a><span class="linkable">lseg_perp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp;&nbsp; *l1 = PG_GETARG_LSEG_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp;&nbsp; *l2 = PG_GETARG_LSEG_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(FPeq(<a href="#L2155" title="utils/adt/geo_ops.c:2155">lseg_sl</a>(l1), <a href="#L2165" title="utils/adt/geo_ops.c:2165">lseg_invsl</a>(l2)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2219">&#x200c;</a><span class="linkable">lseg_vertical</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp;&nbsp; *lseg = PG_GETARG_LSEG_P(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(FPeq(lseg-&gt;p[<span class="Constant">0</span>].x, lseg-&gt;p[<span class="Constant">1</span>].x));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2227">&#x200c;</a><span class="linkable">lseg_horizontal</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp;&nbsp; *lseg = PG_GETARG_LSEG_P(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(FPeq(lseg-&gt;p[<span class="Constant">0</span>].y, lseg-&gt;p[<span class="Constant">1</span>].y));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2236">&#x200c;</a><span class="linkable">lseg_eq</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp;&nbsp; *l1 = PG_GETARG_LSEG_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp;&nbsp; *l2 = PG_GETARG_LSEG_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L1977" title="utils/adt/geo_ops.c:1977">point_eq_point</a>(&amp;l1-&gt;p[<span class="Constant">0</span>], &amp;l2-&gt;p[<span class="Constant">0</span>]) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L1977" title="utils/adt/geo_ops.c:1977">point_eq_point</a>(&amp;l1-&gt;p[<span class="Constant">1</span>], &amp;l2-&gt;p[<span class="Constant">1</span>]));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2246">&#x200c;</a><span class="linkable">lseg_ne</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp;&nbsp; *l1 = PG_GETARG_LSEG_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp;&nbsp; *l2 = PG_GETARG_LSEG_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(!<a href="#L1977" title="utils/adt/geo_ops.c:1977">point_eq_point</a>(&amp;l1-&gt;p[<span class="Constant">0</span>], &amp;l2-&gt;p[<span class="Constant">0</span>]) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !<a href="#L1977" title="utils/adt/geo_ops.c:1977">point_eq_point</a>(&amp;l1-&gt;p[<span class="Constant">1</span>], &amp;l2-&gt;p[<span class="Constant">1</span>]));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2256">&#x200c;</a><span class="linkable">lseg_lt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp;&nbsp; *l1 = PG_GETARG_LSEG_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp;&nbsp; *l2 = PG_GETARG_LSEG_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(FPlt(<a href="#L2002" title="utils/adt/geo_ops.c:2002">point_dt</a>(&amp;l1-&gt;p[<span class="Constant">0</span>], &amp;l1-&gt;p[<span class="Constant">1</span>]),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2002" title="utils/adt/geo_ops.c:2002">point_dt</a>(&amp;l2-&gt;p[<span class="Constant">0</span>], &amp;l2-&gt;p[<span class="Constant">1</span>])));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2266">&#x200c;</a><span class="linkable">lseg_le</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp;&nbsp; *l1 = PG_GETARG_LSEG_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp;&nbsp; *l2 = PG_GETARG_LSEG_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(FPle(<a href="#L2002" title="utils/adt/geo_ops.c:2002">point_dt</a>(&amp;l1-&gt;p[<span class="Constant">0</span>], &amp;l1-&gt;p[<span class="Constant">1</span>]),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2002" title="utils/adt/geo_ops.c:2002">point_dt</a>(&amp;l2-&gt;p[<span class="Constant">0</span>], &amp;l2-&gt;p[<span class="Constant">1</span>])));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2276">&#x200c;</a><span class="linkable">lseg_gt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp;&nbsp; *l1 = PG_GETARG_LSEG_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp;&nbsp; *l2 = PG_GETARG_LSEG_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(FPgt(<a href="#L2002" title="utils/adt/geo_ops.c:2002">point_dt</a>(&amp;l1-&gt;p[<span class="Constant">0</span>], &amp;l1-&gt;p[<span class="Constant">1</span>]),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2002" title="utils/adt/geo_ops.c:2002">point_dt</a>(&amp;l2-&gt;p[<span class="Constant">0</span>], &amp;l2-&gt;p[<span class="Constant">1</span>])));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2286">&#x200c;</a><span class="linkable">lseg_ge</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp;&nbsp; *l1 = PG_GETARG_LSEG_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp;&nbsp; *l2 = PG_GETARG_LSEG_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(FPge(<a href="#L2002" title="utils/adt/geo_ops.c:2002">point_dt</a>(&amp;l1-&gt;p[<span class="Constant">0</span>], &amp;l1-&gt;p[<span class="Constant">1</span>]),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2002" title="utils/adt/geo_ops.c:2002">point_dt</a>(&amp;l2-&gt;p[<span class="Constant">0</span>], &amp;l2-&gt;p[<span class="Constant">1</span>])));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*----------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Line arithmetic routines.<br/></li>
<li></span><span class="Comment"> *---------------------------------------------------------*/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* <a href="#L2306" title="utils/adt/geo_ops.c:2306">lseg_distance</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; If two segments don't intersect, then the closest<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; point will be from one of the endpoints to the other<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; segment.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2306">&#x200c;</a><span class="linkable">lseg_distance</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp;&nbsp; *l1 = PG_GETARG_LSEG_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp;&nbsp; *l2 = PG_GETARG_LSEG_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(<a href="#L2810" title="utils/adt/geo_ops.c:2810">lseg_closept_lseg</a>(<span class="Constant">NULL</span>, l1, l2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2316">&#x200c;</a><span class="linkable">lseg_center</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp;&nbsp; *lseg = PG_GETARG_LSEG_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (Point *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Point));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result-&gt;x = float8_div(float8_pl(lseg-&gt;p[<span class="Constant">0</span>].x, lseg-&gt;p[<span class="Constant">1</span>].x), <span class="Constant">2.0</span>);<br/></li>
<li>&nbsp; &nbsp; result-&gt;y = float8_div(float8_pl(lseg-&gt;p[<span class="Constant">0</span>].y, lseg-&gt;p[<span class="Constant">1</span>].y), <span class="Constant">2.0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return whether the two segments intersect. If *result is not NULL,<br/></li>
<li></span><span class="Comment"> * it is set to the intersection point.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function is almost perfectly symmetric, even though it doesn't look<br/></li>
<li></span><span class="Comment"> * like it.&nbsp; See <a href="#L2675" title="utils/adt/geo_ops.c:2675">lseg_interpt_line</a>() for the other half of it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2338">&#x200c;</a></span><span class="linkable">lseg_interpt_lseg</span>(Point *result, LSEG *l1, LSEG *l2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp; &nbsp; interpt;<br/></li>
<li>&nbsp; &nbsp; LINE&nbsp; &nbsp; &nbsp; &nbsp; tmp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1083" title="utils/adt/geo_ops.c:1083">line_construct</a>(&amp;tmp, &amp;l2-&gt;p[<span class="Constant">0</span>], <a href="#L2155" title="utils/adt/geo_ops.c:2155">lseg_sl</a>(l2));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L2675" title="utils/adt/geo_ops.c:2675">lseg_interpt_line</a>(&amp;interpt, l1, &amp;tmp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the line intersection point isn't within l2, there is no valid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * segment intersection point at all.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L3109" title="utils/adt/geo_ops.c:3109">lseg_contain_point</a>(l2, &amp;interpt))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *result = interpt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2361">&#x200c;</a><span class="linkable">lseg_interpt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp;&nbsp; *l1 = PG_GETARG_LSEG_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp;&nbsp; *l2 = PG_GETARG_LSEG_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (Point *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Point));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L2338" title="utils/adt/geo_ops.c:2338">lseg_interpt_lseg</a>(result, l1, l2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/***********************************************************************<br/></li>
<li></span><span class="Comment"> **<br/></li>
<li></span><span class="Comment"> **&nbsp; &nbsp; &nbsp; &nbsp; Routines for position comparisons of differently-typed<br/></li>
<li></span><span class="Comment"> **&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2D objects.<br/></li>
<li></span><span class="Comment"> **<br/></li>
<li></span><span class="Comment"> ***********************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*---------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; dist_<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Minimum distance from one object to another.<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------*/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Distance from a point to a line<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2390">&#x200c;</a><span class="linkable">dist_pl</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *pt = PG_GETARG_POINT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; LINE&nbsp; &nbsp; &nbsp;&nbsp; *line = PG_GETARG_LINE_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(<a href="#L2724" title="utils/adt/geo_ops.c:2724">line_closept_point</a>(<span class="Constant">NULL</span>, line, pt));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Distance from a line to a point<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2402">&#x200c;</a><span class="linkable">dist_lp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LINE&nbsp; &nbsp; &nbsp;&nbsp; *line = PG_GETARG_LINE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *pt = PG_GETARG_POINT_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(<a href="#L2724" title="utils/adt/geo_ops.c:2724">line_closept_point</a>(<span class="Constant">NULL</span>, line, pt));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Distance from a point to a lseg<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2414">&#x200c;</a><span class="linkable">dist_ps</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *pt = PG_GETARG_POINT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp;&nbsp; *lseg = PG_GETARG_LSEG_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(<a href="#L2772" title="utils/adt/geo_ops.c:2772">lseg_closept_point</a>(<span class="Constant">NULL</span>, lseg, pt));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Distance from a lseg to a point<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2426">&#x200c;</a><span class="linkable">dist_sp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp;&nbsp; *lseg = PG_GETARG_LSEG_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *pt = PG_GETARG_POINT_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(<a href="#L2772" title="utils/adt/geo_ops.c:2772">lseg_closept_point</a>(<span class="Constant">NULL</span>, lseg, pt));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> float8<br/></li>
<li><a id="L2435">&#x200c;</a><span class="linkable">dist_ppath_internal</span>(Point *pt, PATH *path)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">0.0</span>;&nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; have_min = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; tmp;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp; &nbsp; lseg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(path-&gt;npts &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The distance from a point to a path is the smallest distance from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * point to <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of its constituent segments.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; path-&gt;npts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iprev;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iprev = i - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!path-&gt;closed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iprev = path-&gt;npts - <span class="Constant">1</span>; <span class="Comment">/* Include the closure segment */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2142" title="utils/adt/geo_ops.c:2142">statlseg_construct</a>(&amp;lseg, &amp;path-&gt;p[iprev], &amp;path-&gt;p[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tmp = <a href="#L2772" title="utils/adt/geo_ops.c:2772">lseg_closept_point</a>(<span class="Constant">NULL</span>, &amp;lseg, pt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!have_min || float8_lt(tmp, result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = tmp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; have_min = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Distance from a point to a path<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2478">&#x200c;</a><span class="linkable">dist_ppath</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *pt = PG_GETARG_POINT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PATH&nbsp; &nbsp; &nbsp;&nbsp; *path = PG_GETARG_PATH_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(<a href="#L2435" title="utils/adt/geo_ops.c:2435">dist_ppath_internal</a>(pt, path));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Distance from a path to a point<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2490">&#x200c;</a><span class="linkable">dist_pathp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PATH&nbsp; &nbsp; &nbsp;&nbsp; *path = PG_GETARG_PATH_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *pt = PG_GETARG_POINT_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(<a href="#L2435" title="utils/adt/geo_ops.c:2435">dist_ppath_internal</a>(pt, path));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Distance from a point to a box<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2502">&#x200c;</a><span class="linkable">dist_pb</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *pt = PG_GETARG_POINT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box = PG_GETARG_BOX_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(<a href="#L2878" title="utils/adt/geo_ops.c:2878">box_closept_point</a>(<span class="Constant">NULL</span>, box, pt));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Distance from a box to a point<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2514">&#x200c;</a><span class="linkable">dist_bp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box = PG_GETARG_BOX_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *pt = PG_GETARG_POINT_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(<a href="#L2878" title="utils/adt/geo_ops.c:2878">box_closept_point</a>(<span class="Constant">NULL</span>, box, pt));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Distance from a lseg to a line<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2526">&#x200c;</a><span class="linkable">dist_sl</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp;&nbsp; *lseg = PG_GETARG_LSEG_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; LINE&nbsp; &nbsp; &nbsp;&nbsp; *line = PG_GETARG_LINE_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(<a href="#L2960" title="utils/adt/geo_ops.c:2960">lseg_closept_line</a>(<span class="Constant">NULL</span>, lseg, line));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Distance from a line to a lseg<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2538">&#x200c;</a><span class="linkable">dist_ls</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LINE&nbsp; &nbsp; &nbsp;&nbsp; *line = PG_GETARG_LINE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp;&nbsp; *lseg = PG_GETARG_LSEG_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(<a href="#L2960" title="utils/adt/geo_ops.c:2960">lseg_closept_line</a>(<span class="Constant">NULL</span>, lseg, line));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Distance from a lseg to a box<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2550">&#x200c;</a><span class="linkable">dist_sb</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp;&nbsp; *lseg = PG_GETARG_LSEG_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box = PG_GETARG_BOX_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(<a href="#L3013" title="utils/adt/geo_ops.c:3013">box_closept_lseg</a>(<span class="Constant">NULL</span>, box, lseg));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Distance from a box to a lseg<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2562">&#x200c;</a><span class="linkable">dist_bs</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box = PG_GETARG_BOX_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp;&nbsp; *lseg = PG_GETARG_LSEG_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(<a href="#L3013" title="utils/adt/geo_ops.c:3013">box_closept_lseg</a>(<span class="Constant">NULL</span>, box, lseg));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> float8<br/></li>
<li><a id="L2571">&#x200c;</a><span class="linkable">dist_cpoly_internal</span>(CIRCLE *circle, POLYGON *poly)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* calculate distance to center, and subtract radius */<br/></li>
<li></span>&nbsp; &nbsp; result = float8_mi(<a href="#L2630" title="utils/adt/geo_ops.c:2630">dist_ppoly_internal</a>(&amp;circle-&gt;center, poly),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; circle-&gt;radius);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result &lt; <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">0.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Distance from a circle to a polygon<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2588">&#x200c;</a><span class="linkable">dist_cpoly</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle = PG_GETARG_CIRCLE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; POLYGON&nbsp; &nbsp; *poly = PG_GETARG_POLYGON_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(<a href="#L2571" title="utils/adt/geo_ops.c:2571">dist_cpoly_internal</a>(circle, poly));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Distance from a polygon to a circle<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2600">&#x200c;</a><span class="linkable">dist_polyc</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; POLYGON&nbsp; &nbsp; *poly = PG_GETARG_POLYGON_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle = PG_GETARG_CIRCLE_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(<a href="#L2571" title="utils/adt/geo_ops.c:2571">dist_cpoly_internal</a>(circle, poly));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Distance from a point to a polygon<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2612">&#x200c;</a><span class="linkable">dist_ppoly</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *point = PG_GETARG_POINT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; POLYGON&nbsp; &nbsp; *poly = PG_GETARG_POLYGON_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(<a href="#L2630" title="utils/adt/geo_ops.c:2630">dist_ppoly_internal</a>(point, poly));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2621">&#x200c;</a><span class="linkable">dist_polyp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; POLYGON&nbsp; &nbsp; *poly = PG_GETARG_POLYGON_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *point = PG_GETARG_POINT_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(<a href="#L2630" title="utils/adt/geo_ops.c:2630">dist_ppoly_internal</a>(point, poly));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> float8<br/></li>
<li><a id="L2630">&#x200c;</a><span class="linkable">dist_ppoly_internal</span>(Point *pt, POLYGON *poly)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; d;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp; &nbsp; seg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L5340" title="utils/adt/geo_ops.c:5340">point_inside</a>(pt, poly-&gt;npts, poly-&gt;p) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> distance with segment between first and last points */<br/></li>
<li></span>&nbsp; &nbsp; seg.p[<span class="Constant">0</span>].x = poly-&gt;p[<span class="Constant">0</span>].x;<br/></li>
<li>&nbsp; &nbsp; seg.p[<span class="Constant">0</span>].y = poly-&gt;p[<span class="Constant">0</span>].y;<br/></li>
<li>&nbsp; &nbsp; seg.p[<span class="Constant">1</span>].x = poly-&gt;p[poly-&gt;npts - <span class="Constant">1</span>].x;<br/></li>
<li>&nbsp; &nbsp; seg.p[<span class="Constant">1</span>].y = poly-&gt;p[poly-&gt;npts - <span class="Constant">1</span>].y;<br/></li>
<li>&nbsp; &nbsp; result = <a href="#L2772" title="utils/adt/geo_ops.c:2772">lseg_closept_point</a>(<span class="Constant">NULL</span>, &amp;seg, pt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check distances for other segments */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; poly-&gt;npts - <span class="Constant">1</span>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; seg.p[<span class="Constant">0</span>].x = poly-&gt;p[i].x;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; seg.p[<span class="Constant">0</span>].y = poly-&gt;p[i].y;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; seg.p[<span class="Constant">1</span>].x = poly-&gt;p[i + <span class="Constant">1</span>].x;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; seg.p[<span class="Constant">1</span>].y = poly-&gt;p[i + <span class="Constant">1</span>].y;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; d = <a href="#L2772" title="utils/adt/geo_ops.c:2772">lseg_closept_point</a>(<span class="Constant">NULL</span>, &amp;seg, pt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (float8_lt(d, result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = d;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*---------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; interpt_<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Intersection point of objects.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; We choose to ignore the &quot;point&quot; of intersection between<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lines and boxes, since there are typically two.<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------*/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return whether the line segment intersect with the line. If *result is not<br/></li>
<li></span><span class="Comment"> * NULL, it is set to the intersection point.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2675">&#x200c;</a></span><span class="linkable">lseg_interpt_line</span>(Point *result, LSEG *lseg, LINE *line)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp; &nbsp; interpt;<br/></li>
<li>&nbsp; &nbsp; LINE&nbsp; &nbsp; &nbsp; &nbsp; tmp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First, we promote the line segment to a line, because we know how to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the intersection point of two lines.&nbsp; If they don't have an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * intersection point, we are done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1083" title="utils/adt/geo_ops.c:1083">line_construct</a>(&amp;tmp, &amp;lseg-&gt;p[<span class="Constant">0</span>], <a href="#L2155" title="utils/adt/geo_ops.c:2155">lseg_sl</a>(lseg));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L1314" title="utils/adt/geo_ops.c:1314">line_interpt_line</a>(&amp;interpt, &amp;tmp, line))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Then, we check whether the intersection point is actually on the line<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * segment.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L3109" title="utils/adt/geo_ops.c:3109">lseg_contain_point</a>(lseg, &amp;interpt))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If there is an intersection, then check explicitly for matching<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * endpoints since there may be rounding effects with annoying LSB<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * residue.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1977" title="utils/adt/geo_ops.c:1977">point_eq_point</a>(&amp;lseg-&gt;p[<span class="Constant">0</span>], &amp;interpt))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *result = lseg-&gt;p[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L1977" title="utils/adt/geo_ops.c:1977">point_eq_point</a>(&amp;lseg-&gt;p[<span class="Constant">1</span>], &amp;interpt))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *result = lseg-&gt;p[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *result = interpt;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*---------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; close_<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Point of closest proximity between objects.<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------*/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * If *result is not NULL, it is set to the intersection point of a<br/></li>
<li></span><span class="Comment"> * perpendicular of the line through the point.&nbsp; Returns the distance<br/></li>
<li></span><span class="Comment"> * of those two points.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> float8<br/></li>
<li><a id="L2724">&#x200c;</a><span class="linkable">line_closept_point</span>(Point *result, LINE *line, Point *point)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp; &nbsp; closept;<br/></li>
<li>&nbsp; &nbsp; LINE&nbsp; &nbsp; &nbsp; &nbsp; tmp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We drop a perpendicular to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the intersection point.&nbsp; Ordinarily we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * should always <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> it, but that can fail in the presence of NaN<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * coordinates, and perhaps even from simple roundoff issues.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1083" title="utils/adt/geo_ops.c:1083">line_construct</a>(&amp;tmp, point, <a href="#L1247" title="utils/adt/geo_ops.c:1247">line_invsl</a>(line));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L1314" title="utils/adt/geo_ops.c:1314">line_interpt_line</a>(&amp;closept, &amp;tmp, line))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *result = *point;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> get_float8_nan();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *result = closept;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2002" title="utils/adt/geo_ops.c:2002">point_dt</a>(&amp;closept, point);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2750">&#x200c;</a><span class="linkable">close_pl</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *pt = PG_GETARG_POINT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; LINE&nbsp; &nbsp; &nbsp;&nbsp; *line = PG_GETARG_LINE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (Point *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Point));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isnan(<a href="#L2724" title="utils/adt/geo_ops.c:2724">line_closept_point</a>(result, line, pt)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Closest point on line segment to specified point.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If *result is not NULL, set it to the closest point on the line segment<br/></li>
<li></span><span class="Comment"> * to the point.&nbsp; Returns the distance of the two points.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> float8<br/></li>
<li><a id="L2772">&#x200c;</a><span class="linkable">lseg_closept_point</span>(Point *result, LSEG *lseg, Point *pt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp; &nbsp; closept;<br/></li>
<li>&nbsp; &nbsp; LINE&nbsp; &nbsp; &nbsp; &nbsp; tmp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * To <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the closest point, we draw a perpendicular line from the point<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to the line segment.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1083" title="utils/adt/geo_ops.c:1083">line_construct</a>(&amp;tmp, pt, <a href="#L2039" title="utils/adt/geo_ops.c:2039">point_invsl</a>(&amp;lseg-&gt;p[<span class="Constant">0</span>], &amp;lseg-&gt;p[<span class="Constant">1</span>]));<br/></li>
<li>&nbsp; &nbsp; <a href="#L2960" title="utils/adt/geo_ops.c:2960">lseg_closept_line</a>(&amp;closept, lseg, &amp;tmp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *result = closept;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2002" title="utils/adt/geo_ops.c:2002">point_dt</a>(&amp;closept, pt);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2791">&#x200c;</a><span class="linkable">close_ps</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *pt = PG_GETARG_POINT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp;&nbsp; *lseg = PG_GETARG_LSEG_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (Point *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Point));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isnan(<a href="#L2772" title="utils/adt/geo_ops.c:2772">lseg_closept_point</a>(result, lseg, pt)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Closest point on line segment to line segment<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> float8<br/></li>
<li><a id="L2810">&#x200c;</a><span class="linkable">lseg_closept_lseg</span>(Point *result, LSEG *on_lseg, LSEG *to_lseg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp; &nbsp; point;<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; dist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* First, we handle the case when the line segments are intersecting. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2338" title="utils/adt/geo_ops.c:2338">lseg_interpt_lseg</a>(result, on_lseg, to_lseg))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Then, we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the closest points from the endpoints of the second line<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * segment, and keep the closest one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; dist = <a href="#L2772" title="utils/adt/geo_ops.c:2772">lseg_closept_point</a>(result, on_lseg, &amp;to_lseg-&gt;p[<span class="Constant">0</span>]);<br/></li>
<li>&nbsp; &nbsp; d = <a href="#L2772" title="utils/adt/geo_ops.c:2772">lseg_closept_point</a>(&amp;point, on_lseg, &amp;to_lseg-&gt;p[<span class="Constant">1</span>]);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (float8_lt(d, dist))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dist = d;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *result = point;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The closest point can still be one of the endpoints, so we test them. */<br/></li>
<li></span>&nbsp; &nbsp; d = <a href="#L2772" title="utils/adt/geo_ops.c:2772">lseg_closept_point</a>(<span class="Constant">NULL</span>, to_lseg, &amp;on_lseg-&gt;p[<span class="Constant">0</span>]);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (float8_lt(d, dist))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dist = d;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *result = on_lseg-&gt;p[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; d = <a href="#L2772" title="utils/adt/geo_ops.c:2772">lseg_closept_point</a>(<span class="Constant">NULL</span>, to_lseg, &amp;on_lseg-&gt;p[<span class="Constant">1</span>]);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (float8_lt(d, dist))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dist = d;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *result = on_lseg-&gt;p[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> dist;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2853">&#x200c;</a><span class="linkable">close_lseg</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp;&nbsp; *l1 = PG_GETARG_LSEG_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp;&nbsp; *l2 = PG_GETARG_LSEG_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2155" title="utils/adt/geo_ops.c:2155">lseg_sl</a>(l1) == <a href="#L2155" title="utils/adt/geo_ops.c:2155">lseg_sl</a>(l2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (Point *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Point));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isnan(<a href="#L2810" title="utils/adt/geo_ops.c:2810">lseg_closept_lseg</a>(result, l2, l1)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Closest point on or in box to specified point.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If *result is not NULL, set it to the closest point on the box to the<br/></li>
<li></span><span class="Comment"> * given point, and return the distance of the two points.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> float8<br/></li>
<li><a id="L2878">&#x200c;</a><span class="linkable">box_closept_point</span>(Point *result, BOX *box, Point *pt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; dist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d;<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp; &nbsp; point,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; closept;<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp; &nbsp; lseg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3130" title="utils/adt/geo_ops.c:3130">box_contain_point</a>(box, pt))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *result = *pt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* pairwise check lseg distances */<br/></li>
<li></span>&nbsp; &nbsp; point.x = box-&gt;low.x;<br/></li>
<li>&nbsp; &nbsp; point.y = box-&gt;high.y;<br/></li>
<li>&nbsp; &nbsp; <a href="#L2142" title="utils/adt/geo_ops.c:2142">statlseg_construct</a>(&amp;lseg, &amp;box-&gt;low, &amp;point);<br/></li>
<li>&nbsp; &nbsp; dist = <a href="#L2772" title="utils/adt/geo_ops.c:2772">lseg_closept_point</a>(result, &amp;lseg, pt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2142" title="utils/adt/geo_ops.c:2142">statlseg_construct</a>(&amp;lseg, &amp;box-&gt;high, &amp;point);<br/></li>
<li>&nbsp; &nbsp; d = <a href="#L2772" title="utils/adt/geo_ops.c:2772">lseg_closept_point</a>(&amp;closept, &amp;lseg, pt);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (float8_lt(d, dist))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dist = d;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *result = closept;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; point.x = box-&gt;high.x;<br/></li>
<li>&nbsp; &nbsp; point.y = box-&gt;low.y;<br/></li>
<li>&nbsp; &nbsp; <a href="#L2142" title="utils/adt/geo_ops.c:2142">statlseg_construct</a>(&amp;lseg, &amp;box-&gt;low, &amp;point);<br/></li>
<li>&nbsp; &nbsp; d = <a href="#L2772" title="utils/adt/geo_ops.c:2772">lseg_closept_point</a>(&amp;closept, &amp;lseg, pt);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (float8_lt(d, dist))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dist = d;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *result = closept;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2142" title="utils/adt/geo_ops.c:2142">statlseg_construct</a>(&amp;lseg, &amp;box-&gt;high, &amp;point);<br/></li>
<li>&nbsp; &nbsp; d = <a href="#L2772" title="utils/adt/geo_ops.c:2772">lseg_closept_point</a>(&amp;closept, &amp;lseg, pt);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (float8_lt(d, dist))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dist = d;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *result = closept;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> dist;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2933">&#x200c;</a><span class="linkable">close_pb</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *pt = PG_GETARG_POINT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box = PG_GETARG_BOX_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (Point *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Point));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isnan(<a href="#L2878" title="utils/adt/geo_ops.c:2878">box_closept_point</a>(result, box, pt)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Closest point on line segment to line.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return the distance between the line and the closest point of the line<br/></li>
<li></span><span class="Comment"> * segment to the line.&nbsp; If *result is not NULL, set it to that point.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: When the lines are parallel, endpoints of one of the line segment<br/></li>
<li></span><span class="Comment"> * are FPeq(), in presence of NaN or Infinite coordinates, or perhaps =<br/></li>
<li></span><span class="Comment"> * even because of simple roundoff issues, there may not be a single closest<br/></li>
<li></span><span class="Comment"> * point.&nbsp; We are likely to set the result to the second endpoint in these<br/></li>
<li></span><span class="Comment"> * cases.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> float8<br/></li>
<li><a id="L2960">&#x200c;</a><span class="linkable">lseg_closept_line</span>(Point *result, LSEG *lseg, LINE *line)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; dist1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dist2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2675" title="utils/adt/geo_ops.c:2675">lseg_interpt_line</a>(result, lseg, line))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dist1 = <a href="#L2724" title="utils/adt/geo_ops.c:2724">line_closept_point</a>(<span class="Constant">NULL</span>, line, &amp;lseg-&gt;p[<span class="Constant">0</span>]);<br/></li>
<li>&nbsp; &nbsp; dist2 = <a href="#L2724" title="utils/adt/geo_ops.c:2724">line_closept_point</a>(<span class="Constant">NULL</span>, line, &amp;lseg-&gt;p[<span class="Constant">1</span>]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dist1 &lt; dist2)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *result = lseg-&gt;p[<span class="Constant">0</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> dist1;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *result = lseg-&gt;p[<span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> dist2;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2988">&#x200c;</a><span class="linkable">close_ls</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LINE&nbsp; &nbsp; &nbsp;&nbsp; *line = PG_GETARG_LINE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp;&nbsp; *lseg = PG_GETARG_LSEG_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2155" title="utils/adt/geo_ops.c:2155">lseg_sl</a>(lseg) == <a href="#L1233" title="utils/adt/geo_ops.c:1233">line_sl</a>(line))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (Point *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Point));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isnan(<a href="#L2960" title="utils/adt/geo_ops.c:2960">lseg_closept_line</a>(result, lseg, line)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Closest point on or in box to line segment.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the distance between the closest point on or in the box to<br/></li>
<li></span><span class="Comment"> * the line segment.&nbsp; If *result is not NULL, it is set to that point.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> float8<br/></li>
<li><a id="L3013">&#x200c;</a><span class="linkable">box_closept_lseg</span>(Point *result, BOX *box, LSEG *lseg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; dist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d;<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp; &nbsp; point,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; closept;<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp; &nbsp; bseg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3263" title="utils/adt/geo_ops.c:3263">box_interpt_lseg</a>(result, box, lseg))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* pairwise check lseg distances */<br/></li>
<li></span>&nbsp; &nbsp; point.x = box-&gt;low.x;<br/></li>
<li>&nbsp; &nbsp; point.y = box-&gt;high.y;<br/></li>
<li>&nbsp; &nbsp; <a href="#L2142" title="utils/adt/geo_ops.c:2142">statlseg_construct</a>(&amp;bseg, &amp;box-&gt;low, &amp;point);<br/></li>
<li>&nbsp; &nbsp; dist = <a href="#L2810" title="utils/adt/geo_ops.c:2810">lseg_closept_lseg</a>(result, &amp;bseg, lseg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2142" title="utils/adt/geo_ops.c:2142">statlseg_construct</a>(&amp;bseg, &amp;box-&gt;high, &amp;point);<br/></li>
<li>&nbsp; &nbsp; d = <a href="#L2810" title="utils/adt/geo_ops.c:2810">lseg_closept_lseg</a>(&amp;closept, &amp;bseg, lseg);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (float8_lt(d, dist))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dist = d;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *result = closept;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; point.x = box-&gt;high.x;<br/></li>
<li>&nbsp; &nbsp; point.y = box-&gt;low.y;<br/></li>
<li>&nbsp; &nbsp; <a href="#L2142" title="utils/adt/geo_ops.c:2142">statlseg_construct</a>(&amp;bseg, &amp;box-&gt;low, &amp;point);<br/></li>
<li>&nbsp; &nbsp; d = <a href="#L2810" title="utils/adt/geo_ops.c:2810">lseg_closept_lseg</a>(&amp;closept, &amp;bseg, lseg);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (float8_lt(d, dist))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dist = d;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *result = closept;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2142" title="utils/adt/geo_ops.c:2142">statlseg_construct</a>(&amp;bseg, &amp;box-&gt;high, &amp;point);<br/></li>
<li>&nbsp; &nbsp; d = <a href="#L2810" title="utils/adt/geo_ops.c:2810">lseg_closept_lseg</a>(&amp;closept, &amp;bseg, lseg);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (float8_lt(d, dist))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dist = d;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *result = closept;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> dist;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3063">&#x200c;</a><span class="linkable">close_sb</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp;&nbsp; *lseg = PG_GETARG_LSEG_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box = PG_GETARG_BOX_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (Point *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Point));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isnan(<a href="#L3013" title="utils/adt/geo_ops.c:3013">box_closept_lseg</a>(result, box, lseg)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*---------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; on_<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Whether one object lies completely within another.<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------*/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Does the point satisfy the equation?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3087">&#x200c;</a></span><span class="linkable">line_contain_point</span>(LINE *line, Point *point)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> FPzero(float8_pl(float8_pl(float8_mul(line-&gt;A, point-&gt;x),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; float8_mul(line-&gt;B, point-&gt;y)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; line-&gt;C));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3095">&#x200c;</a><span class="linkable">on_pl</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *pt = PG_GETARG_POINT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; LINE&nbsp; &nbsp; &nbsp;&nbsp; *line = PG_GETARG_LINE_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L3087" title="utils/adt/geo_ops.c:3087">line_contain_point</a>(line, pt));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Determine colinearity by detecting a triangle inequality.<br/></li>
<li></span><span class="Comment"> * This algorithm seems to behave nicely even with lsb residues - tgl 1997-07-09<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3109">&#x200c;</a></span><span class="linkable">lseg_contain_point</span>(LSEG *lseg, Point *pt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> FPeq(<a href="#L2002" title="utils/adt/geo_ops.c:2002">point_dt</a>(pt, &amp;lseg-&gt;p[<span class="Constant">0</span>]) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2002" title="utils/adt/geo_ops.c:2002">point_dt</a>(pt, &amp;lseg-&gt;p[<span class="Constant">1</span>]),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2002" title="utils/adt/geo_ops.c:2002">point_dt</a>(&amp;lseg-&gt;p[<span class="Constant">0</span>], &amp;lseg-&gt;p[<span class="Constant">1</span>]));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3117">&#x200c;</a><span class="linkable">on_ps</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *pt = PG_GETARG_POINT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp;&nbsp; *lseg = PG_GETARG_LSEG_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L3109" title="utils/adt/geo_ops.c:3109">lseg_contain_point</a>(lseg, pt));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check whether the point is in the box or on its border<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3130">&#x200c;</a></span><span class="linkable">box_contain_point</span>(BOX *box, Point *point)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> box-&gt;high.x &gt;= point-&gt;x &amp;&amp; box-&gt;low.x &lt;= point-&gt;x &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; box-&gt;high.y &gt;= point-&gt;y &amp;&amp; box-&gt;low.y &lt;= point-&gt;y;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3137">&#x200c;</a><span class="linkable">on_pb</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *pt = PG_GETARG_POINT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box = PG_GETARG_BOX_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L3130" title="utils/adt/geo_ops.c:3130">box_contain_point</a>(box, pt));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3146">&#x200c;</a><span class="linkable">box_contain_pt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box = PG_GETARG_BOX_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *pt = PG_GETARG_POINT_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L3130" title="utils/adt/geo_ops.c:3130">box_contain_point</a>(box, pt));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L3166" title="utils/adt/geo_ops.c:3166">on_ppath</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Whether a point lies within (on) a polyline.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; If open, we have to (groan) check each segment.<br/></li>
<li></span><span class="Comment"> * (uses same algorithm as for point intersecting segment - tgl 1997-07-09)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; If closed, we use the old O(n) ray method for point-in-polygon.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; The ray is horizontal, from pt out to the right.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Each segment that crosses the ray counts as an<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intersection; note that an endpoint or edge may touch<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; but not cross.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (we can do p-in-p in lg(n), but it takes preprocessing)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3166">&#x200c;</a><span class="linkable">on_ppath</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *pt = PG_GETARG_POINT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PATH&nbsp; &nbsp; &nbsp;&nbsp; *path = PG_GETARG_PATH_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n;<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; a,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*-- OPEN --*/<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!path-&gt;closed)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; n = path-&gt;npts - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; a = <a href="#L2002" title="utils/adt/geo_ops.c:2002">point_dt</a>(pt, &amp;path-&gt;p[<span class="Constant">0</span>]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; n; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b = <a href="#L2002" title="utils/adt/geo_ops.c:2002">point_dt</a>(pt, &amp;path-&gt;p[i + <span class="Constant">1</span>]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (FPeq(float8_pl(a, b), <a href="#L2002" title="utils/adt/geo_ops.c:2002">point_dt</a>(&amp;path-&gt;p[i], &amp;path-&gt;p[i + <span class="Constant">1</span>])))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a = b;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*-- CLOSED --*/<br/></li>
<li></span>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L5340" title="utils/adt/geo_ops.c:5340">point_inside</a>(pt, path-&gt;npts, path-&gt;p) != <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check whether the line segment is on the line or close enough<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It is, if both of its points are on the line or close enough.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3201">&#x200c;</a><span class="linkable">on_sl</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp;&nbsp; *lseg = PG_GETARG_LSEG_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; LINE&nbsp; &nbsp; &nbsp;&nbsp; *line = PG_GETARG_LINE_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L3087" title="utils/adt/geo_ops.c:3087">line_contain_point</a>(line, &amp;lseg-&gt;p[<span class="Constant">0</span>]) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L3087" title="utils/adt/geo_ops.c:3087">line_contain_point</a>(line, &amp;lseg-&gt;p[<span class="Constant">1</span>]));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check whether the line segment is in the box or on its border<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It is, if both of its points are in the box or on its border.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3217">&#x200c;</a></span><span class="linkable">box_contain_lseg</span>(BOX *box, LSEG *lseg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L3130" title="utils/adt/geo_ops.c:3130">box_contain_point</a>(box, &amp;lseg-&gt;p[<span class="Constant">0</span>]) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3130" title="utils/adt/geo_ops.c:3130">box_contain_point</a>(box, &amp;lseg-&gt;p[<span class="Constant">1</span>]);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3224">&#x200c;</a><span class="linkable">on_sb</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp;&nbsp; *lseg = PG_GETARG_LSEG_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box = PG_GETARG_BOX_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L3217" title="utils/adt/geo_ops.c:3217">box_contain_lseg</a>(box, lseg));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*---------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; inter_<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Whether one object intersects another.<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------*/<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L3238">&#x200c;</a><span class="linkable">inter_sl</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp;&nbsp; *lseg = PG_GETARG_LSEG_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; LINE&nbsp; &nbsp; &nbsp;&nbsp; *line = PG_GETARG_LINE_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2675" title="utils/adt/geo_ops.c:2675">lseg_interpt_line</a>(<span class="Constant">NULL</span>, lseg, line));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Do line segment and box intersect?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Segment completely inside box counts as intersection.<br/></li>
<li></span><span class="Comment"> * If you want only segments crossing box boundaries,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; try converting box to path first.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function also sets the *result to the closest point on the line<br/></li>
<li></span><span class="Comment"> * segment to the center of the box when they overlap and the result is<br/></li>
<li></span><span class="Comment"> * not NULL.&nbsp; It is somewhat arbitrary, but maybe the best we can do as<br/></li>
<li></span><span class="Comment"> * there are typically two points they intersect.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Optimize for non-intersection by checking for box intersection first.<br/></li>
<li></span><span class="Comment"> * - thomas 1998-01-30<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3263">&#x200c;</a></span><span class="linkable">box_interpt_lseg</span>(Point *result, BOX *box, LSEG *lseg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lbox;<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp; &nbsp; bseg;<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp; &nbsp; point;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; lbox.low.x = float8_min(lseg-&gt;p[<span class="Constant">0</span>].x, lseg-&gt;p[<span class="Constant">1</span>].x);<br/></li>
<li>&nbsp; &nbsp; lbox.low.y = float8_min(lseg-&gt;p[<span class="Constant">0</span>].y, lseg-&gt;p[<span class="Constant">1</span>].y);<br/></li>
<li>&nbsp; &nbsp; lbox.high.x = float8_max(lseg-&gt;p[<span class="Constant">0</span>].x, lseg-&gt;p[<span class="Constant">1</span>].x);<br/></li>
<li>&nbsp; &nbsp; lbox.high.y = float8_max(lseg-&gt;p[<span class="Constant">0</span>].y, lseg-&gt;p[<span class="Constant">1</span>].y);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* nothing close to overlap? then not going to intersect */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L572" title="utils/adt/geo_ops.c:572">box_ov</a>(&amp;lbox, box))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L872" title="utils/adt/geo_ops.c:872">box_cn</a>(&amp;point, box);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2772" title="utils/adt/geo_ops.c:2772">lseg_closept_point</a>(result, lseg, &amp;point);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* an endpoint of segment is inside box? then clearly intersects */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3130" title="utils/adt/geo_ops.c:3130">box_contain_point</a>(box, &amp;lseg-&gt;p[<span class="Constant">0</span>]) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3130" title="utils/adt/geo_ops.c:3130">box_contain_point</a>(box, &amp;lseg-&gt;p[<span class="Constant">1</span>]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* pairwise check lseg intersections */<br/></li>
<li></span>&nbsp; &nbsp; point.x = box-&gt;low.x;<br/></li>
<li>&nbsp; &nbsp; point.y = box-&gt;high.y;<br/></li>
<li>&nbsp; &nbsp; <a href="#L2142" title="utils/adt/geo_ops.c:2142">statlseg_construct</a>(&amp;bseg, &amp;box-&gt;low, &amp;point);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2338" title="utils/adt/geo_ops.c:2338">lseg_interpt_lseg</a>(<span class="Constant">NULL</span>, &amp;bseg, lseg))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2142" title="utils/adt/geo_ops.c:2142">statlseg_construct</a>(&amp;bseg, &amp;box-&gt;high, &amp;point);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2338" title="utils/adt/geo_ops.c:2338">lseg_interpt_lseg</a>(<span class="Constant">NULL</span>, &amp;bseg, lseg))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; point.x = box-&gt;high.x;<br/></li>
<li>&nbsp; &nbsp; point.y = box-&gt;low.y;<br/></li>
<li>&nbsp; &nbsp; <a href="#L2142" title="utils/adt/geo_ops.c:2142">statlseg_construct</a>(&amp;bseg, &amp;box-&gt;low, &amp;point);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2338" title="utils/adt/geo_ops.c:2338">lseg_interpt_lseg</a>(<span class="Constant">NULL</span>, &amp;bseg, lseg))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2142" title="utils/adt/geo_ops.c:2142">statlseg_construct</a>(&amp;bseg, &amp;box-&gt;high, &amp;point);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2338" title="utils/adt/geo_ops.c:2338">lseg_interpt_lseg</a>(<span class="Constant">NULL</span>, &amp;bseg, lseg))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if we dropped through, no two segs intersected */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3315">&#x200c;</a><span class="linkable">inter_sb</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp;&nbsp; *lseg = PG_GETARG_LSEG_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box = PG_GETARG_BOX_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L3263" title="utils/adt/geo_ops.c:3263">box_interpt_lseg</a>(<span class="Constant">NULL</span>, box, lseg));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L3328" title="utils/adt/geo_ops.c:3328">inter_lb</a>()<br/></li>
<li></span><span class="Comment"> * Do line and box intersect?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3328">&#x200c;</a><span class="linkable">inter_lb</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LINE&nbsp; &nbsp; &nbsp;&nbsp; *line = PG_GETARG_LINE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box = PG_GETARG_BOX_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp; &nbsp; bseg;<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp; &nbsp; p1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* pairwise check lseg intersections */<br/></li>
<li></span>&nbsp; &nbsp; p1.x = box-&gt;low.x;<br/></li>
<li>&nbsp; &nbsp; p1.y = box-&gt;low.y;<br/></li>
<li>&nbsp; &nbsp; p2.x = box-&gt;low.x;<br/></li>
<li>&nbsp; &nbsp; p2.y = box-&gt;high.y;<br/></li>
<li>&nbsp; &nbsp; <a href="#L2142" title="utils/adt/geo_ops.c:2142">statlseg_construct</a>(&amp;bseg, &amp;p1, &amp;p2);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2675" title="utils/adt/geo_ops.c:2675">lseg_interpt_line</a>(<span class="Constant">NULL</span>, &amp;bseg, line))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; p1.x = box-&gt;high.x;<br/></li>
<li>&nbsp; &nbsp; p1.y = box-&gt;high.y;<br/></li>
<li>&nbsp; &nbsp; <a href="#L2142" title="utils/adt/geo_ops.c:2142">statlseg_construct</a>(&amp;bseg, &amp;p1, &amp;p2);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2675" title="utils/adt/geo_ops.c:2675">lseg_interpt_line</a>(<span class="Constant">NULL</span>, &amp;bseg, line))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; p2.x = box-&gt;high.x;<br/></li>
<li>&nbsp; &nbsp; p2.y = box-&gt;low.y;<br/></li>
<li>&nbsp; &nbsp; <a href="#L2142" title="utils/adt/geo_ops.c:2142">statlseg_construct</a>(&amp;bseg, &amp;p1, &amp;p2);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2675" title="utils/adt/geo_ops.c:2675">lseg_interpt_line</a>(<span class="Constant">NULL</span>, &amp;bseg, line))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; p1.x = box-&gt;low.x;<br/></li>
<li>&nbsp; &nbsp; p1.y = box-&gt;low.y;<br/></li>
<li>&nbsp; &nbsp; <a href="#L2142" title="utils/adt/geo_ops.c:2142">statlseg_construct</a>(&amp;bseg, &amp;p1, &amp;p2);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2675" title="utils/adt/geo_ops.c:2675">lseg_interpt_line</a>(<span class="Constant">NULL</span>, &amp;bseg, line))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if we dropped through, no intersection */<br/></li>
<li></span>&nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * The following routines define a data type and operator class for<br/></li>
<li></span><span class="Comment"> * POLYGONS .... Part of which (the polygon's bounding box) is built on<br/></li>
<li></span><span class="Comment"> * top of the BOX data type.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L3376" title="utils/adt/geo_ops.c:3376">make_bound_box</a> - create the bounding box for the input polygon<br/></li>
<li></span><span class="Comment"> *------------------------------------------------------------------*/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*---------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * Make the smallest bounding box for the given polygon.<br/></li>
<li></span><span class="Comment"> *---------------------------------------------------------------------*/<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3376">&#x200c;</a></span><span class="linkable">make_bound_box</span>(POLYGON *poly)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; x1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; y1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; y2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(poly-&gt;npts &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; x1 = x2 = poly-&gt;p[<span class="Constant">0</span>].x;<br/></li>
<li>&nbsp; &nbsp; y2 = y1 = poly-&gt;p[<span class="Constant">0</span>].y;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt; poly-&gt;npts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (float8_lt(poly-&gt;p[i].x, x1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x1 = poly-&gt;p[i].x;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (float8_gt(poly-&gt;p[i].x, x2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x2 = poly-&gt;p[i].x;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (float8_lt(poly-&gt;p[i].y, y1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; y1 = poly-&gt;p[i].y;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (float8_gt(poly-&gt;p[i].y, y2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; y2 = poly-&gt;p[i].y;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; poly-&gt;boundbox.low.x = x1;<br/></li>
<li>&nbsp; &nbsp; poly-&gt;boundbox.high.x = x2;<br/></li>
<li>&nbsp; &nbsp; poly-&gt;boundbox.low.y = y1;<br/></li>
<li>&nbsp; &nbsp; poly-&gt;boundbox.high.y = y2;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * <a href="#L3415" title="utils/adt/geo_ops.c:3415">poly_in</a> - read in the polygon from a string specification<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; External format:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;((x0,y0),...,(xn,yn))&quot;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;x0,y0,...,xn,yn&quot;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; also supports the older style &quot;(x1,...,xn,y1,...yn)&quot;<br/></li>
<li></span><span class="Comment"> *------------------------------------------------------------------*/<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3415">&#x200c;</a><span class="linkable">poly_in</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *str = PG_GETARG_CSTRING(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *escontext = fcinfo-&gt;context;<br/></li>
<li>&nbsp; &nbsp; POLYGON&nbsp; &nbsp; *poly;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; npts;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; base_size;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isopen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((npts = <a href="#L392" title="utils/adt/geo_ops.c:392">pair_count</a>(str, <span class="Constant">','</span>)) &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid input syntax for type </span><span class="Special">%s</span><span class="Constant">: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;polygon&quot;</span>, str)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; base_size = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(poly-&gt;p[<span class="Constant">0</span>]) * npts;<br/></li>
<li>&nbsp; &nbsp; size = offsetof(POLYGON, p) + base_size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for integer overflow */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (base_size / npts != <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(poly-&gt;p[<span class="Constant">0</span>]) || size &lt;= base_size)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;too many points requested&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; poly = (POLYGON *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(size);&nbsp; &nbsp; <span class="Comment">/* zero <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> holes */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(poly, size);<br/></li>
<li>&nbsp; &nbsp; poly-&gt;npts = npts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L266" title="utils/adt/geo_ops.c:266">path_decode</a>(str, <span class="Constant">false</span>, npts, &amp;(poly-&gt;p[<span class="Constant">0</span>]), &amp;isopen, <span class="Constant">NULL</span>, <span class="Constant">&quot;polygon&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; str, escontext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L3376" title="utils/adt/geo_ops.c:3376">make_bound_box</a>(poly);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POLYGON_P(poly);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*---------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * <a href="#L3459" title="utils/adt/geo_ops.c:3459">poly_out</a> - convert <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> POLYGON representation to the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; character string format &quot;((f8,f8),...,(f8,f8))&quot;<br/></li>
<li></span><span class="Comment"> *---------------------------------------------------------------*/<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3459">&#x200c;</a><span class="linkable">poly_out</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; POLYGON&nbsp; &nbsp; *poly = PG_GETARG_POLYGON_P(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CSTRING(<a href="#L340" title="utils/adt/geo_ops.c:340">path_encode</a>(PATH_CLOSED, poly-&gt;npts, poly-&gt;p));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3475" title="utils/adt/geo_ops.c:3475">poly_recv</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts external binary format to polygon<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * External representation is int32 number of points, and the points.<br/></li>
<li></span><span class="Comment"> * We recompute the bounding box on read, instead of trusting it to<br/></li>
<li></span><span class="Comment"> * be valid.&nbsp; (Checking it would take just as long, so may as well<br/></li>
<li></span><span class="Comment"> * omit it from external representation.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3475">&#x200c;</a><span class="linkable">poly_recv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; buf = (StringInfo) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; POLYGON&nbsp; &nbsp; *poly;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; npts;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; npts = <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(buf, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int32));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (npts &lt;= <span class="Constant">0</span> || npts &gt;= (int32) ((<span class="Constant">INT_MAX</span> - offsetof(POLYGON, p)) / <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Point)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_BINARY_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid number of points in external </span><span class="Special">\&quot;</span><span class="Constant">polygon</span><span class="Special">\&quot;</span><span class="Constant"> value&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; size = offsetof(POLYGON, p) + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(poly-&gt;p[<span class="Constant">0</span>]) * npts;<br/></li>
<li>&nbsp; &nbsp; poly = (POLYGON *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(size);&nbsp; &nbsp; <span class="Comment">/* zero <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> holes */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(poly, size);<br/></li>
<li>&nbsp; &nbsp; poly-&gt;npts = npts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; npts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; poly-&gt;p[i].x = <a href="../../libpq/pqformat.c.html#L488" title="libpq/pqformat.c:488">pq_getmsgfloat8</a>(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; poly-&gt;p[i].y = <a href="../../libpq/pqformat.c.html#L488" title="libpq/pqformat.c:488">pq_getmsgfloat8</a>(buf);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L3376" title="utils/adt/geo_ops.c:3376">make_bound_box</a>(poly);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POLYGON_P(poly);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3510" title="utils/adt/geo_ops.c:3510">poly_send</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts polygon to binary format<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3510">&#x200c;</a><span class="linkable">poly_send</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; POLYGON&nbsp; &nbsp; *poly = PG_GETARG_POLYGON_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L326" title="libpq/pqformat.c:326">pq_begintypsend</a>(&amp;buf);<br/></li>
<li>&nbsp; &nbsp; pq_sendint32(&amp;buf, poly-&gt;npts);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; poly-&gt;npts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L276" title="libpq/pqformat.c:276">pq_sendfloat8</a>(&amp;buf, poly-&gt;p[i].x);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L276" title="libpq/pqformat.c:276">pq_sendfloat8</a>(&amp;buf, poly-&gt;p[i].y);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BYTEA_P(<a href="../../libpq/pqformat.c.html#L346" title="libpq/pqformat.c:346">pq_endtypsend</a>(&amp;buf));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*-------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * Is polygon A strictly left of polygon B? i.e. is<br/></li>
<li></span><span class="Comment"> * the right most point of A left of the left most point<br/></li>
<li></span><span class="Comment"> * of B?<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------*/<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3533">&#x200c;</a><span class="linkable">poly_left</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; POLYGON&nbsp; &nbsp; *polya = PG_GETARG_POLYGON_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; POLYGON&nbsp; &nbsp; *polyb = PG_GETARG_POLYGON_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = polya-&gt;boundbox.high.x &lt; polyb-&gt;boundbox.low.x;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Avoid leaking memory for toasted inputs ... needed for rtree indexes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; PG_FREE_IF_COPY(polya, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(polyb, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*-------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * Is polygon A overlapping or left of polygon B? i.e. is<br/></li>
<li></span><span class="Comment"> * the right most point of A at or left of the right most point<br/></li>
<li></span><span class="Comment"> * of B?<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------*/<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3556">&#x200c;</a><span class="linkable">poly_overleft</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; POLYGON&nbsp; &nbsp; *polya = PG_GETARG_POLYGON_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; POLYGON&nbsp; &nbsp; *polyb = PG_GETARG_POLYGON_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = polya-&gt;boundbox.high.x &lt;= polyb-&gt;boundbox.high.x;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Avoid leaking memory for toasted inputs ... needed for rtree indexes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; PG_FREE_IF_COPY(polya, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(polyb, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*-------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * Is polygon A strictly right of polygon B? i.e. is<br/></li>
<li></span><span class="Comment"> * the left most point of A right of the right most point<br/></li>
<li></span><span class="Comment"> * of B?<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------*/<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3579">&#x200c;</a><span class="linkable">poly_right</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; POLYGON&nbsp; &nbsp; *polya = PG_GETARG_POLYGON_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; POLYGON&nbsp; &nbsp; *polyb = PG_GETARG_POLYGON_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = polya-&gt;boundbox.low.x &gt; polyb-&gt;boundbox.high.x;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Avoid leaking memory for toasted inputs ... needed for rtree indexes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; PG_FREE_IF_COPY(polya, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(polyb, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*-------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * Is polygon A overlapping or right of polygon B? i.e. is<br/></li>
<li></span><span class="Comment"> * the left most point of A at or right of the left most point<br/></li>
<li></span><span class="Comment"> * of B?<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------*/<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3602">&#x200c;</a><span class="linkable">poly_overright</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; POLYGON&nbsp; &nbsp; *polya = PG_GETARG_POLYGON_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; POLYGON&nbsp; &nbsp; *polyb = PG_GETARG_POLYGON_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = polya-&gt;boundbox.low.x &gt;= polyb-&gt;boundbox.low.x;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Avoid leaking memory for toasted inputs ... needed for rtree indexes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; PG_FREE_IF_COPY(polya, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(polyb, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*-------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * Is polygon A strictly below polygon B? i.e. is<br/></li>
<li></span><span class="Comment"> * the <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> most point of A below the <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> most point<br/></li>
<li></span><span class="Comment"> * of B?<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------*/<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3625">&#x200c;</a><span class="linkable">poly_below</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; POLYGON&nbsp; &nbsp; *polya = PG_GETARG_POLYGON_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; POLYGON&nbsp; &nbsp; *polyb = PG_GETARG_POLYGON_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = polya-&gt;boundbox.high.y &lt; polyb-&gt;boundbox.low.y;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Avoid leaking memory for toasted inputs ... needed for rtree indexes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; PG_FREE_IF_COPY(polya, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(polyb, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*-------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * Is polygon A overlapping or below polygon B? i.e. is<br/></li>
<li></span><span class="Comment"> * the <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> most point of A at or below the <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> most point<br/></li>
<li></span><span class="Comment"> * of B?<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------*/<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3648">&#x200c;</a><span class="linkable">poly_overbelow</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; POLYGON&nbsp; &nbsp; *polya = PG_GETARG_POLYGON_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; POLYGON&nbsp; &nbsp; *polyb = PG_GETARG_POLYGON_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = polya-&gt;boundbox.high.y &lt;= polyb-&gt;boundbox.high.y;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Avoid leaking memory for toasted inputs ... needed for rtree indexes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; PG_FREE_IF_COPY(polya, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(polyb, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*-------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * Is polygon A strictly above polygon B? i.e. is<br/></li>
<li></span><span class="Comment"> * the <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> most point of A above the <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> most point<br/></li>
<li></span><span class="Comment"> * of B?<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------*/<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3671">&#x200c;</a><span class="linkable">poly_above</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; POLYGON&nbsp; &nbsp; *polya = PG_GETARG_POLYGON_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; POLYGON&nbsp; &nbsp; *polyb = PG_GETARG_POLYGON_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = polya-&gt;boundbox.low.y &gt; polyb-&gt;boundbox.high.y;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Avoid leaking memory for toasted inputs ... needed for rtree indexes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; PG_FREE_IF_COPY(polya, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(polyb, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*-------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * Is polygon A overlapping or above polygon B? i.e. is<br/></li>
<li></span><span class="Comment"> * the <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> most point of A at or above the <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> most point<br/></li>
<li></span><span class="Comment"> * of B?<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------*/<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3694">&#x200c;</a><span class="linkable">poly_overabove</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; POLYGON&nbsp; &nbsp; *polya = PG_GETARG_POLYGON_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; POLYGON&nbsp; &nbsp; *polyb = PG_GETARG_POLYGON_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = polya-&gt;boundbox.low.y &gt;= polyb-&gt;boundbox.low.y;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Avoid leaking memory for toasted inputs ... needed for rtree indexes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; PG_FREE_IF_COPY(polya, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(polyb, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*-------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * Is polygon A the same as polygon B? i.e. are all the<br/></li>
<li></span><span class="Comment"> * points the same?<br/></li>
<li></span><span class="Comment"> * Check all points for matches in both forward and reverse<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; direction since polygons are non-directional and are<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; closed shapes.<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------*/<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3720">&#x200c;</a><span class="linkable">poly_same</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; POLYGON&nbsp; &nbsp; *polya = PG_GETARG_POLYGON_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; POLYGON&nbsp; &nbsp; *polyb = PG_GETARG_POLYGON_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (polya-&gt;npts != polyb-&gt;npts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L5457" title="utils/adt/geo_ops.c:5457">plist_same</a>(polya-&gt;npts, polya-&gt;p, polyb-&gt;p);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Avoid leaking memory for toasted inputs ... needed for rtree indexes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; PG_FREE_IF_COPY(polya, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(polyb, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*-----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * Determine if polygon A overlaps polygon B<br/></li>
<li></span><span class="Comment"> *-----------------------------------------------------------------*/<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3744">&#x200c;</a></span><span class="linkable">poly_overlap_internal</span>(POLYGON *polya, POLYGON *polyb)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(polya-&gt;npts &gt; <span class="Constant">0</span> &amp;&amp; polyb-&gt;npts &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Quick check by bounding box */<br/></li>
<li></span>&nbsp; &nbsp; result = <a href="#L572" title="utils/adt/geo_ops.c:572">box_ov</a>(&amp;polya-&gt;boundbox, &amp;polyb-&gt;boundbox);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Brute-force algorithm - try to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> intersected edges, if so then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * polygons are overlapped else check is one polygon inside other or not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * by testing single point of them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (result)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ia,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ib;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp; &nbsp; sa,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sb;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Init first of polya's edge with last point */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sa.p[<span class="Constant">0</span>] = polya-&gt;p[polya-&gt;npts - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (ia = <span class="Constant">0</span>; ia &lt; polya-&gt;npts &amp;&amp; !result; ia++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Second point of polya's edge is a current one */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sa.p[<span class="Constant">1</span>] = polya-&gt;p[ia];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Init first of polyb's edge with last point */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sb.p[<span class="Constant">0</span>] = polyb-&gt;p[polyb-&gt;npts - <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (ib = <span class="Constant">0</span>; ib &lt; polyb-&gt;npts &amp;&amp; !result; ib++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sb.p[<span class="Constant">1</span>] = polyb-&gt;p[ib];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L2338" title="utils/adt/geo_ops.c:2338">lseg_interpt_lseg</a>(<span class="Constant">NULL</span>, &amp;sa, &amp;sb);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sb.p[<span class="Constant">0</span>] = sb.p[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * move current endpoint to the first point of <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> edge<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sa.p[<span class="Constant">0</span>] = sa.p[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!result)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = (<a href="#L5340" title="utils/adt/geo_ops.c:5340">point_inside</a>(polya-&gt;p, polyb-&gt;npts, polyb-&gt;p) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5340" title="utils/adt/geo_ops.c:5340">point_inside</a>(polyb-&gt;p, polya-&gt;npts, polya-&gt;p));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3801">&#x200c;</a><span class="linkable">poly_overlap</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; POLYGON&nbsp; &nbsp; *polya = PG_GETARG_POLYGON_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; POLYGON&nbsp; &nbsp; *polyb = PG_GETARG_POLYGON_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L3744" title="utils/adt/geo_ops.c:3744">poly_overlap_internal</a>(polya, polyb);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Avoid leaking memory for toasted inputs ... needed for rtree indexes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; PG_FREE_IF_COPY(polya, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(polyb, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Tests special kind of segment for in/out of polygon.<br/></li>
<li></span><span class="Comment"> * Special kind means:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; - point a should be on segment s<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; - segment (a,b) should not be contained by s<br/></li>
<li></span><span class="Comment"> * Returns true if:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; - segment (a,b) is collinear to s and (a,b) is in polygon<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; - segment (a,b) s not collinear to s. Note: that doesn't<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; mean that segment is in polygon!<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3830">&#x200c;</a></span><span class="linkable">touched_lseg_inside_poly</span>(Point *a, Point *b, LSEG *s, POLYGON *poly, <span class="Type">int</span> start)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* point a is on s, b is not */<br/></li>
<li></span>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp; &nbsp; t;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; t.p[<span class="Constant">0</span>] = *a;<br/></li>
<li>&nbsp; &nbsp; t.p[<span class="Constant">1</span>] = *b;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1977" title="utils/adt/geo_ops.c:1977">point_eq_point</a>(a, s-&gt;p))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3109" title="utils/adt/geo_ops.c:3109">lseg_contain_point</a>(&amp;t, s-&gt;p + <span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L3866" title="utils/adt/geo_ops.c:3866">lseg_inside_poly</a>(b, s-&gt;p + <span class="Constant">1</span>, poly, start);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L1977" title="utils/adt/geo_ops.c:1977">point_eq_point</a>(a, s-&gt;p + <span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3109" title="utils/adt/geo_ops.c:3109">lseg_contain_point</a>(&amp;t, s-&gt;p))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L3866" title="utils/adt/geo_ops.c:3866">lseg_inside_poly</a>(b, s-&gt;p, poly, start);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L3109" title="utils/adt/geo_ops.c:3109">lseg_contain_point</a>(&amp;t, s-&gt;p))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L3866" title="utils/adt/geo_ops.c:3866">lseg_inside_poly</a>(b, s-&gt;p, poly, start);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L3109" title="utils/adt/geo_ops.c:3109">lseg_contain_point</a>(&amp;t, s-&gt;p + <span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L3866" title="utils/adt/geo_ops.c:3866">lseg_inside_poly</a>(b, s-&gt;p + <span class="Constant">1</span>, poly, start);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* may be not true, but that will check later */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns true if segment (a,b) is in polygon, option<br/></li>
<li></span><span class="Comment"> * start is used for optimization - function checks<br/></li>
<li></span><span class="Comment"> * polygon's edges starting from start<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3866">&#x200c;</a></span><span class="linkable">lseg_inside_poly</span>(Point *a, Point *b, POLYGON *poly, <span class="Type">int</span> start)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp; &nbsp; s,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; res = <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intersection = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* since this function recurses, it could be driven to stack overflow */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; t.p[<span class="Constant">0</span>] = *a;<br/></li>
<li>&nbsp; &nbsp; t.p[<span class="Constant">1</span>] = *b;<br/></li>
<li>&nbsp; &nbsp; s.p[<span class="Constant">0</span>] = poly-&gt;p[(start == <span class="Constant">0</span>) ? (poly-&gt;npts - <span class="Constant">1</span>) : (start - <span class="Constant">1</span>)];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = start; i &lt; poly-&gt;npts &amp;&amp; res; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp; &nbsp; interpt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s.p[<span class="Constant">1</span>] = poly-&gt;p[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3109" title="utils/adt/geo_ops.c:3109">lseg_contain_point</a>(&amp;s, t.p))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3109" title="utils/adt/geo_ops.c:3109">lseg_contain_point</a>(&amp;s, t.p + <span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;&nbsp; &nbsp; <span class="Comment">/* t is contained by s */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Y-cross */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <a href="#L3830" title="utils/adt/geo_ops.c:3830">touched_lseg_inside_poly</a>(t.p, t.p + <span class="Constant">1</span>, &amp;s, poly, i + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L3109" title="utils/adt/geo_ops.c:3109">lseg_contain_point</a>(&amp;s, t.p + <span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Y-cross */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <a href="#L3830" title="utils/adt/geo_ops.c:3830">touched_lseg_inside_poly</a>(t.p + <span class="Constant">1</span>, t.p, &amp;s, poly, i + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L2338" title="utils/adt/geo_ops.c:2338">lseg_interpt_lseg</a>(&amp;interpt, &amp;t, &amp;s))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * segments are X-crossing, go to check each subsegment<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intersection = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <a href="#L3866" title="utils/adt/geo_ops.c:3866">lseg_inside_poly</a>(t.p, &amp;interpt, poly, i + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (res)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <a href="#L3866" title="utils/adt/geo_ops.c:3866">lseg_inside_poly</a>(t.p + <span class="Constant">1</span>, &amp;interpt, poly, i + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s.p[<span class="Constant">0</span>] = s.p[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (res &amp;&amp; !intersection)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp; &nbsp; p;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if X-intersection wasn't found, then check central point of tested<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * segment. In opposite case we already check all subsegments<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; p.x = float8_div(float8_pl(t.p[<span class="Constant">0</span>].x, t.p[<span class="Constant">1</span>].x), <span class="Constant">2.0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; p.y = float8_div(float8_pl(t.p[<span class="Constant">0</span>].y, t.p[<span class="Constant">1</span>].y), <span class="Constant">2.0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res = <a href="#L5340" title="utils/adt/geo_ops.c:5340">point_inside</a>(&amp;p, poly-&gt;npts, poly-&gt;p);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check whether the first polygon contains the second<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3938">&#x200c;</a></span><span class="linkable">poly_contain_poly</span>(POLYGON *contains_poly, POLYGON *contained_poly)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp; &nbsp; s;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(contains_poly-&gt;npts &gt; <span class="Constant">0</span> &amp;&amp; contained_poly-&gt;npts &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Quick check to see if contained's bounding box is contained in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * contains' bb.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L704" title="utils/adt/geo_ops.c:704">box_contain_box</a>(&amp;contains_poly-&gt;boundbox, &amp;contained_poly-&gt;boundbox))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; s.p[<span class="Constant">0</span>] = contained_poly-&gt;p[contained_poly-&gt;npts - <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; contained_poly-&gt;npts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s.p[<span class="Constant">1</span>] = contained_poly-&gt;p[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L3866" title="utils/adt/geo_ops.c:3866">lseg_inside_poly</a>(s.p, s.p + <span class="Constant">1</span>, contains_poly, <span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s.p[<span class="Constant">0</span>] = s.p[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3966">&#x200c;</a><span class="linkable">poly_contain</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; POLYGON&nbsp; &nbsp; *polya = PG_GETARG_POLYGON_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; POLYGON&nbsp; &nbsp; *polyb = PG_GETARG_POLYGON_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L3938" title="utils/adt/geo_ops.c:3938">poly_contain_poly</a>(polya, polyb);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Avoid leaking memory for toasted inputs ... needed for rtree indexes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; PG_FREE_IF_COPY(polya, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(polyb, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*-----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * Determine if polygon A is contained by polygon B<br/></li>
<li></span><span class="Comment"> *-----------------------------------------------------------------*/<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3988">&#x200c;</a><span class="linkable">poly_contained</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; POLYGON&nbsp; &nbsp; *polya = PG_GETARG_POLYGON_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; POLYGON&nbsp; &nbsp; *polyb = PG_GETARG_POLYGON_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Just switch the arguments and pass it off to <a href="#L3966" title="utils/adt/geo_ops.c:3966">poly_contain</a> */<br/></li>
<li></span>&nbsp; &nbsp; result = <a href="#L3938" title="utils/adt/geo_ops.c:3938">poly_contain_poly</a>(polyb, polya);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Avoid leaking memory for toasted inputs ... needed for rtree indexes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; PG_FREE_IF_COPY(polya, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(polyb, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L4008">&#x200c;</a><span class="linkable">poly_contain_pt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; POLYGON&nbsp; &nbsp; *poly = PG_GETARG_POLYGON_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *p = PG_GETARG_POINT_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L5340" title="utils/adt/geo_ops.c:5340">point_inside</a>(p, poly-&gt;npts, poly-&gt;p) != <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L4017">&#x200c;</a><span class="linkable">pt_contained_poly</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *p = PG_GETARG_POINT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; POLYGON&nbsp; &nbsp; *poly = PG_GETARG_POLYGON_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L5340" title="utils/adt/geo_ops.c:5340">point_inside</a>(p, poly-&gt;npts, poly-&gt;p) != <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L4027">&#x200c;</a><span class="linkable">poly_distance</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; POLYGON&nbsp; &nbsp; *polya = PG_GETARG_POLYGON_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; POLYGON&nbsp; &nbsp; *polyb = PG_GETARG_POLYGON_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; min = <span class="Constant">0.0</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> to keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; have_min = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; tmp;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li>&nbsp; &nbsp; LSEG&nbsp; &nbsp; &nbsp; &nbsp; seg1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seg2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Distance is zero if polygons overlap.&nbsp; We must check this because the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * path distance will not give the right answer if one poly is entirely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * within the other.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3744" title="utils/adt/geo_ops.c:3744">poly_overlap_internal</a>(polya, polyb))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(<span class="Constant">0.0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When they don't overlap, the distance calculation is identical to that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for closed paths (i.e., we needn't care about the fact that polygons<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * include their contained areas).&nbsp; See <a href="#L1730" title="utils/adt/geo_ops.c:1730">path_distance</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; polya-&gt;npts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iprev;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iprev = i - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iprev = polya-&gt;npts - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = <span class="Constant">0</span>; j &lt; polyb-&gt;npts; j++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jprev;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (j &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jprev = j - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jprev = polyb-&gt;npts - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2142" title="utils/adt/geo_ops.c:2142">statlseg_construct</a>(&amp;seg1, &amp;polya-&gt;p[iprev], &amp;polya-&gt;p[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2142" title="utils/adt/geo_ops.c:2142">statlseg_construct</a>(&amp;seg2, &amp;polyb-&gt;p[jprev], &amp;polyb-&gt;p[j]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp = <a href="#L2810" title="utils/adt/geo_ops.c:2810">lseg_closept_lseg</a>(<span class="Constant">NULL</span>, &amp;seg1, &amp;seg2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!have_min || float8_lt(tmp, min))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min = tmp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; have_min = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!have_min)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(min);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/***********************************************************************<br/></li>
<li></span><span class="Comment"> **<br/></li>
<li></span><span class="Comment"> **&nbsp; &nbsp; &nbsp; &nbsp; Routines for 2D points.<br/></li>
<li></span><span class="Comment"> **<br/></li>
<li></span><span class="Comment"> ***********************************************************************/<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L4096">&#x200c;</a><span class="linkable">construct_point</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; x = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; y = PG_GETARG_FLOAT8(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (Point *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Point));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1884" title="utils/adt/geo_ops.c:1884">point_construct</a>(result, x, y);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L4111">&#x200c;</a></span><span class="linkable">point_add_point</span>(Point *result, Point *pt1, Point *pt2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L1884" title="utils/adt/geo_ops.c:1884">point_construct</a>(result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; float8_pl(pt1-&gt;x, pt2-&gt;x),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; float8_pl(pt1-&gt;y, pt2-&gt;y));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L4119">&#x200c;</a><span class="linkable">point_add</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *p1 = PG_GETARG_POINT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *p2 = PG_GETARG_POINT_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (Point *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Point));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L4111" title="utils/adt/geo_ops.c:4111">point_add_point</a>(result, p1, p2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L4134">&#x200c;</a></span><span class="linkable">point_sub_point</span>(Point *result, Point *pt1, Point *pt2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L1884" title="utils/adt/geo_ops.c:1884">point_construct</a>(result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; float8_mi(pt1-&gt;x, pt2-&gt;x),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; float8_mi(pt1-&gt;y, pt2-&gt;y));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L4142">&#x200c;</a><span class="linkable">point_sub</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *p1 = PG_GETARG_POINT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *p2 = PG_GETARG_POINT_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (Point *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Point));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L4134" title="utils/adt/geo_ops.c:4134">point_sub_point</a>(result, p1, p2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L4157">&#x200c;</a></span><span class="linkable">point_mul_point</span>(Point *result, Point *pt1, Point *pt2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L1884" title="utils/adt/geo_ops.c:1884">point_construct</a>(result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; float8_mi(float8_mul(pt1-&gt;x, pt2-&gt;x),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; float8_mul(pt1-&gt;y, pt2-&gt;y)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; float8_pl(float8_mul(pt1-&gt;x, pt2-&gt;y),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; float8_mul(pt1-&gt;y, pt2-&gt;x)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L4167">&#x200c;</a><span class="linkable">point_mul</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *p1 = PG_GETARG_POINT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *p2 = PG_GETARG_POINT_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (Point *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Point));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L4157" title="utils/adt/geo_ops.c:4157">point_mul_point</a>(result, p1, p2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L4182">&#x200c;</a></span><span class="linkable">point_div_point</span>(Point *result, Point *pt1, Point *pt2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; div;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; div = float8_pl(float8_mul(pt2-&gt;x, pt2-&gt;x), float8_mul(pt2-&gt;y, pt2-&gt;y));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1884" title="utils/adt/geo_ops.c:1884">point_construct</a>(result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; float8_div(float8_pl(float8_mul(pt1-&gt;x, pt2-&gt;x),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; float8_mul(pt1-&gt;y, pt2-&gt;y)), div),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; float8_div(float8_mi(float8_mul(pt1-&gt;y, pt2-&gt;x),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; float8_mul(pt1-&gt;x, pt2-&gt;y)), div));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L4196">&#x200c;</a><span class="linkable">point_div</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *p1 = PG_GETARG_POINT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *p2 = PG_GETARG_POINT_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (Point *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Point));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L4182" title="utils/adt/geo_ops.c:4182">point_div_point</a>(result, p1, p2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/***********************************************************************<br/></li>
<li></span><span class="Comment"> **<br/></li>
<li></span><span class="Comment"> **&nbsp; &nbsp; &nbsp; &nbsp; Routines for 2D boxes.<br/></li>
<li></span><span class="Comment"> **<br/></li>
<li></span><span class="Comment"> ***********************************************************************/<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L4217">&#x200c;</a><span class="linkable">points_box</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *p1 = PG_GETARG_POINT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *p2 = PG_GETARG_POINT_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (BOX *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BOX));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L518" title="utils/adt/geo_ops.c:518">box_construct</a>(result, p1, p2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOX_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L4231">&#x200c;</a><span class="linkable">box_add</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box = PG_GETARG_BOX_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *p = PG_GETARG_POINT_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (BOX *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BOX));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L4111" title="utils/adt/geo_ops.c:4111">point_add_point</a>(&amp;result-&gt;high, &amp;box-&gt;high, p);<br/></li>
<li>&nbsp; &nbsp; <a href="#L4111" title="utils/adt/geo_ops.c:4111">point_add_point</a>(&amp;result-&gt;low, &amp;box-&gt;low, p);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOX_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L4246">&#x200c;</a><span class="linkable">box_sub</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box = PG_GETARG_BOX_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *p = PG_GETARG_POINT_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (BOX *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BOX));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L4134" title="utils/adt/geo_ops.c:4134">point_sub_point</a>(&amp;result-&gt;high, &amp;box-&gt;high, p);<br/></li>
<li>&nbsp; &nbsp; <a href="#L4134" title="utils/adt/geo_ops.c:4134">point_sub_point</a>(&amp;result-&gt;low, &amp;box-&gt;low, p);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOX_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L4261">&#x200c;</a><span class="linkable">box_mul</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box = PG_GETARG_BOX_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *p = PG_GETARG_POINT_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp; &nbsp; high,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (BOX *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BOX));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L4157" title="utils/adt/geo_ops.c:4157">point_mul_point</a>(&amp;high, &amp;box-&gt;high, p);<br/></li>
<li>&nbsp; &nbsp; <a href="#L4157" title="utils/adt/geo_ops.c:4157">point_mul_point</a>(&amp;low, &amp;box-&gt;low, p);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L518" title="utils/adt/geo_ops.c:518">box_construct</a>(result, &amp;high, &amp;low);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOX_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L4280">&#x200c;</a><span class="linkable">box_div</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box = PG_GETARG_BOX_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *p = PG_GETARG_POINT_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp; &nbsp; high,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (BOX *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BOX));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L4182" title="utils/adt/geo_ops.c:4182">point_div_point</a>(&amp;high, &amp;box-&gt;high, p);<br/></li>
<li>&nbsp; &nbsp; <a href="#L4182" title="utils/adt/geo_ops.c:4182">point_div_point</a>(&amp;low, &amp;box-&gt;low, p);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L518" title="utils/adt/geo_ops.c:518">box_construct</a>(result, &amp;high, &amp;low);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOX_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert point to empty box<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4302">&#x200c;</a><span class="linkable">point_box</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *pt = PG_GETARG_POINT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; box = (BOX *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BOX));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; box-&gt;high.x = pt-&gt;x;<br/></li>
<li>&nbsp; &nbsp; box-&gt;low.x = pt-&gt;x;<br/></li>
<li>&nbsp; &nbsp; box-&gt;high.y = pt-&gt;y;<br/></li>
<li>&nbsp; &nbsp; box-&gt;low.y = pt-&gt;y;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOX_P(box);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Smallest bounding box that includes both of the given boxes<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4321">&#x200c;</a><span class="linkable">boxes_bound_box</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box1 = PG_GETARG_BOX_P(<span class="Constant">0</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box2 = PG_GETARG_BOX_P(<span class="Constant">1</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *container;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; container = (BOX *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BOX));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; container-&gt;high.x = float8_max(box1-&gt;high.x, box2-&gt;high.x);<br/></li>
<li>&nbsp; &nbsp; container-&gt;low.x = float8_min(box1-&gt;low.x, box2-&gt;low.x);<br/></li>
<li>&nbsp; &nbsp; container-&gt;high.y = float8_max(box1-&gt;high.y, box2-&gt;high.y);<br/></li>
<li>&nbsp; &nbsp; container-&gt;low.y = float8_min(box1-&gt;low.y, box2-&gt;low.y);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOX_P(container);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/***********************************************************************<br/></li>
<li></span><span class="Comment"> **<br/></li>
<li></span><span class="Comment"> **&nbsp; &nbsp; &nbsp; &nbsp; Routines for 2D paths.<br/></li>
<li></span><span class="Comment"> **<br/></li>
<li></span><span class="Comment"> ***********************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* <a href="#L4348" title="utils/adt/geo_ops.c:4348">path_add</a>()<br/></li>
<li></span><span class="Comment"> * Concatenate two paths (only if they are both open).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4348">&#x200c;</a><span class="linkable">path_add</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PATH&nbsp; &nbsp; &nbsp;&nbsp; *p1 = PG_GETARG_PATH_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PATH&nbsp; &nbsp; &nbsp;&nbsp; *p2 = PG_GETARG_PATH_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; PATH&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; base_size;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (p1-&gt;closed || p2-&gt;closed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; base_size = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(p1-&gt;p[<span class="Constant">0</span>]) * (p1-&gt;npts + p2-&gt;npts);<br/></li>
<li>&nbsp; &nbsp; size = offsetof(PATH, p) + base_size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for integer overflow */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (base_size / <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(p1-&gt;p[<span class="Constant">0</span>]) != (p1-&gt;npts + p2-&gt;npts) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; size &lt;= base_size)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;too many points requested&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (PATH *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(result, size);<br/></li>
<li>&nbsp; &nbsp; result-&gt;npts = (p1-&gt;npts + p2-&gt;npts);<br/></li>
<li>&nbsp; &nbsp; result-&gt;closed = p1-&gt;closed;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* prevent instability in unused pad bytes */<br/></li>
<li></span>&nbsp; &nbsp; result-&gt;dummy = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; p1-&gt;npts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;p[i].x = p1-&gt;p[i].x;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;p[i].y = p1-&gt;p[i].y;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; p2-&gt;npts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;p[i + p1-&gt;npts].x = p2-&gt;p[i].x;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;p[i + p1-&gt;npts].y = p2-&gt;p[i].y;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_PATH_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L4396" title="utils/adt/geo_ops.c:4396">path_add_pt</a>()<br/></li>
<li></span><span class="Comment"> * Translation operators.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4396">&#x200c;</a><span class="linkable">path_add_pt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PATH&nbsp; &nbsp; &nbsp;&nbsp; *path = PG_GETARG_PATH_P_COPY(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *point = PG_GETARG_POINT_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; path-&gt;npts; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4111" title="utils/adt/geo_ops.c:4111">point_add_point</a>(&amp;path-&gt;p[i], &amp;path-&gt;p[i], point);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_PATH_P(path);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L4409">&#x200c;</a><span class="linkable">path_sub_pt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PATH&nbsp; &nbsp; &nbsp;&nbsp; *path = PG_GETARG_PATH_P_COPY(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *point = PG_GETARG_POINT_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; path-&gt;npts; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4134" title="utils/adt/geo_ops.c:4134">point_sub_point</a>(&amp;path-&gt;p[i], &amp;path-&gt;p[i], point);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_PATH_P(path);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L4425" title="utils/adt/geo_ops.c:4425">path_mul_pt</a>()<br/></li>
<li></span><span class="Comment"> * Rotation and scaling operators.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4425">&#x200c;</a><span class="linkable">path_mul_pt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PATH&nbsp; &nbsp; &nbsp;&nbsp; *path = PG_GETARG_PATH_P_COPY(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *point = PG_GETARG_POINT_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; path-&gt;npts; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4157" title="utils/adt/geo_ops.c:4157">point_mul_point</a>(&amp;path-&gt;p[i], &amp;path-&gt;p[i], point);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_PATH_P(path);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L4438">&#x200c;</a><span class="linkable">path_div_pt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PATH&nbsp; &nbsp; &nbsp;&nbsp; *path = PG_GETARG_PATH_P_COPY(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *point = PG_GETARG_POINT_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; path-&gt;npts; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4182" title="utils/adt/geo_ops.c:4182">point_div_point</a>(&amp;path-&gt;p[i], &amp;path-&gt;p[i], point);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_PATH_P(path);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L4452">&#x200c;</a><span class="linkable">path_poly</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PATH&nbsp; &nbsp; &nbsp;&nbsp; *path = PG_GETARG_PATH_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; POLYGON&nbsp; &nbsp; *poly;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This is not very consistent --- other similar cases return NULL ... */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!path-&gt;closed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;open path cannot be converted to polygon&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Never overflows: the old size fit in MaxAllocSize, and the new size is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * just a small constant larger.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; size = offsetof(POLYGON, p) + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(poly-&gt;p[<span class="Constant">0</span>]) * path-&gt;npts;<br/></li>
<li>&nbsp; &nbsp; poly = (POLYGON *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(poly, size);<br/></li>
<li>&nbsp; &nbsp; poly-&gt;npts = path-&gt;npts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; path-&gt;npts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; poly-&gt;p[i].x = path-&gt;p[i].x;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; poly-&gt;p[i].y = path-&gt;p[i].y;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L3376" title="utils/adt/geo_ops.c:3376">make_bound_box</a>(poly);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POLYGON_P(poly);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/***********************************************************************<br/></li>
<li></span><span class="Comment"> **<br/></li>
<li></span><span class="Comment"> **&nbsp; &nbsp; &nbsp; &nbsp; Routines for 2D polygons.<br/></li>
<li></span><span class="Comment"> **<br/></li>
<li></span><span class="Comment"> ***********************************************************************/<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L4494">&#x200c;</a><span class="linkable">poly_npoints</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; POLYGON&nbsp; &nbsp; *poly = PG_GETARG_POLYGON_P(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(poly-&gt;npts);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L4503">&#x200c;</a><span class="linkable">poly_center</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; POLYGON&nbsp; &nbsp; *poly = PG_GETARG_POLYGON_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp; &nbsp; circle;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (Point *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Point));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L5285" title="utils/adt/geo_ops.c:5285">poly_to_circle</a>(&amp;circle, poly);<br/></li>
<li>&nbsp; &nbsp; *result = circle.center;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L4519">&#x200c;</a><span class="linkable">poly_box</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; POLYGON&nbsp; &nbsp; *poly = PG_GETARG_POLYGON_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; box = (BOX *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BOX));<br/></li>
<li>&nbsp; &nbsp; *box = poly-&gt;boundbox;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOX_P(box);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L4535" title="utils/adt/geo_ops.c:4535">box_poly</a>()<br/></li>
<li></span><span class="Comment"> * Convert a box to a polygon.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4535">&#x200c;</a><span class="linkable">box_poly</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box = PG_GETARG_BOX_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; POLYGON&nbsp; &nbsp; *poly;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* map four corners of the box to a polygon */<br/></li>
<li></span>&nbsp; &nbsp; size = offsetof(POLYGON, p) + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(poly-&gt;p[<span class="Constant">0</span>]) * <span class="Constant">4</span>;<br/></li>
<li>&nbsp; &nbsp; poly = (POLYGON *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(poly, size);<br/></li>
<li>&nbsp; &nbsp; poly-&gt;npts = <span class="Constant">4</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; poly-&gt;p[<span class="Constant">0</span>].x = box-&gt;low.x;<br/></li>
<li>&nbsp; &nbsp; poly-&gt;p[<span class="Constant">0</span>].y = box-&gt;low.y;<br/></li>
<li>&nbsp; &nbsp; poly-&gt;p[<span class="Constant">1</span>].x = box-&gt;low.x;<br/></li>
<li>&nbsp; &nbsp; poly-&gt;p[<span class="Constant">1</span>].y = box-&gt;high.y;<br/></li>
<li>&nbsp; &nbsp; poly-&gt;p[<span class="Constant">2</span>].x = box-&gt;high.x;<br/></li>
<li>&nbsp; &nbsp; poly-&gt;p[<span class="Constant">2</span>].y = box-&gt;high.y;<br/></li>
<li>&nbsp; &nbsp; poly-&gt;p[<span class="Constant">3</span>].x = box-&gt;high.x;<br/></li>
<li>&nbsp; &nbsp; poly-&gt;p[<span class="Constant">3</span>].y = box-&gt;low.y;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L518" title="utils/adt/geo_ops.c:518">box_construct</a>(&amp;poly-&gt;boundbox, &amp;box-&gt;high, &amp;box-&gt;low);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POLYGON_P(poly);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L4564">&#x200c;</a><span class="linkable">poly_path</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; POLYGON&nbsp; &nbsp; *poly = PG_GETARG_POLYGON_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PATH&nbsp; &nbsp; &nbsp;&nbsp; *path;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Never overflows: the old size fit in MaxAllocSize, and the new size is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * smaller by a small constant.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; size = offsetof(PATH, p) + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(path-&gt;p[<span class="Constant">0</span>]) * poly-&gt;npts;<br/></li>
<li>&nbsp; &nbsp; path = (PATH *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(path, size);<br/></li>
<li>&nbsp; &nbsp; path-&gt;npts = poly-&gt;npts;<br/></li>
<li>&nbsp; &nbsp; path-&gt;closed = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* prevent instability in unused pad bytes */<br/></li>
<li></span>&nbsp; &nbsp; path-&gt;dummy = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; poly-&gt;npts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;p[i].x = poly-&gt;p[i].x;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;p[i].y = poly-&gt;p[i].y;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_PATH_P(path);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/***********************************************************************<br/></li>
<li></span><span class="Comment"> **<br/></li>
<li></span><span class="Comment"> **&nbsp; &nbsp; &nbsp; &nbsp; Routines for circles.<br/></li>
<li></span><span class="Comment"> **<br/></li>
<li></span><span class="Comment"> ***********************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*----------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * Formatting and conversion routines.<br/></li>
<li></span><span class="Comment"> *---------------------------------------------------------*/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4611" title="utils/adt/geo_ops.c:4611">circle_in</a>&nbsp; &nbsp; &nbsp; &nbsp; -&nbsp; &nbsp; &nbsp; &nbsp; convert a string to <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> form.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; External format: (center and radius of circle)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;&lt;(f8,f8),f8&gt;&quot;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; also supports quick entry style &quot;f8,f8,f8&quot;<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4611">&#x200c;</a><span class="linkable">circle_in</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *str = PG_GETARG_CSTRING(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *escontext = fcinfo-&gt;context;<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle = (CIRCLE *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(CIRCLE));<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *s,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *cp;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; depth = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; s = str;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (isspace((<span class="Type">unsigned</span> <span class="Type">char</span>) *s))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s++;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*s == <a href="#L162" title="utils/adt/geo_ops.c:162">LDELIM_C</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; depth++, s++;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*s == <a href="#L157" title="utils/adt/geo_ops.c:157">LDELIM</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If there are two left parens, consume the first one */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; cp = (s + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (isspace((<span class="Type">unsigned</span> <span class="Type">char</span>) *cp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cp++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*cp == <a href="#L157" title="utils/adt/geo_ops.c:157">LDELIM</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; depth++, s = cp;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="#L212" title="utils/adt/geo_ops.c:212">pair_decode</a> will consume parens around the pair, if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L212" title="utils/adt/geo_ops.c:212">pair_decode</a>(s, &amp;circle-&gt;center.x, &amp;circle-&gt;center.y, &amp;s, <span class="Constant">&quot;circle&quot;</span>, str,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; escontext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*s == <a href="#L159" title="utils/adt/geo_ops.c:159">DELIM</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L194" title="utils/adt/geo_ops.c:194">single_decode</a>(s, &amp;circle-&gt;radius, &amp;s, <span class="Constant">&quot;circle&quot;</span>, str, escontext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We have to <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> NaN. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (circle-&gt;radius &lt; <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid input syntax for type </span><span class="Special">%s</span><span class="Constant">: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;circle&quot;</span>, str)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (depth &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((*s == <a href="#L158" title="utils/adt/geo_ops.c:158">RDELIM</a>) || ((*s == <a href="#L163" title="utils/adt/geo_ops.c:163">RDELIM_C</a>) &amp;&amp; (depth == <span class="Constant">1</span>)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; depth--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (isspace((<span class="Type">unsigned</span> <span class="Type">char</span>) *s))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid input syntax for type </span><span class="Special">%s</span><span class="Constant">: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;circle&quot;</span>, str)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*s != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid input syntax for type </span><span class="Special">%s</span><span class="Constant">: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;circle&quot;</span>, str)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CIRCLE_P(circle);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4681" title="utils/adt/geo_ops.c:4681">circle_out</a>&nbsp; &nbsp; &nbsp; &nbsp; -&nbsp; &nbsp; &nbsp; &nbsp; convert a circle to external form.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4681">&#x200c;</a><span class="linkable">circle_out</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle = PG_GETARG_CIRCLE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; StringInfoData str;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;str);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfoChar(&amp;str, <a href="#L162" title="utils/adt/geo_ops.c:162">LDELIM_C</a>);<br/></li>
<li>&nbsp; &nbsp; appendStringInfoChar(&amp;str, <a href="#L157" title="utils/adt/geo_ops.c:157">LDELIM</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L255" title="utils/adt/geo_ops.c:255">pair_encode</a>(circle-&gt;center.x, circle-&gt;center.y, &amp;str);<br/></li>
<li>&nbsp; &nbsp; appendStringInfoChar(&amp;str, <a href="#L158" title="utils/adt/geo_ops.c:158">RDELIM</a>);<br/></li>
<li>&nbsp; &nbsp; appendStringInfoChar(&amp;str, <a href="#L159" title="utils/adt/geo_ops.c:159">DELIM</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L203" title="utils/adt/geo_ops.c:203">single_encode</a>(circle-&gt;radius, &amp;str);<br/></li>
<li>&nbsp; &nbsp; appendStringInfoChar(&amp;str, <a href="#L163" title="utils/adt/geo_ops.c:163">RDELIM_C</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CSTRING(str.data);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4703" title="utils/adt/geo_ops.c:4703">circle_recv</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts external binary format to circle<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4703">&#x200c;</a><span class="linkable">circle_recv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; buf = (StringInfo) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; circle = (CIRCLE *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(CIRCLE));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; circle-&gt;center.x = <a href="../../libpq/pqformat.c.html#L488" title="libpq/pqformat.c:488">pq_getmsgfloat8</a>(buf);<br/></li>
<li>&nbsp; &nbsp; circle-&gt;center.y = <a href="../../libpq/pqformat.c.html#L488" title="libpq/pqformat.c:488">pq_getmsgfloat8</a>(buf);<br/></li>
<li>&nbsp; &nbsp; circle-&gt;radius = <a href="../../libpq/pqformat.c.html#L488" title="libpq/pqformat.c:488">pq_getmsgfloat8</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We have to <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> NaN. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (circle-&gt;radius &lt; <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_BINARY_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid radius in external </span><span class="Special">\&quot;</span><span class="Constant">circle</span><span class="Special">\&quot;</span><span class="Constant"> value&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CIRCLE_P(circle);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4727" title="utils/adt/geo_ops.c:4727">circle_send</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts circle to binary format<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4727">&#x200c;</a><span class="linkable">circle_send</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle = PG_GETARG_CIRCLE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L326" title="libpq/pqformat.c:326">pq_begintypsend</a>(&amp;buf);<br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L276" title="libpq/pqformat.c:276">pq_sendfloat8</a>(&amp;buf, circle-&gt;center.x);<br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L276" title="libpq/pqformat.c:276">pq_sendfloat8</a>(&amp;buf, circle-&gt;center.y);<br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L276" title="libpq/pqformat.c:276">pq_sendfloat8</a>(&amp;buf, circle-&gt;radius);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BYTEA_P(<a href="../../libpq/pqformat.c.html#L346" title="libpq/pqformat.c:346">pq_endtypsend</a>(&amp;buf));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*----------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Relational operators for CIRCLEs.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &lt;, &gt;, &lt;=, &gt;=, and == are based on circle area.<br/></li>
<li></span><span class="Comment"> *---------------------------------------------------------*/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; circles identical?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We consider NaNs <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to be <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to each other to let those circles<br/></li>
<li></span><span class="Comment"> * to be found.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4751">&#x200c;</a><span class="linkable">circle_same</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle1 = PG_GETARG_CIRCLE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle2 = PG_GETARG_CIRCLE_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(((isnan(circle1-&gt;radius) &amp;&amp; isnan(circle2-&gt;radius)) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FPeq(circle1-&gt;radius, circle2-&gt;radius)) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L1977" title="utils/adt/geo_ops.c:1977">point_eq_point</a>(&amp;circle1-&gt;center, &amp;circle2-&gt;center));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4764" title="utils/adt/geo_ops.c:4764">circle_overlap</a>&nbsp; &nbsp; -&nbsp; &nbsp; &nbsp; &nbsp; does circle1 overlap circle2?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4764">&#x200c;</a><span class="linkable">circle_overlap</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle1 = PG_GETARG_CIRCLE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle2 = PG_GETARG_CIRCLE_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(FPle(<a href="#L2002" title="utils/adt/geo_ops.c:2002">point_dt</a>(&amp;circle1-&gt;center, &amp;circle2-&gt;center),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; float8_pl(circle1-&gt;radius, circle2-&gt;radius)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4777" title="utils/adt/geo_ops.c:4777">circle_overleft</a> -&nbsp; &nbsp; &nbsp; &nbsp; is the right edge of circle1 at or left of<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the right edge of circle2?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4777">&#x200c;</a><span class="linkable">circle_overleft</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle1 = PG_GETARG_CIRCLE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle2 = PG_GETARG_CIRCLE_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(FPle(float8_pl(circle1-&gt;center.x, circle1-&gt;radius),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; float8_pl(circle2-&gt;center.x, circle2-&gt;radius)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4789" title="utils/adt/geo_ops.c:4789">circle_left</a>&nbsp; &nbsp; &nbsp; &nbsp; -&nbsp; &nbsp; &nbsp; &nbsp; is circle1 strictly left of circle2?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4789">&#x200c;</a><span class="linkable">circle_left</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle1 = PG_GETARG_CIRCLE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle2 = PG_GETARG_CIRCLE_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(FPlt(float8_pl(circle1-&gt;center.x, circle1-&gt;radius),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; float8_mi(circle2-&gt;center.x, circle2-&gt;radius)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4801" title="utils/adt/geo_ops.c:4801">circle_right</a>&nbsp; &nbsp; -&nbsp; &nbsp; &nbsp; &nbsp; is circle1 strictly right of circle2?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4801">&#x200c;</a><span class="linkable">circle_right</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle1 = PG_GETARG_CIRCLE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle2 = PG_GETARG_CIRCLE_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(FPgt(float8_mi(circle1-&gt;center.x, circle1-&gt;radius),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; float8_pl(circle2-&gt;center.x, circle2-&gt;radius)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4814" title="utils/adt/geo_ops.c:4814">circle_overright</a>&nbsp; &nbsp; -&nbsp; &nbsp; is the left edge of circle1 at or right of<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the left edge of circle2?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4814">&#x200c;</a><span class="linkable">circle_overright</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle1 = PG_GETARG_CIRCLE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle2 = PG_GETARG_CIRCLE_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(FPge(float8_mi(circle1-&gt;center.x, circle1-&gt;radius),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; float8_mi(circle2-&gt;center.x, circle2-&gt;radius)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4826" title="utils/adt/geo_ops.c:4826">circle_contained</a>&nbsp; &nbsp; &nbsp; &nbsp; -&nbsp; &nbsp; &nbsp; &nbsp; is circle1 contained by circle2?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4826">&#x200c;</a><span class="linkable">circle_contained</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle1 = PG_GETARG_CIRCLE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle2 = PG_GETARG_CIRCLE_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(FPle(<a href="#L2002" title="utils/adt/geo_ops.c:2002">point_dt</a>(&amp;circle1-&gt;center, &amp;circle2-&gt;center),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; float8_mi(circle2-&gt;radius, circle1-&gt;radius)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4838" title="utils/adt/geo_ops.c:4838">circle_contain</a>&nbsp; &nbsp; -&nbsp; &nbsp; &nbsp; &nbsp; does circle1 contain circle2?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4838">&#x200c;</a><span class="linkable">circle_contain</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle1 = PG_GETARG_CIRCLE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle2 = PG_GETARG_CIRCLE_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(FPle(<a href="#L2002" title="utils/adt/geo_ops.c:2002">point_dt</a>(&amp;circle1-&gt;center, &amp;circle2-&gt;center),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; float8_mi(circle1-&gt;radius, circle2-&gt;radius)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4851" title="utils/adt/geo_ops.c:4851">circle_below</a>&nbsp; &nbsp; &nbsp; &nbsp; -&nbsp; &nbsp; &nbsp; &nbsp; is circle1 strictly below circle2?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4851">&#x200c;</a><span class="linkable">circle_below</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle1 = PG_GETARG_CIRCLE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle2 = PG_GETARG_CIRCLE_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(FPlt(float8_pl(circle1-&gt;center.y, circle1-&gt;radius),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; float8_mi(circle2-&gt;center.y, circle2-&gt;radius)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4863" title="utils/adt/geo_ops.c:4863">circle_above</a>&nbsp; &nbsp; -&nbsp; &nbsp; &nbsp; &nbsp; is circle1 strictly above circle2?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4863">&#x200c;</a><span class="linkable">circle_above</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle1 = PG_GETARG_CIRCLE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle2 = PG_GETARG_CIRCLE_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(FPgt(float8_mi(circle1-&gt;center.y, circle1-&gt;radius),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; float8_pl(circle2-&gt;center.y, circle2-&gt;radius)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4876" title="utils/adt/geo_ops.c:4876">circle_overbelow</a> -&nbsp; &nbsp; &nbsp; &nbsp; is the <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> edge of circle1 at or below<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> edge of circle2?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4876">&#x200c;</a><span class="linkable">circle_overbelow</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle1 = PG_GETARG_CIRCLE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle2 = PG_GETARG_CIRCLE_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(FPle(float8_pl(circle1-&gt;center.y, circle1-&gt;radius),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; float8_pl(circle2-&gt;center.y, circle2-&gt;radius)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4889" title="utils/adt/geo_ops.c:4889">circle_overabove</a>&nbsp; &nbsp; -&nbsp; &nbsp; is the <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> edge of circle1 at or above<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> edge of circle2?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4889">&#x200c;</a><span class="linkable">circle_overabove</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle1 = PG_GETARG_CIRCLE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle2 = PG_GETARG_CIRCLE_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(FPge(float8_mi(circle1-&gt;center.y, circle1-&gt;radius),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; float8_mi(circle2-&gt;center.y, circle2-&gt;radius)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; circle_relop&nbsp; &nbsp; -&nbsp; &nbsp; &nbsp; &nbsp; is area(circle1) relop area(circle2), within<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; our accuracy constraint?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4903">&#x200c;</a><span class="linkable">circle_eq</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle1 = PG_GETARG_CIRCLE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle2 = PG_GETARG_CIRCLE_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(FPeq(<a href="#L5159" title="utils/adt/geo_ops.c:5159">circle_ar</a>(circle1), <a href="#L5159" title="utils/adt/geo_ops.c:5159">circle_ar</a>(circle2)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L4912">&#x200c;</a><span class="linkable">circle_ne</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle1 = PG_GETARG_CIRCLE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle2 = PG_GETARG_CIRCLE_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(FPne(<a href="#L5159" title="utils/adt/geo_ops.c:5159">circle_ar</a>(circle1), <a href="#L5159" title="utils/adt/geo_ops.c:5159">circle_ar</a>(circle2)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L4921">&#x200c;</a><span class="linkable">circle_lt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle1 = PG_GETARG_CIRCLE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle2 = PG_GETARG_CIRCLE_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(FPlt(<a href="#L5159" title="utils/adt/geo_ops.c:5159">circle_ar</a>(circle1), <a href="#L5159" title="utils/adt/geo_ops.c:5159">circle_ar</a>(circle2)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L4930">&#x200c;</a><span class="linkable">circle_gt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle1 = PG_GETARG_CIRCLE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle2 = PG_GETARG_CIRCLE_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(FPgt(<a href="#L5159" title="utils/adt/geo_ops.c:5159">circle_ar</a>(circle1), <a href="#L5159" title="utils/adt/geo_ops.c:5159">circle_ar</a>(circle2)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L4939">&#x200c;</a><span class="linkable">circle_le</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle1 = PG_GETARG_CIRCLE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle2 = PG_GETARG_CIRCLE_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(FPle(<a href="#L5159" title="utils/adt/geo_ops.c:5159">circle_ar</a>(circle1), <a href="#L5159" title="utils/adt/geo_ops.c:5159">circle_ar</a>(circle2)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L4948">&#x200c;</a><span class="linkable">circle_ge</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle1 = PG_GETARG_CIRCLE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle2 = PG_GETARG_CIRCLE_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(FPge(<a href="#L5159" title="utils/adt/geo_ops.c:5159">circle_ar</a>(circle1), <a href="#L5159" title="utils/adt/geo_ops.c:5159">circle_ar</a>(circle2)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*----------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &quot;Arithmetic&quot; operators on circles.<br/></li>
<li></span><span class="Comment"> *---------------------------------------------------------*/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* <a href="#L4965" title="utils/adt/geo_ops.c:4965">circle_add_pt</a>()<br/></li>
<li></span><span class="Comment"> * Translation operator.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4965">&#x200c;</a><span class="linkable">circle_add_pt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle = PG_GETARG_CIRCLE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *point = PG_GETARG_POINT_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (CIRCLE *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(CIRCLE));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L4111" title="utils/adt/geo_ops.c:4111">point_add_point</a>(&amp;result-&gt;center, &amp;circle-&gt;center, point);<br/></li>
<li>&nbsp; &nbsp; result-&gt;radius = circle-&gt;radius;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CIRCLE_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L4980">&#x200c;</a><span class="linkable">circle_sub_pt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle = PG_GETARG_CIRCLE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *point = PG_GETARG_POINT_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (CIRCLE *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(CIRCLE));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L4134" title="utils/adt/geo_ops.c:4134">point_sub_point</a>(&amp;result-&gt;center, &amp;circle-&gt;center, point);<br/></li>
<li>&nbsp; &nbsp; result-&gt;radius = circle-&gt;radius;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CIRCLE_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L4999" title="utils/adt/geo_ops.c:4999">circle_mul_pt</a>()<br/></li>
<li></span><span class="Comment"> * Rotation and scaling operators.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4999">&#x200c;</a><span class="linkable">circle_mul_pt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle = PG_GETARG_CIRCLE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *point = PG_GETARG_POINT_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (CIRCLE *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(CIRCLE));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L4157" title="utils/adt/geo_ops.c:4157">point_mul_point</a>(&amp;result-&gt;center, &amp;circle-&gt;center, point);<br/></li>
<li>&nbsp; &nbsp; result-&gt;radius = float8_mul(circle-&gt;radius, HYPOT(point-&gt;x, point-&gt;y));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CIRCLE_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L5014">&#x200c;</a><span class="linkable">circle_div_pt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle = PG_GETARG_CIRCLE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *point = PG_GETARG_POINT_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (CIRCLE *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(CIRCLE));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L4182" title="utils/adt/geo_ops.c:4182">point_div_point</a>(&amp;result-&gt;center, &amp;circle-&gt;center, point);<br/></li>
<li>&nbsp; &nbsp; result-&gt;radius = float8_div(circle-&gt;radius, HYPOT(point-&gt;x, point-&gt;y));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CIRCLE_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5032" title="utils/adt/geo_ops.c:5032">circle_area</a>&nbsp; &nbsp; &nbsp; &nbsp; -&nbsp; &nbsp; &nbsp; &nbsp; returns the area of the circle.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L5032">&#x200c;</a><span class="linkable">circle_area</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle = PG_GETARG_CIRCLE_P(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(<a href="#L5159" title="utils/adt/geo_ops.c:5159">circle_ar</a>(circle));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5043" title="utils/adt/geo_ops.c:5043">circle_diameter</a> -&nbsp; &nbsp; &nbsp; &nbsp; returns the diameter of the circle.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L5043">&#x200c;</a><span class="linkable">circle_diameter</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle = PG_GETARG_CIRCLE_P(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(float8_mul(circle-&gt;radius, <span class="Constant">2.0</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5054" title="utils/adt/geo_ops.c:5054">circle_radius</a>&nbsp; &nbsp; -&nbsp; &nbsp; &nbsp; &nbsp; returns the radius of the circle.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L5054">&#x200c;</a><span class="linkable">circle_radius</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle = PG_GETARG_CIRCLE_P(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(circle-&gt;radius);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5066" title="utils/adt/geo_ops.c:5066">circle_distance</a> -&nbsp; &nbsp; &nbsp; &nbsp; returns the distance between<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; two circles.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L5066">&#x200c;</a><span class="linkable">circle_distance</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle1 = PG_GETARG_CIRCLE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle2 = PG_GETARG_CIRCLE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = float8_mi(<a href="#L2002" title="utils/adt/geo_ops.c:2002">point_dt</a>(&amp;circle1-&gt;center, &amp;circle2-&gt;center),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; float8_pl(circle1-&gt;radius, circle2-&gt;radius));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result &lt; <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">0.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L5082">&#x200c;</a><span class="linkable">circle_contain_pt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle = PG_GETARG_CIRCLE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *point = PG_GETARG_POINT_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; d;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; d = <a href="#L2002" title="utils/adt/geo_ops.c:2002">point_dt</a>(&amp;circle-&gt;center, point);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(d &lt;= circle-&gt;radius);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L5094">&#x200c;</a><span class="linkable">pt_contained_circle</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *point = PG_GETARG_POINT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle = PG_GETARG_CIRCLE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; d;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; d = <a href="#L2002" title="utils/adt/geo_ops.c:2002">point_dt</a>(&amp;circle-&gt;center, point);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(d &lt;= circle-&gt;radius);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5109" title="utils/adt/geo_ops.c:5109">dist_pc</a> -&nbsp; &nbsp; &nbsp; &nbsp; returns the distance between<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a point and a circle.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L5109">&#x200c;</a><span class="linkable">dist_pc</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *point = PG_GETARG_POINT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle = PG_GETARG_CIRCLE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = float8_mi(<a href="#L2002" title="utils/adt/geo_ops.c:2002">point_dt</a>(point, &amp;circle-&gt;center),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; circle-&gt;radius);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result &lt; <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">0.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Distance from a circle to a point<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L5127">&#x200c;</a><span class="linkable">dist_cpoint</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle = PG_GETARG_CIRCLE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *point = PG_GETARG_POINT_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = float8_mi(<a href="#L2002" title="utils/adt/geo_ops.c:2002">point_dt</a>(point, &amp;circle-&gt;center), circle-&gt;radius);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result &lt; <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">0.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5143" title="utils/adt/geo_ops.c:5143">circle_center</a>&nbsp; &nbsp; -&nbsp; &nbsp; &nbsp; &nbsp; returns the center point of the circle.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L5143">&#x200c;</a><span class="linkable">circle_center</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle = PG_GETARG_CIRCLE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (Point *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Point));<br/></li>
<li>&nbsp; &nbsp; result-&gt;x = circle-&gt;center.x;<br/></li>
<li>&nbsp; &nbsp; result-&gt;y = circle-&gt;center.y;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5159" title="utils/adt/geo_ops.c:5159">circle_ar</a>&nbsp; &nbsp; &nbsp; &nbsp; -&nbsp; &nbsp; &nbsp; &nbsp; returns the area of the circle.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> float8<br/></li>
<li><a id="L5159">&#x200c;</a><span class="linkable">circle_ar</span>(CIRCLE *circle)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> float8_mul(float8_mul(circle-&gt;radius, circle-&gt;radius), <span class="Constant">M_PI</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*----------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Conversion operators.<br/></li>
<li></span><span class="Comment"> *---------------------------------------------------------*/<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L5170">&#x200c;</a><span class="linkable">cr_circle</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *center = PG_GETARG_POINT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; radius = PG_GETARG_FLOAT8(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (CIRCLE *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(CIRCLE));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result-&gt;center.x = center-&gt;x;<br/></li>
<li>&nbsp; &nbsp; result-&gt;center.y = center-&gt;y;<br/></li>
<li>&nbsp; &nbsp; result-&gt;radius = radius;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CIRCLE_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L5186">&#x200c;</a><span class="linkable">circle_box</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle = PG_GETARG_CIRCLE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box;<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; delta;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; box = (BOX *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BOX));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; delta = float8_div(circle-&gt;radius, sqrt(<span class="Constant">2.0</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; box-&gt;high.x = float8_pl(circle-&gt;center.x, delta);<br/></li>
<li>&nbsp; &nbsp; box-&gt;low.x = float8_mi(circle-&gt;center.x, delta);<br/></li>
<li>&nbsp; &nbsp; box-&gt;high.y = float8_pl(circle-&gt;center.y, delta);<br/></li>
<li>&nbsp; &nbsp; box-&gt;low.y = float8_mi(circle-&gt;center.y, delta);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOX_P(box);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L5208" title="utils/adt/geo_ops.c:5208">box_circle</a>()<br/></li>
<li></span><span class="Comment"> * Convert a box to a circle.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L5208">&#x200c;</a><span class="linkable">box_circle</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box = PG_GETARG_BOX_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; circle = (CIRCLE *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(CIRCLE));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; circle-&gt;center.x = float8_div(float8_pl(box-&gt;high.x, box-&gt;low.x), <span class="Constant">2.0</span>);<br/></li>
<li>&nbsp; &nbsp; circle-&gt;center.y = float8_div(float8_pl(box-&gt;high.y, box-&gt;low.y), <span class="Constant">2.0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; circle-&gt;radius = <a href="#L2002" title="utils/adt/geo_ops.c:2002">point_dt</a>(&amp;circle-&gt;center, &amp;box-&gt;high);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CIRCLE_P(circle);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L5225">&#x200c;</a><span class="linkable">circle_poly</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; npts = PG_GETARG_INT32(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *circle = PG_GETARG_CIRCLE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; POLYGON&nbsp; &nbsp; *poly;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; base_size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; angle;<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; anglestep;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (FPzero(circle-&gt;radius))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot convert circle with radius zero to polygon&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (npts &lt; <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;must request at least 2 points&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; base_size = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(poly-&gt;p[<span class="Constant">0</span>]) * npts;<br/></li>
<li>&nbsp; &nbsp; size = offsetof(POLYGON, p) + base_size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for integer overflow */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (base_size / npts != <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(poly-&gt;p[<span class="Constant">0</span>]) || size &lt;= base_size)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;too many points requested&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; poly = (POLYGON *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(size);&nbsp; &nbsp; <span class="Comment">/* zero <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> holes */<br/></li>
<li></span>&nbsp; &nbsp; SET_VARSIZE(poly, size);<br/></li>
<li>&nbsp; &nbsp; poly-&gt;npts = npts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; anglestep = float8_div(<span class="Constant">2.0</span> * <span class="Constant">M_PI</span>, npts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; npts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; angle = float8_mul(anglestep, i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; poly-&gt;p[i].x = float8_mi(circle-&gt;center.x,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; float8_mul(circle-&gt;radius, cos(angle)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; poly-&gt;p[i].y = float8_pl(circle-&gt;center.y,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; float8_mul(circle-&gt;radius, sin(angle)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L3376" title="utils/adt/geo_ops.c:3376">make_bound_box</a>(poly);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POLYGON_P(poly);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert polygon to circle<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The result must be preallocated.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment"> This algorithm should use weighted means of line segments<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; rather than straight average <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of points - tgl 97/01/21.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L5285">&#x200c;</a></span><span class="linkable">poly_to_circle</span>(CIRCLE *result, POLYGON *poly)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(poly-&gt;npts &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result-&gt;center.x = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; result-&gt;center.y = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; result-&gt;radius = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; poly-&gt;npts; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4111" title="utils/adt/geo_ops.c:4111">point_add_point</a>(&amp;result-&gt;center, &amp;result-&gt;center, &amp;poly-&gt;p[i]);<br/></li>
<li>&nbsp; &nbsp; result-&gt;center.x = float8_div(result-&gt;center.x, poly-&gt;npts);<br/></li>
<li>&nbsp; &nbsp; result-&gt;center.y = float8_div(result-&gt;center.y, poly-&gt;npts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; poly-&gt;npts; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;radius = float8_pl(result-&gt;radius,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L2002" title="utils/adt/geo_ops.c:2002">point_dt</a>(&amp;poly-&gt;p[i], &amp;result-&gt;center));<br/></li>
<li>&nbsp; &nbsp; result-&gt;radius = float8_div(result-&gt;radius, poly-&gt;npts);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L5307">&#x200c;</a><span class="linkable">poly_circle</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; POLYGON&nbsp; &nbsp; *poly = PG_GETARG_POLYGON_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (CIRCLE *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(CIRCLE));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L5285" title="utils/adt/geo_ops.c:5285">poly_to_circle</a>(result, poly);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CIRCLE_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/***********************************************************************<br/></li>
<li></span><span class="Comment"> **<br/></li>
<li></span><span class="Comment"> **&nbsp; &nbsp; &nbsp; &nbsp; Private routines for multiple types.<br/></li>
<li></span><span class="Comment"> **<br/></li>
<li></span><span class="Comment"> ***********************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Test to see if the point is inside the polygon, returns 1/0, or 2 if<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; the point is on the polygon.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Code adapted but not copied from integer-based routines in WN: A<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Server for the HTTP<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; version 1.15.1, file wn/image.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; http://hopf.math.northwestern.edu/index.html<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Description of algorithm:&nbsp; http://www.linuxjournal.com/article/2197<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; http://www.linuxjournal.com/article/2029<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><a id="L5337">&#x200c;</a><span class="PreProc">#define <span class="linkable">POINT_ON_POLYGON</span> </span><span class="Constant">INT_MAX<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L5340">&#x200c;</a></span><span class="linkable">point_inside</span>(Point *p, <span class="Type">int</span> npts, Point *plist)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; x0,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; y0;<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; prev_x,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prev_y;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; x,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; y;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cross,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; total_cross = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(npts &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* compute first polygon point relative to single point */<br/></li>
<li></span>&nbsp; &nbsp; x0 = float8_mi(plist[<span class="Constant">0</span>].x, p-&gt;x);<br/></li>
<li>&nbsp; &nbsp; y0 = float8_mi(plist[<span class="Constant">0</span>].y, p-&gt;y);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; prev_x = x0;<br/></li>
<li>&nbsp; &nbsp; prev_y = y0;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* loop over polygon points and aggregate total_cross */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt; npts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* compute <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> polygon point relative to single point */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; x = float8_mi(plist[i].x, p-&gt;x);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; y = float8_mi(plist[i].y, p-&gt;y);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* compute previous to current point crossing */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((cross = <a href="#L5397" title="utils/adt/geo_ops.c:5397">lseg_crossing</a>(x, y, prev_x, prev_y)) == <a href="#L5337" title="utils/adt/geo_ops.c:5337">POINT_ON_POLYGON</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; total_cross += cross;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prev_x = x;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prev_y = y;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> do the first point */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((cross = <a href="#L5397" title="utils/adt/geo_ops.c:5397">lseg_crossing</a>(x0, y0, prev_x, prev_y)) == <a href="#L5337" title="utils/adt/geo_ops.c:5337">POINT_ON_POLYGON</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; total_cross += cross;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (total_cross != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L5397" title="utils/adt/geo_ops.c:5397">lseg_crossing</a>()<br/></li>
<li></span><span class="Comment"> * Returns +/-2 if line segment crosses the positive X-axis in a +/- direction.<br/></li>
<li></span><span class="Comment"> * Returns +/-1 if one point is on the positive X-axis.<br/></li>
<li></span><span class="Comment"> * Returns 0 if both points are on the positive X-axis, or there is no crossing.<br/></li>
<li></span><span class="Comment"> * Returns <a href="#L5337" title="utils/adt/geo_ops.c:5337">POINT_ON_POLYGON</a> if the segment contains (0,0).<br/></li>
<li></span><span class="Comment"> * Wow, that is one confusing API, but it is used above, and when summed,<br/></li>
<li></span><span class="Comment"> * can tell is if a point is in a polygon.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L5397">&#x200c;</a></span><span class="linkable">lseg_crossing</span>(float8 x, float8 y, float8 prev_x, float8 prev_y)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; z;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; y_sign;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (FPzero(y))<br/></li>
<li>&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* y == 0, on X axis */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (FPzero(x))&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* (x,y) is (0,0)? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L5337" title="utils/adt/geo_ops.c:5337">POINT_ON_POLYGON</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (FPgt(x, <span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* x &gt; 0 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (FPzero(prev_y)) <span class="Comment">/* y and prev_y are zero */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* prev_x &gt; 0? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> FPgt(prev_x, <span class="Constant">0.0</span>) ? <span class="Constant">0</span> : <a href="#L5337" title="utils/adt/geo_ops.c:5337">POINT_ON_POLYGON</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> FPlt(prev_y, <span class="Constant">0.0</span>) ? <span class="Constant">1</span> : -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* x &lt; 0, x not on positive X axis */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (FPzero(prev_y))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* prev_x &lt; 0? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> FPlt(prev_x, <span class="Constant">0.0</span>) ? <span class="Constant">0</span> : <a href="#L5337" title="utils/adt/geo_ops.c:5337">POINT_ON_POLYGON</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* y != 0 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* compute y crossing direction from previous point */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; y_sign = FPgt(y, <span class="Constant">0.0</span>) ? <span class="Constant">1</span> : -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (FPzero(prev_y))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* previous point was on X axis, so new point is either off or on */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> FPlt(prev_x, <span class="Constant">0.0</span>) ? <span class="Constant">0</span> : y_sign;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> ((y_sign &lt; <span class="Constant">0</span> &amp;&amp; FPlt(prev_y, <span class="Constant">0.0</span>)) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (y_sign &gt; <span class="Constant">0</span> &amp;&amp; FPgt(prev_y, <span class="Constant">0.0</span>)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* both above or below X axis */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* same sign */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* y and prev_y cross X-axis */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (FPge(x, <span class="Constant">0.0</span>) &amp;&amp; FPgt(prev_x, <span class="Constant">0.0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* both non-negative so cross positive X-axis */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">2</span> * y_sign;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (FPlt(x, <span class="Constant">0.0</span>) &amp;&amp; FPle(prev_x, <span class="Constant">0.0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* both non-positive so do not cross positive X-axis */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* x and y cross axes, see URL above <a href="#L5340" title="utils/adt/geo_ops.c:5340">point_inside</a>() */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; z = float8_mi(float8_mul(float8_mi(x, prev_x), y),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; float8_mul(float8_mi(y, prev_y), x));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (FPzero(z))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L5337" title="utils/adt/geo_ops.c:5337">POINT_ON_POLYGON</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((y_sign &lt; <span class="Constant">0</span> &amp;&amp; FPlt(z, <span class="Constant">0.0</span>)) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (y_sign &gt; <span class="Constant">0</span> &amp;&amp; FPgt(z, <span class="Constant">0.0</span>)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">2</span> * y_sign;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L5457">&#x200c;</a></span><span class="linkable">plist_same</span>(<span class="Type">int</span> npts, Point *p1, Point *p2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ii,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> match for first point */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; npts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1977" title="utils/adt/geo_ops.c:1977">point_eq_point</a>(&amp;p2[i], &amp;p1[<span class="Constant">0</span>]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* match found? then look forward through remaining points */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (ii = <span class="Constant">1</span>, j = i + <span class="Constant">1</span>; ii &lt; npts; ii++, j++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (j &gt;= npts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L1977" title="utils/adt/geo_ops.c:1977">point_eq_point</a>(&amp;p2[j], &amp;p1[ii]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ii == npts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* match not found forwards? then look backwards */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (ii = <span class="Constant">1</span>, j = i - <span class="Constant">1</span>; ii &lt; npts; ii++, j--)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (j &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j = (npts - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L1977" title="utils/adt/geo_ops.c:1977">point_eq_point</a>(&amp;p2[j], &amp;p1[ii]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ii == npts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * Determine the hypotenuse.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If required, x and y are swapped to make x the larger number. The<br/></li>
<li></span><span class="Comment"> * traditional formula of x^2+y^2 is rearranged to factor x outside the<br/></li>
<li></span><span class="Comment"> * sqrt. This allows computation of the hypotenuse for significantly<br/></li>
<li></span><span class="Comment"> * larger <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, and with a higher precision than when using the naive<br/></li>
<li></span><span class="Comment"> * formula.&nbsp; In particular, this cannot overflow unless the final result<br/></li>
<li></span><span class="Comment"> * would be out-of-<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * sqrt( x^2 + y^2 ) = sqrt( x^2( 1 + y^2/x^2) )<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; = x * sqrt( 1 + y^2/x^2 )<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; = x * sqrt( 1 + y/x * y/x )<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It is expected that this routine will eventually be replaced with the<br/></li>
<li></span><span class="Comment"> * C99 hypot() function.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This implementation conforms to IEEE Std 1003.1 and GLIBC, in that the<br/></li>
<li></span><span class="Comment"> * case of hypot(inf,nan) results in <a href="../../regex/regcomp.c.html#L1591" title="regex/regcomp.c:1591">INF</a>, and not NAN.<br/></li>
<li></span><span class="Comment"> *-----------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>float8<br/></li>
<li><a id="L5519">&#x200c;</a><span class="linkable">pg_hypot</span>(float8 x, float8 y)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; yx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Handle <a href="../../regex/regcomp.c.html#L1591" title="regex/regcomp.c:1591">INF</a> and NaN properly */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isinf(x) || isinf(y))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> get_float8_infinity();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isnan(x) || isnan(y))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> get_float8_nan();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Else, drop <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> minus signs */<br/></li>
<li></span>&nbsp; &nbsp; x = fabs(x);<br/></li>
<li>&nbsp; &nbsp; y = fabs(y);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Swap x and y if needed to make x the larger one */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (x &lt; y)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; temp = x;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; x = y;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; y = temp;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If y is zero, the hypotenuse is x.&nbsp; This test saves a few cycles in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * such cases, but more importantly it also protects against<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * divide-by-zero errors, since <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> x &gt;= y.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (y == <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> x;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Determine the hypotenuse */<br/></li>
<li></span>&nbsp; &nbsp; yx = y / x;<br/></li>
<li>&nbsp; &nbsp; result = x * sqrt(<span class="Constant">1.0</span> + (yx * yx));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(isinf(result)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="float.c.html#L79" title="utils/adt/float.c:79">float_overflow_error</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(result == <span class="Constant">0.0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="float.c.html#L87" title="utils/adt/float.c:87">float_underflow_error</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
