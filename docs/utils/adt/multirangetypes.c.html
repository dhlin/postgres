<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/adt/multirangetypes.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/adt/multirangetypes.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L49">MultirangeIOData</a></li>
<li><a href="#L54">MultirangeIOData</a></li>
<li><a href="#L65">MultirangeParseState</a></li>
<li><a href="#L85">multirange_bsearch_comparison</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L1658">elem_contained_by_multirange</a></li>
<li><a href="#L416">get_multirange_io_data</a></li>
<li><a href="#L2787">hash_multirange</a></li>
<li><a href="#L2858">hash_multirange_extended</a></li>
<li><a href="#L848">make_empty_multirange</a></li>
<li><a href="#L646">make_multirange</a></li>
<li><a href="#L2534">multirange_adjacent_multirange</a></li>
<li><a href="#L2519">multirange_adjacent_range</a></li>
<li><a href="#L2389">multirange_after_multirange</a></li>
<li><a href="#L2377">multirange_after_range</a></li>
<li><a href="#L1412">multirange_agg_transfn</a></li>
<li><a href="#L2352">multirange_before_multirange</a></li>
<li><a href="#L2424">multirange_before_multirange_internal</a></li>
<li><a href="#L2340">multirange_before_range</a></li>
<li><a href="#L898">multirange_bsearch_match</a></li>
<li><a href="#L477">multirange_canonicalize</a></li>
<li><a href="#L2575">multirange_cmp</a></li>
<li><a href="#L1059">multirange_constructor0</a></li>
<li><a href="#L1023">multirange_constructor1</a></li>
<li><a href="#L941">multirange_constructor2</a></li>
<li><a href="#L2251">multirange_contained_by_multirange</a></li>
<li><a href="#L1758">multirange_contained_by_range</a></li>
<li><a href="#L1645">multirange_contains_elem</a></li>
<li><a href="#L1707">multirange_contains_elem_internal</a></li>
<li><a href="#L2238">multirange_contains_multirange</a></li>
<li><a href="#L2266">multirange_contains_multirange_internal</a></li>
<li><a href="#L1721">multirange_contains_range</a></li>
<li><a href="#L1801">multirange_contains_range_internal</a></li>
<li><a href="#L826">multirange_deserialize</a></li>
<li><a href="#L1674">multirange_elem_bsearch_comparison</a></li>
<li><a href="#L1556">multirange_empty</a></li>
<li><a href="#L1901">multirange_eq</a></li>
<li><a href="#L1864">multirange_eq_internal</a></li>
<li><a href="#L2656">multirange_ge</a></li>
<li><a href="#L744">multirange_get_bounds</a></li>
<li><a href="#L673">multirange_get_bounds_offset</a></li>
<li><a href="#L695">multirange_get_range</a></li>
<li><a href="#L548">multirange_get_typcache</a></li>
<li><a href="#L802">multirange_get_union_range</a></li>
<li><a href="#L2664">multirange_gt</a></li>
<li><a href="#L117">multirange_in</a></li>
<li><a href="#L1230">multirange_intersect</a></li>
<li><a href="#L1465">multirange_intersect_agg_transfn</a></li>
<li><a href="#L1260">multirange_intersect_internal</a></li>
<li><a href="#L2648">multirange_le</a></li>
<li><a href="#L1507">multirange_lower</a></li>
<li><a href="#L1565">multirange_lower_inc</a></li>
<li><a href="#L1603">multirange_lower_inf</a></li>
<li><a href="#L2640">multirange_lt</a></li>
<li><a href="#L1114">multirange_minus</a></li>
<li><a href="#L1144">multirange_minus_internal</a></li>
<li><a href="#L1923">multirange_ne</a></li>
<li><a href="#L1914">multirange_ne_internal</a></li>
<li><a href="#L299">multirange_out</a></li>
<li><a href="#L1960">multirange_overlaps_multirange</a></li>
<li><a href="#L2015">multirange_overlaps_multirange_internal</a></li>
<li><a href="#L1948">multirange_overlaps_range</a></li>
<li><a href="#L2133">multirange_overleft_multirange</a></li>
<li><a href="#L2108">multirange_overleft_range</a></li>
<li><a href="#L2215">multirange_overright_multirange</a></li>
<li><a href="#L2191">multirange_overright_range</a></li>
<li><a href="#L1774">multirange_range_contains_bsearch_comparison</a></li>
<li><a href="#L1976">multirange_range_overlaps_bsearch_comparison</a></li>
<li><a href="#L337">multirange_recv</a></li>
<li><a href="#L377">multirange_send</a></li>
<li><a href="#L569">multirange_size_estimate</a></li>
<li><a href="#L1082">multirange_union</a></li>
<li><a href="#L2713">multirange_unnest</a></li>
<li><a href="#L1530">multirange_upper</a></li>
<li><a href="#L1584">multirange_upper_inc</a></li>
<li><a href="#L1622">multirange_upper_inf</a></li>
<li><a href="#L2507">range_adjacent_multirange</a></li>
<li><a href="#L2471">range_adjacent_multirange_internal</a></li>
<li><a href="#L2365">range_after_multirange</a></li>
<li><a href="#L2446">range_after_multirange_internal</a></li>
<li><a href="#L1372">range_agg_finalfn</a></li>
<li><a href="#L1340">range_agg_transfn</a></li>
<li><a href="#L2328">range_before_multirange</a></li>
<li><a href="#L2402">range_before_multirange_internal</a></li>
<li><a href="#L878">range_bounds_contains</a></li>
<li><a href="#L858">range_bounds_overlaps</a></li>
<li><a href="#L1746">range_contained_by_multirange</a></li>
<li><a href="#L1733">range_contains_multirange</a></li>
<li><a href="#L1829">range_contains_multirange_internal</a></li>
<li><a href="#L2675">range_merge_from_multirange</a></li>
<li><a href="#L1936">range_overlaps_multirange</a></li>
<li><a href="#L1993">range_overlaps_multirange_internal</a></li>
<li><a href="#L2096">range_overleft_multirange</a></li>
<li><a href="#L2073">range_overleft_multirange_internal</a></li>
<li><a href="#L2179">range_overright_multirange</a></li>
<li><a href="#L2158">range_overright_multirange_internal</a></li>
<li><a href="#L596">write_multirange_data</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L81">MULTIRANGE_ITEM_GET_OFFLEN</a></li>
<li><a href="#L82">MULTIRANGE_ITEM_HAS_OFF</a></li>
<li><a href="#L83">MULTIRANGE_ITEM_OFFSET_STRIDE</a></li>
<li><a href="#L80">MULTIRANGE_ITEM_OFF_BIT</a></li>
<li><a href="#L75">MultirangeGetBoundariesPtr</a></li>
<li><a href="#L73">MultirangeGetFlagsPtr</a></li>
<li><a href="#L71">MultirangeGetItemsPtr</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * multirangetypes.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; I/O <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, operators, and support <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for multirange types.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The stored (serialized) format of a multirange value is:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; 12 bytes: MultirangeType struct including varlena header, multirange<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type's OID and the number of ranges in the multirange.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; 4 * (rangesCount - 1) bytes: 32-<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> items pointing to the each <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; in the multirange starting from<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; the second one.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; 1 * rangesCount bytes : 8-<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> flags for each <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> in the multirange<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; The rest of the multirange are <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> bound <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> pointed by multirange<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; items.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Majority of items contain lengths of corresponding <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> bound <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Thanks to that items are typically low numbers.&nbsp; This makes multiranges<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; compression-friendly.&nbsp; Every <a href="#L83" title="utils/adt/multirangetypes.c:83">MULTIRANGE_ITEM_OFFSET_STRIDE</a> item contains<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; an offset of the corresponding <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> bound <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.&nbsp; That allows fast lookups<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; for a particular <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> index.&nbsp; Offsets are counted starting from the end of<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; flags aligned to the bound type.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/adt/multirangetypes.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/tupmacs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/hashfn.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;funcapi.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lib/stringinfo.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/pqformat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/nodes.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;port/pg_bitutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/array.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/multirangetypes.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rangetypes.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* fn_extra cache entry for one of the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> I/O <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li><a id="L49">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">MultirangeIOData</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;&nbsp; &nbsp; <span class="Comment">/* multirange type's typcache entry */<br/></li>
<li></span>&nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; typioproc;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> type's I/O proc */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typioparam;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> type's I/O parameter */<br/></li>
<li><a id="L54">&#x200c;</a></span>} <span class="linkable">MultirangeIOData</span>;<br/></li>
<li><br/></li>
<li><span class="Type">typedef</span> <span class="Type">enum<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; MULTIRANGE_BEFORE_RANGE,<br/></li>
<li>&nbsp; &nbsp; MULTIRANGE_IN_RANGE,<br/></li>
<li>&nbsp; &nbsp; MULTIRANGE_IN_RANGE_ESCAPED,<br/></li>
<li>&nbsp; &nbsp; MULTIRANGE_IN_RANGE_QUOTED,<br/></li>
<li>&nbsp; &nbsp; MULTIRANGE_IN_RANGE_QUOTED_ESCAPED,<br/></li>
<li>&nbsp; &nbsp; MULTIRANGE_AFTER_RANGE,<br/></li>
<li>&nbsp; &nbsp; MULTIRANGE_FINISHED,<br/></li>
<li><a id="L65">&#x200c;</a>} <span class="linkable">MultirangeParseState</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Macros for accessing past MultirangeType parts of multirange: items, flags<br/></li>
<li></span><span class="Comment"> * and boundaries.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L71">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MultirangeGetItemsPtr</span>(mr) ((uint32 *) ((Pointer) (mr) + \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(MultirangeType)))<br/></li>
<li><a id="L73">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MultirangeGetFlagsPtr</span>(mr) ((uint8 *) ((Pointer) (mr) + \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(MultirangeType) + ((mr)-&gt;rangeCount - </span><span class="Constant">1</span><span class="PreProc">) * </span><span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(uint32)))<br/></li>
<li><a id="L75">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MultirangeGetBoundariesPtr</span>(mr, align) ((Pointer) (mr) + \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; att_align_nominal(</span><span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(MultirangeType) + \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; ((mr)-&gt;rangeCount - </span><span class="Constant">1</span><span class="PreProc">) * </span><span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(uint32) + \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; (mr)-&gt;rangeCount * </span><span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(uint8), (align)))<br/></li>
<li></span><br/></li>
<li><a id="L80">&#x200c;</a><span class="PreProc">#define <span class="linkable">MULTIRANGE_ITEM_OFF_BIT</span> </span><span class="Constant">0x80000000<br/></li>
<li><a id="L81">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MULTIRANGE_ITEM_GET_OFFLEN</span>(item) ((item) &amp; </span><span class="Constant">0x7FFFFFFF</span><span class="PreProc">)<br/></li>
<li><a id="L82">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MULTIRANGE_ITEM_HAS_OFF</span>(item) ((item) &amp; <a href="#L80" title="utils/adt/multirangetypes.c:80">MULTIRANGE_ITEM_OFF_BIT</a>)<br/></li>
<li><a id="L83">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MULTIRANGE_ITEM_OFFSET_STRIDE</span> </span><span class="Constant">4<br/></li>
<li></span><br/></li>
<li><a id="L85">&#x200c;</a><span class="Type">typedef</span> <span class="Type">int</span> (*<span class="linkable">multirange_bsearch_comparison</span>) (TypeCacheEntry *typcache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeBound *<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeBound *<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span> *key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *match);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <a href="#L49" title="utils/adt/multirangetypes.c:49">MultirangeIOData</a> *<a href="#L416" title="utils/adt/multirangetypes.c:416">get_multirange_io_data</a>(FunctionCallInfo fcinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid mltrngtypid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IOFuncSelector func);<br/></li>
<li><span class="Type">static</span> int32 <a href="#L477" title="utils/adt/multirangetypes.c:477">multirange_canonicalize</a>(TypeCacheEntry *rangetyp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; int32 input_range_count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RangeType **ranges);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *----------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * I/O FUNCTIONS<br/></li>
<li></span><span class="Comment"> *----------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Converts string to multirange.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We expect curly brackets to bound the list, with zero or more ranges<br/></li>
<li></span><span class="Comment"> * separated by commas.&nbsp; We <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> whitespace anywhere: <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>/after our<br/></li>
<li></span><span class="Comment"> * brackets and around the commas.&nbsp; <a href="../../access/brin/brin_minmax_multi.c.html#L170" title="access/brin/brin_minmax_multi.c:170">Ranges</a> can be the empty literal or some<br/></li>
<li></span><span class="Comment"> * stuff inside parens/brackets.&nbsp; Mostly we delegate parsing the individual<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> contents to <a href="rangetypes.c.html#L88" title="utils/adt/rangetypes.c:88">range_in</a>, but we have to detect quoting and<br/></li>
<li></span><span class="Comment"> * backslash-escaping which can happen for <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> bounds.&nbsp; Backslashes can<br/></li>
<li></span><span class="Comment"> * escape something inside or outside a quoted string, and a quoted string<br/></li>
<li></span><span class="Comment"> * can escape quote marks with either backslashes or double double-quotes.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L117">&#x200c;</a><span class="linkable">multirange_in</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *input_str = PG_GETARG_CSTRING(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mltrngtypoid = PG_GETARG_OID(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typmod = PG_GETARG_INT32(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *escontext = fcinfo-&gt;context;<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *rangetyp;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; ranges_seen = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; range_count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; range_capacity = <span class="Constant">8</span>;<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>;<br/></li>
<li>&nbsp; &nbsp; RangeType **ranges = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(range_capacity * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RangeType *));<br/></li>
<li>&nbsp; &nbsp; <a href="#L49" title="utils/adt/multirangetypes.c:49">MultirangeIOData</a> *cache;<br/></li>
<li>&nbsp; &nbsp; MultirangeType *ret;<br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="utils/adt/multirangetypes.c:65">MultirangeParseState</a> parse_state;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *ptr = input_str;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *range_str_begin = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; range_str_len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *range_str;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; range_datum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cache = <a href="#L416" title="utils/adt/multirangetypes.c:416">get_multirange_io_data</a>(fcinfo, mltrngtypoid, IOFunc_input);<br/></li>
<li>&nbsp; &nbsp; rangetyp = cache-&gt;typcache-&gt;rngtype;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* consume whitespace */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (*ptr != <span class="Special">'\0'</span> &amp;&amp; isspace((<span class="Type">unsigned</span> <span class="Type">char</span>) *ptr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*ptr == <span class="Constant">'{'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr++;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;malformed multirange literal: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; input_str),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Missing left brace.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* consume ranges */<br/></li>
<li></span>&nbsp; &nbsp; parse_state = MULTIRANGE_BEFORE_RANGE;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (; parse_state != MULTIRANGE_FINISHED; ptr++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; ch = *ptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ch == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;malformed multirange literal: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; input_str),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Unexpected end of input.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> whitespace */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isspace((<span class="Type">unsigned</span> <span class="Type">char</span>) ch))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (parse_state)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> MULTIRANGE_BEFORE_RANGE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ch == <span class="Constant">'['</span> || ch == <span class="Constant">'('</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; range_str_begin = ptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parse_state = MULTIRANGE_IN_RANGE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (ch == <span class="Constant">'}'</span> &amp;&amp; ranges_seen == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parse_state = MULTIRANGE_FINISHED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (pg_strncasecmp(ptr, RANGE_EMPTY_LITERAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strlen(RANGE_EMPTY_LITERAL)) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ranges_seen++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nothing to do with an empty <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr += strlen(RANGE_EMPTY_LITERAL) - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parse_state = MULTIRANGE_AFTER_RANGE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;malformed multirange literal: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; input_str),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Expected <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> start.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> MULTIRANGE_IN_RANGE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ch == <span class="Constant">']'</span> || ch == <span class="Constant">')'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; range_str_len = ptr - range_str_begin + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; range_str = <a href="../mmgr/mcxt.c.html#L1706" title="utils/mmgr/mcxt.c:1706">pnstrdup</a>(range_str_begin, range_str_len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (range_capacity == range_count)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; range_capacity *= <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ranges = (RangeType **)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(ranges, range_capacity * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RangeType *));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ranges_seen++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../fmgr/fmgr.c.html#L1585" title="utils/fmgr/fmgr.c:1585">InputFunctionCallSafe</a>(&amp;cache-&gt;typioproc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; range_str,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cache-&gt;typioparam,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; escontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;range_datum))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> = DatumGetRangeTypeP(range_datum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!RangeIsEmpty(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ranges[range_count++] = <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parse_state = MULTIRANGE_AFTER_RANGE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ch == <span class="Constant">'&quot;'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parse_state = MULTIRANGE_IN_RANGE_QUOTED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (ch == <span class="Special">'\\'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parse_state = MULTIRANGE_IN_RANGE_ESCAPED;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We will include this character into range_str once we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the end of the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> MULTIRANGE_IN_RANGE_ESCAPED:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We will include this character into range_str once we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the end of the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parse_state = MULTIRANGE_IN_RANGE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> MULTIRANGE_IN_RANGE_QUOTED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ch == <span class="Constant">'&quot;'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*(ptr + <span class="Constant">1</span>) == <span class="Constant">'&quot;'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* two quote marks means an escaped quote mark */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parse_state = MULTIRANGE_IN_RANGE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (ch == <span class="Special">'\\'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parse_state = MULTIRANGE_IN_RANGE_QUOTED_ESCAPED;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We will include this character into range_str once we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the end of the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> MULTIRANGE_AFTER_RANGE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ch == <span class="Constant">','</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parse_state = MULTIRANGE_BEFORE_RANGE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (ch == <span class="Constant">'}'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parse_state = MULTIRANGE_FINISHED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;malformed multirange literal: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; input_str),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Expected comma or end of multirange.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> MULTIRANGE_IN_RANGE_QUOTED_ESCAPED:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We will include this character into range_str once we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the end of the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parse_state = MULTIRANGE_IN_RANGE_QUOTED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unknown <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> state: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, parse_state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* consume whitespace */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (*ptr != <span class="Special">'\0'</span> &amp;&amp; isspace((<span class="Type">unsigned</span> <span class="Type">char</span>) *ptr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*ptr != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;malformed multirange literal: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; input_str),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Junk after closing right brace.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ret = <a href="#L646" title="utils/adt/multirangetypes.c:646">make_multirange</a>(mltrngtypoid, rangetyp, range_count, ranges);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_MULTIRANGE_P(ret);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L299">&#x200c;</a><span class="linkable">multirange_out</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultirangeType *multirange = PG_GETARG_MULTIRANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mltrngtypoid = MultirangeTypeGetOid(multirange);<br/></li>
<li>&nbsp; &nbsp; <a href="#L49" title="utils/adt/multirangetypes.c:49">MultirangeIOData</a> *cache;<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *rangeStr;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; range_count;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; RangeType **ranges;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cache = <a href="#L416" title="utils/adt/multirangetypes.c:416">get_multirange_io_data</a>(fcinfo, mltrngtypoid, IOFunc_output);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfoChar(&amp;buf, <span class="Constant">'{'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L826" title="utils/adt/multirangetypes.c:826">multirange_deserialize</a>(cache-&gt;typcache-&gt;rngtype, multirange, &amp;range_count, &amp;ranges);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; range_count; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(&amp;buf, <span class="Constant">','</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> = ranges[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rangeStr = <a href="../fmgr/fmgr.c.html#L1683" title="utils/fmgr/fmgr.c:1683">OutputFunctionCall</a>(&amp;cache-&gt;typioproc, RangeTypePGetDatum(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;buf, rangeStr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfoChar(&amp;buf, <span class="Constant">'}'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CSTRING(buf.data);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Binary representation: First an int32-sized count of ranges, followed by<br/></li>
<li></span><span class="Comment"> * ranges in their native binary representation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L337">&#x200c;</a><span class="linkable">multirange_recv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; buf = (StringInfo) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mltrngtypoid = PG_GETARG_OID(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; typmod = PG_GETARG_INT32(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L49" title="utils/adt/multirangetypes.c:49">MultirangeIOData</a> *cache;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; range_count;<br/></li>
<li>&nbsp; &nbsp; RangeType **ranges;<br/></li>
<li>&nbsp; &nbsp; MultirangeType *ret;<br/></li>
<li>&nbsp; &nbsp; StringInfoData <a href="../../replication/walsender.c.html#L170" title="replication/walsender.c:170">tmpbuf</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cache = <a href="#L416" title="utils/adt/multirangetypes.c:416">get_multirange_io_data</a>(fcinfo, mltrngtypoid, IOFunc_receive);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; range_count = <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(buf, <span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; ranges = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(range_count * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RangeType *));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;<a href="../../replication/walsender.c.html#L170" title="replication/walsender.c:170">tmpbuf</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; range_count; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; range_len = <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(buf, <span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *range_data = <a href="../../libpq/pqformat.c.html#L508" title="libpq/pqformat.c:508">pq_getmsgbytes</a>(buf, range_len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; resetStringInfo(&amp;<a href="../../replication/walsender.c.html#L170" title="replication/walsender.c:170">tmpbuf</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendBinaryStringInfo(&amp;<a href="../../replication/walsender.c.html#L170" title="replication/walsender.c:170">tmpbuf</a>, range_data, range_len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ranges[i] = DatumGetRangeTypeP(<a href="../fmgr/fmgr.c.html#L1697" title="utils/fmgr/fmgr.c:1697">ReceiveFunctionCall</a>(&amp;cache-&gt;typioproc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;<a href="../../replication/walsender.c.html#L170" title="replication/walsender.c:170">tmpbuf</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cache-&gt;typioparam,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typmod));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(<a href="../../replication/walsender.c.html#L170" title="replication/walsender.c:170">tmpbuf</a>.data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L635" title="libpq/pqformat.c:635">pq_getmsgend</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ret = <a href="#L646" title="utils/adt/multirangetypes.c:646">make_multirange</a>(mltrngtypoid, cache-&gt;typcache-&gt;rngtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; range_count, ranges);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_MULTIRANGE_P(ret);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L377">&#x200c;</a><span class="linkable">multirange_send</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultirangeType *multirange = PG_GETARG_MULTIRANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mltrngtypoid = MultirangeTypeGetOid(multirange);<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; buf = makeStringInfo();<br/></li>
<li>&nbsp; &nbsp; RangeType **ranges;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; range_count;<br/></li>
<li>&nbsp; &nbsp; <a href="#L49" title="utils/adt/multirangetypes.c:49">MultirangeIOData</a> *cache;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cache = <a href="#L416" title="utils/adt/multirangetypes.c:416">get_multirange_io_data</a>(fcinfo, mltrngtypoid, IOFunc_send);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* construct output */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L326" title="libpq/pqformat.c:326">pq_begintypsend</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pq_sendint32(buf, multirange-&gt;rangeCount);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L826" title="utils/adt/multirangetypes.c:826">multirange_deserialize</a>(cache-&gt;typcache-&gt;rngtype, multirange, &amp;range_count, &amp;ranges);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; range_count; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> = RangeTypePGetDatum(ranges[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> = PointerGetDatum(<a href="../fmgr/fmgr.c.html#L1744" title="utils/fmgr/fmgr.c:1744">SendFunctionCall</a>(&amp;cache-&gt;typioproc, <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pq_sendint32(buf, VARSIZE(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>) - VARHDRSZ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L126" title="libpq/pqformat.c:126">pq_sendbytes</a>(buf, VARDATA(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>), VARSIZE(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>) - VARHDRSZ);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BYTEA_P(<a href="../../libpq/pqformat.c.html#L346" title="libpq/pqformat.c:346">pq_endtypsend</a>(buf));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L416" title="utils/adt/multirangetypes.c:416">get_multirange_io_data</a>: get cached information needed for multirange type I/O<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The multirange I/O <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> need a <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> more cached info than other multirange<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, so they store a <a href="#L49" title="utils/adt/multirangetypes.c:49">MultirangeIOData</a> struct in fn_extra, not just a<br/></li>
<li></span><span class="Comment"> * pointer to a type cache entry.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L49" title="utils/adt/multirangetypes.c:49">MultirangeIOData</a> *<br/></li>
<li><a id="L416">&#x200c;</a><span class="linkable">get_multirange_io_data</span>(FunctionCallInfo fcinfo, Oid mltrngtypid, IOFuncSelector func)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L49" title="utils/adt/multirangetypes.c:49">MultirangeIOData</a> *cache = (<a href="#L49" title="utils/adt/multirangetypes.c:49">MultirangeIOData</a> *) fcinfo-&gt;flinfo-&gt;fn_extra;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cache == <span class="Constant">NULL</span> || cache-&gt;typcache-&gt;type_id != mltrngtypid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typiofunc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; typlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; typbyval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; typalign;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; typdelim;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cache = (<a href="#L49" title="utils/adt/multirangetypes.c:49">MultirangeIOData</a> *) <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(fcinfo-&gt;flinfo-&gt;fn_mcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L49" title="utils/adt/multirangetypes.c:49">MultirangeIOData</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cache-&gt;typcache = <a href="../cache/typcache.c.html#L346" title="utils/cache/typcache.c:346">lookup_type_cache</a>(mltrngtypid, TYPECACHE_MULTIRANGE_INFO);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cache-&gt;typcache-&gt;rngtype == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;type </span><span class="Special">%u</span><span class="Constant"> is not a multirange type&quot;</span>, mltrngtypid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../cache/lsyscache.c.html#L2325" title="utils/cache/lsyscache.c:2325">get_type_io_data</a> does more than we need, but is convenient */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L2325" title="utils/cache/lsyscache.c:2325">get_type_io_data</a>(cache-&gt;typcache-&gt;rngtype-&gt;type_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; func,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;typlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;typbyval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;typalign,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;typdelim,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;cache-&gt;typioparam,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;typiofunc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(typiofunc))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* this could only happen for receive or <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (func == IOFunc_receive)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;no binary input function available for type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(cache-&gt;typcache-&gt;rngtype-&gt;type_id))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;no binary output function available for type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(cache-&gt;typcache-&gt;rngtype-&gt;type_id))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../fmgr/fmgr.c.html#L137" title="utils/fmgr/fmgr.c:137">fmgr_info_cxt</a>(typiofunc, &amp;cache-&gt;typioproc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;flinfo-&gt;fn_mcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;flinfo-&gt;fn_extra = (<span class="Type">void</span> *) cache;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> cache;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Converts a list of arbitrary ranges into a list that is sorted and merged.<br/></li>
<li></span><span class="Comment"> * Changes the contents of `ranges`.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the number of slots actually used, which may be less than<br/></li>
<li></span><span class="Comment"> * input_range_count but never more.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We assume that no input ranges are null, but empties are okay.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> int32<br/></li>
<li><a id="L477">&#x200c;</a><span class="linkable">multirange_canonicalize</span>(TypeCacheEntry *rangetyp, int32 input_range_count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeType **ranges)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *lastRange = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *currentRange;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; output_range_count = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Sort the ranges so we can <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the ones that overlap/meet. */<br/></li>
<li></span>&nbsp; &nbsp; qsort_arg(ranges, input_range_count, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RangeType *), <a href="rangetypes.c.html#L2129" title="utils/adt/rangetypes.c:2129">range_compare</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rangetyp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> where possible: */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; input_range_count; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; currentRange = ranges[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RangeIsEmpty(currentRange))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lastRange == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ranges[output_range_count++] = lastRange = currentRange;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="rangetypes.c.html#L798" title="utils/adt/rangetypes.c:798">range_adjacent_internal</a> gives true if *either* A meets B or B meets<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * A, which is not quite want we want, but we rely on the sorting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * above to rule out B meets A ever happening.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="rangetypes.c.html#L798" title="utils/adt/rangetypes.c:798">range_adjacent_internal</a>(rangetyp, lastRange, currentRange))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The two ranges touch (without overlap), so <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> them: */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ranges[output_range_count - <span class="Constant">1</span>] = lastRange =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="rangetypes.c.html#L1052" title="utils/adt/rangetypes.c:1052">range_union_internal</a>(rangetyp, lastRange, currentRange, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="rangetypes.c.html#L664" title="utils/adt/rangetypes.c:664">range_before_internal</a>(rangetyp, lastRange, currentRange))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* There's a gap, so make a new entry: */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lastRange = ranges[output_range_count] = currentRange;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; output_range_count++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* They must overlap, so <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> them: */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ranges[output_range_count - <span class="Constant">1</span>] = lastRange =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="rangetypes.c.html#L1052" title="utils/adt/rangetypes.c:1052">range_union_internal</a>(rangetyp, lastRange, currentRange, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> output_range_count;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *----------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * SUPPORT FUNCTIONS<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; These <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> aren't in pg_proc, but are useful for<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; defining new generic multirange <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> in C.<br/></li>
<li></span><span class="Comment"> *----------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L548" title="utils/adt/multirangetypes.c:548">multirange_get_typcache</a>: get cached information about a multirange type<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is for use by multirange-related <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> that follow the convention<br/></li>
<li></span><span class="Comment"> * of using the fn_extra field as a pointer to the type cache entry for<br/></li>
<li></span><span class="Comment"> * the multirange type.&nbsp; Functions that need to cache more information than<br/></li>
<li></span><span class="Comment"> * that must fend for themselves.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TypeCacheEntry *<br/></li>
<li><a id="L548">&#x200c;</a><span class="linkable">multirange_get_typcache</span>(FunctionCallInfo fcinfo, Oid mltrngtypid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo-&gt;flinfo-&gt;fn_extra;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (typcache == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typcache-&gt;type_id != mltrngtypid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typcache = <a href="../cache/typcache.c.html#L346" title="utils/cache/typcache.c:346">lookup_type_cache</a>(mltrngtypid, TYPECACHE_MULTIRANGE_INFO);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typcache-&gt;rngtype == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;type </span><span class="Special">%u</span><span class="Constant"> is not a multirange type&quot;</span>, mltrngtypid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;flinfo-&gt;fn_extra = (<span class="Type">void</span> *) typcache;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> typcache;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Estimate size occupied by serialized multirange.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Size<br/></li>
<li><a id="L569">&#x200c;</a><span class="linkable">multirange_size_estimate</span>(TypeCacheEntry *rangetyp, int32 range_count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RangeType **ranges)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; elemalign = rangetyp-&gt;rngelemtype-&gt;typalign;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Count space for MultirangeType struct, items and flags.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; size = att_align_nominal(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(MultirangeType) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Max(range_count - <span class="Constant">1</span>, <span class="Constant">0</span>) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; range_count * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint8), elemalign);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Count space for <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> bounds */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; range_count; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; size += att_align_nominal(VARSIZE(ranges[i]) -<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RangeType) -<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">char</span>), elemalign);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> size;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write multirange data into pre-allocated space.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L596">&#x200c;</a></span><span class="linkable">write_multirange_data</span>(MultirangeType *multirange, TypeCacheEntry *rangetyp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int32 range_count, RangeType **ranges)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp;&nbsp; *items;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; prev_offset = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp;&nbsp; *flags;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; Pointer&nbsp; &nbsp; &nbsp; &nbsp; begin,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; elemalign = rangetyp-&gt;rngelemtype-&gt;typalign;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; items = <a href="#L71" title="utils/adt/multirangetypes.c:71">MultirangeGetItemsPtr</a>(multirange);<br/></li>
<li>&nbsp; &nbsp; flags = <a href="#L73" title="utils/adt/multirangetypes.c:73">MultirangeGetFlagsPtr</a>(multirange);<br/></li>
<li>&nbsp; &nbsp; ptr = begin = <a href="#L75" title="utils/adt/multirangetypes.c:75">MultirangeGetBoundariesPtr</a>(multirange, elemalign);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; range_count; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Every <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, except the first one, has an item.&nbsp; Every<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L83" title="utils/adt/multirangetypes.c:83">MULTIRANGE_ITEM_OFFSET_STRIDE</a> item contains an offset, others<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * contain lengths.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; items[i - <span class="Constant">1</span>] = ptr - begin;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((i % <a href="#L83" title="utils/adt/multirangetypes.c:83">MULTIRANGE_ITEM_OFFSET_STRIDE</a>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; items[i - <span class="Constant">1</span>] -= prev_offset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; items[i - <span class="Constant">1</span>] |= <a href="#L80" title="utils/adt/multirangetypes.c:80">MULTIRANGE_ITEM_OFF_BIT</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prev_offset = ptr - begin;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; flags[i] = *((Pointer) ranges[i] + VARSIZE(ranges[i]) - <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">char</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len = VARSIZE(ranges[i]) - <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RangeType) - <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">char</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(ptr, (Pointer) (ranges[i] + <span class="Constant">1</span>), len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr += att_align_nominal(len, elemalign);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This serializes the multirange from a list of non-null ranges.&nbsp; It also<br/></li>
<li></span><span class="Comment"> * sorts the ranges and merges <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> that touch.&nbsp; The ranges should already be<br/></li>
<li></span><span class="Comment"> * detoasted, and there should be no NULLs.&nbsp; This should be used by most<br/></li>
<li></span><span class="Comment"> * callers.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that we may change the `ranges` parameter (the pointers, but not<br/></li>
<li></span><span class="Comment"> * <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> already-existing RangeType contents).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>MultirangeType *<br/></li>
<li><a id="L646">&#x200c;</a><span class="linkable">make_multirange</span>(Oid mltrngtypoid, TypeCacheEntry *rangetyp, int32 range_count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeType **ranges)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultirangeType *multirange;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Sort and <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> input ranges. */<br/></li>
<li></span>&nbsp; &nbsp; range_count = <a href="#L477" title="utils/adt/multirangetypes.c:477">multirange_canonicalize</a>(rangetyp, range_count, ranges);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Note: zero-fill is required here, just as in heap tuples */<br/></li>
<li></span>&nbsp; &nbsp; size = <a href="#L569" title="utils/adt/multirangetypes.c:569">multirange_size_estimate</a>(rangetyp, range_count, ranges);<br/></li>
<li>&nbsp; &nbsp; multirange = <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(size);<br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(multirange, size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now fill in the datum */<br/></li>
<li></span>&nbsp; &nbsp; multirange-&gt;multirangetypid = mltrngtypoid;<br/></li>
<li>&nbsp; &nbsp; multirange-&gt;rangeCount = range_count;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L596" title="utils/adt/multirangetypes.c:596">write_multirange_data</a>(multirange, rangetyp, range_count, ranges);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> multirange;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get offset of bounds <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of the i'th <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> in the multirange.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> uint32<br/></li>
<li><a id="L673">&#x200c;</a><span class="linkable">multirange_get_bounds_offset</span>(<span class="Type">const</span> MultirangeType *multirange, int32 i)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp;&nbsp; *items = <a href="#L71" title="utils/adt/multirangetypes.c:71">MultirangeGetItemsPtr</a>(multirange);<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; offset = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Summarize lengths till we meet an offset.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (i &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; offset += <a href="#L81" title="utils/adt/multirangetypes.c:81">MULTIRANGE_ITEM_GET_OFFLEN</a>(items[i - <span class="Constant">1</span>]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L82" title="utils/adt/multirangetypes.c:82">MULTIRANGE_ITEM_HAS_OFF</a>(items[i - <span class="Constant">1</span>]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i--;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> offset;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Fetch the i'th <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> from the multirange.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>RangeType *<br/></li>
<li><a id="L695">&#x200c;</a><span class="linkable">multirange_get_range</span>(TypeCacheEntry *rangetyp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> MultirangeType *multirange, <span class="Type">int</span> i)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; offset;<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; flags;<br/></li>
<li>&nbsp; &nbsp; Pointer&nbsp; &nbsp; &nbsp; &nbsp; begin,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr;<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; typlen = rangetyp-&gt;rngelemtype-&gt;typlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; typalign = rangetyp-&gt;rngelemtype-&gt;typalign;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(i &lt; multirange-&gt;rangeCount);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; offset = <a href="#L673" title="utils/adt/multirangetypes.c:673">multirange_get_bounds_offset</a>(multirange, i);<br/></li>
<li>&nbsp; &nbsp; flags = <a href="#L73" title="utils/adt/multirangetypes.c:73">MultirangeGetFlagsPtr</a>(multirange)[i];<br/></li>
<li>&nbsp; &nbsp; ptr = begin = <a href="#L75" title="utils/adt/multirangetypes.c:75">MultirangeGetBoundariesPtr</a>(multirange, typalign) + offset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Calculate the size of bound <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.&nbsp; In principle, we could get offset<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> bound <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> and calculate accordingly.&nbsp; But <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bound <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are aligned, so we have to walk the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to get the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exact size.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RANGE_HAS_LBOUND(flags))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (RANGE_HAS_UBOUND(flags))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; len = (ptr - begin) + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RangeType) + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint8);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> = <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(len);<br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, len);<br/></li>
<li>&nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;rangetypid = rangetyp-&gt;type_id;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memcpy(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> + <span class="Constant">1</span>, begin, ptr - begin);<br/></li>
<li>&nbsp; &nbsp; *((uint8 *) (<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> + <span class="Constant">1</span>) + (ptr - begin)) = flags;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Fetch bounds from the i'th <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of the multirange.&nbsp; This is the shortcut for<br/></li>
<li></span><span class="Comment"> * doing the same thing as <a href="#L695" title="utils/adt/multirangetypes.c:695">multirange_get_range</a>() + <a href="rangetypes.c.html#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(), but<br/></li>
<li></span><span class="Comment"> * performing fewer operations.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L744">&#x200c;</a></span><span class="linkable">multirange_get_bounds</span>(TypeCacheEntry *rangetyp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> MultirangeType *multirange,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32 i, RangeBound *<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, RangeBound *<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; offset;<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; flags;<br/></li>
<li>&nbsp; &nbsp; Pointer&nbsp; &nbsp; &nbsp; &nbsp; ptr;<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; typlen = rangetyp-&gt;rngelemtype-&gt;typlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; typalign = rangetyp-&gt;rngelemtype-&gt;typalign;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; typbyval = rangetyp-&gt;rngelemtype-&gt;typbyval;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; lbound;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; ubound;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(i &lt; multirange-&gt;rangeCount);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; offset = <a href="#L673" title="utils/adt/multirangetypes.c:673">multirange_get_bounds_offset</a>(multirange, i);<br/></li>
<li>&nbsp; &nbsp; flags = <a href="#L73" title="utils/adt/multirangetypes.c:73">MultirangeGetFlagsPtr</a>(multirange)[i];<br/></li>
<li>&nbsp; &nbsp; ptr = <a href="#L75" title="utils/adt/multirangetypes.c:75">MultirangeGetBoundariesPtr</a>(multirange, typalign) + offset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* multirange can't contain empty ranges */<br/></li>
<li></span>&nbsp; &nbsp; Assert((flags &amp; RANGE_EMPTY) == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fetch <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound, if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RANGE_HAS_LBOUND(flags))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* att_align_pointer cannot be necessary here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; lbound = fetch_att(ptr, typbyval, typlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; lbound = (Datum) <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fetch <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound, if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RANGE_HAS_UBOUND(flags))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ubound = fetch_att(ptr, typbyval, typlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no need for att_addlength_pointer */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ubound = (Datum) <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* emit results */<br/></li>
<li></span>&nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-&gt;val = lbound;<br/></li>
<li>&nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-&gt;infinite = (flags &amp; RANGE_LB_INF) != <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-&gt;inclusive = (flags &amp; RANGE_LB_INC) != <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-&gt;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-&gt;val = ubound;<br/></li>
<li>&nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-&gt;infinite = (flags &amp; RANGE_UB_INF) != <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-&gt;inclusive = (flags &amp; RANGE_UB_INC) != <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-&gt;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> = <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Construct union <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> from the multirange.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>RangeType *<br/></li>
<li><a id="L802">&#x200c;</a><span class="linkable">multirange_get_union_range</span>(TypeCacheEntry *rangetyp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> MultirangeType *mr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (MultirangeIsEmpty(mr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="rangetypes.c.html#L2165" title="utils/adt/rangetypes.c:2165">make_empty_range</a>(rangetyp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L744" title="utils/adt/multirangetypes.c:744">multirange_get_bounds</a>(rangetyp, mr, <span class="Constant">0</span>, &amp;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, &amp;tmp);<br/></li>
<li>&nbsp; &nbsp; <a href="#L744" title="utils/adt/multirangetypes.c:744">multirange_get_bounds</a>(rangetyp, mr, mr-&gt;rangeCount - <span class="Constant">1</span>, &amp;tmp, &amp;<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="rangetypes.c.html#L1952" title="utils/adt/rangetypes.c:1952">make_range</a>(rangetyp, &amp;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, &amp;<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>, <span class="Constant">false</span>, <span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L826" title="utils/adt/multirangetypes.c:826">multirange_deserialize</a>: deconstruct a multirange value<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: the given multirange object must be fully detoasted; it cannot have a<br/></li>
<li></span><span class="Comment"> * short varlena header.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L826">&#x200c;</a></span><span class="linkable">multirange_deserialize</span>(TypeCacheEntry *rangetyp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> MultirangeType *multirange, int32 *range_count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RangeType ***ranges)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; *range_count = multirange-&gt;rangeCount;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Convert each ShortRangeType into a RangeType */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (*range_count &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *ranges = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(*range_count * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RangeType *));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; *range_count; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (*ranges)[i] = <a href="#L695" title="utils/adt/multirangetypes.c:695">multirange_get_range</a>(rangetyp, multirange, i);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *ranges = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>MultirangeType *<br/></li>
<li><a id="L848">&#x200c;</a><span class="linkable">make_empty_multirange</span>(Oid mltrngtypoid, TypeCacheEntry *rangetyp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L646" title="utils/adt/multirangetypes.c:646">make_multirange</a>(mltrngtypoid, rangetyp, <span class="Constant">0</span>, <span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Similar to <a href="rangetypes.c.html#L841" title="utils/adt/rangetypes.c:841">range_overlaps_internal</a>(), but takes <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> bounds instead of<br/></li>
<li></span><span class="Comment"> * ranges as arguments.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L858">&#x200c;</a></span><span class="linkable">range_bounds_overlaps</span>(TypeCacheEntry *typcache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeBound *lower1, RangeBound *upper1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeBound *lower2, RangeBound *upper2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="rangetypes.c.html#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache, lower1, lower2) &gt;= <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="rangetypes.c.html#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache, lower1, upper2) &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="rangetypes.c.html#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache, lower2, lower1) &gt;= <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="rangetypes.c.html#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache, lower2, upper1) &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Similar to <a href="rangetypes.c.html#L2586" title="utils/adt/rangetypes.c:2586">range_contains_internal</a>(), but takes <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> bounds instead of<br/></li>
<li></span><span class="Comment"> * ranges as arguments.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L878">&#x200c;</a></span><span class="linkable">range_bounds_contains</span>(TypeCacheEntry *typcache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeBound *lower1, RangeBound *upper1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeBound *lower2, RangeBound *upper2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="rangetypes.c.html#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache, lower1, lower2) &lt;= <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="rangetypes.c.html#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache, upper1, upper2) &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check if the given key matches <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> in multirange using binary search.<br/></li>
<li></span><span class="Comment"> * If the required <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> isn't found, that counts as a mismatch.&nbsp; When the<br/></li>
<li></span><span class="Comment"> * required <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> is found, the comparison function can still report this as<br/></li>
<li></span><span class="Comment"> * either match or mismatch.&nbsp; For instance, if we search for containment, we can<br/></li>
<li></span><span class="Comment"> * found a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, which is overlapping but not containing the key <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, and<br/></li>
<li></span><span class="Comment"> * that would count as a mismatch.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L898">&#x200c;</a></span><span class="linkable">multirange_bsearch_match</span>(TypeCacheEntry *typcache, <span class="Type">const</span> MultirangeType *mr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">void</span> *key, <a href="#L85" title="utils/adt/multirangetypes.c:85">multirange_bsearch_comparison</a> cmp_func)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; l,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; u,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idx;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; comparison;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; match = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; l = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; u = mr-&gt;rangeCount;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (l &lt; u)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeBound&nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; idx = (l + u) / <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L744" title="utils/adt/multirangetypes.c:744">multirange_get_bounds</a>(typcache, mr, idx, &amp;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, &amp;<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; comparison = (*cmp_func) (typcache, &amp;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, &amp;<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>, key, &amp;match);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (comparison &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; u = idx;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (comparison &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l = idx + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> match;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *----------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * GENERIC FUNCTIONS<br/></li>
<li></span><span class="Comment"> *----------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Construct multirange value from zero or more ranges.&nbsp; Since this is a<br/></li>
<li></span><span class="Comment"> * variadic function we get passed an array.&nbsp; The array must contain ranges<br/></li>
<li></span><span class="Comment"> * that match our return value, and there must be no NULLs.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L941">&#x200c;</a><span class="linkable">multirange_constructor2</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mltrngtypid = <a href="../fmgr/fmgr.c.html#L1888" title="utils/fmgr/fmgr.c:1888">get_fn_expr_rettype</a>(fcinfo-&gt;flinfo);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rngtypid;<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *rangetyp;<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *rangeArray;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; range_count;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *elements;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *nulls;<br/></li>
<li>&nbsp; &nbsp; RangeType **ranges;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dims;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L548" title="utils/adt/multirangetypes.c:548">multirange_get_typcache</a>(fcinfo, mltrngtypid);<br/></li>
<li>&nbsp; &nbsp; rangetyp = typcache-&gt;rngtype;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * A no-arg invocation should call <a href="#L1059" title="utils/adt/multirangetypes.c:1059">multirange_constructor0</a> instead, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * returning an empty <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> is what that does.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PG_NARGS() == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_MULTIRANGE_P(<a href="#L646" title="utils/adt/multirangetypes.c:646">make_multirange</a>(mltrngtypid, rangetyp, <span class="Constant">0</span>, <span class="Constant">NULL</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This check should be guaranteed by our signature, but let's do it just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PG_ARGISNULL(<span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;multirange <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> cannot contain null members&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rangeArray = PG_GETARG_ARRAYTYPE_P(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dims = ARR_NDIM(rangeArray);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dims &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_CARDINALITY_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;multiranges cannot be constructed from multidimensional arrays&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rngtypid = ARR_ELEMTYPE(rangeArray);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rngtypid != rangetyp-&gt;type_id)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;type </span><span class="Special">%u</span><span class="Constant"> does not match constructor type&quot;</span>, rngtypid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Be careful: we can still be called with zero ranges, like this:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * `int4multirange(variadic '{}'::int4range[])<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (dims == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; range_count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ranges = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="arrayfuncs.c.html#L3612" title="utils/adt/arrayfuncs.c:3612">deconstruct_array</a>(rangeArray, rngtypid, rangetyp-&gt;typlen, rangetyp-&gt;typbyval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rangetyp-&gt;typalign, &amp;elements, &amp;nulls, &amp;range_count);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ranges = <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(range_count * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RangeType *));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; range_count; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nulls[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NULL_VALUE_NOT_ALLOWED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;multirange <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> cannot contain null members&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L646" title="utils/adt/multirangetypes.c:646">make_multirange</a> will do its own copy */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ranges[i] = DatumGetRangeTypeP(elements[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_MULTIRANGE_P(<a href="#L646" title="utils/adt/multirangetypes.c:646">make_multirange</a>(mltrngtypid, rangetyp, range_count, ranges));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Construct multirange value from a single <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.&nbsp; It'd be nice if we could<br/></li>
<li></span><span class="Comment"> * just use <a href="#L941" title="utils/adt/multirangetypes.c:941">multirange_constructor2</a> for this case, but we need a non-variadic<br/></li>
<li></span><span class="Comment"> * single-arg function to let us define a CAST from a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> to its multirange.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1023">&#x200c;</a><span class="linkable">multirange_constructor1</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mltrngtypid = <a href="../fmgr/fmgr.c.html#L1888" title="utils/fmgr/fmgr.c:1888">get_fn_expr_rettype</a>(fcinfo-&gt;flinfo);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rngtypid;<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *rangetyp;<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L548" title="utils/adt/multirangetypes.c:548">multirange_get_typcache</a>(fcinfo, mltrngtypid);<br/></li>
<li>&nbsp; &nbsp; rangetyp = typcache-&gt;rngtype;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This check should be guaranteed by our signature, but let's do it just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PG_ARGISNULL(<span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;multirange <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> cannot contain null members&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> = PG_GETARG_RANGE_P(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> type matches. */<br/></li>
<li></span>&nbsp; &nbsp; rngtypid = RangeTypeGetOid(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rngtypid != rangetyp-&gt;type_id)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;type </span><span class="Special">%u</span><span class="Constant"> does not match constructor type&quot;</span>, rngtypid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_MULTIRANGE_P(<a href="#L646" title="utils/adt/multirangetypes.c:646">make_multirange</a>(mltrngtypid, rangetyp, <span class="Constant">1</span>, &amp;<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Constructor just like <a href="#L1023" title="utils/adt/multirangetypes.c:1023">multirange_constructor1</a>, but opr_sanity gets angry<br/></li>
<li></span><span class="Comment"> * if the same <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> function handles multiple <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> with different arg<br/></li>
<li></span><span class="Comment"> * counts.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1059">&#x200c;</a><span class="linkable">multirange_constructor0</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mltrngtypid;<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *rangetyp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This should always be called without arguments */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PG_NARGS() != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;niladic multirange constructor must not receive arguments&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; mltrngtypid = <a href="../fmgr/fmgr.c.html#L1888" title="utils/fmgr/fmgr.c:1888">get_fn_expr_rettype</a>(fcinfo-&gt;flinfo);<br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L548" title="utils/adt/multirangetypes.c:548">multirange_get_typcache</a>(fcinfo, mltrngtypid);<br/></li>
<li>&nbsp; &nbsp; rangetyp = typcache-&gt;rngtype;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_MULTIRANGE_P(<a href="#L646" title="utils/adt/multirangetypes.c:646">make_multirange</a>(mltrngtypid, rangetyp, <span class="Constant">0</span>, <span class="Constant">NULL</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* multirange, multirange -&gt; multirange type <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* multirange union */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1082">&#x200c;</a><span class="linkable">multirange_union</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultirangeType *mr1 = PG_GETARG_MULTIRANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; MultirangeType *mr2 = PG_GETARG_MULTIRANGE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; range_count1;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; range_count2;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; range_count3;<br/></li>
<li>&nbsp; &nbsp; RangeType **ranges1;<br/></li>
<li>&nbsp; &nbsp; RangeType **ranges2;<br/></li>
<li>&nbsp; &nbsp; RangeType **ranges3;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (MultirangeIsEmpty(mr1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_MULTIRANGE_P(mr2);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (MultirangeIsEmpty(mr2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_MULTIRANGE_P(mr1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L548" title="utils/adt/multirangetypes.c:548">multirange_get_typcache</a>(fcinfo, MultirangeTypeGetOid(mr1));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L826" title="utils/adt/multirangetypes.c:826">multirange_deserialize</a>(typcache-&gt;rngtype, mr1, &amp;range_count1, &amp;ranges1);<br/></li>
<li>&nbsp; &nbsp; <a href="#L826" title="utils/adt/multirangetypes.c:826">multirange_deserialize</a>(typcache-&gt;rngtype, mr2, &amp;range_count2, &amp;ranges2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; range_count3 = range_count1 + range_count2;<br/></li>
<li>&nbsp; &nbsp; ranges3 = <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(range_count3 * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RangeType *));<br/></li>
<li>&nbsp; &nbsp; memcpy(ranges3, ranges1, range_count1 * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RangeType *));<br/></li>
<li>&nbsp; &nbsp; memcpy(ranges3 + range_count1, ranges2, range_count2 * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RangeType *));<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_MULTIRANGE_P(<a href="#L646" title="utils/adt/multirangetypes.c:646">make_multirange</a>(typcache-&gt;type_id, typcache-&gt;rngtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; range_count3, ranges3));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* multirange minus */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1114">&#x200c;</a><span class="linkable">multirange_minus</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultirangeType *mr1 = PG_GETARG_MULTIRANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; MultirangeType *mr2 = PG_GETARG_MULTIRANGE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mltrngtypoid = MultirangeTypeGetOid(mr1);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *rangetyp;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; range_count1;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; range_count2;<br/></li>
<li>&nbsp; &nbsp; RangeType **ranges1;<br/></li>
<li>&nbsp; &nbsp; RangeType **ranges2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L548" title="utils/adt/multirangetypes.c:548">multirange_get_typcache</a>(fcinfo, mltrngtypoid);<br/></li>
<li>&nbsp; &nbsp; rangetyp = typcache-&gt;rngtype;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (MultirangeIsEmpty(mr1) || MultirangeIsEmpty(mr2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_MULTIRANGE_P(mr1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L826" title="utils/adt/multirangetypes.c:826">multirange_deserialize</a>(typcache-&gt;rngtype, mr1, &amp;range_count1, &amp;ranges1);<br/></li>
<li>&nbsp; &nbsp; <a href="#L826" title="utils/adt/multirangetypes.c:826">multirange_deserialize</a>(typcache-&gt;rngtype, mr2, &amp;range_count2, &amp;ranges2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_MULTIRANGE_P(<a href="#L1144" title="utils/adt/multirangetypes.c:1144">multirange_minus_internal</a>(mltrngtypoid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rangetyp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; range_count1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ranges1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; range_count2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ranges2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>MultirangeType *<br/></li>
<li><a id="L1144">&#x200c;</a><span class="linkable">multirange_minus_internal</span>(Oid mltrngtypoid, TypeCacheEntry *rangetyp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int32 range_count1, RangeType **ranges1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int32 range_count2, RangeType **ranges2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r1;<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r2;<br/></li>
<li>&nbsp; &nbsp; RangeType **ranges3;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; range_count3;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; i1;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; i2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Worst case: every <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> in ranges1 makes a different cut to some <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in ranges2.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ranges3 = <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>((range_count1 + range_count2) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RangeType *));<br/></li>
<li>&nbsp; &nbsp; range_count3 = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For each <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> in mr1, keep subtracting until it's gone or the ranges<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in mr2 have passed it. After a subtraction we assign what's left back<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to r1. The parallel progress through mr1 and mr2 is similar to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L2015" title="utils/adt/multirangetypes.c:2015">multirange_overlaps_multirange_internal</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; r2 = ranges2[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i1 = <span class="Constant">0</span>, i2 = <span class="Constant">0</span>; i1 &lt; range_count1; i1++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; r1 = ranges1[i1];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Discard r2s while r2 &lt;&lt; r1 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (r2 != <span class="Constant">NULL</span> &amp;&amp; <a href="rangetypes.c.html#L664" title="utils/adt/rangetypes.c:664">range_before_internal</a>(rangetyp, r2, r1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r2 = ++i2 &gt;= range_count2 ? <span class="Constant">NULL</span> : ranges2[i2];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (r2 != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="rangetypes.c.html#L1182" title="utils/adt/rangetypes.c:1182">range_split_internal</a>(rangetyp, r1, r2, &amp;ranges3[range_count3], &amp;r1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If r2 takes a bite out of the middle of r1, we need two<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * outputs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; range_count3++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r2 = ++i2 &gt;= range_count2 ? <span class="Constant">NULL</span> : ranges2[i2];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="rangetypes.c.html#L841" title="utils/adt/rangetypes.c:841">range_overlaps_internal</a>(rangetyp, r1, r2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If r2 overlaps r1, replace r1 with r1 - r2.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r1 = <a href="rangetypes.c.html#L993" title="utils/adt/rangetypes.c:993">range_minus_internal</a>(rangetyp, r1, r2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If r2 goes past r1, then we need to stay with it, in case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it hits future r1s. Otherwise we need to keep r1, in case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * future r2s hit it. Since we already subtracted, there's no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * point in using the overright/overleft calls.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RangeIsEmpty(r1) || <a href="rangetypes.c.html#L664" title="utils/adt/rangetypes.c:664">range_before_internal</a>(rangetyp, r1, r2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r2 = ++i2 &gt;= range_count2 ? <span class="Constant">NULL</span> : ranges2[i2];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This and all future r2s are past r1, so keep them. Also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * assign whatever is left of r1 to the result.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Nothing else can remove anything from r1, so keep it. Even if r1 is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * empty here, <a href="#L646" title="utils/adt/multirangetypes.c:646">make_multirange</a> will remove it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ranges3[range_count3++] = r1;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L646" title="utils/adt/multirangetypes.c:646">make_multirange</a>(mltrngtypoid, rangetyp, range_count3, ranges3);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* multirange intersection */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1230">&#x200c;</a><span class="linkable">multirange_intersect</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultirangeType *mr1 = PG_GETARG_MULTIRANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; MultirangeType *mr2 = PG_GETARG_MULTIRANGE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mltrngtypoid = MultirangeTypeGetOid(mr1);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *rangetyp;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; range_count1;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; range_count2;<br/></li>
<li>&nbsp; &nbsp; RangeType **ranges1;<br/></li>
<li>&nbsp; &nbsp; RangeType **ranges2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L548" title="utils/adt/multirangetypes.c:548">multirange_get_typcache</a>(fcinfo, mltrngtypoid);<br/></li>
<li>&nbsp; &nbsp; rangetyp = typcache-&gt;rngtype;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (MultirangeIsEmpty(mr1) || MultirangeIsEmpty(mr2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_MULTIRANGE_P(<a href="#L848" title="utils/adt/multirangetypes.c:848">make_empty_multirange</a>(mltrngtypoid, rangetyp));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L826" title="utils/adt/multirangetypes.c:826">multirange_deserialize</a>(rangetyp, mr1, &amp;range_count1, &amp;ranges1);<br/></li>
<li>&nbsp; &nbsp; <a href="#L826" title="utils/adt/multirangetypes.c:826">multirange_deserialize</a>(rangetyp, mr2, &amp;range_count2, &amp;ranges2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_MULTIRANGE_P(<a href="#L1260" title="utils/adt/multirangetypes.c:1260">multirange_intersect_internal</a>(mltrngtypoid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rangetyp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; range_count1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ranges1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; range_count2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ranges2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>MultirangeType *<br/></li>
<li><a id="L1260">&#x200c;</a><span class="linkable">multirange_intersect_internal</span>(Oid mltrngtypoid, TypeCacheEntry *rangetyp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int32 range_count1, RangeType **ranges1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int32 range_count2, RangeType **ranges2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r1;<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r2;<br/></li>
<li>&nbsp; &nbsp; RangeType **ranges3;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; range_count3;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; i1;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; i2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (range_count1 == <span class="Constant">0</span> || range_count2 == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L646" title="utils/adt/multirangetypes.c:646">make_multirange</a>(mltrngtypoid, rangetyp, <span class="Constant">0</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*-----------------------------------------------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Worst case is a stitching pattern like this:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * mr1: --- --- --- ---<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * mr2:&nbsp;&nbsp; --- --- ---<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * mr3:&nbsp;&nbsp; - - - - - -<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * That seems to be range_count1 + range_count2 - 1,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but one extra won't hurt.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *-----------------------------------------------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ranges3 = <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>((range_count1 + range_count2) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RangeType *));<br/></li>
<li>&nbsp; &nbsp; range_count3 = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For each <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> in mr1, keep intersecting until the ranges in mr2 have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * passed it. The parallel progress through mr1 and mr2 is similar to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * multirange_minus_multirange_internal, but we don't have to assign back<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to r1.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; r2 = ranges2[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i1 = <span class="Constant">0</span>, i2 = <span class="Constant">0</span>; i1 &lt; range_count1; i1++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; r1 = ranges1[i1];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Discard r2s while r2 &lt;&lt; r1 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (r2 != <span class="Constant">NULL</span> &amp;&amp; <a href="rangetypes.c.html#L664" title="utils/adt/rangetypes.c:664">range_before_internal</a>(rangetyp, r2, r1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r2 = ++i2 &gt;= range_count2 ? <span class="Constant">NULL</span> : ranges2[i2];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (r2 != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="rangetypes.c.html#L841" title="utils/adt/rangetypes.c:841">range_overlaps_internal</a>(rangetyp, r1, r2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Keep the overlapping part */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ranges3[range_count3++] = <a href="rangetypes.c.html#L1143" title="utils/adt/rangetypes.c:1143">range_intersect_internal</a>(rangetyp, r1, r2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we &quot;used up&quot; all of r2, go to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> one... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="rangetypes.c.html#L887" title="utils/adt/rangetypes.c:887">range_overleft_internal</a>(rangetyp, r2, r1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r2 = ++i2 &gt;= range_count2 ? <span class="Constant">NULL</span> : ranges2[i2];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ...otherwise go to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> r1 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We're past r1, so move to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> one */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we're out of r2s, there can be no more intersections */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (r2 == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L646" title="utils/adt/multirangetypes.c:646">make_multirange</a>(mltrngtypoid, rangetyp, range_count3, ranges3);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1340" title="utils/adt/multirangetypes.c:1340">range_agg_transfn</a>: <a href="../../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> adjacent/overlapping ranges.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * All we do here is gather the input ranges into an array<br/></li>
<li></span><span class="Comment"> * so that the finalfn can sort and <a href="../../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> them.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1340">&#x200c;</a><span class="linkable">range_agg_transfn</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext aggContext;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rngtypoid;<br/></li>
<li>&nbsp; &nbsp; ArrayBuildState *state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../executor/nodeAgg.c.html#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>(fcinfo, &amp;aggContext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L1340" title="utils/adt/multirangetypes.c:1340">range_agg_transfn</a> called in non-aggregate context&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rngtypoid = <a href="../fmgr/fmgr.c.html#L1910" title="utils/fmgr/fmgr.c:1910">get_fn_expr_argtype</a>(fcinfo-&gt;flinfo, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../cache/lsyscache.c.html#L2688" title="utils/cache/lsyscache.c:2688">type_is_range</a>(rngtypoid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;range_agg must be called with a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PG_ARGISNULL(<span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state = <a href="arrayfuncs.c.html#L5274" title="utils/adt/arrayfuncs.c:5274">initArrayResult</a>(rngtypoid, aggContext, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; state = (ArrayBuildState *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> NULLs */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!PG_ARGISNULL(<span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="arrayfuncs.c.html#L5331" title="utils/adt/arrayfuncs.c:5331">accumArrayResult</a>(state, PG_GETARG_DATUM(<span class="Constant">1</span>), <span class="Constant">false</span>, rngtypoid, aggContext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(state);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1372" title="utils/adt/multirangetypes.c:1372">range_agg_finalfn</a>: use our <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> array to <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> touching ranges.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Shared by <a href="#L1372" title="utils/adt/multirangetypes.c:1372">range_agg_finalfn</a>(<a href="pseudotypes.c.html#L207" title="utils/adt/pseudotypes.c:207">anyrange</a>) and<br/></li>
<li></span><span class="Comment"> * multirange_agg_finalfn(<a href="pseudotypes.c.html#L233" title="utils/adt/pseudotypes.c:233">anymultirange</a>).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1372">&#x200c;</a><span class="linkable">range_agg_finalfn</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext aggContext;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mltrngtypoid;<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li>&nbsp; &nbsp; ArrayBuildState *state;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; range_count;<br/></li>
<li>&nbsp; &nbsp; RangeType **ranges;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../executor/nodeAgg.c.html#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>(fcinfo, &amp;aggContext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L1372" title="utils/adt/multirangetypes.c:1372">range_agg_finalfn</a> called in non-aggregate context&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = PG_ARGISNULL(<span class="Constant">0</span>) ? <span class="Constant">NULL</span> : (ArrayBuildState *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This shouldn't be possible, but just in case.... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Also return NULL if we had zero inputs, like other aggregates */<br/></li>
<li></span>&nbsp; &nbsp; range_count = state-&gt;nelems;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (range_count == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; mltrngtypoid = <a href="../fmgr/fmgr.c.html#L1888" title="utils/fmgr/fmgr.c:1888">get_fn_expr_rettype</a>(fcinfo-&gt;flinfo);<br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L548" title="utils/adt/multirangetypes.c:548">multirange_get_typcache</a>(fcinfo, mltrngtypoid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ranges = <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(range_count * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RangeType *));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; range_count; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ranges[i] = DatumGetRangeTypeP(state-&gt;dvalues[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_MULTIRANGE_P(<a href="#L646" title="utils/adt/multirangetypes.c:646">make_multirange</a>(mltrngtypoid, typcache-&gt;rngtype, range_count, ranges));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1412" title="utils/adt/multirangetypes.c:1412">multirange_agg_transfn</a>: <a href="../../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> adjacent/overlapping multiranges.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * All we do here is gather the input multiranges' ranges into an array so<br/></li>
<li></span><span class="Comment"> * that the finalfn can sort and <a href="../../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> them.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1412">&#x200c;</a><span class="linkable">multirange_agg_transfn</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext aggContext;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mltrngtypoid;<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *rngtypcache;<br/></li>
<li>&nbsp; &nbsp; ArrayBuildState *state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../executor/nodeAgg.c.html#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>(fcinfo, &amp;aggContext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L1412" title="utils/adt/multirangetypes.c:1412">multirange_agg_transfn</a> called in non-aggregate context&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; mltrngtypoid = <a href="../fmgr/fmgr.c.html#L1910" title="utils/fmgr/fmgr.c:1910">get_fn_expr_argtype</a>(fcinfo-&gt;flinfo, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../cache/lsyscache.c.html#L2698" title="utils/cache/lsyscache.c:2698">type_is_multirange</a>(mltrngtypoid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;range_agg must be called with a multirange&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L548" title="utils/adt/multirangetypes.c:548">multirange_get_typcache</a>(fcinfo, mltrngtypoid);<br/></li>
<li>&nbsp; &nbsp; rngtypcache = typcache-&gt;rngtype;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PG_ARGISNULL(<span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state = <a href="arrayfuncs.c.html#L5274" title="utils/adt/arrayfuncs.c:5274">initArrayResult</a>(rngtypcache-&gt;type_id, aggContext, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; state = (ArrayBuildState *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> NULLs */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!PG_ARGISNULL(<span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MultirangeType *current;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; range_count;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeType **ranges;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; current = PG_GETARG_MULTIRANGE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L826" title="utils/adt/multirangetypes.c:826">multirange_deserialize</a>(rngtypcache, current, &amp;range_count, &amp;ranges);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (range_count == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Add an empty <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> so we get an empty result (not a null<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * result).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="arrayfuncs.c.html#L5331" title="utils/adt/arrayfuncs.c:5331">accumArrayResult</a>(state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RangeTypePGetDatum(<a href="rangetypes.c.html#L2165" title="utils/adt/rangetypes.c:2165">make_empty_range</a>(rngtypcache)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>, rngtypcache-&gt;type_id, aggContext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (int32 i = <span class="Constant">0</span>; i &lt; range_count; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="arrayfuncs.c.html#L5331" title="utils/adt/arrayfuncs.c:5331">accumArrayResult</a>(state, RangeTypePGetDatum(ranges[i]), <span class="Constant">false</span>, rngtypcache-&gt;type_id, aggContext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(state);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1465">&#x200c;</a><span class="linkable">multirange_intersect_agg_transfn</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext aggContext;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mltrngtypoid;<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li>&nbsp; &nbsp; MultirangeType *result;<br/></li>
<li>&nbsp; &nbsp; MultirangeType *current;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; range_count1;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; range_count2;<br/></li>
<li>&nbsp; &nbsp; RangeType **ranges1;<br/></li>
<li>&nbsp; &nbsp; RangeType **ranges2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../executor/nodeAgg.c.html#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>(fcinfo, &amp;aggContext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L1465" title="utils/adt/multirangetypes.c:1465">multirange_intersect_agg_transfn</a> called in non-aggregate context&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; mltrngtypoid = <a href="../fmgr/fmgr.c.html#L1910" title="utils/fmgr/fmgr.c:1910">get_fn_expr_argtype</a>(fcinfo-&gt;flinfo, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../cache/lsyscache.c.html#L2698" title="utils/cache/lsyscache.c:2698">type_is_multirange</a>(mltrngtypoid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;range_intersect_agg must be called with a multirange&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L548" title="utils/adt/multirangetypes.c:548">multirange_get_typcache</a>(fcinfo, mltrngtypoid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* strictness ensures these are non-null */<br/></li>
<li></span>&nbsp; &nbsp; result = PG_GETARG_MULTIRANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; current = PG_GETARG_MULTIRANGE_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L826" title="utils/adt/multirangetypes.c:826">multirange_deserialize</a>(typcache-&gt;rngtype, result, &amp;range_count1, &amp;ranges1);<br/></li>
<li>&nbsp; &nbsp; <a href="#L826" title="utils/adt/multirangetypes.c:826">multirange_deserialize</a>(typcache-&gt;rngtype, current, &amp;range_count2, &amp;ranges2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L1260" title="utils/adt/multirangetypes.c:1260">multirange_intersect_internal</a>(mltrngtypoid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typcache-&gt;rngtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; range_count1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ranges1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; range_count2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ranges2);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_MULTIRANGE_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* multirange -&gt; <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* extract <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound value */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1507">&#x200c;</a><span class="linkable">multirange_lower</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultirangeType *mr = PG_GETARG_MULTIRANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (MultirangeIsEmpty(mr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L548" title="utils/adt/multirangetypes.c:548">multirange_get_typcache</a>(fcinfo, MultirangeTypeGetOid(mr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L744" title="utils/adt/multirangetypes.c:744">multirange_get_bounds</a>(typcache-&gt;rngtype, mr, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, &amp;<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.infinite)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_DATUM(<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.val);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* extract <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound value */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1530">&#x200c;</a><span class="linkable">multirange_upper</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultirangeType *mr = PG_GETARG_MULTIRANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (MultirangeIsEmpty(mr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L548" title="utils/adt/multirangetypes.c:548">multirange_get_typcache</a>(fcinfo, MultirangeTypeGetOid(mr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L744" title="utils/adt/multirangetypes.c:744">multirange_get_bounds</a>(typcache-&gt;rngtype, mr, mr-&gt;rangeCount - <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, &amp;<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.infinite)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_DATUM(<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.val);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* multirange -&gt; <a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a> <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* is multirange empty? */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1556">&#x200c;</a><span class="linkable">multirange_empty</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultirangeType *mr = PG_GETARG_MULTIRANGE_P(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(MultirangeIsEmpty(mr));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* is <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound inclusive? */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1565">&#x200c;</a><span class="linkable">multirange_lower_inc</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultirangeType *mr = PG_GETARG_MULTIRANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (MultirangeIsEmpty(mr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L548" title="utils/adt/multirangetypes.c:548">multirange_get_typcache</a>(fcinfo, MultirangeTypeGetOid(mr));<br/></li>
<li>&nbsp; &nbsp; <a href="#L744" title="utils/adt/multirangetypes.c:744">multirange_get_bounds</a>(typcache-&gt;rngtype, mr, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, &amp;<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.inclusive);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* is <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound inclusive? */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1584">&#x200c;</a><span class="linkable">multirange_upper_inc</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultirangeType *mr = PG_GETARG_MULTIRANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (MultirangeIsEmpty(mr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L548" title="utils/adt/multirangetypes.c:548">multirange_get_typcache</a>(fcinfo, MultirangeTypeGetOid(mr));<br/></li>
<li>&nbsp; &nbsp; <a href="#L744" title="utils/adt/multirangetypes.c:744">multirange_get_bounds</a>(typcache-&gt;rngtype, mr, mr-&gt;rangeCount - <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, &amp;<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.inclusive);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* is <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound infinite? */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1603">&#x200c;</a><span class="linkable">multirange_lower_inf</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultirangeType *mr = PG_GETARG_MULTIRANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (MultirangeIsEmpty(mr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L548" title="utils/adt/multirangetypes.c:548">multirange_get_typcache</a>(fcinfo, MultirangeTypeGetOid(mr));<br/></li>
<li>&nbsp; &nbsp; <a href="#L744" title="utils/adt/multirangetypes.c:744">multirange_get_bounds</a>(typcache-&gt;rngtype, mr, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, &amp;<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.infinite);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* is <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound infinite? */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1622">&#x200c;</a><span class="linkable">multirange_upper_inf</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultirangeType *mr = PG_GETARG_MULTIRANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (MultirangeIsEmpty(mr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L548" title="utils/adt/multirangetypes.c:548">multirange_get_typcache</a>(fcinfo, MultirangeTypeGetOid(mr));<br/></li>
<li>&nbsp; &nbsp; <a href="#L744" title="utils/adt/multirangetypes.c:744">multirange_get_bounds</a>(typcache-&gt;rngtype, mr, mr-&gt;rangeCount - <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, &amp;<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.infinite);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* multirange, <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> -&gt; <a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a> <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* contains? */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1645">&#x200c;</a><span class="linkable">multirange_contains_elem</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultirangeType *mr = PG_GETARG_MULTIRANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; val = PG_GETARG_DATUM(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L548" title="utils/adt/multirangetypes.c:548">multirange_get_typcache</a>(fcinfo, MultirangeTypeGetOid(mr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L1707" title="utils/adt/multirangetypes.c:1707">multirange_contains_elem_internal</a>(typcache-&gt;rngtype, mr, val));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* contained by? */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1658">&#x200c;</a><span class="linkable">elem_contained_by_multirange</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; val = PG_GETARG_DATUM(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; MultirangeType *mr = PG_GETARG_MULTIRANGE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L548" title="utils/adt/multirangetypes.c:548">multirange_get_typcache</a>(fcinfo, MultirangeTypeGetOid(mr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L1707" title="utils/adt/multirangetypes.c:1707">multirange_contains_elem_internal</a>(typcache-&gt;rngtype, mr, val));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Comparison function for checking if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of multirange contains given<br/></li>
<li></span><span class="Comment"> * key <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> using binary search.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1674">&#x200c;</a></span><span class="linkable">multirange_elem_bsearch_comparison</span>(TypeCacheEntry *typcache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RangeBound *<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, RangeBound *<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">void</span> *key, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *match)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; val = *((Datum *) key);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-&gt;infinite)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = DatumGetInt32(<a href="../fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(&amp;typcache-&gt;rng_cmp_proc_finfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typcache-&gt;rng_collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-&gt;val, val));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> &gt; <span class="Constant">0</span> || (<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> == <span class="Constant">0</span> &amp;&amp; !<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-&gt;inclusive))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-&gt;infinite)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = DatumGetInt32(<a href="../fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(&amp;typcache-&gt;rng_cmp_proc_finfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typcache-&gt;rng_collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-&gt;val, val));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> &lt; <span class="Constant">0</span> || (<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> == <span class="Constant">0</span> &amp;&amp; !<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-&gt;inclusive))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *match = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Test whether multirange mr contains a specific <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> value.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1707">&#x200c;</a></span><span class="linkable">multirange_contains_elem_internal</span>(TypeCacheEntry *rangetyp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> MultirangeType *mr, Datum val)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (MultirangeIsEmpty(mr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L898" title="utils/adt/multirangetypes.c:898">multirange_bsearch_match</a>(rangetyp, mr, &amp;val,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1674" title="utils/adt/multirangetypes.c:1674">multirange_elem_bsearch_comparison</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* multirange, <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> -&gt; <a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a> <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* contains? */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1721">&#x200c;</a><span class="linkable">multirange_contains_range</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultirangeType *mr = PG_GETARG_MULTIRANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r = PG_GETARG_RANGE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L548" title="utils/adt/multirangetypes.c:548">multirange_get_typcache</a>(fcinfo, MultirangeTypeGetOid(mr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L1801" title="utils/adt/multirangetypes.c:1801">multirange_contains_range_internal</a>(typcache-&gt;rngtype, mr, r));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1733">&#x200c;</a><span class="linkable">range_contains_multirange</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r = PG_GETARG_RANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; MultirangeType *mr = PG_GETARG_MULTIRANGE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L548" title="utils/adt/multirangetypes.c:548">multirange_get_typcache</a>(fcinfo, MultirangeTypeGetOid(mr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L1829" title="utils/adt/multirangetypes.c:1829">range_contains_multirange_internal</a>(typcache-&gt;rngtype, r, mr));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* contained by? */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1746">&#x200c;</a><span class="linkable">range_contained_by_multirange</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r = PG_GETARG_RANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; MultirangeType *mr = PG_GETARG_MULTIRANGE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L548" title="utils/adt/multirangetypes.c:548">multirange_get_typcache</a>(fcinfo, MultirangeTypeGetOid(mr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L1801" title="utils/adt/multirangetypes.c:1801">multirange_contains_range_internal</a>(typcache-&gt;rngtype, mr, r));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1758">&#x200c;</a><span class="linkable">multirange_contained_by_range</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultirangeType *mr = PG_GETARG_MULTIRANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r = PG_GETARG_RANGE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L548" title="utils/adt/multirangetypes.c:548">multirange_get_typcache</a>(fcinfo, MultirangeTypeGetOid(mr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L1829" title="utils/adt/multirangetypes.c:1829">range_contains_multirange_internal</a>(typcache-&gt;rngtype, r, mr));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Comparison function for checking if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of multirange contains given<br/></li>
<li></span><span class="Comment"> * key <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> using binary search.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1774">&#x200c;</a></span><span class="linkable">multirange_range_contains_bsearch_comparison</span>(TypeCacheEntry *typcache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RangeBound *<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, RangeBound *<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">void</span> *key, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *match)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeBound *keyLower = (RangeBound *) key;<br/></li>
<li>&nbsp; &nbsp; RangeBound *keyUpper = (RangeBound *) key + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check if key <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> is strictly in the left or in the right */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="rangetypes.c.html#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache, keyUpper, <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="rangetypes.c.html#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache, keyLower, <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>) &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * At this point we found overlapping <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.&nbsp; But we have to check if it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * really contains the key <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.&nbsp; Anyway, we have to stop our search<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * here, because multirange contains only non-overlapping ranges.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; *match = <a href="#L878" title="utils/adt/multirangetypes.c:878">range_bounds_contains</a>(typcache, <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>, keyLower, keyUpper);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Test whether multirange mr contains a specific <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> r.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1801">&#x200c;</a></span><span class="linkable">multirange_contains_range_internal</span>(TypeCacheEntry *rangetyp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> MultirangeType *mr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> RangeType *r)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; bounds[<span class="Constant">2</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; empty;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Every multirange contains an infinite number of empty ranges, even an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * empty one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RangeIsEmpty(r))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (MultirangeIsEmpty(mr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="rangetypes.c.html#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(rangetyp, r, &amp;bounds[<span class="Constant">0</span>], &amp;bounds[<span class="Constant">1</span>], &amp;empty);<br/></li>
<li>&nbsp; &nbsp; Assert(!empty);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L898" title="utils/adt/multirangetypes.c:898">multirange_bsearch_match</a>(rangetyp, mr, bounds,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1774" title="utils/adt/multirangetypes.c:1774">multirange_range_contains_bsearch_comparison</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Test whether <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> r contains a multirange mr.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1829">&#x200c;</a></span><span class="linkable">range_contains_multirange_internal</span>(TypeCacheEntry *rangetyp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> RangeType *r,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> MultirangeType *mr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; lower1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lower2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; empty;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Every <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> contains an infinite number of empty multiranges, even an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * empty one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (MultirangeIsEmpty(mr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (RangeIsEmpty(r))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="geo_spgist.c.html#L107" title="utils/adt/geo_spgist.c:107">Range</a> contains multirange iff it contains its union <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="rangetypes.c.html#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(rangetyp, r, &amp;lower1, &amp;upper1, &amp;empty);<br/></li>
<li>&nbsp; &nbsp; Assert(!empty);<br/></li>
<li>&nbsp; &nbsp; <a href="#L744" title="utils/adt/multirangetypes.c:744">multirange_get_bounds</a>(rangetyp, mr, <span class="Constant">0</span>, &amp;lower2, &amp;tmp);<br/></li>
<li>&nbsp; &nbsp; <a href="#L744" title="utils/adt/multirangetypes.c:744">multirange_get_bounds</a>(rangetyp, mr, mr-&gt;rangeCount - <span class="Constant">1</span>, &amp;tmp, &amp;upper2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L878" title="utils/adt/multirangetypes.c:878">range_bounds_contains</a>(rangetyp, &amp;lower1, &amp;upper1, &amp;lower2, &amp;upper2);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* multirange, multirange -&gt; <a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a> <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* equality (<a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> version) */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1864">&#x200c;</a></span><span class="linkable">multirange_eq_internal</span>(TypeCacheEntry *rangetyp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> MultirangeType *mr1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> MultirangeType *mr2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; range_count_1;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; range_count_2;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; lower1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lower2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Different types should be prevented by ANYMULTIRANGE matching rules */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (MultirangeTypeGetOid(mr1) != MultirangeTypeGetOid(mr2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;multirange types do not match&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; range_count_1 = mr1-&gt;rangeCount;<br/></li>
<li>&nbsp; &nbsp; range_count_2 = mr2-&gt;rangeCount;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (range_count_1 != range_count_2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; range_count_1; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L744" title="utils/adt/multirangetypes.c:744">multirange_get_bounds</a>(rangetyp, mr1, i, &amp;lower1, &amp;upper1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L744" title="utils/adt/multirangetypes.c:744">multirange_get_bounds</a>(rangetyp, mr2, i, &amp;lower2, &amp;upper2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="rangetypes.c.html#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(rangetyp, &amp;lower1, &amp;lower2) != <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="rangetypes.c.html#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(rangetyp, &amp;upper1, &amp;upper2) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* equality */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1901">&#x200c;</a><span class="linkable">multirange_eq</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultirangeType *mr1 = PG_GETARG_MULTIRANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; MultirangeType *mr2 = PG_GETARG_MULTIRANGE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L548" title="utils/adt/multirangetypes.c:548">multirange_get_typcache</a>(fcinfo, MultirangeTypeGetOid(mr1));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L1864" title="utils/adt/multirangetypes.c:1864">multirange_eq_internal</a>(typcache-&gt;rngtype, mr1, mr2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* inequality (<a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> version) */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1914">&#x200c;</a></span><span class="linkable">multirange_ne_internal</span>(TypeCacheEntry *rangetyp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> MultirangeType *mr1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> MultirangeType *mr2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (!<a href="#L1864" title="utils/adt/multirangetypes.c:1864">multirange_eq_internal</a>(rangetyp, mr1, mr2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* inequality */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1923">&#x200c;</a><span class="linkable">multirange_ne</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultirangeType *mr1 = PG_GETARG_MULTIRANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; MultirangeType *mr2 = PG_GETARG_MULTIRANGE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L548" title="utils/adt/multirangetypes.c:548">multirange_get_typcache</a>(fcinfo, MultirangeTypeGetOid(mr1));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L1914" title="utils/adt/multirangetypes.c:1914">multirange_ne_internal</a>(typcache-&gt;rngtype, mr1, mr2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* overlaps? */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1936">&#x200c;</a><span class="linkable">range_overlaps_multirange</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r = PG_GETARG_RANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; MultirangeType *mr = PG_GETARG_MULTIRANGE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L548" title="utils/adt/multirangetypes.c:548">multirange_get_typcache</a>(fcinfo, MultirangeTypeGetOid(mr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L1993" title="utils/adt/multirangetypes.c:1993">range_overlaps_multirange_internal</a>(typcache-&gt;rngtype, r, mr));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1948">&#x200c;</a><span class="linkable">multirange_overlaps_range</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultirangeType *mr = PG_GETARG_MULTIRANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r = PG_GETARG_RANGE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L548" title="utils/adt/multirangetypes.c:548">multirange_get_typcache</a>(fcinfo, MultirangeTypeGetOid(mr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L1993" title="utils/adt/multirangetypes.c:1993">range_overlaps_multirange_internal</a>(typcache-&gt;rngtype, r, mr));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1960">&#x200c;</a><span class="linkable">multirange_overlaps_multirange</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultirangeType *mr1 = PG_GETARG_MULTIRANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; MultirangeType *mr2 = PG_GETARG_MULTIRANGE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L548" title="utils/adt/multirangetypes.c:548">multirange_get_typcache</a>(fcinfo, MultirangeTypeGetOid(mr1));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2015" title="utils/adt/multirangetypes.c:2015">multirange_overlaps_multirange_internal</a>(typcache-&gt;rngtype, mr1, mr2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Comparison function for checking if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of multirange overlaps given<br/></li>
<li></span><span class="Comment"> * key <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> using binary search.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1976">&#x200c;</a></span><span class="linkable">multirange_range_overlaps_bsearch_comparison</span>(TypeCacheEntry *typcache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RangeBound *<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, RangeBound *<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">void</span> *key, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *match)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeBound *keyLower = (RangeBound *) key;<br/></li>
<li>&nbsp; &nbsp; RangeBound *keyUpper = (RangeBound *) key + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="rangetypes.c.html#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache, keyUpper, <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="rangetypes.c.html#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache, keyLower, <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>) &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *match = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1993">&#x200c;</a></span><span class="linkable">range_overlaps_multirange_internal</span>(TypeCacheEntry *rangetyp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> RangeType *r,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> MultirangeType *mr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; bounds[<span class="Constant">2</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; empty;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Empties never overlap, even with empties. (This seems strange since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * they *do* contain each other, but we want to follow how ranges work.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RangeIsEmpty(r) || MultirangeIsEmpty(mr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="rangetypes.c.html#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(rangetyp, r, &amp;bounds[<span class="Constant">0</span>], &amp;bounds[<span class="Constant">1</span>], &amp;empty);<br/></li>
<li>&nbsp; &nbsp; Assert(!empty);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L898" title="utils/adt/multirangetypes.c:898">multirange_bsearch_match</a>(rangetyp, mr, bounds,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1976" title="utils/adt/multirangetypes.c:1976">multirange_range_overlaps_bsearch_comparison</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2015">&#x200c;</a></span><span class="linkable">multirange_overlaps_multirange_internal</span>(TypeCacheEntry *rangetyp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> MultirangeType *mr1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> MultirangeType *mr2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; range_count1;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; range_count2;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; i1;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; i2;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; lower1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lower2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Empties never overlap, even with empties. (This seems strange since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * they *do* contain each other, but we want to follow how ranges work.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (MultirangeIsEmpty(mr1) || MultirangeIsEmpty(mr2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; range_count1 = mr1-&gt;rangeCount;<br/></li>
<li>&nbsp; &nbsp; range_count2 = mr2-&gt;rangeCount;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Every <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> in mr1 gets a chance to overlap with the ranges in mr2, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we can use their ordering to avoid O(n^2). This is similar to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L1936" title="utils/adt/multirangetypes.c:1936">range_overlaps_multirange</a> where r1 : r2 :: mrr : r, but there if we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> an overlap with r we're done, and here if we don't <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * overlap with r2 we try the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> r2.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; i1 = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L744" title="utils/adt/multirangetypes.c:744">multirange_get_bounds</a>(rangetyp, mr1, i1, &amp;lower1, &amp;upper1);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i1 = <span class="Constant">0</span>, i2 = <span class="Constant">0</span>; i2 &lt; range_count2; i2++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L744" title="utils/adt/multirangetypes.c:744">multirange_get_bounds</a>(rangetyp, mr2, i2, &amp;lower2, &amp;upper2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Discard r1s while r1 &lt;&lt; r2 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (<a href="rangetypes.c.html#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(rangetyp, &amp;upper1, &amp;lower2) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (++i1 &gt;= range_count1)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L744" title="utils/adt/multirangetypes.c:744">multirange_get_bounds</a>(rangetyp, mr1, i1, &amp;lower1, &amp;upper1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If r1 &amp;&amp; r2, we're done, otherwise we failed to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> an overlap for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * r2, so go to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L858" title="utils/adt/multirangetypes.c:858">range_bounds_overlaps</a>(rangetyp, &amp;lower1, &amp;upper1, &amp;lower2, &amp;upper2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We looked through all of mr2 without finding an overlap */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* does not extend to right of? */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2073">&#x200c;</a></span><span class="linkable">range_overleft_multirange_internal</span>(TypeCacheEntry *rangetyp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> RangeType *r,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> MultirangeType *mr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; lower1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lower2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; empty;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (RangeIsEmpty(r) || MultirangeIsEmpty(mr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="rangetypes.c.html#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(rangetyp, r, &amp;lower1, &amp;upper1, &amp;empty);<br/></li>
<li>&nbsp; &nbsp; Assert(!empty);<br/></li>
<li>&nbsp; &nbsp; <a href="#L744" title="utils/adt/multirangetypes.c:744">multirange_get_bounds</a>(rangetyp, mr, mr-&gt;rangeCount - <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;lower2, &amp;upper2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="rangetypes.c.html#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(rangetyp, &amp;upper1, &amp;upper2) &lt;= <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2096">&#x200c;</a><span class="linkable">range_overleft_multirange</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r = PG_GETARG_RANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; MultirangeType *mr = PG_GETARG_MULTIRANGE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L548" title="utils/adt/multirangetypes.c:548">multirange_get_typcache</a>(fcinfo, MultirangeTypeGetOid(mr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2073" title="utils/adt/multirangetypes.c:2073">range_overleft_multirange_internal</a>(typcache-&gt;rngtype, r, mr));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2108">&#x200c;</a><span class="linkable">multirange_overleft_range</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultirangeType *mr = PG_GETARG_MULTIRANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r = PG_GETARG_RANGE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; lower1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lower2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; empty;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (MultirangeIsEmpty(mr) || RangeIsEmpty(r))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L548" title="utils/adt/multirangetypes.c:548">multirange_get_typcache</a>(fcinfo, MultirangeTypeGetOid(mr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L744" title="utils/adt/multirangetypes.c:744">multirange_get_bounds</a>(typcache-&gt;rngtype, mr, mr-&gt;rangeCount - <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;lower1, &amp;upper1);<br/></li>
<li>&nbsp; &nbsp; <a href="rangetypes.c.html#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(typcache-&gt;rngtype, r, &amp;lower2, &amp;upper2, &amp;empty);<br/></li>
<li>&nbsp; &nbsp; Assert(!empty);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="rangetypes.c.html#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache-&gt;rngtype, &amp;upper1, &amp;upper2) &lt;= <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2133">&#x200c;</a><span class="linkable">multirange_overleft_multirange</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultirangeType *mr1 = PG_GETARG_MULTIRANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; MultirangeType *mr2 = PG_GETARG_MULTIRANGE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; lower1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lower2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (MultirangeIsEmpty(mr1) || MultirangeIsEmpty(mr2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L548" title="utils/adt/multirangetypes.c:548">multirange_get_typcache</a>(fcinfo, MultirangeTypeGetOid(mr1));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L744" title="utils/adt/multirangetypes.c:744">multirange_get_bounds</a>(typcache-&gt;rngtype, mr1, mr1-&gt;rangeCount - <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;lower1, &amp;upper1);<br/></li>
<li>&nbsp; &nbsp; <a href="#L744" title="utils/adt/multirangetypes.c:744">multirange_get_bounds</a>(typcache-&gt;rngtype, mr2, mr2-&gt;rangeCount - <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;lower2, &amp;upper2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="rangetypes.c.html#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache-&gt;rngtype, &amp;upper1, &amp;upper2) &lt;= <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* does not extend to left of? */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2158">&#x200c;</a></span><span class="linkable">range_overright_multirange_internal</span>(TypeCacheEntry *rangetyp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> RangeType *r,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> MultirangeType *mr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; lower1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lower2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; empty;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (RangeIsEmpty(r) || MultirangeIsEmpty(mr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="rangetypes.c.html#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(rangetyp, r, &amp;lower1, &amp;upper1, &amp;empty);<br/></li>
<li>&nbsp; &nbsp; Assert(!empty);<br/></li>
<li>&nbsp; &nbsp; <a href="#L744" title="utils/adt/multirangetypes.c:744">multirange_get_bounds</a>(rangetyp, mr, <span class="Constant">0</span>, &amp;lower2, &amp;upper2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (<a href="rangetypes.c.html#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(rangetyp, &amp;lower1, &amp;lower2) &gt;= <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2179">&#x200c;</a><span class="linkable">range_overright_multirange</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r = PG_GETARG_RANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; MultirangeType *mr = PG_GETARG_MULTIRANGE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L548" title="utils/adt/multirangetypes.c:548">multirange_get_typcache</a>(fcinfo, MultirangeTypeGetOid(mr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2158" title="utils/adt/multirangetypes.c:2158">range_overright_multirange_internal</a>(typcache-&gt;rngtype, r, mr));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2191">&#x200c;</a><span class="linkable">multirange_overright_range</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultirangeType *mr = PG_GETARG_MULTIRANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r = PG_GETARG_RANGE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; lower1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lower2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; empty;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (MultirangeIsEmpty(mr) || RangeIsEmpty(r))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L548" title="utils/adt/multirangetypes.c:548">multirange_get_typcache</a>(fcinfo, MultirangeTypeGetOid(mr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L744" title="utils/adt/multirangetypes.c:744">multirange_get_bounds</a>(typcache-&gt;rngtype, mr, <span class="Constant">0</span>, &amp;lower1, &amp;upper1);<br/></li>
<li>&nbsp; &nbsp; <a href="rangetypes.c.html#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(typcache-&gt;rngtype, r, &amp;lower2, &amp;upper2, &amp;empty);<br/></li>
<li>&nbsp; &nbsp; Assert(!empty);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="rangetypes.c.html#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache-&gt;rngtype, &amp;lower1, &amp;lower2) &gt;= <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2215">&#x200c;</a><span class="linkable">multirange_overright_multirange</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultirangeType *mr1 = PG_GETARG_MULTIRANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; MultirangeType *mr2 = PG_GETARG_MULTIRANGE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; lower1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lower2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (MultirangeIsEmpty(mr1) || MultirangeIsEmpty(mr2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L548" title="utils/adt/multirangetypes.c:548">multirange_get_typcache</a>(fcinfo, MultirangeTypeGetOid(mr1));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L744" title="utils/adt/multirangetypes.c:744">multirange_get_bounds</a>(typcache-&gt;rngtype, mr1, <span class="Constant">0</span>, &amp;lower1, &amp;upper1);<br/></li>
<li>&nbsp; &nbsp; <a href="#L744" title="utils/adt/multirangetypes.c:744">multirange_get_bounds</a>(typcache-&gt;rngtype, mr2, <span class="Constant">0</span>, &amp;lower2, &amp;upper2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="rangetypes.c.html#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache-&gt;rngtype, &amp;lower1, &amp;lower2) &gt;= <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* contains? */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2238">&#x200c;</a><span class="linkable">multirange_contains_multirange</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultirangeType *mr1 = PG_GETARG_MULTIRANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; MultirangeType *mr2 = PG_GETARG_MULTIRANGE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L548" title="utils/adt/multirangetypes.c:548">multirange_get_typcache</a>(fcinfo, MultirangeTypeGetOid(mr1));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2266" title="utils/adt/multirangetypes.c:2266">multirange_contains_multirange_internal</a>(typcache-&gt;rngtype, mr1, mr2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* contained by? */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2251">&#x200c;</a><span class="linkable">multirange_contained_by_multirange</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultirangeType *mr1 = PG_GETARG_MULTIRANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; MultirangeType *mr2 = PG_GETARG_MULTIRANGE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L548" title="utils/adt/multirangetypes.c:548">multirange_get_typcache</a>(fcinfo, MultirangeTypeGetOid(mr1));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2266" title="utils/adt/multirangetypes.c:2266">multirange_contains_multirange_internal</a>(typcache-&gt;rngtype, mr2, mr1));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Test whether multirange mr1 contains every <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> from another multirange mr2.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2266">&#x200c;</a></span><span class="linkable">multirange_contains_multirange_internal</span>(TypeCacheEntry *rangetyp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> MultirangeType *mr1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> MultirangeType *mr2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; range_count1 = mr1-&gt;rangeCount;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; range_count2 = mr2-&gt;rangeCount;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i2;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; lower1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lower2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We follow the same logic for empties as ranges: - an empty multirange<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * contains an empty <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>/multirange. - an empty multirange can't contain<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>/multirange. - an empty multirange is contained by <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * other <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>/multirange.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (range_count2 == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (range_count1 == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Every <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> in mr2 must be contained by some <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> in mr1. To avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * O(n^2) we walk through both ranges in tandem.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; i1 = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L744" title="utils/adt/multirangetypes.c:744">multirange_get_bounds</a>(rangetyp, mr1, i1, &amp;lower1, &amp;upper1);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i2 = <span class="Constant">0</span>; i2 &lt; range_count2; i2++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L744" title="utils/adt/multirangetypes.c:744">multirange_get_bounds</a>(rangetyp, mr2, i2, &amp;lower2, &amp;upper2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Discard r1s while r1 &lt;&lt; r2 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (<a href="rangetypes.c.html#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(rangetyp, &amp;upper1, &amp;lower2) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (++i1 &gt;= range_count1)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L744" title="utils/adt/multirangetypes.c:744">multirange_get_bounds</a>(rangetyp, mr1, i1, &amp;lower1, &amp;upper1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If r1 @&gt; r2, go to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> r2, otherwise return false (since every<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * r1[n] and r1[n+1] must have a gap). Note this will give weird<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * answers if you don't canonicalize, e.g. with a custom<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * int2multirange {[1,1], [2,2]} there is a &quot;gap&quot;. But that is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * consistent with other <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> operators, e.g. '[1,1]'::int2range -|-<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * '[2,2]'::int2range is false.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L878" title="utils/adt/multirangetypes.c:878">range_bounds_contains</a>(rangetyp, &amp;lower1, &amp;upper1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;lower2, &amp;upper2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* All ranges in mr2 are satisfied */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* strictly left of? */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2328">&#x200c;</a><span class="linkable">range_before_multirange</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r = PG_GETARG_RANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; MultirangeType *mr = PG_GETARG_MULTIRANGE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L548" title="utils/adt/multirangetypes.c:548">multirange_get_typcache</a>(fcinfo, MultirangeTypeGetOid(mr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2402" title="utils/adt/multirangetypes.c:2402">range_before_multirange_internal</a>(typcache-&gt;rngtype, r, mr));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2340">&#x200c;</a><span class="linkable">multirange_before_range</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultirangeType *mr = PG_GETARG_MULTIRANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r = PG_GETARG_RANGE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L548" title="utils/adt/multirangetypes.c:548">multirange_get_typcache</a>(fcinfo, MultirangeTypeGetOid(mr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2446" title="utils/adt/multirangetypes.c:2446">range_after_multirange_internal</a>(typcache-&gt;rngtype, r, mr));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2352">&#x200c;</a><span class="linkable">multirange_before_multirange</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultirangeType *mr1 = PG_GETARG_MULTIRANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; MultirangeType *mr2 = PG_GETARG_MULTIRANGE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L548" title="utils/adt/multirangetypes.c:548">multirange_get_typcache</a>(fcinfo, MultirangeTypeGetOid(mr1));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2424" title="utils/adt/multirangetypes.c:2424">multirange_before_multirange_internal</a>(typcache-&gt;rngtype, mr1, mr2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* strictly right of? */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2365">&#x200c;</a><span class="linkable">range_after_multirange</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r = PG_GETARG_RANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; MultirangeType *mr = PG_GETARG_MULTIRANGE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L548" title="utils/adt/multirangetypes.c:548">multirange_get_typcache</a>(fcinfo, MultirangeTypeGetOid(mr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2446" title="utils/adt/multirangetypes.c:2446">range_after_multirange_internal</a>(typcache-&gt;rngtype, r, mr));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2377">&#x200c;</a><span class="linkable">multirange_after_range</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultirangeType *mr = PG_GETARG_MULTIRANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r = PG_GETARG_RANGE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L548" title="utils/adt/multirangetypes.c:548">multirange_get_typcache</a>(fcinfo, MultirangeTypeGetOid(mr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2402" title="utils/adt/multirangetypes.c:2402">range_before_multirange_internal</a>(typcache-&gt;rngtype, r, mr));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2389">&#x200c;</a><span class="linkable">multirange_after_multirange</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultirangeType *mr1 = PG_GETARG_MULTIRANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; MultirangeType *mr2 = PG_GETARG_MULTIRANGE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L548" title="utils/adt/multirangetypes.c:548">multirange_get_typcache</a>(fcinfo, MultirangeTypeGetOid(mr1));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2424" title="utils/adt/multirangetypes.c:2424">multirange_before_multirange_internal</a>(typcache-&gt;rngtype, mr2, mr1));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* strictly left of? (<a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> version) */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2402">&#x200c;</a></span><span class="linkable">range_before_multirange_internal</span>(TypeCacheEntry *rangetyp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> RangeType *r,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> MultirangeType *mr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; lower1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lower2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; empty;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (RangeIsEmpty(r) || MultirangeIsEmpty(mr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="rangetypes.c.html#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(rangetyp, r, &amp;lower1, &amp;upper1, &amp;empty);<br/></li>
<li>&nbsp; &nbsp; Assert(!empty);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L744" title="utils/adt/multirangetypes.c:744">multirange_get_bounds</a>(rangetyp, mr, <span class="Constant">0</span>, &amp;lower2, &amp;upper2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (<a href="rangetypes.c.html#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(rangetyp, &amp;upper1, &amp;lower2) &lt; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2424">&#x200c;</a></span><span class="linkable">multirange_before_multirange_internal</span>(TypeCacheEntry *rangetyp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> MultirangeType *mr1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> MultirangeType *mr2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; lower1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lower2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (MultirangeIsEmpty(mr1) || MultirangeIsEmpty(mr2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L744" title="utils/adt/multirangetypes.c:744">multirange_get_bounds</a>(rangetyp, mr1, mr1-&gt;rangeCount - <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;lower1, &amp;upper1);<br/></li>
<li>&nbsp; &nbsp; <a href="#L744" title="utils/adt/multirangetypes.c:744">multirange_get_bounds</a>(rangetyp, mr2, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;lower2, &amp;upper2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (<a href="rangetypes.c.html#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(rangetyp, &amp;upper1, &amp;lower2) &lt; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* strictly right of? (<a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> version) */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2446">&#x200c;</a></span><span class="linkable">range_after_multirange_internal</span>(TypeCacheEntry *rangetyp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> RangeType *r,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> MultirangeType *mr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; lower1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lower2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; empty;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; range_count;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (RangeIsEmpty(r) || MultirangeIsEmpty(mr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="rangetypes.c.html#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(rangetyp, r, &amp;lower1, &amp;upper1, &amp;empty);<br/></li>
<li>&nbsp; &nbsp; Assert(!empty);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; range_count = mr-&gt;rangeCount;<br/></li>
<li>&nbsp; &nbsp; <a href="#L744" title="utils/adt/multirangetypes.c:744">multirange_get_bounds</a>(rangetyp, mr, range_count - <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;lower2, &amp;upper2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (<a href="rangetypes.c.html#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(rangetyp, &amp;lower1, &amp;upper2) &gt; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2471">&#x200c;</a></span><span class="linkable">range_adjacent_multirange_internal</span>(TypeCacheEntry *rangetyp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> RangeType *r,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> MultirangeType *mr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; lower1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lower2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; empty;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; range_count;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (RangeIsEmpty(r) || MultirangeIsEmpty(mr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="rangetypes.c.html#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(rangetyp, r, &amp;lower1, &amp;upper1, &amp;empty);<br/></li>
<li>&nbsp; &nbsp; Assert(!empty);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; range_count = mr-&gt;rangeCount;<br/></li>
<li>&nbsp; &nbsp; <a href="#L744" title="utils/adt/multirangetypes.c:744">multirange_get_bounds</a>(rangetyp, mr, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;lower2, &amp;upper2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="rangetypes.c.html#L757" title="utils/adt/rangetypes.c:757">bounds_adjacent</a>(rangetyp, upper1, lower2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (range_count &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L744" title="utils/adt/multirangetypes.c:744">multirange_get_bounds</a>(rangetyp, mr, range_count - <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;lower2, &amp;upper2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="rangetypes.c.html#L757" title="utils/adt/rangetypes.c:757">bounds_adjacent</a>(rangetyp, upper2, lower1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* adjacent to? */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2507">&#x200c;</a><span class="linkable">range_adjacent_multirange</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r = PG_GETARG_RANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; MultirangeType *mr = PG_GETARG_MULTIRANGE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L548" title="utils/adt/multirangetypes.c:548">multirange_get_typcache</a>(fcinfo, MultirangeTypeGetOid(mr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2471" title="utils/adt/multirangetypes.c:2471">range_adjacent_multirange_internal</a>(typcache-&gt;rngtype, r, mr));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2519">&#x200c;</a><span class="linkable">multirange_adjacent_range</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultirangeType *mr = PG_GETARG_MULTIRANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r = PG_GETARG_RANGE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (RangeIsEmpty(r) || MultirangeIsEmpty(mr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L548" title="utils/adt/multirangetypes.c:548">multirange_get_typcache</a>(fcinfo, MultirangeTypeGetOid(mr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2471" title="utils/adt/multirangetypes.c:2471">range_adjacent_multirange_internal</a>(typcache-&gt;rngtype, r, mr));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2534">&#x200c;</a><span class="linkable">multirange_adjacent_multirange</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultirangeType *mr1 = PG_GETARG_MULTIRANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; MultirangeType *mr2 = PG_GETARG_MULTIRANGE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; range_count1;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; range_count2;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; lower1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lower2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (MultirangeIsEmpty(mr1) || MultirangeIsEmpty(mr2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L548" title="utils/adt/multirangetypes.c:548">multirange_get_typcache</a>(fcinfo, MultirangeTypeGetOid(mr1));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; range_count1 = mr1-&gt;rangeCount;<br/></li>
<li>&nbsp; &nbsp; range_count2 = mr2-&gt;rangeCount;<br/></li>
<li>&nbsp; &nbsp; <a href="#L744" title="utils/adt/multirangetypes.c:744">multirange_get_bounds</a>(typcache-&gt;rngtype, mr1, range_count1 - <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;lower1, &amp;upper1);<br/></li>
<li>&nbsp; &nbsp; <a href="#L744" title="utils/adt/multirangetypes.c:744">multirange_get_bounds</a>(typcache-&gt;rngtype, mr2, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;lower2, &amp;upper2);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="rangetypes.c.html#L757" title="utils/adt/rangetypes.c:757">bounds_adjacent</a>(typcache-&gt;rngtype, upper1, lower2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (range_count1 &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L744" title="utils/adt/multirangetypes.c:744">multirange_get_bounds</a>(typcache-&gt;rngtype, mr1, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;lower1, &amp;upper1);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (range_count2 &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L744" title="utils/adt/multirangetypes.c:744">multirange_get_bounds</a>(typcache-&gt;rngtype, mr2, range_count2 - <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;lower2, &amp;upper2);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="rangetypes.c.html#L757" title="utils/adt/rangetypes.c:757">bounds_adjacent</a>(typcache-&gt;rngtype, upper2, lower1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Btree support */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* btree comparator */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2575">&#x200c;</a><span class="linkable">multirange_cmp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultirangeType *mr1 = PG_GETARG_MULTIRANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; MultirangeType *mr2 = PG_GETARG_MULTIRANGE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; range_count_1;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; range_count_2;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; range_count_max;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If both are empty we'll use this. */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Different types should be prevented by ANYMULTIRANGE matching rules */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (MultirangeTypeGetOid(mr1) != MultirangeTypeGetOid(mr2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;multirange types do not match&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L548" title="utils/adt/multirangetypes.c:548">multirange_get_typcache</a>(fcinfo, MultirangeTypeGetOid(mr1));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; range_count_1 = mr1-&gt;rangeCount;<br/></li>
<li>&nbsp; &nbsp; range_count_2 = mr2-&gt;rangeCount;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Loop over source data */<br/></li>
<li></span>&nbsp; &nbsp; range_count_max = Max(range_count_1, range_count_2);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; range_count_max; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeBound&nbsp; &nbsp; lower1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lower2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If one multirange is shorter, it's as if it had empty ranges at the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * end to extend its length. An empty <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> compares earlier than <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * other <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, so the shorter multirange comes <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the longer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is the same behavior as in other types, e.g. in strings 'aaa'<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * &lt; 'aaaaaa'.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &gt;= range_count_1)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &gt;= range_count_2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L744" title="utils/adt/multirangetypes.c:744">multirange_get_bounds</a>(typcache-&gt;rngtype, mr1, i, &amp;lower1, &amp;upper1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L744" title="utils/adt/multirangetypes.c:744">multirange_get_bounds</a>(typcache-&gt;rngtype, mr2, i, &amp;lower2, &amp;upper2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = <a href="rangetypes.c.html#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache-&gt;rngtype, &amp;lower1, &amp;lower2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = <a href="rangetypes.c.html#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache-&gt;rngtype, &amp;upper1, &amp;upper2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(mr1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(mr2, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* inequality operators using the <a href="#L2575" title="utils/adt/multirangetypes.c:2575">multirange_cmp</a> function */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2640">&#x200c;</a><span class="linkable">multirange_lt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = <a href="#L2575" title="utils/adt/multirangetypes.c:2575">multirange_cmp</a>(fcinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> &lt; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2648">&#x200c;</a><span class="linkable">multirange_le</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = <a href="#L2575" title="utils/adt/multirangetypes.c:2575">multirange_cmp</a>(fcinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> &lt;= <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2656">&#x200c;</a><span class="linkable">multirange_ge</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = <a href="#L2575" title="utils/adt/multirangetypes.c:2575">multirange_cmp</a>(fcinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> &gt;= <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2664">&#x200c;</a><span class="linkable">multirange_gt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = <a href="#L2575" title="utils/adt/multirangetypes.c:2575">multirange_cmp</a>(fcinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> &gt; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* multirange -&gt; <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Find the smallest <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> that includes everything in the multirange */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2675">&#x200c;</a><span class="linkable">range_merge_from_multirange</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultirangeType *mr = PG_GETARG_MULTIRANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mltrngtypoid = MultirangeTypeGetOid(mr);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L548" title="utils/adt/multirangetypes.c:548">multirange_get_typcache</a>(fcinfo, mltrngtypoid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (MultirangeIsEmpty(mr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="rangetypes.c.html#L2165" title="utils/adt/rangetypes.c:2165">make_empty_range</a>(typcache-&gt;rngtype);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (mr-&gt;rangeCount == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L695" title="utils/adt/multirangetypes.c:695">multirange_get_range</a>(typcache-&gt;rngtype, mr, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeBound&nbsp; &nbsp; firstLower,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; firstUpper,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lastLower,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lastUpper;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L744" title="utils/adt/multirangetypes.c:744">multirange_get_bounds</a>(typcache-&gt;rngtype, mr, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;firstLower, &amp;firstUpper);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L744" title="utils/adt/multirangetypes.c:744">multirange_get_bounds</a>(typcache-&gt;rngtype, mr, mr-&gt;rangeCount - <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;lastLower, &amp;lastUpper);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="rangetypes.c.html#L1952" title="utils/adt/rangetypes.c:1952">make_range</a>(typcache-&gt;rngtype, &amp;firstLower, &amp;lastUpper,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_RANGE_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Turn multirange into a set of ranges */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2713">&#x200c;</a><span class="linkable">multirange_unnest</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MultirangeType *mr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index;<br/></li>
<li>&nbsp; &nbsp; } multirange_unnest_fctx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; FuncCallContext *funcctx;<br/></li>
<li>&nbsp; &nbsp; multirange_unnest_fctx *fctx;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* stuff done only on the first call of the function */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (SRF_IS_FIRSTCALL())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MultirangeType *mr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* create a function context for cross-call persistence */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; funcctx = SRF_FIRSTCALL_INIT();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * switch to memory context appropriate for multiple function calls<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(funcctx-&gt;multi_call_memory_ctx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Get the multirange value and detoast if needed.&nbsp; We can't do this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * earlier because if we have to detoast, we want the detoasted copy<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to be in multi_call_memory_ctx, so it will go away when we're done<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and not <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>.&nbsp; (If no detoast happens, we assume the originally<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * passed multirange will stick around till then.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; mr = PG_GETARG_MULTIRANGE_P(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* allocate memory for user context */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; fctx = (multirange_unnest_fctx *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(multirange_unnest_fctx));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> state */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; fctx-&gt;mr = mr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fctx-&gt;index = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fctx-&gt;typcache = <a href="../cache/typcache.c.html#L346" title="utils/cache/typcache.c:346">lookup_type_cache</a>(MultirangeTypeGetOid(mr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TYPECACHE_MULTIRANGE_INFO);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; funcctx-&gt;user_fctx = fctx;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* stuff done on every call of the function */<br/></li>
<li></span>&nbsp; &nbsp; funcctx = SRF_PERCALL_SETUP();<br/></li>
<li>&nbsp; &nbsp; fctx = funcctx-&gt;user_fctx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fctx-&gt;index &lt; fctx-&gt;mr-&gt;rangeCount)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeType&nbsp; *<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> = <a href="#L695" title="utils/adt/multirangetypes.c:695">multirange_get_range</a>(fctx-&gt;typcache-&gt;rngtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fctx-&gt;mr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fctx-&gt;index);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fctx-&gt;index++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SRF_RETURN_NEXT(funcctx, RangeTypePGetDatum(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* do when there is no more left */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; SRF_RETURN_DONE(funcctx);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Hash support */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> a multirange value */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2787">&#x200c;</a><span class="linkable">hash_multirange</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultirangeType *mr = PG_GETARG_MULTIRANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *scache;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; range_count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L548" title="utils/adt/multirangetypes.c:548">multirange_get_typcache</a>(fcinfo, MultirangeTypeGetOid(mr));<br/></li>
<li>&nbsp; &nbsp; scache = typcache-&gt;rngtype-&gt;rngelemtype;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(scache-&gt;hash_proc_finfo.fn_oid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scache = <a href="../cache/typcache.c.html#L346" title="utils/cache/typcache.c:346">lookup_type_cache</a>(scache-&gt;type_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TYPECACHE_HASH_PROC_FINFO);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(scache-&gt;hash_proc_finfo.fn_oid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not identify a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> function for type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(scache-&gt;type_id))));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; range_count = mr-&gt;rangeCount;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; range_count; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeBound&nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; flags = <a href="#L73" title="utils/adt/multirangetypes.c:73">MultirangeGetFlagsPtr</a>(mr)[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; lower_hash;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; upper_hash;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; range_hash;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L744" title="utils/adt/multirangetypes.c:744">multirange_get_bounds</a>(typcache-&gt;rngtype, mr, i, &amp;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, &amp;<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RANGE_HAS_LBOUND(flags))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lower_hash = DatumGetUInt32(<a href="../fmgr/fmgr.c.html#L1129" title="utils/fmgr/fmgr.c:1129">FunctionCall1Coll</a>(&amp;scache-&gt;hash_proc_finfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typcache-&gt;rngtype-&gt;rng_collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.val));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lower_hash = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RANGE_HAS_UBOUND(flags))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper_hash = DatumGetUInt32(<a href="../fmgr/fmgr.c.html#L1129" title="utils/fmgr/fmgr.c:1129">FunctionCall1Coll</a>(&amp;scache-&gt;hash_proc_finfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typcache-&gt;rngtype-&gt;rng_collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.val));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper_hash = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Merge hashes of flags and bounds */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; range_hash = hash_uint32((uint32) flags);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; range_hash ^= lower_hash;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; range_hash = pg_rotate_left32(range_hash, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; range_hash ^= upper_hash;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Use the same approach as <a href="arrayfuncs.c.html#L4139" title="utils/adt/arrayfuncs.c:4139">hash_array</a> to <a href="../../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> the individual<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * elements' <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = (result &lt;&lt; <span class="Constant">5</span>) - result + range_hash;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(mr, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_UINT32(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns 64-<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> value by hashing a value to a 64-<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> value, with a seed.<br/></li>
<li></span><span class="Comment"> * Otherwise, similar to <a href="#L2787" title="utils/adt/multirangetypes.c:2787">hash_multirange</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2858">&#x200c;</a><span class="linkable">hash_multirange_extended</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultirangeType *mr = PG_GETARG_MULTIRANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; seed = PG_GETARG_DATUM(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *scache;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; range_count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L548" title="utils/adt/multirangetypes.c:548">multirange_get_typcache</a>(fcinfo, MultirangeTypeGetOid(mr));<br/></li>
<li>&nbsp; &nbsp; scache = typcache-&gt;rngtype-&gt;rngelemtype;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(scache-&gt;hash_extended_proc_finfo.fn_oid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scache = <a href="../cache/typcache.c.html#L346" title="utils/cache/typcache.c:346">lookup_type_cache</a>(scache-&gt;type_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TYPECACHE_HASH_EXTENDED_PROC_FINFO);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(scache-&gt;hash_extended_proc_finfo.fn_oid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not identify a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> function for type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(scache-&gt;type_id))));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; range_count = mr-&gt;rangeCount;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; range_count; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeBound&nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; flags = <a href="#L73" title="utils/adt/multirangetypes.c:73">MultirangeGetFlagsPtr</a>(mr)[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; lower_hash;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; upper_hash;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; range_hash;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L744" title="utils/adt/multirangetypes.c:744">multirange_get_bounds</a>(typcache-&gt;rngtype, mr, i, &amp;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, &amp;<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RANGE_HAS_LBOUND(flags))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lower_hash = DatumGetUInt64(<a href="../fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(&amp;scache-&gt;hash_extended_proc_finfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typcache-&gt;rngtype-&gt;rng_collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.val,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seed));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lower_hash = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RANGE_HAS_UBOUND(flags))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper_hash = DatumGetUInt64(<a href="../fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(&amp;scache-&gt;hash_extended_proc_finfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typcache-&gt;rngtype-&gt;rng_collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.val,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seed));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper_hash = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Merge hashes of flags and bounds */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; range_hash = DatumGetUInt64(hash_uint32_extended((uint32) flags,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; DatumGetInt64(seed)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; range_hash ^= lower_hash;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; range_hash = ROTATE_HIGH_AND_LOW_32BITS(range_hash);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; range_hash ^= upper_hash;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Use the same approach as <a href="arrayfuncs.c.html#L4139" title="utils/adt/arrayfuncs.c:4139">hash_array</a> to <a href="../../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> the individual<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * elements' <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = (result &lt;&lt; <span class="Constant">5</span>) - result + range_hash;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(mr, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_UINT64(result);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
