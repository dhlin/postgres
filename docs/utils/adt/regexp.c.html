<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/adt/regexp.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/adt/regexp.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L99">RegexpCacheMemoryContext</a></li>
<li><a href="#L112">num_res</a></li>
<li><a href="#L113">re_array</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L102">cached_re_str</a></li>
<li><a href="#L110">cached_re_str</a></li>
<li><a href="#L45">pg_re_flags</a></li>
<li><a href="#L49">pg_re_flags</a></li>
<li><a href="#L52">regexp_matches_ctx</a></li>
<li><a href="#L67">regexp_matches_ctx</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L141">RE_compile_and_cache</a></li>
<li><a href="#L358">RE_compile_and_execute</a></li>
<li><a href="#L324">RE_execute</a></li>
<li><a href="#L282">RE_wchar_execute</a></li>
<li><a href="#L1620">build_regexp_match_result</a></li>
<li><a href="#L1791">build_regexp_split_result</a></li>
<li><a href="#L522">nameicregexeq</a></li>
<li><a href="#L536">nameicregexne</a></li>
<li><a href="#L459">nameregexeq</a></li>
<li><a href="#L473">nameregexne</a></li>
<li><a href="#L385">parse_re_flags</a></li>
<li><a href="#L1066">regexp_count</a></li>
<li><a href="#L1116">regexp_count_no_flags</a></li>
<li><a href="#L1109">regexp_count_no_start</a></li>
<li><a href="#L1953">regexp_fixed_prefix</a></li>
<li><a href="#L1126">regexp_instr</a></li>
<li><a href="#L1233">regexp_instr_no_endoption</a></li>
<li><a href="#L1240">regexp_instr_no_flags</a></li>
<li><a href="#L1226">regexp_instr_no_n</a></li>
<li><a href="#L1219">regexp_instr_no_start</a></li>
<li><a href="#L1247">regexp_instr_no_subexpr</a></li>
<li><a href="#L1257">regexp_like</a></li>
<li><a href="#L1285">regexp_like_no_flags</a></li>
<li><a href="#L1295">regexp_match</a></li>
<li><a href="#L1331">regexp_match_no_flags</a></li>
<li><a href="#L1341">regexp_matches</a></li>
<li><a href="#L1390">regexp_matches_no_flags</a></li>
<li><a href="#L1740">regexp_split_to_array</a></li>
<li><a href="#L1779">regexp_split_to_array_no_flags</a></li>
<li><a href="#L1676">regexp_split_to_table</a></li>
<li><a href="#L1729">regexp_split_to_table_no_flags</a></li>
<li><a href="#L1832">regexp_substr</a></li>
<li><a href="#L1934">regexp_substr_no_flags</a></li>
<li><a href="#L1927">regexp_substr_no_n</a></li>
<li><a href="#L1920">regexp_substr_no_start</a></li>
<li><a href="#L1941">regexp_substr_no_subexpr</a></li>
<li><a href="#L1416">setup_regexp_matches</a></li>
<li><a href="#L1040">similar_escape</a></li>
<li><a href="#L767">similar_escape_internal</a></li>
<li><a href="#L1022">similar_to_escape_1</a></li>
<li><a href="#L1006">similar_to_escape_2</a></li>
<li><a href="#L550">texticregexeq</a></li>
<li><a href="#L564">texticregexne</a></li>
<li><a href="#L487">textregexeq</a></li>
<li><a href="#L501">textregexne</a></li>
<li><a href="#L658">textregexreplace</a></li>
<li><a href="#L699">textregexreplace_extended</a></li>
<li><a href="#L751">textregexreplace_extended_no_flags</a></li>
<li><a href="#L744">textregexreplace_extended_no_n</a></li>
<li><a href="#L642">textregexreplace_noopt</a></li>
<li><a href="#L583">textregexsubstr</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L95">MAX_CACHED_RES</a></li>
<li><a href="#L40">PG_GETARG_TEXT_PP_IF_EXISTS</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * regexp.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Postgres' interface to the regular expression package.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/adt/regexp.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Alistair Crooks added the code for the regex caching<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; agc - cached the regular expressions used - there's a good chance<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; that we'll get a hit, so this saves a compile step for every<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; attempted match. I haven't actually measured the speed improvement,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; but it `looks' a lot quicker visually when watching regression<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; test output.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; agc - incorporated Keith Bostic's Berkeley regex code into<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; the tree for all ports. To distinguish this regex code from <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> that<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; is existent on a platform, I've prepended the string &quot;pg_&quot; to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; the <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> regcomp, regerror, regexec and regfree.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Fixed a bug that was originally a typo by me, where `i' was used<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; instead of `oldest' when compiling regular expressions - benign<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; results mostly, although occasionally it <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> you...<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;funcapi.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;regex/regex.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/array.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/varlena.h&quot;<br/></li>
<li></span><br/></li>
<li><a id="L40">&#x200c;</a><span class="PreProc">#define <span class="linkable">PG_GETARG_TEXT_PP_IF_EXISTS</span>(_n) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (PG_NARGS() &gt; (_n) ? PG_GETARG_TEXT_PP(_n) : </span><span class="Constant">NULL</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* all the options of interest for regex <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li><a id="L45">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">pg_re_flags</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cflags;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* compile flags for Spencer's regex code */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; glob;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* do it globally (for each occurrence) */<br/></li>
<li><a id="L49">&#x200c;</a></span>} <span class="linkable">pg_re_flags</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* cross-call state for <a href="#L1295" title="utils/adt/regexp.c:1295">regexp_match</a> and regexp_split <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li><a id="L52">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">regexp_matches_ctx</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *orig_str;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* data string in original TEXT form */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nmatches;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* number of places where pattern matched */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; npatterns;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* number of capturing subpatterns */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* We store start char index and end+1 char index for each match */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* so the number of entries in match_locs is nmatches * npatterns * 2 */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *match_locs;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* 0-based character indexes */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; next_match;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* 0-based index of <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> match to process */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* workspace for <a href="#L1620" title="utils/adt/regexp.c:1620">build_regexp_match_result</a>() */<br/></li>
<li></span>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *elems;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* has npatterns elements */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *nulls;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* has npatterns elements */<br/></li>
<li></span>&nbsp; &nbsp; pg_wchar&nbsp;&nbsp; *wide_str;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* wide-char version of original string */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *conv_buf;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* conversion buffer, if needed */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; conv_bufsiz;&nbsp; &nbsp; <span class="Comment">/* size thereof */<br/></li>
<li><a id="L67">&#x200c;</a></span>} <span class="linkable">regexp_matches_ctx</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * We cache precompiled regular expressions using a &quot;self organizing list&quot;<br/></li>
<li></span><span class="Comment"> * structure, in which recently-used items tend to be near the front.<br/></li>
<li></span><span class="Comment"> * Whenever we use an entry, it's moved up to the front of the list.<br/></li>
<li></span><span class="Comment"> * Over time, an item's average position corresponds to its frequency of use.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When we first create an entry, it's inserted at the front of<br/></li>
<li></span><span class="Comment"> * the array, dropping the entry at the end of the array if necessary to<br/></li>
<li></span><span class="Comment"> * make room.&nbsp; (This might seem to be weighting the new entry too heavily,<br/></li>
<li></span><span class="Comment"> * but if we insert new entries further back, we'll be unable to adjust to<br/></li>
<li></span><span class="Comment"> * a sudden shift in the query mix where we are presented with <a href="#L95" title="utils/adt/regexp.c:95">MAX_CACHED_RES</a><br/></li>
<li></span><span class="Comment"> * never-<a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>-seen items used circularly.&nbsp; We ought to be able to handle<br/></li>
<li></span><span class="Comment"> * that case, so we have to insert at the front.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Knuth mentions a variant strategy in which a used item is moved up just<br/></li>
<li></span><span class="Comment"> * one place in the list.&nbsp; Although he says this uses fewer comparisons on<br/></li>
<li></span><span class="Comment"> * average, it seems not to adapt very well to the situation where you have<br/></li>
<li></span><span class="Comment"> * both some reusable patterns and a steady stream of non-reusable patterns.<br/></li>
<li></span><span class="Comment"> * A reusable pattern that isn't used at least as often as non-reusable<br/></li>
<li></span><span class="Comment"> * patterns are seen will &quot;fail to keep up&quot; and will drop off the end of the<br/></li>
<li></span><span class="Comment"> * cache.&nbsp; With move-to-front, a reusable pattern is guaranteed to stay in<br/></li>
<li></span><span class="Comment"> * the cache as long as it's used at least once in every <a href="#L95" title="utils/adt/regexp.c:95">MAX_CACHED_RES</a> uses.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* this is the maximum number of cached regular expressions */<br/></li>
<li></span><span class="PreProc">#ifndef <a href="#L95" title="utils/adt/regexp.c:95">MAX_CACHED_RES</a><br/></li>
<li><a id="L95">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MAX_CACHED_RES</span>&nbsp; &nbsp; </span><span class="Constant">32<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* A parent memory context for regular expressions. */<br/></li>
<li><a id="L99">&#x200c;</a></span><span class="Type">static</span> MemoryContext <span class="linkable">RegexpCacheMemoryContext</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* this structure describes one cached regular expression */<br/></li>
<li><a id="L102">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">cached_re_str</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext cre_context;&nbsp; &nbsp; <span class="Comment">/* memory context for this regexp */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *cre_pat;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* original RE (not null terminated!) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cre_pat_len;&nbsp; &nbsp; <span class="Comment">/* length of original RE, in bytes */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cre_flags;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* compile flags: extended,icase etc */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cre_collation;&nbsp; &nbsp; <span class="Comment">/* collation to use */<br/></li>
<li></span>&nbsp; &nbsp; regex_t&nbsp; &nbsp; &nbsp; &nbsp; cre_re;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the compiled regular expression */<br/></li>
<li><a id="L110">&#x200c;</a></span>} <span class="linkable">cached_re_str</span>;<br/></li>
<li><br/></li>
<li><a id="L112">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">num_res</span> = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* # of cached re's */<br/></li>
<li><a id="L113">&#x200c;</a></span><span class="Type">static</span> <a href="#L102" title="utils/adt/regexp.c:102">cached_re_str</a> <span class="linkable">re_array</span>[<a href="#L95" title="utils/adt/regexp.c:95">MAX_CACHED_RES</a>];&nbsp; &nbsp; <span class="Comment">/* cached re's */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* Local <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L52" title="utils/adt/regexp.c:52">regexp_matches_ctx</a> *<a href="#L1416" title="utils/adt/regexp.c:1416">setup_regexp_matches</a>(text *orig_str, text *pattern,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L45" title="utils/adt/regexp.c:45">pg_re_flags</a> *re_flags,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> start_search,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> use_subpatterns,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> ignore_degenerate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> fetching_unmatched);<br/></li>
<li><span class="Type">static</span> ArrayType *<a href="#L1620" title="utils/adt/regexp.c:1620">build_regexp_match_result</a>(<a href="#L52" title="utils/adt/regexp.c:52">regexp_matches_ctx</a> *matchctx);<br/></li>
<li><span class="Type">static</span> Datum <a href="#L1791" title="utils/adt/regexp.c:1791">build_regexp_split_result</a>(<a href="#L52" title="utils/adt/regexp.c:52">regexp_matches_ctx</a> *splitctx);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L141" title="utils/adt/regexp.c:141">RE_compile_and_cache</a> - compile a RE, caching if possible<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns regex_t *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; text_re --- the pattern, expressed as a TEXT object<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; cflags --- compile options for the pattern<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; collation --- collation to use for LC_CTYPE-dependent behavior<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Pattern is given in the database encoding.&nbsp; We internally convert to<br/></li>
<li></span><span class="Comment"> * an array of pg_wchar, which is what Spencer's regex package wants.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>regex_t *<br/></li>
<li><a id="L141">&#x200c;</a><span class="linkable">RE_compile_and_cache</span>(text *text_re, <span class="Type">int</span> cflags, Oid collation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; text_re_len = VARSIZE_ANY_EXHDR(text_re);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *text_re_val = VARDATA_ANY(text_re);<br/></li>
<li>&nbsp; &nbsp; pg_wchar&nbsp;&nbsp; *pattern;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pattern_len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; regcomp_result;<br/></li>
<li>&nbsp; &nbsp; <a href="#L102" title="utils/adt/regexp.c:102">cached_re_str</a> re_temp;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; errMsg[<span class="Constant">100</span>];<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Look for a match among previously compiled REs.&nbsp; Since the data<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * structure is self-organizing with most-used entries at the front, our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * search strategy can just be to scan from the front.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L112" title="utils/adt/regexp.c:112">num_res</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L113" title="utils/adt/regexp.c:113">re_array</a>[i].cre_pat_len == text_re_len &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L113" title="utils/adt/regexp.c:113">re_array</a>[i].cre_flags == cflags &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L113" title="utils/adt/regexp.c:113">re_array</a>[i].cre_collation == collation &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcmp(<a href="#L113" title="utils/adt/regexp.c:113">re_array</a>[i].cre_pat, text_re_val, text_re_len) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Found a match; move it to front if not there already.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; re_temp = <a href="#L113" title="utils/adt/regexp.c:113">re_array</a>[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memmove(&amp;<a href="#L113" title="utils/adt/regexp.c:113">re_array</a>[<span class="Constant">1</span>], &amp;<a href="#L113" title="utils/adt/regexp.c:113">re_array</a>[<span class="Constant">0</span>], i * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L102" title="utils/adt/regexp.c:102">cached_re_str</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L113" title="utils/adt/regexp.c:113">re_array</a>[<span class="Constant">0</span>] = re_temp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> &amp;<a href="#L113" title="utils/adt/regexp.c:113">re_array</a>[<span class="Constant">0</span>].cre_re;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set up the cache memory on first go through. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(<a href="#L99" title="utils/adt/regexp.c:99">RegexpCacheMemoryContext</a> == <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L99" title="utils/adt/regexp.c:99">RegexpCacheMemoryContext</a> =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AllocSetContextCreate(<a href="../mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;<a href="#L99" title="utils/adt/regexp.c:99">RegexpCacheMemoryContext</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_SMALL_SIZES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Couldn't <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> it, so try to compile the new RE.&nbsp; To avoid leaking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * resources on failure, we build into the re_temp local.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Convert pattern string to wide characters */<br/></li>
<li></span>&nbsp; &nbsp; pattern = (pg_wchar *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>((text_re_len + <span class="Constant">1</span>) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(pg_wchar));<br/></li>
<li>&nbsp; &nbsp; pattern_len = <a href="../mb/mbutils.c.html#L986" title="utils/mb/mbutils.c:986">pg_mb2wchar_with_len</a>(text_re_val,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pattern,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; text_re_len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make a memory context for this compiled regexp.&nbsp; This is initially a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * child of the current memory context, so it will be cleaned up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * automatically if compilation is interrupted and throws an ERROR. We'll<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * re-parent it under the longer lived cache context if we make it to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bottom of this function.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; re_temp.cre_context = AllocSetContextCreate(<a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;RegexpMemoryContext&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_SMALL_SIZES);<br/></li>
<li>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(re_temp.cre_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; regcomp_result = <a href="../../regex/regcomp.c.html#L370" title="regex/regcomp.c:370">pg_regcomp</a>(&amp;re_temp.cre_re,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pattern,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pattern_len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cflags,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(pattern);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (regcomp_result != REG_OKAY)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* re didn't compile (no need for <a href="../../regex/regfree.c.html#L49" title="regex/regfree.c:49">pg_regfree</a>, if so) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regerror.c.html#L60" title="regex/regerror.c:60">pg_regerror</a>(regcomp_result, &amp;re_temp.cre_re, errMsg, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(errMsg));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_REGULAR_EXPRESSION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid regular expression: </span><span class="Special">%s</span><span class="Constant">&quot;</span>, errMsg)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Copy the pattern into the per-regexp memory context. */<br/></li>
<li></span>&nbsp; &nbsp; re_temp.cre_pat = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(text_re_len + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; memcpy(re_temp.cre_pat, text_re_val, text_re_len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NUL-terminate it only for the benefit of the identifier used for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * memory context, visible in the pg_backend_memory_contexts view.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; re_temp.cre_pat[text_re_len] = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L612" title="utils/mmgr/mcxt.c:612">MemoryContextSetIdentifier</a>(re_temp.cre_context, re_temp.cre_pat);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; re_temp.cre_pat_len = text_re_len;<br/></li>
<li>&nbsp; &nbsp; re_temp.cre_flags = cflags;<br/></li>
<li>&nbsp; &nbsp; re_temp.cre_collation = collation;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Okay, we have a valid new item in re_temp; insert it into the storage<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * array.&nbsp; Discard last entry if needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L112" title="utils/adt/regexp.c:112">num_res</a> &gt;= <a href="#L95" title="utils/adt/regexp.c:95">MAX_CACHED_RES</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; --<a href="#L112" title="utils/adt/regexp.c:112">num_res</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L112" title="utils/adt/regexp.c:112">num_res</a> &lt; <a href="#L95" title="utils/adt/regexp.c:95">MAX_CACHED_RES</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> the memory context holding the regexp and pattern. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(<a href="#L113" title="utils/adt/regexp.c:113">re_array</a>[<a href="#L112" title="utils/adt/regexp.c:112">num_res</a>].cre_context);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Re-parent the memory context to our long-lived cache context. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L637" title="utils/mmgr/mcxt.c:637">MemoryContextSetParent</a>(re_temp.cre_context, <a href="#L99" title="utils/adt/regexp.c:99">RegexpCacheMemoryContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L112" title="utils/adt/regexp.c:112">num_res</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memmove(&amp;<a href="#L113" title="utils/adt/regexp.c:113">re_array</a>[<span class="Constant">1</span>], &amp;<a href="#L113" title="utils/adt/regexp.c:113">re_array</a>[<span class="Constant">0</span>], <a href="#L112" title="utils/adt/regexp.c:112">num_res</a> * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L102" title="utils/adt/regexp.c:102">cached_re_str</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L113" title="utils/adt/regexp.c:113">re_array</a>[<span class="Constant">0</span>] = re_temp;<br/></li>
<li>&nbsp; &nbsp; <a href="#L112" title="utils/adt/regexp.c:112">num_res</a>++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> &amp;<a href="#L113" title="utils/adt/regexp.c:113">re_array</a>[<span class="Constant">0</span>].cre_re;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L282" title="utils/adt/regexp.c:282">RE_wchar_execute</a> - execute a RE on pg_wchar data<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true on match, false on no match<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; re --- the compiled pattern as returned by <a href="#L141" title="utils/adt/regexp.c:141">RE_compile_and_cache</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; data --- the data to match against (need not be null-terminated)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; data_len --- the length of the data string<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; start_search -- the offset in the data to start searching<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; nmatch, pmatch&nbsp; &nbsp; --- optional return area for match details<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Data is given as array of pg_wchar which is what Spencer's regex package<br/></li>
<li></span><span class="Comment"> * wants.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L282">&#x200c;</a></span><span class="linkable">RE_wchar_execute</span>(regex_t *re, pg_wchar *data, <span class="Type">int</span> data_len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> start_search, <span class="Type">int</span> nmatch, regmatch_t *pmatch)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; regexec_result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; errMsg[<span class="Constant">100</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Perform RE match and return result */<br/></li>
<li></span>&nbsp; &nbsp; regexec_result = <a href="../../regex/regexec.c.html#L185" title="regex/regexec.c:185">pg_regexec</a>(re,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data_len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; start_search,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>,&nbsp; &nbsp; <span class="Comment">/* no details */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nmatch,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pmatch,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (regexec_result != REG_OKAY &amp;&amp; regexec_result != REG_NOMATCH)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* re failed??? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regerror.c.html#L60" title="regex/regerror.c:60">pg_regerror</a>(regexec_result, re, errMsg, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(errMsg));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_REGULAR_EXPRESSION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;regular expression failed: </span><span class="Special">%s</span><span class="Constant">&quot;</span>, errMsg)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (regexec_result == REG_OKAY);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L324" title="utils/adt/regexp.c:324">RE_execute</a> - execute a RE<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true on match, false on no match<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; re --- the compiled pattern as returned by <a href="#L141" title="utils/adt/regexp.c:141">RE_compile_and_cache</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; dat --- the data to match against (need not be null-terminated)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; dat_len --- the length of the data string<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; nmatch, pmatch&nbsp; &nbsp; --- optional return area for match details<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Data is given in the database encoding.&nbsp; We internally<br/></li>
<li></span><span class="Comment"> * convert to array of pg_wchar which is what Spencer's regex package wants.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L324">&#x200c;</a></span><span class="linkable">RE_execute</span>(regex_t *re, <span class="Type">char</span> *dat, <span class="Type">int</span> dat_len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> nmatch, regmatch_t *pmatch)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pg_wchar&nbsp;&nbsp; *data;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data_len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; match;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Convert data string to wide characters */<br/></li>
<li></span>&nbsp; &nbsp; data = (pg_wchar *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>((dat_len + <span class="Constant">1</span>) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(pg_wchar));<br/></li>
<li>&nbsp; &nbsp; data_len = <a href="../mb/mbutils.c.html#L986" title="utils/mb/mbutils.c:986">pg_mb2wchar_with_len</a>(dat, data, dat_len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Perform RE match and return result */<br/></li>
<li></span>&nbsp; &nbsp; match = <a href="#L282" title="utils/adt/regexp.c:282">RE_wchar_execute</a>(re, data, data_len, <span class="Constant">0</span>, nmatch, pmatch);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(data);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> match;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L358" title="utils/adt/regexp.c:358">RE_compile_and_execute</a> - compile and execute a RE<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true on match, false on no match<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; text_re --- the pattern, expressed as a TEXT object<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; dat --- the data to match against (need not be null-terminated)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; dat_len --- the length of the data string<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; cflags --- compile options for the pattern<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; collation --- collation to use for LC_CTYPE-dependent behavior<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; nmatch, pmatch&nbsp; &nbsp; --- optional return area for match details<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Both pattern and data are given in the database encoding.&nbsp; We internally<br/></li>
<li></span><span class="Comment"> * convert to array of pg_wchar which is what Spencer's regex package wants.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L358">&#x200c;</a></span><span class="linkable">RE_compile_and_execute</span>(text *text_re, <span class="Type">char</span> *dat, <span class="Type">int</span> dat_len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> cflags, Oid collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> nmatch, regmatch_t *pmatch)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; regex_t&nbsp; &nbsp; *re;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Use REG_NOSUB if caller does not want sub-match details */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nmatch &lt; <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cflags |= REG_NOSUB;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Compile RE */<br/></li>
<li></span>&nbsp; &nbsp; re = <a href="#L141" title="utils/adt/regexp.c:141">RE_compile_and_cache</a>(text_re, cflags, collation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L324" title="utils/adt/regexp.c:324">RE_execute</a>(re, dat, dat_len, nmatch, pmatch);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L385" title="utils/adt/regexp.c:385">parse_re_flags</a> - <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> the options argument of <a href="#L1295" title="utils/adt/regexp.c:1295">regexp_match</a> and friends<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; flags --- output argument, filled with desired options<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; opts --- TEXT object, or NULL for defaults<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This accepts all the options allowed by <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the callers; callers that<br/></li>
<li></span><span class="Comment"> * don't want some have to reject them after the fact.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L385">&#x200c;</a></span><span class="linkable">parse_re_flags</span>(<a href="#L45" title="utils/adt/regexp.c:45">pg_re_flags</a> *flags, text *opts)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* regex flavor is always folded into the compile flags */<br/></li>
<li></span>&nbsp; &nbsp; flags-&gt;cflags = REG_ADVANCED;<br/></li>
<li>&nbsp; &nbsp; flags-&gt;glob = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (opts)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *opt_p = VARDATA_ANY(opts);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opt_len = VARSIZE_ANY_EXHDR(opts);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; opt_len; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (opt_p[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'g'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags-&gt;glob = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'b'</span>:&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* BREs (but why???) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags-&gt;cflags &amp;= ~(REG_ADVANCED | REG_EXTENDED | REG_QUOTE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'c'</span>:&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* case sensitive */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags-&gt;cflags &amp;= ~REG_ICASE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'e'</span>:&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* plain EREs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags-&gt;cflags |= REG_EXTENDED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags-&gt;cflags &amp;= ~(REG_ADVANCED | REG_QUOTE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'i'</span>:&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* case insensitive */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags-&gt;cflags |= REG_ICASE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'m'</span>:&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Perloid synonym for n */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'n'</span>:&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* \n affects ^ $ . [^ */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags-&gt;cflags |= REG_NEWLINE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'p'</span>:&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ~Perl, \n affects . [^ */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags-&gt;cflags |= REG_NLSTOP;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags-&gt;cflags &amp;= ~REG_NLANCH;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'q'</span>:&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* literal string */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags-&gt;cflags |= REG_QUOTE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags-&gt;cflags &amp;= ~(REG_ADVANCED | REG_EXTENDED);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'s'</span>:&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* single line, \n ordinary */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags-&gt;cflags &amp;= ~REG_NEWLINE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'t'</span>:&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* tight syntax */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags-&gt;cflags &amp;= ~REG_EXPANDED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'w'</span>:&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* weird, \n affects ^ $ only */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags-&gt;cflags &amp;= ~REG_NLSTOP;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags-&gt;cflags |= REG_NLANCH;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'x'</span>:&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* expanded syntax */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags-&gt;cflags |= REG_EXPANDED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid regular expression option: </span><span class="Special">\&quot;%.*s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mb/mbutils.c.html#L1023" title="utils/mb/mbutils.c:1023">pg_mblen</a>(opt_p + i), opt_p + i)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; interface routines called by the function manager<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L459">&#x200c;</a><span class="linkable">nameregexeq</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Name&nbsp; &nbsp; &nbsp; &nbsp; n = PG_GETARG_NAME(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *p = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L358" title="utils/adt/regexp.c:358">RE_compile_and_execute</a>(p,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(*n),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strlen(NameStr(*n)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; REG_ADVANCED,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_GET_COLLATION(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>, <span class="Constant">NULL</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L473">&#x200c;</a><span class="linkable">nameregexne</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Name&nbsp; &nbsp; &nbsp; &nbsp; n = PG_GETARG_NAME(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *p = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(!<a href="#L358" title="utils/adt/regexp.c:358">RE_compile_and_execute</a>(p,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NameStr(*n),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; strlen(NameStr(*n)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; REG_ADVANCED,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PG_GET_COLLATION(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>, <span class="Constant">NULL</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L487">&#x200c;</a><span class="linkable">textregexeq</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *s = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *p = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L358" title="utils/adt/regexp.c:358">RE_compile_and_execute</a>(p,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VARDATA_ANY(s),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VARSIZE_ANY_EXHDR(s),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; REG_ADVANCED,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_GET_COLLATION(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>, <span class="Constant">NULL</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L501">&#x200c;</a><span class="linkable">textregexne</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *s = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *p = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(!<a href="#L358" title="utils/adt/regexp.c:358">RE_compile_and_execute</a>(p,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VARDATA_ANY(s),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VARSIZE_ANY_EXHDR(s),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; REG_ADVANCED,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PG_GET_COLLATION(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>, <span class="Constant">NULL</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; routines that use the regexp stuff, but ignore the case.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; for this, we use the REG_ICASE flag to <a href="../../regex/regcomp.c.html#L370" title="regex/regcomp.c:370">pg_regcomp</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L522">&#x200c;</a><span class="linkable">nameicregexeq</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Name&nbsp; &nbsp; &nbsp; &nbsp; n = PG_GETARG_NAME(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *p = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L358" title="utils/adt/regexp.c:358">RE_compile_and_execute</a>(p,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(*n),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strlen(NameStr(*n)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; REG_ADVANCED | REG_ICASE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_GET_COLLATION(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>, <span class="Constant">NULL</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L536">&#x200c;</a><span class="linkable">nameicregexne</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Name&nbsp; &nbsp; &nbsp; &nbsp; n = PG_GETARG_NAME(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *p = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(!<a href="#L358" title="utils/adt/regexp.c:358">RE_compile_and_execute</a>(p,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NameStr(*n),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; strlen(NameStr(*n)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; REG_ADVANCED | REG_ICASE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PG_GET_COLLATION(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>, <span class="Constant">NULL</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L550">&#x200c;</a><span class="linkable">texticregexeq</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *s = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *p = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L358" title="utils/adt/regexp.c:358">RE_compile_and_execute</a>(p,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VARDATA_ANY(s),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VARSIZE_ANY_EXHDR(s),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; REG_ADVANCED | REG_ICASE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_GET_COLLATION(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>, <span class="Constant">NULL</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L564">&#x200c;</a><span class="linkable">texticregexne</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *s = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *p = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(!<a href="#L358" title="utils/adt/regexp.c:358">RE_compile_and_execute</a>(p,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VARDATA_ANY(s),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VARSIZE_ANY_EXHDR(s),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; REG_ADVANCED | REG_ICASE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PG_GET_COLLATION(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>, <span class="Constant">NULL</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L583" title="utils/adt/regexp.c:583">textregexsubstr</a>()<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Return a substring matched by a regular expression.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L583">&#x200c;</a><span class="linkable">textregexsubstr</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *s = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *p = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; regex_t&nbsp; &nbsp; *re;<br/></li>
<li>&nbsp; &nbsp; regmatch_t&nbsp; &nbsp; pmatch[<span class="Constant">2</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; so,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Compile RE */<br/></li>
<li></span>&nbsp; &nbsp; re = <a href="#L141" title="utils/adt/regexp.c:141">RE_compile_and_cache</a>(p, REG_ADVANCED, PG_GET_COLLATION());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We pass two regmatch_t structs to get info about the overall match and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the match for the first parenthesized subexpression (if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>). If there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is a parenthesized subexpression, we return what it matched; else<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * return what the whole regexp matched.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L324" title="utils/adt/regexp.c:324">RE_execute</a>(re,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VARDATA_ANY(s), VARSIZE_ANY_EXHDR(s),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">2</span>, pmatch))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* definitely no match */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (re-&gt;re_nsub &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* has parenthesized subexpressions, use the first one */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; so = pmatch[<span class="Constant">1</span>].rm_so;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; eo = pmatch[<span class="Constant">1</span>].rm_eo;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no parenthesized subexpression, use whole match */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; so = pmatch[<span class="Constant">0</span>].rm_so;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; eo = pmatch[<span class="Constant">0</span>].rm_eo;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It is possible to have a match to the whole pattern but no match for a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * subexpression; for example 'foo(bar)?' is considered to match 'foo' but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there is no subexpression match.&nbsp; So this extra test for match failure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is not redundant.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (so &lt; <span class="Constant">0</span> || eo &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> DirectFunctionCall3(<a href="varlena.c.html#L852" title="utils/adt/varlena.c:852">text_substr</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PointerGetDatum(s),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Int32GetDatum(so + <span class="Constant">1</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Int32GetDatum(eo - so));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L642" title="utils/adt/regexp.c:642">textregexreplace_noopt</a>()<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Return a string matched by a regular expression, with replacement.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This version doesn't have an option argument: we default to case<br/></li>
<li></span><span class="Comment"> * sensitive match, replace the first instance only.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L642">&#x200c;</a><span class="linkable">textregexreplace_noopt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *s = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *p = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *r = PG_GETARG_TEXT_PP(<span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(<a href="varlena.c.html#L4206" title="utils/adt/varlena.c:4206">replace_text_regexp</a>(s, p, r,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; REG_ADVANCED, PG_GET_COLLATION(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>, <span class="Constant">1</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L658" title="utils/adt/regexp.c:658">textregexreplace</a>()<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Return a string matched by a regular expression, with replacement.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L658">&#x200c;</a><span class="linkable">textregexreplace</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *s = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *p = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *r = PG_GETARG_TEXT_PP(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *opt = PG_GETARG_TEXT_PP(<span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L45" title="utils/adt/regexp.c:45">pg_re_flags</a> flags;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * regexp_replace() with four arguments will be preferentially resolved as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this form when the fourth argument is of type UNKNOWN.&nbsp; However, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * user might have intended to call <a href="#L744" title="utils/adt/regexp.c:744">textregexreplace_extended_no_n</a>.&nbsp; If we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * see flags that look like an integer, emit the same error that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L385" title="utils/adt/regexp.c:385">parse_re_flags</a> would, but add a HINT about how to fix it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (VARSIZE_ANY_EXHDR(opt) &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *opt_p = VARDATA_ANY(opt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*opt_p &gt;= <span class="Constant">'0'</span> &amp;&amp; *opt_p &lt;= <span class="Constant">'9'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid regular expression option: </span><span class="Special">\&quot;%.*s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mb/mbutils.c.html#L1023" title="utils/mb/mbutils.c:1023">pg_mblen</a>(opt_p), opt_p),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;If you meant to use regexp_replace() with a start parameter, cast the fourth argument to integer explicitly.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L385" title="utils/adt/regexp.c:385">parse_re_flags</a>(&amp;flags, opt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(<a href="varlena.c.html#L4206" title="utils/adt/varlena.c:4206">replace_text_regexp</a>(s, p, r,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; flags.cflags, PG_GET_COLLATION(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>, flags.glob ? <span class="Constant">0</span> : <span class="Constant">1</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L699" title="utils/adt/regexp.c:699">textregexreplace_extended</a>()<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Return a string matched by a regular expression, with replacement.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Extends <a href="#L658" title="utils/adt/regexp.c:658">textregexreplace</a> by allowing a start position and the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; choice of the occurrence to replace (0 means all occurrences).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L699">&#x200c;</a><span class="linkable">textregexreplace_extended</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *s = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *p = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *r = PG_GETARG_TEXT_PP(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; start = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *flags = <a href="#L40" title="utils/adt/regexp.c:40">PG_GETARG_TEXT_PP_IF_EXISTS</a>(<span class="Constant">5</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L45" title="utils/adt/regexp.c:45">pg_re_flags</a> re_flags;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Collect optional parameters */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PG_NARGS() &gt; <span class="Constant">3</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; start = PG_GETARG_INT32(<span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (start &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid value for parameter </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;start&quot;</span>, start)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PG_NARGS() &gt; <span class="Constant">4</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; n = PG_GETARG_INT32(<span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (n &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid value for parameter </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;n&quot;</span>, n)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Determine options */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L385" title="utils/adt/regexp.c:385">parse_re_flags</a>(&amp;re_flags, flags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If N was not specified, deduce it from the 'g' flag */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PG_NARGS() &lt;= <span class="Constant">4</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; n = re_flags.glob ? <span class="Constant">0</span> : <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Do the replacement(s) */<br/></li>
<li></span>&nbsp; &nbsp; PG_RETURN_TEXT_P(<a href="varlena.c.html#L4206" title="utils/adt/varlena.c:4206">replace_text_regexp</a>(s, p, r,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; re_flags.cflags, PG_GET_COLLATION(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; start - <span class="Constant">1</span>, n));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* This is separate to keep the opr_sanity regression test from complaining */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L744">&#x200c;</a><span class="linkable">textregexreplace_extended_no_n</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L699" title="utils/adt/regexp.c:699">textregexreplace_extended</a>(fcinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* This is separate to keep the opr_sanity regression test from complaining */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L751">&#x200c;</a><span class="linkable">textregexreplace_extended_no_flags</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L699" title="utils/adt/regexp.c:699">textregexreplace_extended</a>(fcinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * similar_to_escape(), <a href="#L1040" title="utils/adt/regexp.c:1040">similar_escape</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Convert a SQL &quot;SIMILAR TO&quot; regexp pattern to POSIX style, so it can be<br/></li>
<li></span><span class="Comment"> * used by our regexp engine.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L767" title="utils/adt/regexp.c:767">similar_escape_internal</a>() is the common workhorse for three SQL-exposed<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.&nbsp; esc_text can be passed as NULL to <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> the default escape<br/></li>
<li></span><span class="Comment"> * (which is '\'), or as an empty string to <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> no escape character.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> text *<br/></li>
<li><a id="L767">&#x200c;</a><span class="linkable">similar_escape_internal</span>(text *pat_text, text *esc_text)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *p,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *e,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *r;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; afterescape = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; incharclass = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nquotes = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; p = VARDATA_ANY(pat_text);<br/></li>
<li>&nbsp; &nbsp; plen = VARSIZE_ANY_EXHDR(pat_text);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (esc_text == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No ESCAPE clause provided; default to backslash as escape */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; e = <span class="Constant">&quot;</span><span class="Special">\\</span><span class="Constant">&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elen = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; e = VARDATA_ANY(esc_text);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elen = VARSIZE_ANY_EXHDR(esc_text);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (elen == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; e = <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no escape character */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (elen &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; escape_mblen = <a href="../mb/mbutils.c.html#L1057" title="utils/mb/mbutils.c:1057">pg_mbstrlen_with_len</a>(e, elen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (escape_mblen &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_ESCAPE_SEQUENCE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid escape string&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Escape string must be empty or one character.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We surround the transformed input string with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^(?: ... )$<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which requires some explanation.&nbsp; We need &quot;^&quot; and &quot;$&quot; to force<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the pattern to match the entire input string as per the SQL spec.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The &quot;(?:&quot; and &quot;)&quot; are a non-capturing set of parens; we have to have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parens in case the string contains &quot;|&quot;, else the &quot;^&quot; and &quot;$&quot; will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be bound into the first and last alternatives which is not what we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * want, and the parens must be non capturing because we don't want them<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to count when selecting output for SUBSTRING.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When the pattern is divided into three parts by escape-double-quotes,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * what we emit is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^(?:part1){1,1}?(part2){1,1}(?:part3)$<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which requires even more explanation.&nbsp; The &quot;{1,1}?&quot; on part1 makes it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * non-greedy so that it will match the smallest possible amount of text<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not the largest, as required by SQL.&nbsp; The plain parens around part2<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are capturing parens so that that part is what controls the result of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * SUBSTRING.&nbsp; The &quot;{1,1}&quot; forces part2 to be greedy, so that it matches<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the largest possible amount of text; hence part3 must match the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * smallest amount of text, as required by SQL.&nbsp; We don't need an explicit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * greediness marker on part3.&nbsp; Note that this also confines the effects<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> &quot;|&quot; characters to the respective part, which is what we want.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The SQL spec says that SUBSTRING's pattern must contain exactly two<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * escape-double-quotes, but we only complain if there's more than two.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * With <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a>, we act as though part1 and part3 are empty; with one, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * act as though part3 is empty.&nbsp; Both behaviors fall out of omitting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the relevant part separators in the above expansion.&nbsp; If the result<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of this function is used in a plain regexp match (SIMILAR TO), the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * escape-double-quotes have no effect on the match behavior.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need room for the prefix/postfix and part separators, plus as many<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as 3 output bytes per input byte; since the input is at most 1GB this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can't overflow size_t.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; result = (text *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(VARHDRSZ + <span class="Constant">23</span> + <span class="Constant">3</span> * (<span class="Type">size_t</span>) plen);<br/></li>
<li>&nbsp; &nbsp; r = VARDATA(result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *r++ = <span class="Constant">'^'</span>;<br/></li>
<li>&nbsp; &nbsp; *r++ = <span class="Constant">'('</span>;<br/></li>
<li>&nbsp; &nbsp; *r++ = <span class="Constant">'?'</span>;<br/></li>
<li>&nbsp; &nbsp; *r++ = <span class="Constant">':'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (plen &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; pchar = *p;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If both the escape character and the current character from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pattern are multi-byte, we need to take the slow path.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * But if one of them is single-byte, we can process the pattern one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * byte at a time, ignoring multi-byte characters.&nbsp; (This works<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because all server-encodings have the property that a valid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * multi-byte character representation cannot contain the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * representation of a valid single-byte character.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (elen &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mblen = <a href="../mb/mbutils.c.html#L1023" title="utils/mb/mbutils.c:1023">pg_mblen</a>(p);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (mblen &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* slow, multi-byte path */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (afterescape)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *r++ = <span class="Special">'\\'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(r, p, mblen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r += mblen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; afterescape = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (e &amp;&amp; elen == mblen &amp;&amp; memcmp(e, p, mblen) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* SQL escape character; do not <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> to output */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; afterescape = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We know it's a multi-byte character, so we don't need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to do all the comparisons to single-byte characters<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that we do below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(r, p, mblen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r += mblen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p += mblen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plen -= mblen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fast path */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (afterescape)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pchar == <span class="Constant">'&quot;'</span> &amp;&amp; !incharclass)&nbsp; &nbsp; <span class="Comment">/* escape-double-quote? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* emit appropriate part separator, per notes above */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nquotes == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *r++ = <span class="Constant">')'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *r++ = <span class="Constant">'{'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *r++ = <span class="Constant">'1'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *r++ = <span class="Constant">','</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *r++ = <span class="Constant">'1'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *r++ = <span class="Constant">'}'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *r++ = <span class="Constant">'?'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *r++ = <span class="Constant">'('</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (nquotes == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *r++ = <span class="Constant">')'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *r++ = <span class="Constant">'{'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *r++ = <span class="Constant">'1'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *r++ = <span class="Constant">','</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *r++ = <span class="Constant">'1'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *r++ = <span class="Constant">'}'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *r++ = <span class="Constant">'('</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *r++ = <span class="Constant">'?'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *r++ = <span class="Constant">':'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_USE_OF_ESCAPE_CHARACTER),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;SQL regular expression may not contain more than two escape-double-quote separators&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nquotes++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We allow <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> character at all to be escaped; notably, this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * allows access to POSIX character-class escapes such as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * &quot;\d&quot;.&nbsp; The SQL spec is considerably more restrictive.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *r++ = <span class="Special">'\\'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *r++ = pchar;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; afterescape = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (e &amp;&amp; pchar == *e)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* SQL escape character; do not <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> to output */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; afterescape = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (incharclass)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pchar == <span class="Special">'\\'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *r++ = <span class="Special">'\\'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *r++ = pchar;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pchar == <span class="Constant">']'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; incharclass = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (pchar == <span class="Constant">'['</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *r++ = pchar;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; incharclass = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (pchar == <span class="Constant">'%'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *r++ = <span class="Constant">'.'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *r++ = <span class="Constant">'*'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (pchar == <span class="Constant">'<a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *r++ = <span class="Constant">'.'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (pchar == <span class="Constant">'('</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* convert to non-capturing parenthesis */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *r++ = <span class="Constant">'('</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *r++ = <span class="Constant">'?'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *r++ = <span class="Constant">':'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (pchar == <span class="Special">'\\'</span> || pchar == <span class="Constant">'.'</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pchar == <span class="Constant">'^'</span> || pchar == <span class="Constant">'$'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *r++ = <span class="Special">'\\'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *r++ = pchar;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *r++ = pchar;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; p++, plen--;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *r++ = <span class="Constant">')'</span>;<br/></li>
<li>&nbsp; &nbsp; *r++ = <span class="Constant">'$'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(result, r - ((<span class="Type">char</span> *) result));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * similar_to_escape(pattern, escape)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1006">&#x200c;</a><span class="linkable">similar_to_escape_2</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *pat_text = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *esc_text = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L767" title="utils/adt/regexp.c:767">similar_escape_internal</a>(pat_text, esc_text);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * similar_to_escape(pattern)<br/></li>
<li></span><span class="Comment"> * Inserts a default escape character.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1022">&#x200c;</a><span class="linkable">similar_to_escape_1</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *pat_text = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L767" title="utils/adt/regexp.c:767">similar_escape_internal</a>(pat_text, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1040" title="utils/adt/regexp.c:1040">similar_escape</a>(pattern, escape)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Legacy function for compatibility with views stored using the<br/></li>
<li></span><span class="Comment"> * pre-v13 expansion of SIMILAR TO.&nbsp; Unlike the above <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, this<br/></li>
<li></span><span class="Comment"> * is non-strict, which leads to not-per-spec handling of &quot;ESCAPE NULL&quot;.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1040">&#x200c;</a><span class="linkable">similar_escape</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *pat_text;<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *esc_text;<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This function is not strict, so must test explicitly */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PG_ARGISNULL(<span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; pat_text = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PG_ARGISNULL(<span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; esc_text = <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* use default escape character */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; esc_text = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L767" title="utils/adt/regexp.c:767">similar_escape_internal</a>(pat_text, esc_text);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1066" title="utils/adt/regexp.c:1066">regexp_count</a>()<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Return the number of matches of a pattern within a string.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1066">&#x200c;</a><span class="linkable">regexp_count</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *str = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *pattern = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; start = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *flags = <a href="#L40" title="utils/adt/regexp.c:40">PG_GETARG_TEXT_PP_IF_EXISTS</a>(<span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L45" title="utils/adt/regexp.c:45">pg_re_flags</a> re_flags;<br/></li>
<li>&nbsp; &nbsp; <a href="#L52" title="utils/adt/regexp.c:52">regexp_matches_ctx</a> *matchctx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Collect optional parameters */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PG_NARGS() &gt; <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; start = PG_GETARG_INT32(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (start &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid value for parameter </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;start&quot;</span>, start)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Determine options */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L385" title="utils/adt/regexp.c:385">parse_re_flags</a>(&amp;re_flags, flags);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* User mustn't specify 'g' */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (re_flags.glob)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: %s is a SQL function name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> does not support the </span><span class="Special">\&quot;</span><span class="Constant">global</span><span class="Special">\&quot;</span><span class="Constant"> option&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;<a href="#L1066" title="utils/adt/regexp.c:1066">regexp_count</a>()&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* But we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> all the matches anyway */<br/></li>
<li></span>&nbsp; &nbsp; re_flags.glob = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Do the matching */<br/></li>
<li></span>&nbsp; &nbsp; matchctx = <a href="#L1416" title="utils/adt/regexp.c:1416">setup_regexp_matches</a>(str, pattern, &amp;re_flags, start - <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_GET_COLLATION(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>,&nbsp; &nbsp; <span class="Comment">/* can ignore subexprs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(matchctx-&gt;nmatches);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* This is separate to keep the opr_sanity regression test from complaining */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1109">&#x200c;</a><span class="linkable">regexp_count_no_start</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1066" title="utils/adt/regexp.c:1066">regexp_count</a>(fcinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* This is separate to keep the opr_sanity regression test from complaining */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1116">&#x200c;</a><span class="linkable">regexp_count_no_flags</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1066" title="utils/adt/regexp.c:1066">regexp_count</a>(fcinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1126" title="utils/adt/regexp.c:1126">regexp_instr</a>()<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Return the match's position within the string<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1126">&#x200c;</a><span class="linkable">regexp_instr</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *str = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *pattern = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; start = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; endoption = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *flags = <a href="#L40" title="utils/adt/regexp.c:40">PG_GETARG_TEXT_PP_IF_EXISTS</a>(<span class="Constant">5</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subexpr = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pos;<br/></li>
<li>&nbsp; &nbsp; <a href="#L45" title="utils/adt/regexp.c:45">pg_re_flags</a> re_flags;<br/></li>
<li>&nbsp; &nbsp; <a href="#L52" title="utils/adt/regexp.c:52">regexp_matches_ctx</a> *matchctx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Collect optional parameters */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PG_NARGS() &gt; <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; start = PG_GETARG_INT32(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (start &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid value for parameter </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;start&quot;</span>, start)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PG_NARGS() &gt; <span class="Constant">3</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; n = PG_GETARG_INT32(<span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (n &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid value for parameter </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;n&quot;</span>, n)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PG_NARGS() &gt; <span class="Constant">4</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; endoption = PG_GETARG_INT32(<span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (endoption != <span class="Constant">0</span> &amp;&amp; endoption != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid value for parameter </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;endoption&quot;</span>, endoption)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PG_NARGS() &gt; <span class="Constant">6</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; subexpr = PG_GETARG_INT32(<span class="Constant">6</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subexpr &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid value for parameter </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;subexpr&quot;</span>, subexpr)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Determine options */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L385" title="utils/adt/regexp.c:385">parse_re_flags</a>(&amp;re_flags, flags);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* User mustn't specify 'g' */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (re_flags.glob)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: %s is a SQL function name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> does not support the </span><span class="Special">\&quot;</span><span class="Constant">global</span><span class="Special">\&quot;</span><span class="Constant"> option&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;<a href="#L1126" title="utils/adt/regexp.c:1126">regexp_instr</a>()&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* But we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> all the matches anyway */<br/></li>
<li></span>&nbsp; &nbsp; re_flags.glob = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Do the matching */<br/></li>
<li></span>&nbsp; &nbsp; matchctx = <a href="#L1416" title="utils/adt/regexp.c:1416">setup_regexp_matches</a>(str, pattern, &amp;re_flags, start - <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_GET_COLLATION(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (subexpr &gt; <span class="Constant">0</span>),&nbsp; &nbsp; <span class="Comment">/* need submatches? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* When n exceeds matches return 0 (includes case of no matches) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (n &gt; matchctx-&gt;nmatches)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_INT32(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* When subexpr exceeds number of subexpressions return 0 */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (subexpr &gt; matchctx-&gt;npatterns)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_INT32(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Select the appropriate match position to return */<br/></li>
<li></span>&nbsp; &nbsp; pos = (n - <span class="Constant">1</span>) * matchctx-&gt;npatterns;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (subexpr &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pos += subexpr - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; pos *= <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (endoption == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pos += <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (matchctx-&gt;match_locs[pos] &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_INT32(matchctx-&gt;match_locs[pos] + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_INT32(<span class="Constant">0</span>);&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* position not identifiable */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* This is separate to keep the opr_sanity regression test from complaining */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1219">&#x200c;</a><span class="linkable">regexp_instr_no_start</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1126" title="utils/adt/regexp.c:1126">regexp_instr</a>(fcinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* This is separate to keep the opr_sanity regression test from complaining */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1226">&#x200c;</a><span class="linkable">regexp_instr_no_n</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1126" title="utils/adt/regexp.c:1126">regexp_instr</a>(fcinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* This is separate to keep the opr_sanity regression test from complaining */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1233">&#x200c;</a><span class="linkable">regexp_instr_no_endoption</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1126" title="utils/adt/regexp.c:1126">regexp_instr</a>(fcinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* This is separate to keep the opr_sanity regression test from complaining */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1240">&#x200c;</a><span class="linkable">regexp_instr_no_flags</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1126" title="utils/adt/regexp.c:1126">regexp_instr</a>(fcinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* This is separate to keep the opr_sanity regression test from complaining */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1247">&#x200c;</a><span class="linkable">regexp_instr_no_subexpr</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1126" title="utils/adt/regexp.c:1126">regexp_instr</a>(fcinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1257" title="utils/adt/regexp.c:1257">regexp_like</a>()<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Test for a pattern match within a string.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1257">&#x200c;</a><span class="linkable">regexp_like</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *str = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *pattern = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *flags = <a href="#L40" title="utils/adt/regexp.c:40">PG_GETARG_TEXT_PP_IF_EXISTS</a>(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L45" title="utils/adt/regexp.c:45">pg_re_flags</a> re_flags;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Determine options */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L385" title="utils/adt/regexp.c:385">parse_re_flags</a>(&amp;re_flags, flags);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* User mustn't specify 'g' */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (re_flags.glob)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: %s is a SQL function name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> does not support the </span><span class="Special">\&quot;</span><span class="Constant">global</span><span class="Special">\&quot;</span><span class="Constant"> option&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;<a href="#L1257" title="utils/adt/regexp.c:1257">regexp_like</a>()&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Otherwise it's like <a href="#L487" title="utils/adt/regexp.c:487">textregexeq</a>/<a href="#L550" title="utils/adt/regexp.c:550">texticregexeq</a> */<br/></li>
<li></span>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L358" title="utils/adt/regexp.c:358">RE_compile_and_execute</a>(pattern,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VARDATA_ANY(str),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VARSIZE_ANY_EXHDR(str),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; re_flags.cflags,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_GET_COLLATION(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>, <span class="Constant">NULL</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* This is separate to keep the opr_sanity regression test from complaining */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1285">&#x200c;</a><span class="linkable">regexp_like_no_flags</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1257" title="utils/adt/regexp.c:1257">regexp_like</a>(fcinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1295" title="utils/adt/regexp.c:1295">regexp_match</a>()<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Return the first substring(s) matching a pattern within a string.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1295">&#x200c;</a><span class="linkable">regexp_match</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *orig_str = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *pattern = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *flags = <a href="#L40" title="utils/adt/regexp.c:40">PG_GETARG_TEXT_PP_IF_EXISTS</a>(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L45" title="utils/adt/regexp.c:45">pg_re_flags</a> re_flags;<br/></li>
<li>&nbsp; &nbsp; <a href="#L52" title="utils/adt/regexp.c:52">regexp_matches_ctx</a> *matchctx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Determine options */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L385" title="utils/adt/regexp.c:385">parse_re_flags</a>(&amp;re_flags, flags);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* User mustn't specify 'g' */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (re_flags.glob)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: %s is a SQL function name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> does not support the </span><span class="Special">\&quot;</span><span class="Constant">global</span><span class="Special">\&quot;</span><span class="Constant"> option&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;<a href="#L1295" title="utils/adt/regexp.c:1295">regexp_match</a>()&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Use the <a href="#L1341" title="utils/adt/regexp.c:1341">regexp_matches</a> function instead.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; matchctx = <a href="#L1416" title="utils/adt/regexp.c:1416">setup_regexp_matches</a>(orig_str, pattern, &amp;re_flags, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_GET_COLLATION(), <span class="Constant">true</span>, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (matchctx-&gt;nmatches == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(matchctx-&gt;nmatches == <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create workspace that <a href="#L1620" title="utils/adt/regexp.c:1620">build_regexp_match_result</a> needs */<br/></li>
<li></span>&nbsp; &nbsp; matchctx-&gt;elems = (Datum *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum) * matchctx-&gt;npatterns);<br/></li>
<li>&nbsp; &nbsp; matchctx-&gt;nulls = (<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>) * matchctx-&gt;npatterns);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_DATUM(PointerGetDatum(<a href="#L1620" title="utils/adt/regexp.c:1620">build_regexp_match_result</a>(matchctx)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* This is separate to keep the opr_sanity regression test from complaining */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1331">&#x200c;</a><span class="linkable">regexp_match_no_flags</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1295" title="utils/adt/regexp.c:1295">regexp_match</a>(fcinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1341" title="utils/adt/regexp.c:1341">regexp_matches</a>()<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Return a table of all matches of a pattern within a string.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1341">&#x200c;</a><span class="linkable">regexp_matches</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FuncCallContext *funcctx;<br/></li>
<li>&nbsp; &nbsp; <a href="#L52" title="utils/adt/regexp.c:52">regexp_matches_ctx</a> *matchctx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (SRF_IS_FIRSTCALL())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *pattern = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *flags = <a href="#L40" title="utils/adt/regexp.c:40">PG_GETARG_TEXT_PP_IF_EXISTS</a>(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L45" title="utils/adt/regexp.c:45">pg_re_flags</a> re_flags;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; funcctx = SRF_FIRSTCALL_INIT();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(funcctx-&gt;multi_call_memory_ctx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Determine options */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L385" title="utils/adt/regexp.c:385">parse_re_flags</a>(&amp;re_flags, flags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* be sure to copy the input string into the multi-call ctx */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; matchctx = <a href="#L1416" title="utils/adt/regexp.c:1416">setup_regexp_matches</a>(PG_GETARG_TEXT_P_COPY(<span class="Constant">0</span>), pattern,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;re_flags, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_GET_COLLATION(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Pre-create workspace that <a href="#L1620" title="utils/adt/regexp.c:1620">build_regexp_match_result</a> needs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; matchctx-&gt;elems = (Datum *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum) * matchctx-&gt;npatterns);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; matchctx-&gt;nulls = (<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>) * matchctx-&gt;npatterns);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; funcctx-&gt;user_fctx = (<span class="Type">void</span> *) matchctx;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; funcctx = SRF_PERCALL_SETUP();<br/></li>
<li>&nbsp; &nbsp; matchctx = (<a href="#L52" title="utils/adt/regexp.c:52">regexp_matches_ctx</a> *) funcctx-&gt;user_fctx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (matchctx-&gt;next_match &lt; matchctx-&gt;nmatches)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ArrayType&nbsp; *result_ary;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result_ary = <a href="#L1620" title="utils/adt/regexp.c:1620">build_regexp_match_result</a>(matchctx);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; matchctx-&gt;next_match++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SRF_RETURN_NEXT(funcctx, PointerGetDatum(result_ary));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SRF_RETURN_DONE(funcctx);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* This is separate to keep the opr_sanity regression test from complaining */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1390">&#x200c;</a><span class="linkable">regexp_matches_no_flags</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1341" title="utils/adt/regexp.c:1341">regexp_matches</a>(fcinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1416" title="utils/adt/regexp.c:1416">setup_regexp_matches</a> --- do the initial matching for <a href="#L1295" title="utils/adt/regexp.c:1295">regexp_match</a>,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; regexp_split, and related <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To avoid having to re-<a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the compiled pattern on each call, we do<br/></li>
<li></span><span class="Comment"> * all the matching in one swoop.&nbsp; The returned <a href="#L52" title="utils/adt/regexp.c:52">regexp_matches_ctx</a> contains<br/></li>
<li></span><span class="Comment"> * the locations of all the substrings matching the pattern.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * start_search: the character (not byte) offset in orig_str at which to<br/></li>
<li></span><span class="Comment"> * begin the search.&nbsp; Returned positions are relative to orig_str anyway.<br/></li>
<li></span><span class="Comment"> * use_subpatterns: collect data about matches to parenthesized subexpressions.<br/></li>
<li></span><span class="Comment"> * ignore_degenerate: ignore zero-length matches.<br/></li>
<li></span><span class="Comment"> * fetching_unmatched: caller wants to fetch unmatched substrings.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We don't currently assume that fetching_unmatched is exclusive of fetching<br/></li>
<li></span><span class="Comment"> * the matched text too; if it's set, the conversion buffer is large enough to<br/></li>
<li></span><span class="Comment"> * fetch <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> single matched or unmatched string, but not <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> larger<br/></li>
<li></span><span class="Comment"> * substring.&nbsp; (In practice, when splitting the matches are usually small<br/></li>
<li></span><span class="Comment"> * anyway, and it didn't seem worth complicating the code further.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L52" title="utils/adt/regexp.c:52">regexp_matches_ctx</a> *<br/></li>
<li><a id="L1416">&#x200c;</a><span class="linkable">setup_regexp_matches</span>(text *orig_str, text *pattern, <a href="#L45" title="utils/adt/regexp.c:45">pg_re_flags</a> *re_flags,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> start_search,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> use_subpatterns,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> ignore_degenerate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> fetching_unmatched)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L52" title="utils/adt/regexp.c:52">regexp_matches_ctx</a> *matchctx = <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L52" title="utils/adt/regexp.c:52">regexp_matches_ctx</a>));<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eml = <a href="../mb/mbutils.c.html#L1546" title="utils/mb/mbutils.c:1546">pg_database_encoding_max_length</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; orig_len;<br/></li>
<li>&nbsp; &nbsp; pg_wchar&nbsp;&nbsp; *wide_str;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wide_len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cflags;<br/></li>
<li>&nbsp; &nbsp; regex_t&nbsp; &nbsp; *cpattern;<br/></li>
<li>&nbsp; &nbsp; regmatch_t *pmatch;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pmatch_len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; array_len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; array_idx;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prev_match_end;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prev_valid_match_end;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxlen = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* largest fetch length in characters */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* save original string --- we'll extract result substrings from it */<br/></li>
<li></span>&nbsp; &nbsp; matchctx-&gt;orig_str = orig_str;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* convert string to pg_wchar form for matching */<br/></li>
<li></span>&nbsp; &nbsp; orig_len = VARSIZE_ANY_EXHDR(orig_str);<br/></li>
<li>&nbsp; &nbsp; wide_str = (pg_wchar *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(pg_wchar) * (orig_len + <span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; wide_len = <a href="../mb/mbutils.c.html#L986" title="utils/mb/mbutils.c:986">pg_mb2wchar_with_len</a>(VARDATA_ANY(orig_str), wide_str, orig_len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set up the compiled pattern */<br/></li>
<li></span>&nbsp; &nbsp; cflags = re_flags-&gt;cflags;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!use_subpatterns)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cflags |= REG_NOSUB;<br/></li>
<li>&nbsp; &nbsp; cpattern = <a href="#L141" title="utils/adt/regexp.c:141">RE_compile_and_cache</a>(pattern, cflags, collation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* do we want to remember subpatterns? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (use_subpatterns &amp;&amp; cpattern-&gt;re_nsub &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; matchctx-&gt;npatterns = cpattern-&gt;re_nsub;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pmatch_len = cpattern-&gt;re_nsub + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; use_subpatterns = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; matchctx-&gt;npatterns = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pmatch_len = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* temporary output space for RE package */<br/></li>
<li></span>&nbsp; &nbsp; pmatch = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(regmatch_t) * pmatch_len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the real output space (grown dynamically if needed)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * use <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> 2^n-1, not 2^n, so that we hit the limit at 2^28-1 rather<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * than at 2^27<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; array_len = re_flags-&gt;glob ? <span class="Constant">255</span> : <span class="Constant">31</span>;<br/></li>
<li>&nbsp; &nbsp; matchctx-&gt;match_locs = (<span class="Type">int</span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>) * array_len);<br/></li>
<li>&nbsp; &nbsp; array_idx = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* search for the pattern, perhaps repeatedly */<br/></li>
<li></span>&nbsp; &nbsp; prev_match_end = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; prev_valid_match_end = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="#L282" title="utils/adt/regexp.c:282">RE_wchar_execute</a>(cpattern, wide_str, wide_len, start_search,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pmatch_len, pmatch))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If requested, ignore degenerate matches, which are zero-length<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * matches occurring at the start or end of a string or just after a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * previous match.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!ignore_degenerate ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (pmatch[<span class="Constant">0</span>].rm_so &lt; wide_len &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pmatch[<span class="Constant">0</span>].rm_eo &gt; prev_match_end))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* enlarge output space if needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (array_idx + matchctx-&gt;npatterns * <span class="Constant">2</span> + <span class="Constant">1</span> &gt; array_len)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; array_len += array_len + <span class="Constant">1</span>; <span class="Comment">/* 2^n-1 =&gt; 2^(n+1)-1 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (array_len &gt; MaxAllocSize / <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;too many regular expression matches&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matchctx-&gt;match_locs = (<span class="Type">int</span> *) <a href="../mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(matchctx-&gt;match_locs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>) * array_len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* save this match's locations */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (use_subpatterns)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt;= matchctx-&gt;npatterns; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; so = pmatch[i].rm_so;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eo = pmatch[i].rm_eo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matchctx-&gt;match_locs[array_idx++] = so;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matchctx-&gt;match_locs[array_idx++] = eo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (so &gt;= <span class="Constant">0</span> &amp;&amp; eo &gt;= <span class="Constant">0</span> &amp;&amp; (eo - so) &gt; maxlen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxlen = (eo - so);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; so = pmatch[<span class="Constant">0</span>].rm_so;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eo = pmatch[<span class="Constant">0</span>].rm_eo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matchctx-&gt;match_locs[array_idx++] = so;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matchctx-&gt;match_locs[array_idx++] = eo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (so &gt;= <span class="Constant">0</span> &amp;&amp; eo &gt;= <span class="Constant">0</span> &amp;&amp; (eo - so) &gt; maxlen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxlen = (eo - so);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matchctx-&gt;nmatches++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * check length of unmatched portion between end of previous valid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (nondegenerate, or degenerate but not ignored) match and start<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of current one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fetching_unmatched &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pmatch[<span class="Constant">0</span>].rm_so &gt;= <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (pmatch[<span class="Constant">0</span>].rm_so - prev_valid_match_end) &gt; maxlen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxlen = (pmatch[<span class="Constant">0</span>].rm_so - prev_valid_match_end);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prev_valid_match_end = pmatch[<span class="Constant">0</span>].rm_eo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prev_match_end = pmatch[<span class="Constant">0</span>].rm_eo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if not glob, stop after one match */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!re_flags-&gt;glob)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Advance search position.&nbsp; Normally we start the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> search at the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * end of the previous match; but if the match was of zero length, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have to advance by one character, or we'd just <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the same match<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; start_search = prev_match_end;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pmatch[<span class="Constant">0</span>].rm_so == pmatch[<span class="Constant">0</span>].rm_eo)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; start_search++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (start_search &gt; wide_len)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * check length of unmatched portion between end of last match and end of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * input string<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fetching_unmatched &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (wide_len - prev_valid_match_end) &gt; maxlen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; maxlen = (wide_len - prev_valid_match_end);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Keep a note of the end position of the string for the benefit of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * splitting code.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; matchctx-&gt;match_locs[array_idx] = wide_len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (eml &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; maxsiz = eml * (int64) maxlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; conv_bufsiz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make the conversion buffer large enough for <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> substring of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * interest.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Worst case: assume we need the maximum size (maxlen*eml), but take<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * advantage of the fact that the original string length in bytes is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * an <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound on the byte length of <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> fetched substring (and we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * know that len+1 is safe to allocate because the varlena header is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * longer than 1 byte).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (maxsiz &gt; orig_len)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; conv_bufsiz = orig_len + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; conv_bufsiz = maxsiz + <span class="Constant">1</span>;&nbsp; &nbsp; <span class="Comment">/* safe since maxsiz &lt; 2^30 */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; matchctx-&gt;conv_buf = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(conv_bufsiz);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; matchctx-&gt;conv_bufsiz = conv_bufsiz;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; matchctx-&gt;wide_str = wide_str;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No need to keep the wide string if we're in a single-byte charset. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(wide_str);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; matchctx-&gt;wide_str = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; matchctx-&gt;conv_buf = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; matchctx-&gt;conv_bufsiz = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Clean up temp storage */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(pmatch);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> matchctx;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1620" title="utils/adt/regexp.c:1620">build_regexp_match_result</a> - build output array for current match<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ArrayType *<br/></li>
<li><a id="L1620">&#x200c;</a><span class="linkable">build_regexp_match_result</span>(<a href="#L52" title="utils/adt/regexp.c:52">regexp_matches_ctx</a> *matchctx)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *buf = matchctx-&gt;conv_buf;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *elems = matchctx-&gt;elems;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *nulls = matchctx-&gt;nulls;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dims[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lbs[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; loc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Extract matching substrings from the original string */<br/></li>
<li></span>&nbsp; &nbsp; loc = matchctx-&gt;next_match * matchctx-&gt;npatterns * <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; matchctx-&gt;npatterns; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; so = matchctx-&gt;match_locs[loc++];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eo = matchctx-&gt;match_locs[loc++];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (so &lt; <span class="Constant">0</span> || eo &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elems[i] = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[i] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (buf)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len = <a href="../mb/mbutils.c.html#L1008" title="utils/mb/mbutils.c:1008">pg_wchar2mb_with_len</a>(matchctx-&gt;wide_str + so,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; eo - so);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(len &lt; matchctx-&gt;conv_bufsiz);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elems[i] = PointerGetDatum(<a href="varlena.c.html#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(buf, len));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[i] = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elems[i] = DirectFunctionCall3(<a href="varlena.c.html#L852" title="utils/adt/varlena.c:852">text_substr</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PointerGetDatum(matchctx-&gt;orig_str),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Int32GetDatum(so + <span class="Constant">1</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Int32GetDatum(eo - so));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[i] = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And form an array */<br/></li>
<li></span>&nbsp; &nbsp; dims[<span class="Constant">0</span>] = matchctx-&gt;npatterns;<br/></li>
<li>&nbsp; &nbsp; lbs[<span class="Constant">0</span>] = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">XXX</span><span class="Comment">: this hardcodes assumptions about the text type */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="arrayfuncs.c.html#L3475" title="utils/adt/arrayfuncs.c:3475">construct_md_array</a>(elems, nulls, <span class="Constant">1</span>, dims, lbs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TEXTOID, -<span class="Constant">1</span>, <span class="Constant">false</span>, TYPALIGN_INT);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1676" title="utils/adt/regexp.c:1676">regexp_split_to_table</a>()<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Split the string at matches of the pattern, returning the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; split-out substrings as a table.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1676">&#x200c;</a><span class="linkable">regexp_split_to_table</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FuncCallContext *funcctx;<br/></li>
<li>&nbsp; &nbsp; <a href="#L52" title="utils/adt/regexp.c:52">regexp_matches_ctx</a> *splitctx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (SRF_IS_FIRSTCALL())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *pattern = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *flags = <a href="#L40" title="utils/adt/regexp.c:40">PG_GETARG_TEXT_PP_IF_EXISTS</a>(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L45" title="utils/adt/regexp.c:45">pg_re_flags</a> re_flags;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; funcctx = SRF_FIRSTCALL_INIT();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(funcctx-&gt;multi_call_memory_ctx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Determine options */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L385" title="utils/adt/regexp.c:385">parse_re_flags</a>(&amp;re_flags, flags);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* User mustn't specify 'g' */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (re_flags.glob)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: %s is a SQL function name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> does not support the </span><span class="Special">\&quot;</span><span class="Constant">global</span><span class="Special">\&quot;</span><span class="Constant"> option&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;<a href="#L1676" title="utils/adt/regexp.c:1676">regexp_split_to_table</a>()&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* But we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> all the matches anyway */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; re_flags.glob = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* be sure to copy the input string into the multi-call ctx */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; splitctx = <a href="#L1416" title="utils/adt/regexp.c:1416">setup_regexp_matches</a>(PG_GETARG_TEXT_P_COPY(<span class="Constant">0</span>), pattern,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;re_flags, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_GET_COLLATION(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>, <span class="Constant">true</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; funcctx-&gt;user_fctx = (<span class="Type">void</span> *) splitctx;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; funcctx = SRF_PERCALL_SETUP();<br/></li>
<li>&nbsp; &nbsp; splitctx = (<a href="#L52" title="utils/adt/regexp.c:52">regexp_matches_ctx</a> *) funcctx-&gt;user_fctx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (splitctx-&gt;next_match &lt;= splitctx-&gt;nmatches)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L1791" title="utils/adt/regexp.c:1791">build_regexp_split_result</a>(splitctx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; splitctx-&gt;next_match++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SRF_RETURN_NEXT(funcctx, result);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SRF_RETURN_DONE(funcctx);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* This is separate to keep the opr_sanity regression test from complaining */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1729">&#x200c;</a><span class="linkable">regexp_split_to_table_no_flags</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1676" title="utils/adt/regexp.c:1676">regexp_split_to_table</a>(fcinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1740" title="utils/adt/regexp.c:1740">regexp_split_to_array</a>()<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Split the string at matches of the pattern, returning the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; split-out substrings as an array.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1740">&#x200c;</a><span class="linkable">regexp_split_to_array</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayBuildState *astate = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L45" title="utils/adt/regexp.c:45">pg_re_flags</a> re_flags;<br/></li>
<li>&nbsp; &nbsp; <a href="#L52" title="utils/adt/regexp.c:52">regexp_matches_ctx</a> *splitctx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Determine options */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L385" title="utils/adt/regexp.c:385">parse_re_flags</a>(&amp;re_flags, <a href="#L40" title="utils/adt/regexp.c:40">PG_GETARG_TEXT_PP_IF_EXISTS</a>(<span class="Constant">2</span>));<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* User mustn't specify 'g' */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (re_flags.glob)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: %s is a SQL function name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> does not support the </span><span class="Special">\&quot;</span><span class="Constant">global</span><span class="Special">\&quot;</span><span class="Constant"> option&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;<a href="#L1740" title="utils/adt/regexp.c:1740">regexp_split_to_array</a>()&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* But we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> all the matches anyway */<br/></li>
<li></span>&nbsp; &nbsp; re_flags.glob = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; splitctx = <a href="#L1416" title="utils/adt/regexp.c:1416">setup_regexp_matches</a>(PG_GETARG_TEXT_PP(<span class="Constant">0</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_GETARG_TEXT_PP(<span class="Constant">1</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;re_flags, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_GET_COLLATION(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>, <span class="Constant">true</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (splitctx-&gt;next_match &lt;= splitctx-&gt;nmatches)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; astate = <a href="arrayfuncs.c.html#L5331" title="utils/adt/arrayfuncs.c:5331">accumArrayResult</a>(astate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1791" title="utils/adt/regexp.c:1791">build_regexp_split_result</a>(splitctx),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TEXTOID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; splitctx-&gt;next_match++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_DATUM(<a href="arrayfuncs.c.html#L5401" title="utils/adt/arrayfuncs.c:5401">makeArrayResult</a>(astate, <a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* This is separate to keep the opr_sanity regression test from complaining */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1779">&#x200c;</a><span class="linkable">regexp_split_to_array_no_flags</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1740" title="utils/adt/regexp.c:1740">regexp_split_to_array</a>(fcinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1791" title="utils/adt/regexp.c:1791">build_regexp_split_result</a> - build output string for current match<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We return the string between the current match and the previous one,<br/></li>
<li></span><span class="Comment"> * or the string after the last match when next_match == nmatches.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Datum<br/></li>
<li><a id="L1791">&#x200c;</a><span class="linkable">build_regexp_split_result</span>(<a href="#L52" title="utils/adt/regexp.c:52">regexp_matches_ctx</a> *splitctx)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *buf = splitctx-&gt;conv_buf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; startpos;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; endpos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (splitctx-&gt;next_match &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; startpos = splitctx-&gt;match_locs[splitctx-&gt;next_match * <span class="Constant">2</span> - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; startpos = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (startpos &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid match ending position&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; endpos = splitctx-&gt;match_locs[splitctx-&gt;next_match * <span class="Constant">2</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (endpos &lt; startpos)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid match starting position&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (buf)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len = <a href="../mb/mbutils.c.html#L1008" title="utils/mb/mbutils.c:1008">pg_wchar2mb_with_len</a>(splitctx-&gt;wide_str + startpos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; endpos - startpos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(len &lt; splitctx-&gt;conv_bufsiz);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PointerGetDatum(<a href="varlena.c.html#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(buf, len));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DirectFunctionCall3(<a href="varlena.c.html#L852" title="utils/adt/varlena.c:852">text_substr</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PointerGetDatum(splitctx-&gt;orig_str),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Int32GetDatum(startpos + <span class="Constant">1</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Int32GetDatum(endpos - startpos));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1832" title="utils/adt/regexp.c:1832">regexp_substr</a>()<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Return the substring that matches a regular expression pattern<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1832">&#x200c;</a><span class="linkable">regexp_substr</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *str = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *pattern = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; start = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *flags = <a href="#L40" title="utils/adt/regexp.c:40">PG_GETARG_TEXT_PP_IF_EXISTS</a>(<span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subexpr = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; so,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pos;<br/></li>
<li>&nbsp; &nbsp; <a href="#L45" title="utils/adt/regexp.c:45">pg_re_flags</a> re_flags;<br/></li>
<li>&nbsp; &nbsp; <a href="#L52" title="utils/adt/regexp.c:52">regexp_matches_ctx</a> *matchctx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Collect optional parameters */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PG_NARGS() &gt; <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; start = PG_GETARG_INT32(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (start &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid value for parameter </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;start&quot;</span>, start)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PG_NARGS() &gt; <span class="Constant">3</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; n = PG_GETARG_INT32(<span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (n &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid value for parameter </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;n&quot;</span>, n)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PG_NARGS() &gt; <span class="Constant">5</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; subexpr = PG_GETARG_INT32(<span class="Constant">5</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subexpr &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid value for parameter </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;subexpr&quot;</span>, subexpr)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Determine options */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L385" title="utils/adt/regexp.c:385">parse_re_flags</a>(&amp;re_flags, flags);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* User mustn't specify 'g' */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (re_flags.glob)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: %s is a SQL function name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> does not support the </span><span class="Special">\&quot;</span><span class="Constant">global</span><span class="Special">\&quot;</span><span class="Constant"> option&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;<a href="#L1832" title="utils/adt/regexp.c:1832">regexp_substr</a>()&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* But we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> all the matches anyway */<br/></li>
<li></span>&nbsp; &nbsp; re_flags.glob = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Do the matching */<br/></li>
<li></span>&nbsp; &nbsp; matchctx = <a href="#L1416" title="utils/adt/regexp.c:1416">setup_regexp_matches</a>(str, pattern, &amp;re_flags, start - <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_GET_COLLATION(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (subexpr &gt; <span class="Constant">0</span>),&nbsp; &nbsp; <span class="Comment">/* need submatches? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* When n exceeds matches return NULL (includes case of no matches) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (n &gt; matchctx-&gt;nmatches)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* When subexpr exceeds number of subexpressions return NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (subexpr &gt; matchctx-&gt;npatterns)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Select the appropriate match position to return */<br/></li>
<li></span>&nbsp; &nbsp; pos = (n - <span class="Constant">1</span>) * matchctx-&gt;npatterns;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (subexpr &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pos += subexpr - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; pos *= <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; so = matchctx-&gt;match_locs[pos];<br/></li>
<li>&nbsp; &nbsp; eo = matchctx-&gt;match_locs[pos + <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (so &lt; <span class="Constant">0</span> || eo &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* unidentifiable location */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_DATUM(DirectFunctionCall3(<a href="varlena.c.html#L852" title="utils/adt/varlena.c:852">text_substr</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(matchctx-&gt;orig_str),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Int32GetDatum(so + <span class="Constant">1</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Int32GetDatum(eo - so)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* This is separate to keep the opr_sanity regression test from complaining */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1920">&#x200c;</a><span class="linkable">regexp_substr_no_start</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1832" title="utils/adt/regexp.c:1832">regexp_substr</a>(fcinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* This is separate to keep the opr_sanity regression test from complaining */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1927">&#x200c;</a><span class="linkable">regexp_substr_no_n</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1832" title="utils/adt/regexp.c:1832">regexp_substr</a>(fcinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* This is separate to keep the opr_sanity regression test from complaining */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1934">&#x200c;</a><span class="linkable">regexp_substr_no_flags</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1832" title="utils/adt/regexp.c:1832">regexp_substr</a>(fcinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* This is separate to keep the opr_sanity regression test from complaining */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1941">&#x200c;</a><span class="linkable">regexp_substr_no_subexpr</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1832" title="utils/adt/regexp.c:1832">regexp_substr</a>(fcinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1953" title="utils/adt/regexp.c:1953">regexp_fixed_prefix</a> - extract fixed prefix, if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, for a regexp<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The result is NULL if there is no fixed prefix, else a <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d string.<br/></li>
<li></span><span class="Comment"> * If it is an exact match, not just a prefix, *exact is returned as true.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L1953">&#x200c;</a><span class="linkable">regexp_fixed_prefix</span>(text *text_re, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> case_insensitive, Oid collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *exact)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; regex_t&nbsp; &nbsp; *re;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cflags;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; re_result;<br/></li>
<li>&nbsp; &nbsp; pg_wchar&nbsp;&nbsp; *str;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; slen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; maxlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; errMsg[<span class="Constant">100</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *exact = <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* default result */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Compile RE */<br/></li>
<li></span>&nbsp; &nbsp; cflags = REG_ADVANCED;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (case_insensitive)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cflags |= REG_ICASE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; re = <a href="#L141" title="utils/adt/regexp.c:141">RE_compile_and_cache</a>(text_re, cflags | REG_NOSUB, collation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Examine it to see if there's a fixed prefix */<br/></li>
<li></span>&nbsp; &nbsp; re_result = <a href="../../regex/regprefix.c.html#L46" title="regex/regprefix.c:46">pg_regprefix</a>(re, &amp;str, &amp;slen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (re_result)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REG_NOMATCH:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REG_PREFIX:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* continue with wchar conversion */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REG_EXACT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *exact = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* continue with wchar conversion */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* re failed??? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regerror.c.html#L60" title="regex/regerror.c:60">pg_regerror</a>(re_result, re, errMsg, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(errMsg));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_REGULAR_EXPRESSION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;regular expression failed: </span><span class="Special">%s</span><span class="Constant">&quot;</span>, errMsg)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Convert pg_wchar result back to database encoding */<br/></li>
<li></span>&nbsp; &nbsp; maxlen = <a href="../mb/mbutils.c.html#L1546" title="utils/mb/mbutils.c:1546">pg_database_encoding_max_length</a>() * slen + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; result = (<span class="Type">char</span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(maxlen);<br/></li>
<li>&nbsp; &nbsp; slen = <a href="../mb/mbutils.c.html#L1008" title="utils/mb/mbutils.c:1008">pg_wchar2mb_with_len</a>(str, result, slen);<br/></li>
<li>&nbsp; &nbsp; Assert(slen &lt; maxlen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(str);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
