<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/adt/rangetypes.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/adt/rangetypes.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L50">RangeIOData</a></li>
<li><a href="#L55">RangeIOData</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L757">bounds_adjacent</a></li>
<li><a href="#L2908">build_bound_expr</a></li>
<li><a href="#L1558">daterange_canonical</a></li>
<li><a href="#L1655">daterange_subdiff</a></li>
<li><a href="#L2683">datum_compute_size</a></li>
<li><a href="#L2709">datum_write</a></li>
<li><a href="#L557">elem_contained_by_range</a></li>
<li><a href="#L2187">elem_contained_by_range_support</a></li>
<li><a href="#L2786">find_simplified_clause</a></li>
<li><a href="#L317">get_range_io_data</a></li>
<li><a href="#L1330">hash_range</a></li>
<li><a href="#L1396">hash_range_extended</a></li>
<li><a href="#L1464">int4range_canonical</a></li>
<li><a href="#L1621">int4range_subdiff</a></li>
<li><a href="#L1511">int8range_canonical</a></li>
<li><a href="#L1630">int8range_subdiff</a></li>
<li><a href="#L2165">make_empty_range</a></li>
<li><a href="#L1952">make_range</a></li>
<li><a href="#L1639">numrange_subdiff</a></li>
<li><a href="#L828">range_adjacent</a></li>
<li><a href="#L798">range_adjacent_internal</a></li>
<li><a href="#L727">range_after</a></li>
<li><a href="#L702">range_after_internal</a></li>
<li><a href="#L689">range_before</a></li>
<li><a href="#L664">range_before_internal</a></li>
<li><a href="#L2537">range_bound_escape</a></li>
<li><a href="#L1249">range_cmp</a></li>
<li><a href="#L2090">range_cmp_bound_values</a></li>
<li><a href="#L2016">range_cmp_bounds</a></li>
<li><a href="#L2129">range_compare</a></li>
<li><a href="#L377">range_constructor2</a></li>
<li><a href="#L406">range_constructor3</a></li>
<li><a href="#L651">range_contained_by</a></li>
<li><a href="#L2618">range_contained_by_internal</a></li>
<li><a href="#L638">range_contains</a></li>
<li><a href="#L544">range_contains_elem</a></li>
<li><a href="#L2627">range_contains_elem_internal</a></li>
<li><a href="#L2213">range_contains_elem_support</a></li>
<li><a href="#L2586">range_contains_internal</a></li>
<li><a href="#L2507">range_deparse</a></li>
<li><a href="#L1856">range_deserialize</a></li>
<li><a href="#L491">range_empty</a></li>
<li><a href="#L605">range_eq</a></li>
<li><a href="#L573">range_eq_internal</a></li>
<li><a href="#L1311">range_ge</a></li>
<li><a href="#L1923">range_get_flags</a></li>
<li><a href="#L1703">range_get_typcache</a></li>
<li><a href="#L1319">range_gt</a></li>
<li><a href="#L88">range_in</a></li>
<li><a href="#L1127">range_intersect</a></li>
<li><a href="#L1219">range_intersect_agg_transfn</a></li>
<li><a href="#L1143">range_intersect_internal</a></li>
<li><a href="#L1303">range_le</a></li>
<li><a href="#L446">range_lower</a></li>
<li><a href="#L501">range_lower_inc</a></li>
<li><a href="#L521">range_lower_inf</a></li>
<li><a href="#L1295">range_lt</a></li>
<li><a href="#L1114">range_merge</a></li>
<li><a href="#L972">range_minus</a></li>
<li><a href="#L993">range_minus_internal</a></li>
<li><a href="#L625">range_ne</a></li>
<li><a href="#L618">range_ne_internal</a></li>
<li><a href="#L137">range_out</a></li>
<li><a href="#L874">range_overlaps</a></li>
<li><a href="#L841">range_overlaps_internal</a></li>
<li><a href="#L915">range_overleft</a></li>
<li><a href="#L887">range_overleft_internal</a></li>
<li><a href="#L956">range_overright</a></li>
<li><a href="#L928">range_overright_internal</a></li>
<li><a href="#L2322">range_parse</a></li>
<li><a href="#L2438">range_parse_bound</a></li>
<li><a href="#L2247">range_parse_flags</a></li>
<li><a href="#L177">range_recv</a></li>
<li><a href="#L261">range_send</a></li>
<li><a href="#L1727">range_serialize</a></li>
<li><a href="#L1937">range_set_contain_empty</a></li>
<li><a href="#L1182">range_split_internal</a></li>
<li><a href="#L1098">range_union</a></li>
<li><a href="#L1052">range_union_internal</a></li>
<li><a href="#L467">range_upper</a></li>
<li><a href="#L511">range_upper_inc</a></li>
<li><a href="#L531">range_upper_inf</a></li>
<li><a href="#L1664">tsrange_subdiff</a></li>
<li><a href="#L1675">tstzrange_subdiff</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L2675">TYPE_IS_PACKABLE</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * rangetypes.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; I/O <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, operators, and support <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> types.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The stored (serialized) format of a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> value is:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; 4 bytes: varlena header<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; 4 bytes: <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> type's OID<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Lower boundary value, if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, aligned according to subtype's typalign<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Upper boundary value, if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, aligned according to subtype's typalign<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; 1 byte for flags<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This representation is chosen to avoid needing <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> padding <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the<br/></li>
<li></span><span class="Comment"> * <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> boundary value, even when it requires double alignment.&nbsp; We can<br/></li>
<li></span><span class="Comment"> * expect that the varlena header is presented to us on a suitably aligned<br/></li>
<li></span><span class="Comment"> * boundary (possibly after detoasting), and then the <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> boundary is too.<br/></li>
<li></span><span class="Comment"> * Note that this means we can't work with a packed (short varlena header)<br/></li>
<li></span><span class="Comment"> * value; we must detoast it first.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/adt/rangetypes.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;common/hashfn.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/pqformat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/makefuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/miscnodes.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/supportnodes.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/clauses.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/cost.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/optimizer.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/date.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rangetypes.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/timestamp.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* fn_extra cache entry for one of the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> I/O <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li><a id="L50">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">RangeIOData</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> type's typcache entry */<br/></li>
<li></span>&nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; typioproc;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type's I/O function */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typioparam;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type's I/O parameter */<br/></li>
<li><a id="L55">&#x200c;</a></span>} <span class="linkable">RangeIOData</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">static</span> <a href="#L50" title="utils/adt/rangetypes.c:50">RangeIOData</a> *<a href="#L317" title="utils/adt/rangetypes.c:317">get_range_io_data</a>(FunctionCallInfo fcinfo, Oid rngtypid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IOFuncSelector func);<br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> <a href="#L2247" title="utils/adt/rangetypes.c:2247">range_parse_flags</a>(<span class="Type">const</span> <span class="Type">char</span> *flags_str);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2322" title="utils/adt/rangetypes.c:2322">range_parse</a>(<span class="Type">const</span> <span class="Type">char</span> *string, <span class="Type">char</span> *flags, <span class="Type">char</span> **lbound_str,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span> **ubound_str, Node *escontext);<br/></li>
<li><span class="Type">static</span> <span class="Type">const</span> <span class="Type">char</span> *<a href="#L2438" title="utils/adt/rangetypes.c:2438">range_parse_bound</a>(<span class="Type">const</span> <span class="Type">char</span> *string, <span class="Type">const</span> <span class="Type">char</span> *ptr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">char</span> **bound_str, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *infinite,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Node *escontext);<br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<a href="#L2507" title="utils/adt/rangetypes.c:2507">range_deparse</a>(<span class="Type">char</span> flags, <span class="Type">const</span> <span class="Type">char</span> *lbound_str,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *ubound_str);<br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<a href="#L2537" title="utils/adt/rangetypes.c:2537">range_bound_escape</a>(<span class="Type">const</span> <span class="Type">char</span> *value);<br/></li>
<li><span class="Type">static</span> Size <a href="#L2683" title="utils/adt/rangetypes.c:2683">datum_compute_size</a>(Size data_length, Datum val, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> typbyval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">char</span> typalign, int16 typlen, <span class="Type">char</span> typstorage);<br/></li>
<li><span class="Type">static</span> Pointer <a href="#L2709" title="utils/adt/rangetypes.c:2709">datum_write</a>(Pointer ptr, Datum datum, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> typbyval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">char</span> typalign, int16 typlen, <span class="Type">char</span> typstorage);<br/></li>
<li><span class="Type">static</span> Node *<a href="#L2786" title="utils/adt/rangetypes.c:2786">find_simplified_clause</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Expr *rangeExpr, Expr *elemExpr);<br/></li>
<li><span class="Type">static</span> Expr *<a href="#L2908" title="utils/adt/rangetypes.c:2908">build_bound_expr</a>(Expr *elemExpr, Datum val,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isLowerBound, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isInclusive,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TypeCacheEntry *typeCache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid opfamily, Oid rng_collation);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *----------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * I/O FUNCTIONS<br/></li>
<li></span><span class="Comment"> *----------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L88">&#x200c;</a><span class="linkable">range_in</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *input_str = PG_GETARG_CSTRING(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rngtypoid = PG_GETARG_OID(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typmod = PG_GETARG_INT32(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *escontext = fcinfo-&gt;context;<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L50" title="utils/adt/rangetypes.c:50">RangeIOData</a> *cache;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; flags;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *lbound_str;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ubound_str;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* recurses when subtype is a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> type */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; cache = <a href="#L317" title="utils/adt/rangetypes.c:317">get_range_io_data</a>(fcinfo, rngtypoid, IOFunc_input);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L2322" title="utils/adt/rangetypes.c:2322">range_parse</a>(input_str, &amp;flags, &amp;lbound_str, &amp;ubound_str, escontext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* call <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type's input function */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RANGE_HAS_LBOUND(flags))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../fmgr/fmgr.c.html#L1585" title="utils/fmgr/fmgr.c:1585">InputFunctionCallSafe</a>(&amp;cache-&gt;typioproc, lbound_str,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cache-&gt;typioparam, typmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; escontext, &amp;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.val))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (RANGE_HAS_UBOUND(flags))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../fmgr/fmgr.c.html#L1585" title="utils/fmgr/fmgr.c:1585">InputFunctionCallSafe</a>(&amp;cache-&gt;typioproc, ubound_str,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cache-&gt;typioparam, typmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; escontext, &amp;<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.val))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.infinite = (flags &amp; RANGE_LB_INF) != <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.inclusive = (flags &amp; RANGE_LB_INC) != <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.infinite = (flags &amp; RANGE_UB_INF) != <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.inclusive = (flags &amp; RANGE_UB_INC) != <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* serialize and canonicalize */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> = <a href="#L1952" title="utils/adt/rangetypes.c:1952">make_range</a>(cache-&gt;typcache, &amp;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, &amp;<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; flags &amp; RANGE_EMPTY, escontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_RANGE_P(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L137">&#x200c;</a><span class="linkable">range_out</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> = PG_GETARG_RANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *output_str;<br/></li>
<li>&nbsp; &nbsp; <a href="#L50" title="utils/adt/rangetypes.c:50">RangeIOData</a> *cache;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; flags;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *lbound_str = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ubound_str = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; empty;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* recurses when subtype is a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> type */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; cache = <a href="#L317" title="utils/adt/rangetypes.c:317">get_range_io_data</a>(fcinfo, RangeTypeGetOid(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>), IOFunc_output);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* deserialize */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(cache-&gt;typcache, <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, &amp;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, &amp;<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>, &amp;empty);<br/></li>
<li>&nbsp; &nbsp; flags = <a href="#L1923" title="utils/adt/rangetypes.c:1923">range_get_flags</a>(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* call <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type's output function */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RANGE_HAS_LBOUND(flags))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lbound_str = <a href="../fmgr/fmgr.c.html#L1683" title="utils/fmgr/fmgr.c:1683">OutputFunctionCall</a>(&amp;cache-&gt;typioproc, <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.val);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (RANGE_HAS_UBOUND(flags))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ubound_str = <a href="../fmgr/fmgr.c.html#L1683" title="utils/fmgr/fmgr.c:1683">OutputFunctionCall</a>(&amp;cache-&gt;typioproc, <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.val);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* construct result string */<br/></li>
<li></span>&nbsp; &nbsp; output_str = <a href="#L2507" title="utils/adt/rangetypes.c:2507">range_deparse</a>(flags, lbound_str, ubound_str);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CSTRING(output_str);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Binary representation: The first byte is the flags, then the <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound<br/></li>
<li></span><span class="Comment"> * (if present), then the <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound (if present).&nbsp; Each bound is represented<br/></li>
<li></span><span class="Comment"> * by a 4-byte length header and the binary representation of that bound (as<br/></li>
<li></span><span class="Comment"> * returned by a call to the <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> function for the subtype).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L177">&#x200c;</a><span class="linkable">range_recv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; buf = (StringInfo) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rngtypoid = PG_GETARG_OID(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; typmod = PG_GETARG_INT32(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L50" title="utils/adt/rangetypes.c:50">RangeIOData</a> *cache;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; flags;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* recurses when subtype is a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> type */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; cache = <a href="#L317" title="utils/adt/rangetypes.c:317">get_range_io_data</a>(fcinfo, rngtypoid, IOFunc_receive);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* receive the flags... */<br/></li>
<li></span>&nbsp; &nbsp; flags = (<span class="Type">unsigned</span> <span class="Type">char</span>) <a href="../../libpq/pqformat.c.html#L399" title="libpq/pqformat.c:399">pq_getmsgbyte</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Mask out <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> unsupported flags, particularly RANGE_xB_NULL which would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * confuse following tests.&nbsp; Note that <a href="#L1727" title="utils/adt/rangetypes.c:1727">range_serialize</a> will take care of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cleaning up <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> inconsistencies in the remaining flags.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; flags &amp;= (RANGE_EMPTY |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RANGE_LB_INC |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RANGE_LB_INF |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RANGE_UB_INC |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RANGE_UB_INF);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* receive the bounds ... */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RANGE_HAS_LBOUND(flags))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; bound_len = <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(buf, <span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *bound_data = <a href="../../libpq/pqformat.c.html#L508" title="libpq/pqformat.c:508">pq_getmsgbytes</a>(buf, bound_len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; StringInfoData bound_buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; initStringInfo(&amp;bound_buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendBinaryStringInfo(&amp;bound_buf, bound_data, bound_len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.val = <a href="../fmgr/fmgr.c.html#L1697" title="utils/fmgr/fmgr.c:1697">ReceiveFunctionCall</a>(&amp;cache-&gt;typioproc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;bound_buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cache-&gt;typioparam,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typmod);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(bound_buf.data);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.val = (Datum) <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (RANGE_HAS_UBOUND(flags))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; bound_len = <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(buf, <span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *bound_data = <a href="../../libpq/pqformat.c.html#L508" title="libpq/pqformat.c:508">pq_getmsgbytes</a>(buf, bound_len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; StringInfoData bound_buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; initStringInfo(&amp;bound_buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendBinaryStringInfo(&amp;bound_buf, bound_data, bound_len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.val = <a href="../fmgr/fmgr.c.html#L1697" title="utils/fmgr/fmgr.c:1697">ReceiveFunctionCall</a>(&amp;cache-&gt;typioproc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;bound_buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cache-&gt;typioparam,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typmod);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(bound_buf.data);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.val = (Datum) <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L635" title="libpq/pqformat.c:635">pq_getmsgend</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* finish constructing RangeBound representation */<br/></li>
<li></span>&nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.infinite = (flags &amp; RANGE_LB_INF) != <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.inclusive = (flags &amp; RANGE_LB_INC) != <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.infinite = (flags &amp; RANGE_UB_INF) != <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.inclusive = (flags &amp; RANGE_UB_INC) != <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* serialize and canonicalize */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> = <a href="#L1952" title="utils/adt/rangetypes.c:1952">make_range</a>(cache-&gt;typcache, &amp;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, &amp;<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; flags &amp; RANGE_EMPTY, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_RANGE_P(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L261">&#x200c;</a><span class="linkable">range_send</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> = PG_GETARG_RANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; buf = makeStringInfo();<br/></li>
<li>&nbsp; &nbsp; <a href="#L50" title="utils/adt/rangetypes.c:50">RangeIOData</a> *cache;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; flags;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; empty;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* recurses when subtype is a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> type */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; cache = <a href="#L317" title="utils/adt/rangetypes.c:317">get_range_io_data</a>(fcinfo, RangeTypeGetOid(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>), IOFunc_send);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* deserialize */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(cache-&gt;typcache, <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, &amp;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, &amp;<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>, &amp;empty);<br/></li>
<li>&nbsp; &nbsp; flags = <a href="#L1923" title="utils/adt/rangetypes.c:1923">range_get_flags</a>(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* construct output */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L326" title="libpq/pqformat.c:326">pq_begintypsend</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pq_sendbyte(buf, flags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (RANGE_HAS_LBOUND(flags))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; bound = PointerGetDatum(<a href="../fmgr/fmgr.c.html#L1744" title="utils/fmgr/fmgr.c:1744">SendFunctionCall</a>(&amp;cache-&gt;typioproc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.val));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; bound_len = VARSIZE(bound) - VARHDRSZ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *bound_data = VARDATA(bound);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pq_sendint32(buf, bound_len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L126" title="libpq/pqformat.c:126">pq_sendbytes</a>(buf, bound_data, bound_len);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (RANGE_HAS_UBOUND(flags))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; bound = PointerGetDatum(<a href="../fmgr/fmgr.c.html#L1744" title="utils/fmgr/fmgr.c:1744">SendFunctionCall</a>(&amp;cache-&gt;typioproc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.val));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; bound_len = VARSIZE(bound) - VARHDRSZ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *bound_data = VARDATA(bound);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pq_sendint32(buf, bound_len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L126" title="libpq/pqformat.c:126">pq_sendbytes</a>(buf, bound_data, bound_len);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BYTEA_P(<a href="../../libpq/pqformat.c.html#L346" title="libpq/pqformat.c:346">pq_endtypsend</a>(buf));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L317" title="utils/adt/rangetypes.c:317">get_range_io_data</a>: get cached information needed for <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> type I/O<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> I/O <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> need a <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> more cached info than other <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a><br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, so they store a <a href="#L50" title="utils/adt/rangetypes.c:50">RangeIOData</a> struct in fn_extra, not just a<br/></li>
<li></span><span class="Comment"> * pointer to a type cache entry.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L50" title="utils/adt/rangetypes.c:50">RangeIOData</a> *<br/></li>
<li><a id="L317">&#x200c;</a><span class="linkable">get_range_io_data</span>(FunctionCallInfo fcinfo, Oid rngtypid, IOFuncSelector func)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L50" title="utils/adt/rangetypes.c:50">RangeIOData</a> *cache = (<a href="#L50" title="utils/adt/rangetypes.c:50">RangeIOData</a> *) fcinfo-&gt;flinfo-&gt;fn_extra;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cache == <span class="Constant">NULL</span> || cache-&gt;typcache-&gt;type_id != rngtypid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; typlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; typbyval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; typalign;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; typdelim;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typiofunc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cache = (<a href="#L50" title="utils/adt/rangetypes.c:50">RangeIOData</a> *) <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(fcinfo-&gt;flinfo-&gt;fn_mcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L50" title="utils/adt/rangetypes.c:50">RangeIOData</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cache-&gt;typcache = <a href="../cache/typcache.c.html#L346" title="utils/cache/typcache.c:346">lookup_type_cache</a>(rngtypid, TYPECACHE_RANGE_INFO);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cache-&gt;typcache-&gt;rngelemtype == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;type </span><span class="Special">%u</span><span class="Constant"> is not a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> type&quot;</span>, rngtypid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../cache/lsyscache.c.html#L2325" title="utils/cache/lsyscache.c:2325">get_type_io_data</a> does more than we need, but is convenient */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L2325" title="utils/cache/lsyscache.c:2325">get_type_io_data</a>(cache-&gt;typcache-&gt;rngelemtype-&gt;type_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; func,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;typlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;typbyval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;typalign,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;typdelim,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;cache-&gt;typioparam,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;typiofunc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(typiofunc))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* this could only happen for receive or <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (func == IOFunc_receive)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;no binary input function available for type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(cache-&gt;typcache-&gt;rngelemtype-&gt;type_id))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;no binary output function available for type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(cache-&gt;typcache-&gt;rngelemtype-&gt;type_id))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../fmgr/fmgr.c.html#L137" title="utils/fmgr/fmgr.c:137">fmgr_info_cxt</a>(typiofunc, &amp;cache-&gt;typioproc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;flinfo-&gt;fn_mcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;flinfo-&gt;fn_extra = (<span class="Type">void</span> *) cache;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> cache;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *----------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * GENERIC FUNCTIONS<br/></li>
<li></span><span class="Comment"> *----------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Construct standard-form <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> value from two arguments */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L377">&#x200c;</a><span class="linkable">range_constructor2</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_DATUM(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_DATUM(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rngtypid = <a href="../fmgr/fmgr.c.html#L1888" title="utils/fmgr/fmgr.c:1888">get_fn_expr_rettype</a>(fcinfo-&gt;flinfo);<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>;<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L1703" title="utils/adt/rangetypes.c:1703">range_get_typcache</a>(fcinfo, rngtypid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.val = PG_ARGISNULL(<span class="Constant">0</span>) ? (Datum) <span class="Constant">0</span> : arg1;<br/></li>
<li>&nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.infinite = PG_ARGISNULL(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.inclusive = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.val = PG_ARGISNULL(<span class="Constant">1</span>) ? (Datum) <span class="Constant">0</span> : arg2;<br/></li>
<li>&nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.infinite = PG_ARGISNULL(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.inclusive = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> = <a href="#L1952" title="utils/adt/rangetypes.c:1952">make_range</a>(typcache, &amp;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, &amp;<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>, <span class="Constant">false</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_RANGE_P(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Construct general <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> value from three arguments */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L406">&#x200c;</a><span class="linkable">range_constructor3</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_DATUM(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_DATUM(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rngtypid = <a href="../fmgr/fmgr.c.html#L1888" title="utils/fmgr/fmgr.c:1888">get_fn_expr_rettype</a>(fcinfo-&gt;flinfo);<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>;<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; flags;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L1703" title="utils/adt/rangetypes.c:1703">range_get_typcache</a>(fcinfo, rngtypid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PG_ARGISNULL(<span class="Constant">2</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_EXCEPTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> constructor flags argument must not be null&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; flags = <a href="#L2247" title="utils/adt/rangetypes.c:2247">range_parse_flags</a>(<a href="varlena.c.html#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>(PG_GETARG_TEXT_PP(<span class="Constant">2</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.val = PG_ARGISNULL(<span class="Constant">0</span>) ? (Datum) <span class="Constant">0</span> : arg1;<br/></li>
<li>&nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.infinite = PG_ARGISNULL(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.inclusive = (flags &amp; RANGE_LB_INC) != <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.val = PG_ARGISNULL(<span class="Constant">1</span>) ? (Datum) <span class="Constant">0</span> : arg2;<br/></li>
<li>&nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.infinite = PG_ARGISNULL(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.inclusive = (flags &amp; RANGE_UB_INC) != <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> = <a href="#L1952" title="utils/adt/rangetypes.c:1952">make_range</a>(typcache, &amp;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, &amp;<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>, <span class="Constant">false</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_RANGE_P(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> -&gt; subtype <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* extract <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound value */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L446">&#x200c;</a><span class="linkable">range_lower</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r1 = PG_GETARG_RANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; empty;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L1703" title="utils/adt/rangetypes.c:1703">range_get_typcache</a>(fcinfo, RangeTypeGetOid(r1));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(typcache, r1, &amp;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, &amp;<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>, &amp;empty);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Return NULL if there's no finite <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (empty || <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.infinite)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_DATUM(<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.val);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* extract <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound value */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L467">&#x200c;</a><span class="linkable">range_upper</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r1 = PG_GETARG_RANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; empty;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L1703" title="utils/adt/rangetypes.c:1703">range_get_typcache</a>(fcinfo, RangeTypeGetOid(r1));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(typcache, r1, &amp;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, &amp;<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>, &amp;empty);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Return NULL if there's no finite <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (empty || <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.infinite)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_DATUM(<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.val);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> -&gt; <a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a> <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* is <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> empty? */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L491">&#x200c;</a><span class="linkable">range_empty</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r1 = PG_GETARG_RANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; flags = <a href="#L1923" title="utils/adt/rangetypes.c:1923">range_get_flags</a>(r1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(flags &amp; RANGE_EMPTY);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* is <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound inclusive? */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L501">&#x200c;</a><span class="linkable">range_lower_inc</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r1 = PG_GETARG_RANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; flags = <a href="#L1923" title="utils/adt/rangetypes.c:1923">range_get_flags</a>(r1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(flags &amp; RANGE_LB_INC);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* is <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound inclusive? */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L511">&#x200c;</a><span class="linkable">range_upper_inc</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r1 = PG_GETARG_RANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; flags = <a href="#L1923" title="utils/adt/rangetypes.c:1923">range_get_flags</a>(r1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(flags &amp; RANGE_UB_INC);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* is <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound infinite? */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L521">&#x200c;</a><span class="linkable">range_lower_inf</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r1 = PG_GETARG_RANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; flags = <a href="#L1923" title="utils/adt/rangetypes.c:1923">range_get_flags</a>(r1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(flags &amp; RANGE_LB_INF);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* is <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound infinite? */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L531">&#x200c;</a><span class="linkable">range_upper_inf</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r1 = PG_GETARG_RANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; flags = <a href="#L1923" title="utils/adt/rangetypes.c:1923">range_get_flags</a>(r1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(flags &amp; RANGE_UB_INF);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> -&gt; <a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a> <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* contains? */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L544">&#x200c;</a><span class="linkable">range_contains_elem</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r = PG_GETARG_RANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; val = PG_GETARG_DATUM(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L1703" title="utils/adt/rangetypes.c:1703">range_get_typcache</a>(fcinfo, RangeTypeGetOid(r));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2627" title="utils/adt/rangetypes.c:2627">range_contains_elem_internal</a>(typcache, r, val));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* contained by? */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L557">&#x200c;</a><span class="linkable">elem_contained_by_range</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; val = PG_GETARG_DATUM(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r = PG_GETARG_RANGE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L1703" title="utils/adt/rangetypes.c:1703">range_get_typcache</a>(fcinfo, RangeTypeGetOid(r));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2627" title="utils/adt/rangetypes.c:2627">range_contains_elem_internal</a>(typcache, r, val));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> -&gt; <a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a> <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* equality (<a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> version) */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L573">&#x200c;</a></span><span class="linkable">range_eq_internal</span>(TypeCacheEntry *typcache, <span class="Type">const</span> RangeType *r1, <span class="Type">const</span> RangeType *r2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; lower1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lower2;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; upper1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; empty1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; empty2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Different types should be prevented by ANYRANGE matching rules */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> types do not match&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(typcache, r1, &amp;lower1, &amp;upper1, &amp;empty1);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(typcache, r2, &amp;lower2, &amp;upper2, &amp;empty2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (empty1 &amp;&amp; empty2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (empty1 != empty2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache, &amp;lower1, &amp;lower2) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache, &amp;upper1, &amp;upper2) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* equality */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L605">&#x200c;</a><span class="linkable">range_eq</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r1 = PG_GETARG_RANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r2 = PG_GETARG_RANGE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L1703" title="utils/adt/rangetypes.c:1703">range_get_typcache</a>(fcinfo, RangeTypeGetOid(r1));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L573" title="utils/adt/rangetypes.c:573">range_eq_internal</a>(typcache, r1, r2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* inequality (<a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> version) */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L618">&#x200c;</a></span><span class="linkable">range_ne_internal</span>(TypeCacheEntry *typcache, <span class="Type">const</span> RangeType *r1, <span class="Type">const</span> RangeType *r2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (!<a href="#L573" title="utils/adt/rangetypes.c:573">range_eq_internal</a>(typcache, r1, r2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* inequality */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L625">&#x200c;</a><span class="linkable">range_ne</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r1 = PG_GETARG_RANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r2 = PG_GETARG_RANGE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L1703" title="utils/adt/rangetypes.c:1703">range_get_typcache</a>(fcinfo, RangeTypeGetOid(r1));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L618" title="utils/adt/rangetypes.c:618">range_ne_internal</a>(typcache, r1, r2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* contains? */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L638">&#x200c;</a><span class="linkable">range_contains</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r1 = PG_GETARG_RANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r2 = PG_GETARG_RANGE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L1703" title="utils/adt/rangetypes.c:1703">range_get_typcache</a>(fcinfo, RangeTypeGetOid(r1));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2586" title="utils/adt/rangetypes.c:2586">range_contains_internal</a>(typcache, r1, r2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* contained by? */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L651">&#x200c;</a><span class="linkable">range_contained_by</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r1 = PG_GETARG_RANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r2 = PG_GETARG_RANGE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L1703" title="utils/adt/rangetypes.c:1703">range_get_typcache</a>(fcinfo, RangeTypeGetOid(r1));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2618" title="utils/adt/rangetypes.c:2618">range_contained_by_internal</a>(typcache, r1, r2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* strictly left of? (<a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> version) */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L664">&#x200c;</a></span><span class="linkable">range_before_internal</span>(TypeCacheEntry *typcache, <span class="Type">const</span> RangeType *r1, <span class="Type">const</span> RangeType *r2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; lower1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lower2;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; upper1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; empty1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; empty2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Different types should be prevented by ANYRANGE matching rules */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> types do not match&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(typcache, r1, &amp;lower1, &amp;upper1, &amp;empty1);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(typcache, r2, &amp;lower2, &amp;upper2, &amp;empty2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* An empty <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> is neither <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> nor after <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (empty1 || empty2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (<a href="#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache, &amp;upper1, &amp;lower2) &lt; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* strictly left of? */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L689">&#x200c;</a><span class="linkable">range_before</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r1 = PG_GETARG_RANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r2 = PG_GETARG_RANGE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L1703" title="utils/adt/rangetypes.c:1703">range_get_typcache</a>(fcinfo, RangeTypeGetOid(r1));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L664" title="utils/adt/rangetypes.c:664">range_before_internal</a>(typcache, r1, r2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* strictly right of? (<a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> version) */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L702">&#x200c;</a></span><span class="linkable">range_after_internal</span>(TypeCacheEntry *typcache, <span class="Type">const</span> RangeType *r1, <span class="Type">const</span> RangeType *r2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; lower1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lower2;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; upper1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; empty1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; empty2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Different types should be prevented by ANYRANGE matching rules */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> types do not match&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(typcache, r1, &amp;lower1, &amp;upper1, &amp;empty1);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(typcache, r2, &amp;lower2, &amp;upper2, &amp;empty2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* An empty <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> is neither <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> nor after <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (empty1 || empty2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (<a href="#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache, &amp;lower1, &amp;upper2) &gt; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* strictly right of? */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L727">&#x200c;</a><span class="linkable">range_after</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r1 = PG_GETARG_RANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r2 = PG_GETARG_RANGE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L1703" title="utils/adt/rangetypes.c:1703">range_get_typcache</a>(fcinfo, RangeTypeGetOid(r1));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L702" title="utils/adt/rangetypes.c:702">range_after_internal</a>(typcache, r1, r2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check if two bounds A and B are &quot;adjacent&quot;, where A is an <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound and B<br/></li>
<li></span><span class="Comment"> * is a <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound. For the bounds to be adjacent, each subtype value must<br/></li>
<li></span><span class="Comment"> * satisfy strictly one of the bounds: there are no <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> which satisfy both<br/></li>
<li></span><span class="Comment"> * bounds (i.e. less than A and greater than B); and there are no <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> which<br/></li>
<li></span><span class="Comment"> * satisfy neither bound (i.e. greater than A and less than B).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For discrete ranges, we rely on the canonicalization function to see if A..B<br/></li>
<li></span><span class="Comment"> * normalizes to empty. (If there is no canonicalization function, it's<br/></li>
<li></span><span class="Comment"> * impossible for such a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> to normalize to empty, so we needn't bother to<br/></li>
<li></span><span class="Comment"> * try.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If A == B, the ranges are adjacent only if the bounds have different<br/></li>
<li></span><span class="Comment"> * inclusive flags (i.e., exactly one of the ranges includes the common<br/></li>
<li></span><span class="Comment"> * boundary point).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * And if A &gt; B then the ranges are not adjacent in this order.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L757">&#x200c;</a></span><span class="linkable">bounds_adjacent</span>(TypeCacheEntry *typcache, RangeBound boundA, RangeBound boundB)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!boundA.<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> &amp;&amp; boundB.<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = <a href="#L2090" title="utils/adt/rangetypes.c:2090">range_cmp_bound_values</a>(typcache, &amp;boundA, &amp;boundB);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeType&nbsp; *r;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Bounds do not overlap; see if there are points in between.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* in a continuous subtype, there are assumed to be points between */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(typcache-&gt;rng_canonical_finfo.fn_oid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The bounds are of a discrete <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> type; so make a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> A..B and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * see if it's empty.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* flip the inclusion flags */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; boundA.inclusive = !boundA.inclusive;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; boundB.inclusive = !boundB.inclusive;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* change <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>/<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> labels to avoid Assert failures */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; boundA.<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; boundB.<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; r = <a href="#L1952" title="utils/adt/rangetypes.c:1952">make_range</a>(typcache, &amp;boundA, &amp;boundB, <span class="Constant">false</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> RangeIsEmpty(r);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> boundA.inclusive != boundB.inclusive;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* bounds overlap */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* adjacent to (but not overlapping)? (<a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> version) */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L798">&#x200c;</a></span><span class="linkable">range_adjacent_internal</span>(TypeCacheEntry *typcache, <span class="Type">const</span> RangeType *r1, <span class="Type">const</span> RangeType *r2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; lower1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lower2;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; upper1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; empty1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; empty2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Different types should be prevented by ANYRANGE matching rules */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> types do not match&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(typcache, r1, &amp;lower1, &amp;upper1, &amp;empty1);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(typcache, r2, &amp;lower2, &amp;upper2, &amp;empty2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* An empty <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> is not adjacent to <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (empty1 || empty2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Given two ranges A..B and C..D, the ranges are adjacent if and only if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * B is adjacent to C, or D is adjacent to A.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> (<a href="#L757" title="utils/adt/rangetypes.c:757">bounds_adjacent</a>(typcache, upper1, lower2) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L757" title="utils/adt/rangetypes.c:757">bounds_adjacent</a>(typcache, upper2, lower1));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* adjacent to (but not overlapping)? */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L828">&#x200c;</a><span class="linkable">range_adjacent</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r1 = PG_GETARG_RANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r2 = PG_GETARG_RANGE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L1703" title="utils/adt/rangetypes.c:1703">range_get_typcache</a>(fcinfo, RangeTypeGetOid(r1));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L798" title="utils/adt/rangetypes.c:798">range_adjacent_internal</a>(typcache, r1, r2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* overlaps? (<a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> version) */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L841">&#x200c;</a></span><span class="linkable">range_overlaps_internal</span>(TypeCacheEntry *typcache, <span class="Type">const</span> RangeType *r1, <span class="Type">const</span> RangeType *r2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; lower1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lower2;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; upper1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; empty1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; empty2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Different types should be prevented by ANYRANGE matching rules */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> types do not match&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(typcache, r1, &amp;lower1, &amp;upper1, &amp;empty1);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(typcache, r2, &amp;lower2, &amp;upper2, &amp;empty2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* An empty <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> does not overlap <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (empty1 || empty2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache, &amp;lower1, &amp;lower2) &gt;= <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache, &amp;lower1, &amp;upper2) &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache, &amp;lower2, &amp;lower1) &gt;= <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache, &amp;lower2, &amp;upper1) &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* overlaps? */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L874">&#x200c;</a><span class="linkable">range_overlaps</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r1 = PG_GETARG_RANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r2 = PG_GETARG_RANGE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L1703" title="utils/adt/rangetypes.c:1703">range_get_typcache</a>(fcinfo, RangeTypeGetOid(r1));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L841" title="utils/adt/rangetypes.c:841">range_overlaps_internal</a>(typcache, r1, r2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* does not extend to right of? (<a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> version) */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L887">&#x200c;</a></span><span class="linkable">range_overleft_internal</span>(TypeCacheEntry *typcache, <span class="Type">const</span> RangeType *r1, <span class="Type">const</span> RangeType *r2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; lower1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lower2;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; upper1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; empty1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; empty2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Different types should be prevented by ANYRANGE matching rules */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> types do not match&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(typcache, r1, &amp;lower1, &amp;upper1, &amp;empty1);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(typcache, r2, &amp;lower2, &amp;upper2, &amp;empty2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* An empty <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> is neither <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> nor after <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (empty1 || empty2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache, &amp;upper1, &amp;upper2) &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* does not extend to right of? */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L915">&#x200c;</a><span class="linkable">range_overleft</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r1 = PG_GETARG_RANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r2 = PG_GETARG_RANGE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L1703" title="utils/adt/rangetypes.c:1703">range_get_typcache</a>(fcinfo, RangeTypeGetOid(r1));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L887" title="utils/adt/rangetypes.c:887">range_overleft_internal</a>(typcache, r1, r2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* does not extend to left of? (<a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> version) */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L928">&#x200c;</a></span><span class="linkable">range_overright_internal</span>(TypeCacheEntry *typcache, <span class="Type">const</span> RangeType *r1, <span class="Type">const</span> RangeType *r2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; lower1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lower2;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; upper1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; empty1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; empty2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Different types should be prevented by ANYRANGE matching rules */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> types do not match&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(typcache, r1, &amp;lower1, &amp;upper1, &amp;empty1);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(typcache, r2, &amp;lower2, &amp;upper2, &amp;empty2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* An empty <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> is neither <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> nor after <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (empty1 || empty2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache, &amp;lower1, &amp;lower2) &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* does not extend to left of? */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L956">&#x200c;</a><span class="linkable">range_overright</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r1 = PG_GETARG_RANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r2 = PG_GETARG_RANGE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L1703" title="utils/adt/rangetypes.c:1703">range_get_typcache</a>(fcinfo, RangeTypeGetOid(r1));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L928" title="utils/adt/rangetypes.c:928">range_overright_internal</a>(typcache, r1, r2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> -&gt; <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* set difference */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L972">&#x200c;</a><span class="linkable">range_minus</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r1 = PG_GETARG_RANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r2 = PG_GETARG_RANGE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *ret;<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Different types should be prevented by ANYRANGE matching rules */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> types do not match&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L1703" title="utils/adt/rangetypes.c:1703">range_get_typcache</a>(fcinfo, RangeTypeGetOid(r1));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ret = <a href="#L993" title="utils/adt/rangetypes.c:993">range_minus_internal</a>(typcache, r1, r2);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ret)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_RANGE_P(ret);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>RangeType *<br/></li>
<li><a id="L993">&#x200c;</a><span class="linkable">range_minus_internal</span>(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; lower1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lower2;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; upper1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; empty1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; empty2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmp_l1l2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmp_l1u2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmp_u1l2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmp_u1u2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(typcache, r1, &amp;lower1, &amp;upper1, &amp;empty1);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(typcache, r2, &amp;lower2, &amp;upper2, &amp;empty2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if either is empty, r1 is the correct answer */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (empty1 || empty2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> r1;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cmp_l1l2 = <a href="#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache, &amp;lower1, &amp;lower2);<br/></li>
<li>&nbsp; &nbsp; cmp_l1u2 = <a href="#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache, &amp;lower1, &amp;upper2);<br/></li>
<li>&nbsp; &nbsp; cmp_u1l2 = <a href="#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache, &amp;upper1, &amp;lower2);<br/></li>
<li>&nbsp; &nbsp; cmp_u1u2 = <a href="#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache, &amp;upper1, &amp;upper2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cmp_l1l2 &lt; <span class="Constant">0</span> &amp;&amp; cmp_u1u2 &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_EXCEPTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;result of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> difference would not be contiguous&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cmp_l1u2 &gt; <span class="Constant">0</span> || cmp_u1l2 &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> r1;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cmp_l1l2 &gt;= <span class="Constant">0</span> &amp;&amp; cmp_u1u2 &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2165" title="utils/adt/rangetypes.c:2165">make_empty_range</a>(typcache);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cmp_l1l2 &lt;= <span class="Constant">0</span> &amp;&amp; cmp_u1l2 &gt;= <span class="Constant">0</span> &amp;&amp; cmp_u1u2 &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lower2.inclusive = !lower2.inclusive;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lower2.<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> = <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* it will become the <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1952" title="utils/adt/rangetypes.c:1952">make_range</a>(typcache, &amp;lower1, &amp;lower2, <span class="Constant">false</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cmp_l1l2 &gt;= <span class="Constant">0</span> &amp;&amp; cmp_u1u2 &gt;= <span class="Constant">0</span> &amp;&amp; cmp_l1u2 &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; upper2.inclusive = !upper2.inclusive;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; upper2.<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> = <span class="Constant">true</span>;&nbsp; &nbsp; <span class="Comment">/* it will become the <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1952" title="utils/adt/rangetypes.c:1952">make_range</a>(typcache, &amp;upper2, &amp;upper1, <span class="Constant">false</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected case in <a href="#L972" title="utils/adt/rangetypes.c:972">range_minus</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Set union.&nbsp; If strict is true, it is an error that the two input ranges<br/></li>
<li></span><span class="Comment"> * are not adjacent or overlapping.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>RangeType *<br/></li>
<li><a id="L1052">&#x200c;</a><span class="linkable">range_union_internal</span>(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> strict)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; lower1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lower2;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; upper1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; empty1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; empty2;<br/></li>
<li>&nbsp; &nbsp; RangeBound *result_lower;<br/></li>
<li>&nbsp; &nbsp; RangeBound *result_upper;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Different types should be prevented by ANYRANGE matching rules */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> types do not match&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(typcache, r1, &amp;lower1, &amp;upper1, &amp;empty1);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(typcache, r2, &amp;lower2, &amp;upper2, &amp;empty2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if either is empty, the other is the correct answer */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (empty1)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> r2;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (empty2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> r1;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (strict &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !DatumGetBool(<a href="#L841" title="utils/adt/rangetypes.c:841">range_overlaps_internal</a>(typcache, r1, r2)) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !DatumGetBool(<a href="#L798" title="utils/adt/rangetypes.c:798">range_adjacent_internal</a>(typcache, r1, r2)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_EXCEPTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;result of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> union would not be contiguous&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache, &amp;lower1, &amp;lower2) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result_lower = &amp;lower1;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result_lower = &amp;lower2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache, &amp;upper1, &amp;upper2) &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result_upper = &amp;upper1;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result_upper = &amp;upper2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1952" title="utils/adt/rangetypes.c:1952">make_range</a>(typcache, result_lower, result_upper, <span class="Constant">false</span>, <span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1098">&#x200c;</a><span class="linkable">range_union</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r1 = PG_GETARG_RANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r2 = PG_GETARG_RANGE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L1703" title="utils/adt/rangetypes.c:1703">range_get_typcache</a>(fcinfo, RangeTypeGetOid(r1));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_RANGE_P(<a href="#L1052" title="utils/adt/rangetypes.c:1052">range_union_internal</a>(typcache, r1, r2, <span class="Constant">true</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a>: like set union, except also allow and account for non-adjacent<br/></li>
<li></span><span class="Comment"> * input ranges.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1114">&#x200c;</a><span class="linkable">range_merge</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r1 = PG_GETARG_RANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r2 = PG_GETARG_RANGE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L1703" title="utils/adt/rangetypes.c:1703">range_get_typcache</a>(fcinfo, RangeTypeGetOid(r1));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_RANGE_P(<a href="#L1052" title="utils/adt/rangetypes.c:1052">range_union_internal</a>(typcache, r1, r2, <span class="Constant">false</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* set intersection */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1127">&#x200c;</a><span class="linkable">range_intersect</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r1 = PG_GETARG_RANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r2 = PG_GETARG_RANGE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Different types should be prevented by ANYRANGE matching rules */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> types do not match&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L1703" title="utils/adt/rangetypes.c:1703">range_get_typcache</a>(fcinfo, RangeTypeGetOid(r1));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_RANGE_P(<a href="#L1143" title="utils/adt/rangetypes.c:1143">range_intersect_internal</a>(typcache, r1, r2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>RangeType *<br/></li>
<li><a id="L1143">&#x200c;</a><span class="linkable">range_intersect_internal</span>(TypeCacheEntry *typcache, <span class="Type">const</span> RangeType *r1, <span class="Type">const</span> RangeType *r2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; lower1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lower2;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; upper1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; empty1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; empty2;<br/></li>
<li>&nbsp; &nbsp; RangeBound *result_lower;<br/></li>
<li>&nbsp; &nbsp; RangeBound *result_upper;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(typcache, r1, &amp;lower1, &amp;upper1, &amp;empty1);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(typcache, r2, &amp;lower2, &amp;upper2, &amp;empty2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (empty1 || empty2 || !<a href="#L841" title="utils/adt/rangetypes.c:841">range_overlaps_internal</a>(typcache, r1, r2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2165" title="utils/adt/rangetypes.c:2165">make_empty_range</a>(typcache);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache, &amp;lower1, &amp;lower2) &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result_lower = &amp;lower1;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result_lower = &amp;lower2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache, &amp;upper1, &amp;upper2) &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result_upper = &amp;upper1;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result_upper = &amp;upper2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1952" title="utils/adt/rangetypes.c:1952">make_range</a>(typcache, result_lower, result_upper, <span class="Constant">false</span>, <span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> -&gt; <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1182" title="utils/adt/rangetypes.c:1182">range_split_internal</a> - if r2 intersects the middle of r1, leaving non-empty<br/></li>
<li></span><span class="Comment"> * ranges on both sides, then return true and set output1 and output2 to the<br/></li>
<li></span><span class="Comment"> * results of r1 - r2 (in order). Otherwise return false and don't set output1<br/></li>
<li></span><span class="Comment"> * or output2. Neither input <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> should be empty.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1182">&#x200c;</a></span><span class="linkable">range_split_internal</span>(TypeCacheEntry *typcache, <span class="Type">const</span> RangeType *r1, <span class="Type">const</span> RangeType *r2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RangeType **output1, RangeType **output2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; lower1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lower2;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; upper1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; empty1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; empty2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(typcache, r1, &amp;lower1, &amp;upper1, &amp;empty1);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(typcache, r2, &amp;lower2, &amp;upper2, &amp;empty2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache, &amp;lower1, &amp;lower2) &lt; <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache, &amp;upper1, &amp;upper2) &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Need to invert inclusive/exclusive for the lower2 and upper2<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * points. They can't be infinite though. We're allowed to overwrite<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * these RangeBounds since they only exist locally.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; lower2.inclusive = !lower2.inclusive;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lower2.<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; upper2.inclusive = !upper2.inclusive;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; upper2.<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *output1 = <a href="#L1952" title="utils/adt/rangetypes.c:1952">make_range</a>(typcache, &amp;lower1, &amp;lower2, <span class="Constant">false</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *output2 = <a href="#L1952" title="utils/adt/rangetypes.c:1952">make_range</a>(typcache, &amp;upper2, &amp;upper1, <span class="Constant">false</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> -&gt; <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> aggregate <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L1219">&#x200c;</a><span class="linkable">range_intersect_agg_transfn</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext aggContext;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rngtypoid;<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *current;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../executor/nodeAgg.c.html#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>(fcinfo, &amp;aggContext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L1219" title="utils/adt/rangetypes.c:1219">range_intersect_agg_transfn</a> called in non-aggregate context&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rngtypoid = <a href="../fmgr/fmgr.c.html#L1910" title="utils/fmgr/fmgr.c:1910">get_fn_expr_argtype</a>(fcinfo-&gt;flinfo, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../cache/lsyscache.c.html#L2688" title="utils/cache/lsyscache.c:2688">type_is_range</a>(rngtypoid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;range_intersect_agg must be called with a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L1703" title="utils/adt/rangetypes.c:1703">range_get_typcache</a>(fcinfo, rngtypoid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* strictness ensures these are non-null */<br/></li>
<li></span>&nbsp; &nbsp; result = PG_GETARG_RANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; current = PG_GETARG_RANGE_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L1143" title="utils/adt/rangetypes.c:1143">range_intersect_internal</a>(typcache, result, current);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_RANGE_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* Btree support */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* btree comparator */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1249">&#x200c;</a><span class="linkable">range_cmp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r1 = PG_GETARG_RANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r2 = PG_GETARG_RANGE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; lower1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lower2;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; upper1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; empty1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; empty2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* recurses when subtype is a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> type */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Different types should be prevented by ANYRANGE matching rules */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> types do not match&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L1703" title="utils/adt/rangetypes.c:1703">range_get_typcache</a>(fcinfo, RangeTypeGetOid(r1));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(typcache, r1, &amp;lower1, &amp;upper1, &amp;empty1);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(typcache, r2, &amp;lower2, &amp;upper2, &amp;empty2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* For b-tree use, empty ranges sort <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> all else */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (empty1 &amp;&amp; empty2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (empty1)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (empty2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = <a href="#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache, &amp;lower1, &amp;lower2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = <a href="#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache, &amp;upper1, &amp;upper2);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(r1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(r2, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* inequality operators using the <a href="#L1249" title="utils/adt/rangetypes.c:1249">range_cmp</a> function */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1295">&#x200c;</a><span class="linkable">range_lt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = <a href="#L1249" title="utils/adt/rangetypes.c:1249">range_cmp</a>(fcinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> &lt; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1303">&#x200c;</a><span class="linkable">range_le</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = <a href="#L1249" title="utils/adt/rangetypes.c:1249">range_cmp</a>(fcinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> &lt;= <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1311">&#x200c;</a><span class="linkable">range_ge</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = <a href="#L1249" title="utils/adt/rangetypes.c:1249">range_cmp</a>(fcinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> &gt;= <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1319">&#x200c;</a><span class="linkable">range_gt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = <a href="#L1249" title="utils/adt/rangetypes.c:1249">range_cmp</a>(fcinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> &gt; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Hash support */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> value */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1330">&#x200c;</a><span class="linkable">hash_range</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r = PG_GETARG_RANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *scache;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; empty;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; flags;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; lower_hash;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; upper_hash;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* recurses when subtype is a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> type */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L1703" title="utils/adt/rangetypes.c:1703">range_get_typcache</a>(fcinfo, RangeTypeGetOid(r));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* deserialize */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(typcache, r, &amp;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, &amp;<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>, &amp;empty);<br/></li>
<li>&nbsp; &nbsp; flags = <a href="#L1923" title="utils/adt/rangetypes.c:1923">range_get_flags</a>(r);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Look up the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type's <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> function, if not done already.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; scache = typcache-&gt;rngelemtype;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(scache-&gt;hash_proc_finfo.fn_oid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scache = <a href="../cache/typcache.c.html#L346" title="utils/cache/typcache.c:346">lookup_type_cache</a>(scache-&gt;type_id, TYPECACHE_HASH_PROC_FINFO);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(scache-&gt;hash_proc_finfo.fn_oid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not identify a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> function for type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(scache-&gt;type_id))));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Apply the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> function to each bound.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RANGE_HAS_LBOUND(flags))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lower_hash = DatumGetUInt32(<a href="../fmgr/fmgr.c.html#L1129" title="utils/fmgr/fmgr.c:1129">FunctionCall1Coll</a>(&amp;scache-&gt;hash_proc_finfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typcache-&gt;rng_collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.val));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; lower_hash = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (RANGE_HAS_UBOUND(flags))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; upper_hash = DatumGetUInt32(<a href="../fmgr/fmgr.c.html#L1129" title="utils/fmgr/fmgr.c:1129">FunctionCall1Coll</a>(&amp;scache-&gt;hash_proc_finfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typcache-&gt;rng_collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.val));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; upper_hash = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Merge hashes of flags and bounds */<br/></li>
<li></span>&nbsp; &nbsp; result = hash_uint32((uint32) flags);<br/></li>
<li>&nbsp; &nbsp; result ^= lower_hash;<br/></li>
<li>&nbsp; &nbsp; result = pg_rotate_left32(result, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; result ^= upper_hash;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns 64-<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> value by hashing a value to a 64-<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> value, with a seed.<br/></li>
<li></span><span class="Comment"> * Otherwise, similar to <a href="#L1330" title="utils/adt/rangetypes.c:1330">hash_range</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1396">&#x200c;</a><span class="linkable">hash_range_extended</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r = PG_GETARG_RANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; seed = PG_GETARG_DATUM(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *scache;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; empty;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; flags;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; lower_hash;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; upper_hash;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L1703" title="utils/adt/rangetypes.c:1703">range_get_typcache</a>(fcinfo, RangeTypeGetOid(r));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(typcache, r, &amp;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, &amp;<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>, &amp;empty);<br/></li>
<li>&nbsp; &nbsp; flags = <a href="#L1923" title="utils/adt/rangetypes.c:1923">range_get_flags</a>(r);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; scache = typcache-&gt;rngelemtype;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(scache-&gt;hash_extended_proc_finfo.fn_oid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scache = <a href="../cache/typcache.c.html#L346" title="utils/cache/typcache.c:346">lookup_type_cache</a>(scache-&gt;type_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TYPECACHE_HASH_EXTENDED_PROC_FINFO);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(scache-&gt;hash_extended_proc_finfo.fn_oid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not identify a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> function for type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(scache-&gt;type_id))));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (RANGE_HAS_LBOUND(flags))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lower_hash = DatumGetUInt64(<a href="../fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(&amp;scache-&gt;hash_extended_proc_finfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typcache-&gt;rng_collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.val,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seed));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; lower_hash = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (RANGE_HAS_UBOUND(flags))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; upper_hash = DatumGetUInt64(<a href="../fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(&amp;scache-&gt;hash_extended_proc_finfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typcache-&gt;rng_collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.val,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seed));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; upper_hash = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Merge hashes of flags and bounds */<br/></li>
<li></span>&nbsp; &nbsp; result = DatumGetUInt64(hash_uint32_extended((uint32) flags,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; DatumGetInt64(seed)));<br/></li>
<li>&nbsp; &nbsp; result ^= lower_hash;<br/></li>
<li>&nbsp; &nbsp; result = ROTATE_HIGH_AND_LOW_32BITS(result);<br/></li>
<li>&nbsp; &nbsp; result ^= upper_hash;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_UINT64(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *----------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * CANONICAL FUNCTIONS<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; Functions for specific built-in <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> types.<br/></li>
<li></span><span class="Comment"> *----------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L1464">&#x200c;</a><span class="linkable">int4range_canonical</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r = PG_GETARG_RANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *escontext = fcinfo-&gt;context;<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; empty;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L1703" title="utils/adt/rangetypes.c:1703">range_get_typcache</a>(fcinfo, RangeTypeGetOid(r));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(typcache, r, &amp;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, &amp;<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>, &amp;empty);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (empty)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_RANGE_P(r);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.infinite &amp;&amp; !<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.inclusive)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; bnd = DatumGetInt32(<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.val);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Handle possible overflow manually */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlikely(bnd == PG_INT32_MAX))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;integer out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.val = Int32GetDatum(bnd + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.inclusive = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.infinite &amp;&amp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.inclusive)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; bnd = DatumGetInt32(<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.val);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Handle possible overflow manually */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlikely(bnd == PG_INT32_MAX))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;integer out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.val = Int32GetDatum(bnd + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.inclusive = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_RANGE_P(<a href="#L1727" title="utils/adt/rangetypes.c:1727">range_serialize</a>(typcache, &amp;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, &amp;<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>, escontext));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1511">&#x200c;</a><span class="linkable">int8range_canonical</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r = PG_GETARG_RANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *escontext = fcinfo-&gt;context;<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; empty;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L1703" title="utils/adt/rangetypes.c:1703">range_get_typcache</a>(fcinfo, RangeTypeGetOid(r));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(typcache, r, &amp;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, &amp;<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>, &amp;empty);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (empty)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_RANGE_P(r);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.infinite &amp;&amp; !<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.inclusive)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; bnd = DatumGetInt64(<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.val);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Handle possible overflow manually */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlikely(bnd == PG_INT64_MAX))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;bigint out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.val = <a href="../fmgr/fmgr.c.html#L1807" title="utils/fmgr/fmgr.c:1807">Int64GetDatum</a>(bnd + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.inclusive = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.infinite &amp;&amp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.inclusive)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; bnd = DatumGetInt64(<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.val);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Handle possible overflow manually */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlikely(bnd == PG_INT64_MAX))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;bigint out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.val = <a href="../fmgr/fmgr.c.html#L1807" title="utils/fmgr/fmgr.c:1807">Int64GetDatum</a>(bnd + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.inclusive = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_RANGE_P(<a href="#L1727" title="utils/adt/rangetypes.c:1727">range_serialize</a>(typcache, &amp;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, &amp;<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>, escontext));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1558">&#x200c;</a><span class="linkable">daterange_canonical</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r = PG_GETARG_RANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *escontext = fcinfo-&gt;context;<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; empty;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="#L1703" title="utils/adt/rangetypes.c:1703">range_get_typcache</a>(fcinfo, RangeTypeGetOid(r));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(typcache, r, &amp;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, &amp;<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>, &amp;empty);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (empty)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_RANGE_P(r);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.infinite &amp;&amp; !DATE_NOT_FINITE(DatumGetDateADT(<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.val)) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.inclusive)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; bnd = DatumGetDateADT(<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.val);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check for overflow -- note we already eliminated PG_INT32_MAX */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; bnd++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlikely(!IS_VALID_DATE(bnd)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;date out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.val = DateADTGetDatum(bnd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.inclusive = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.infinite &amp;&amp; !DATE_NOT_FINITE(DatumGetDateADT(<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.val)) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.inclusive)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; bnd = DatumGetDateADT(<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.val);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check for overflow -- note we already eliminated PG_INT32_MAX */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; bnd++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlikely(!IS_VALID_DATE(bnd)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;date out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.val = DateADTGetDatum(bnd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.inclusive = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_RANGE_P(<a href="#L1727" title="utils/adt/rangetypes.c:1727">range_serialize</a>(typcache, &amp;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, &amp;<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>, escontext));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *----------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * SUBTYPE_DIFF FUNCTIONS<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Functions for specific built-in <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> types.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that subtype_diff does return the difference, not the absolute value<br/></li>
<li></span><span class="Comment"> * of the difference, and it must take care to avoid overflow.<br/></li>
<li></span><span class="Comment"> * (<a href="#L1639" title="utils/adt/rangetypes.c:1639">numrange_subdiff</a> is at some risk there ...)<br/></li>
<li></span><span class="Comment"> *----------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L1621">&#x200c;</a><span class="linkable">int4range_subdiff</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; v1 = PG_GETARG_INT32(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; v2 = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8((float8) v1 - (float8) v2);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1630">&#x200c;</a><span class="linkable">int8range_subdiff</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; v1 = PG_GETARG_INT64(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; v2 = PG_GETARG_INT64(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8((float8) v1 - (float8) v2);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1639">&#x200c;</a><span class="linkable">numrange_subdiff</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; v1 = PG_GETARG_DATUM(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; v2 = PG_GETARG_DATUM(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; numresult;<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; floatresult;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; numresult = DirectFunctionCall2(<a href="numeric.c.html#L2925" title="utils/adt/numeric.c:2925">numeric_sub</a>, v1, v2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; floatresult = DatumGetFloat8(DirectFunctionCall1(<a href="numeric.c.html#L4628" title="utils/adt/numeric.c:4628">numeric_float8</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; numresult));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(floatresult);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1655">&#x200c;</a><span class="linkable">daterange_subdiff</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; v1 = PG_GETARG_INT32(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; v2 = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8((float8) v1 - (float8) v2);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1664">&#x200c;</a><span class="linkable">tsrange_subdiff</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; v1 = PG_GETARG_TIMESTAMP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; v2 = PG_GETARG_TIMESTAMP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = ((float8) v1 - (float8) v2) / USECS_PER_SEC;<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1675">&#x200c;</a><span class="linkable">tstzrange_subdiff</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; v1 = PG_GETARG_TIMESTAMP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; v2 = PG_GETARG_TIMESTAMP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = ((float8) v1 - (float8) v2) / USECS_PER_SEC;<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *----------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * SUPPORT FUNCTIONS<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; These <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> aren't in pg_proc, but are useful for<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; defining new generic <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> in C.<br/></li>
<li></span><span class="Comment"> *----------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1703" title="utils/adt/rangetypes.c:1703">range_get_typcache</a>: get cached information about a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> type<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is for use by <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-related <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> that follow the convention<br/></li>
<li></span><span class="Comment"> * of using the fn_extra field as a pointer to the type cache entry for<br/></li>
<li></span><span class="Comment"> * the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> type.&nbsp; Functions that need to cache more information than<br/></li>
<li></span><span class="Comment"> * that must fend for themselves.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TypeCacheEntry *<br/></li>
<li><a id="L1703">&#x200c;</a><span class="linkable">range_get_typcache</span>(FunctionCallInfo fcinfo, Oid rngtypid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo-&gt;flinfo-&gt;fn_extra;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (typcache == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typcache-&gt;type_id != rngtypid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typcache = <a href="../cache/typcache.c.html#L346" title="utils/cache/typcache.c:346">lookup_type_cache</a>(rngtypid, TYPECACHE_RANGE_INFO);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typcache-&gt;rngelemtype == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;type </span><span class="Special">%u</span><span class="Constant"> is not a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> type&quot;</span>, rngtypid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;flinfo-&gt;fn_extra = (<span class="Type">void</span> *) typcache;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> typcache;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1727" title="utils/adt/rangetypes.c:1727">range_serialize</a>: construct a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> value from bounds and empty-flag<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This does not force canonicalization of the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> value.&nbsp; In most cases,<br/></li>
<li></span><span class="Comment"> * external callers should only be canonicalization <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.&nbsp; Note that<br/></li>
<li></span><span class="Comment"> * we perform some datatype-independent canonicalization checks anyway.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>RangeType *<br/></li>
<li><a id="L1727">&#x200c;</a><span class="linkable">range_serialize</span>(TypeCacheEntry *typcache, RangeBound *<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, RangeBound *<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> empty, <span class="Type">struct</span> Node *escontext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a>;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; msize;<br/></li>
<li>&nbsp; &nbsp; Pointer&nbsp; &nbsp; &nbsp; &nbsp; ptr;<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; typlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; typbyval;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; typalign;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; typstorage;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; flags = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Verify <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> is not invalid on its face, and construct flags value,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * preventing <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> non-canonical combinations such as infinite+inclusive.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-&gt;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>);<br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-&gt;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (empty)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; flags |= RANGE_EMPTY;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = <a href="#L2090" title="utils/adt/rangetypes.c:2090">range_cmp_bound_values</a>(typcache, <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* error check: if <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound value is above <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>, it's wrong */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_EXCEPTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound must be less than or <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if bounds are <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>, and not both inclusive, <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> is empty */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> == <span class="Constant">0</span> &amp;&amp; !(<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-&gt;inclusive &amp;&amp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-&gt;inclusive))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags |= RANGE_EMPTY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* infinite boundaries are never inclusive */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-&gt;infinite)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags |= RANGE_LB_INF;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-&gt;inclusive)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags |= RANGE_LB_INC;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-&gt;infinite)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags |= RANGE_UB_INF;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-&gt;inclusive)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags |= RANGE_UB_INC;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fetch information about <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>'s <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type */<br/></li>
<li></span>&nbsp; &nbsp; typlen = typcache-&gt;rngelemtype-&gt;typlen;<br/></li>
<li>&nbsp; &nbsp; typbyval = typcache-&gt;rngelemtype-&gt;typbyval;<br/></li>
<li>&nbsp; &nbsp; typalign = typcache-&gt;rngelemtype-&gt;typalign;<br/></li>
<li>&nbsp; &nbsp; typstorage = typcache-&gt;rngelemtype-&gt;typstorage;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Count space for varlena header and <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> type's OID */<br/></li>
<li></span>&nbsp; &nbsp; msize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RangeType);<br/></li>
<li>&nbsp; &nbsp; Assert(msize == MAXALIGN(msize));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Count space for bounds */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RANGE_HAS_LBOUND(flags))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make sure item to be inserted is not toasted.&nbsp; It is essential that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we not insert an out-of-line toast value pointer into a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * object, for the same reasons that arrays and <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> can't contain<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * them.&nbsp; It would work to store a compressed-in-line value, but we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * prefer to decompress and then let compression be applied to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * whole <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> object if necessary.&nbsp; But, unlike arrays, we do allow<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * short-header varlena objects to stay as-is.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typlen == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-&gt;val = PointerGetDatum(PG_DETOAST_DATUM_PACKED(<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-&gt;val));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; msize = <a href="#L2683" title="utils/adt/rangetypes.c:2683">datum_compute_size</a>(msize, <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-&gt;val, typbyval, typalign,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typlen, typstorage);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (RANGE_HAS_UBOUND(flags))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make sure item to be inserted is not toasted */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typlen == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-&gt;val = PointerGetDatum(PG_DETOAST_DATUM_PACKED(<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-&gt;val));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; msize = <a href="#L2683" title="utils/adt/rangetypes.c:2683">datum_compute_size</a>(msize, <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-&gt;val, typbyval, typalign,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typlen, typstorage);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Add space for flag byte */<br/></li>
<li></span>&nbsp; &nbsp; msize += <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">char</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Note: zero-fill is required here, just as in heap tuples */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> = (RangeType *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(msize);<br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, msize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now fill in the datum */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;rangetypid = typcache-&gt;type_id;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ptr = (<span class="Type">char</span> *) (<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (RANGE_HAS_LBOUND(flags))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-&gt;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr = <a href="#L2709" title="utils/adt/rangetypes.c:2709">datum_write</a>(ptr, <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-&gt;val, typbyval, typalign, typlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typstorage);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (RANGE_HAS_UBOUND(flags))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-&gt;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr = <a href="#L2709" title="utils/adt/rangetypes.c:2709">datum_write</a>(ptr, <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-&gt;val, typbyval, typalign, typlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typstorage);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *((<span class="Type">char</span> *) ptr) = flags;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>: deconstruct a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> value<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: the given <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> object must be fully detoasted; it cannot have a<br/></li>
<li></span><span class="Comment"> * short varlena header.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that if the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type is pass-by-reference, the datums in the<br/></li>
<li></span><span class="Comment"> * RangeBound structs will be pointers into the given <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> object.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1856">&#x200c;</a></span><span class="linkable">range_deserialize</span>(TypeCacheEntry *typcache, <span class="Type">const</span> RangeType *<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeBound *<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, RangeBound *<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *empty)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; flags;<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; typlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; typbyval;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; typalign;<br/></li>
<li>&nbsp; &nbsp; Pointer&nbsp; &nbsp; &nbsp; &nbsp; ptr;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; lbound;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; ubound;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* assert caller passed the right typcache entry */<br/></li>
<li></span>&nbsp; &nbsp; Assert(RangeTypeGetOid(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>) == typcache-&gt;type_id);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fetch the flag byte from datum's last byte */<br/></li>
<li></span>&nbsp; &nbsp; flags = *((<span class="Type">const</span> <span class="Type">char</span> *) <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> + VARSIZE(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>) - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fetch information about <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>'s <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type */<br/></li>
<li></span>&nbsp; &nbsp; typlen = typcache-&gt;rngelemtype-&gt;typlen;<br/></li>
<li>&nbsp; &nbsp; typbyval = typcache-&gt;rngelemtype-&gt;typbyval;<br/></li>
<li>&nbsp; &nbsp; typalign = typcache-&gt;rngelemtype-&gt;typalign;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> data pointer just after the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> OID */<br/></li>
<li></span>&nbsp; &nbsp; ptr = (Pointer) (<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fetch <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound, if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RANGE_HAS_LBOUND(flags))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* att_align_pointer cannot be necessary here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; lbound = fetch_att(ptr, typbyval, typlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; lbound = (Datum) <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fetch <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound, if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RANGE_HAS_UBOUND(flags))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ubound = fetch_att(ptr, typbyval, typlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no need for att_addlength_pointer */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ubound = (Datum) <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* emit results */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; *empty = (flags &amp; RANGE_EMPTY) != <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-&gt;val = lbound;<br/></li>
<li>&nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-&gt;infinite = (flags &amp; RANGE_LB_INF) != <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-&gt;inclusive = (flags &amp; RANGE_LB_INC) != <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-&gt;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-&gt;val = ubound;<br/></li>
<li>&nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-&gt;infinite = (flags &amp; RANGE_UB_INF) != <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-&gt;inclusive = (flags &amp; RANGE_UB_INC) != <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-&gt;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> = <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1923" title="utils/adt/rangetypes.c:1923">range_get_flags</a>: just get the flags from a RangeType value.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is frequently useful in places that only need the flags and not<br/></li>
<li></span><span class="Comment"> * the full results of <a href="#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char<br/></li>
<li><a id="L1923">&#x200c;</a></span><span class="linkable">range_get_flags</span>(<span class="Type">const</span> RangeType *<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fetch the flag byte from datum's last byte */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> *((<span class="Type">char</span> *) <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> + VARSIZE(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>) - <span class="Constant">1</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1937" title="utils/adt/rangetypes.c:1937">range_set_contain_empty</a>: set the RANGE_CONTAIN_EMPTY <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> in the value.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is only needed in GiST operations, so we don't include a provision<br/></li>
<li></span><span class="Comment"> * for setting it in <a href="#L1727" title="utils/adt/rangetypes.c:1727">range_serialize</a>; rather, this function must be applied<br/></li>
<li></span><span class="Comment"> * afterwards.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1937">&#x200c;</a></span><span class="linkable">range_set_contain_empty</span>(RangeType *<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *flagsp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* flag byte is datum's last byte */<br/></li>
<li></span>&nbsp; &nbsp; flagsp = (<span class="Type">char</span> *) <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> + VARSIZE(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>) - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *flagsp |= RANGE_CONTAIN_EMPTY;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This both serializes and canonicalizes (if applicable) the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.<br/></li>
<li></span><span class="Comment"> * This should be used by most callers.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>RangeType *<br/></li>
<li><a id="L1952">&#x200c;</a><span class="linkable">make_range</span>(TypeCacheEntry *typcache, RangeBound *<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, RangeBound *<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> empty, <span class="Type">struct</span> Node *escontext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> = <a href="#L1727" title="utils/adt/rangetypes.c:1727">range_serialize</a>(typcache, <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>, empty, escontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (SOFT_ERROR_OCCURRED(escontext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* no need to call canonical on empty ranges ... */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(typcache-&gt;rng_canonical_finfo.fn_oid) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !RangeIsEmpty(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Do this the hard way so that we can pass escontext */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; LOCAL_FCINFO(fcinfo, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; InitFunctionCallInfoData(*fcinfo, &amp;typcache-&gt;rng_canonical_finfo, <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid, escontext, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].value = RangeTypePGetDatum(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = FunctionCallInvoke(fcinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (SOFT_ERROR_OCCURRED(escontext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Should not get a null result if there was no error */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fcinfo-&gt;isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;function </span><span class="Special">%u</span><span class="Constant"> returned NULL&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typcache-&gt;rng_canonical_finfo.fn_oid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> = DatumGetRangeTypeP(result);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compare two <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> boundary points, returning &lt;0, 0, or &gt;0 according to<br/></li>
<li></span><span class="Comment"> * whether b1 is less than, <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to, or greater than b2.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The boundaries can be <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> combination of <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> and <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>; so it's useful<br/></li>
<li></span><span class="Comment"> * for a variety of operators.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The simple case is when b1 and b2 are both finite and inclusive, in which<br/></li>
<li></span><span class="Comment"> * case the result is just a comparison of the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> held in b1 and b2.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If a bound is exclusive, then we need to know whether it's a <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound,<br/></li>
<li></span><span class="Comment"> * in which case we treat the boundary point as &quot;just greater than&quot; the held<br/></li>
<li></span><span class="Comment"> * value; or an <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound, in which case we treat the boundary point as<br/></li>
<li></span><span class="Comment"> * &quot;just less than&quot; the held value.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If a bound is infinite, it represents minus infinity (less than every other<br/></li>
<li></span><span class="Comment"> * point) if it's a <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound; or plus infinity (greater than every other<br/></li>
<li></span><span class="Comment"> * point) if it's an <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * There is only one case where two boundaries <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> but are not<br/></li>
<li></span><span class="Comment"> * identical: when both bounds are inclusive and hold the same finite value,<br/></li>
<li></span><span class="Comment"> * but one is an <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound and the other a <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L2016">&#x200c;</a></span><span class="linkable">range_cmp_bounds</span>(TypeCacheEntry *typcache, <span class="Type">const</span> RangeBound *b1, <span class="Type">const</span> RangeBound *b2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First, handle cases involving infinity, which don't require invoking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the comparison proc.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (b1-&gt;infinite &amp;&amp; b2-&gt;infinite)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Both are infinity, so they are <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> unless one is <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> and the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * other not.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (b1-&gt;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> == b2-&gt;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> b1-&gt;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> ? -<span class="Constant">1</span> : <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (b1-&gt;infinite)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> b1-&gt;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> ? -<span class="Constant">1</span> : <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (b2-&gt;infinite)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> b2-&gt;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> ? <span class="Constant">1</span> : -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Both boundaries are finite, so <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> the held <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; result = DatumGetInt32(<a href="../fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(&amp;typcache-&gt;rng_cmp_proc_finfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typcache-&gt;rng_collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; b1-&gt;val, b2-&gt;val));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the comparison is anything other than <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>, we're done. If they<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> though, we still have to consider whether the boundaries<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are inclusive or exclusive.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (result == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!b1-&gt;inclusive &amp;&amp; !b2-&gt;inclusive)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* both are exclusive */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (b1-&gt;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> == b2-&gt;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> b1-&gt;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> ? <span class="Constant">1</span> : -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!b1-&gt;inclusive)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> b1-&gt;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> ? <span class="Constant">1</span> : -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!b2-&gt;inclusive)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> b2-&gt;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> ? -<span class="Constant">1</span> : <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Both are inclusive and the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> held are <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>, so they are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> regardless of whether they are <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> or <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> boundaries,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * or a mix.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compare two <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> boundary point <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, returning &lt;0, 0, or &gt;0 according<br/></li>
<li></span><span class="Comment"> * to whether b1 is less than, <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to, or greater than b2.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is similar to but simpler than <a href="#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>().&nbsp; We just <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a><br/></li>
<li></span><span class="Comment"> * the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> held in b1 and b2, ignoring inclusive/exclusive flags.&nbsp; The<br/></li>
<li></span><span class="Comment"> * <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>/<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> flags only matter for infinities, where they tell us if the<br/></li>
<li></span><span class="Comment"> * infinity is plus or minus.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L2090">&#x200c;</a></span><span class="linkable">range_cmp_bound_values</span>(TypeCacheEntry *typcache, <span class="Type">const</span> RangeBound *b1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> RangeBound *b2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First, handle cases involving infinity, which don't require invoking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the comparison proc.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (b1-&gt;infinite &amp;&amp; b2-&gt;infinite)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Both are infinity, so they are <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> unless one is <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> and the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * other not.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (b1-&gt;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> == b2-&gt;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> b1-&gt;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> ? -<span class="Constant">1</span> : <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (b1-&gt;infinite)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> b1-&gt;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> ? -<span class="Constant">1</span> : <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (b2-&gt;infinite)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> b2-&gt;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> ? <span class="Constant">1</span> : -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Both boundaries are finite, so <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> the held <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> DatumGetInt32(<a href="../fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(&amp;typcache-&gt;rng_cmp_proc_finfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typcache-&gt;rng_collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; b1-&gt;val, b2-&gt;val));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * qsort callback for sorting ranges.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Two empty ranges <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>; an empty <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> sorts to the left of <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * non-empty <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.&nbsp; Two non-empty ranges are sorted by <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound first<br/></li>
<li></span><span class="Comment"> * and by <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L2129">&#x200c;</a></span><span class="linkable">range_compare</span>(<span class="Type">const</span> <span class="Type">void</span> *key1, <span class="Type">const</span> <span class="Type">void</span> *key2, <span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r1 = *(RangeType **) key1;<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r2 = *(RangeType **) key2;<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache = (TypeCacheEntry *) arg;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; lower1;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; upper1;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; lower2;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; upper2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; empty1;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; empty2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(typcache, r1, &amp;lower1, &amp;upper1, &amp;empty1);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(typcache, r2, &amp;lower2, &amp;upper2, &amp;empty2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (empty1 &amp;&amp; empty2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (empty1)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (empty2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = <a href="#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache, &amp;lower1, &amp;lower2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = <a href="#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache, &amp;upper1, &amp;upper2);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Build an empty <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> value of the type indicated by the typcache entry.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>RangeType *<br/></li>
<li><a id="L2165">&#x200c;</a><span class="linkable">make_empty_range</span>(TypeCacheEntry *typcache)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.val = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.infinite = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.inclusive = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.val = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.infinite = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.inclusive = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1952" title="utils/adt/rangetypes.c:1952">make_range</a>(typcache, &amp;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, &amp;<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>, <span class="Constant">true</span>, <span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Planner support function for <a href="#L557" title="utils/adt/rangetypes.c:557">elem_contained_by_range</a> (&lt;@ operator).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2187">&#x200c;</a><span class="linkable">elem_contained_by_range_support</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *rawreq = (Node *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *ret = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(rawreq, SupportRequestSimplify))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SupportRequestSimplify *req = (SupportRequestSimplify *) rawreq;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FuncExpr&nbsp;&nbsp; *fexpr = req-&gt;fcall;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *leftop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *rightop;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(list_length(fexpr-&gt;args) == <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; leftop = linitial(fexpr-&gt;args);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rightop = lsecond(fexpr-&gt;args);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ret = <a href="#L2786" title="utils/adt/rangetypes.c:2786">find_simplified_clause</a>(req-&gt;root, rightop, leftop);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(ret);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Planner support function for <a href="#L544" title="utils/adt/rangetypes.c:544">range_contains_elem</a> (@&gt; operator).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2213">&#x200c;</a><span class="linkable">range_contains_elem_support</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *rawreq = (Node *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *ret = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(rawreq, SupportRequestSimplify))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SupportRequestSimplify *req = (SupportRequestSimplify *) rawreq;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FuncExpr&nbsp;&nbsp; *fexpr = req-&gt;fcall;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *leftop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *rightop;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(list_length(fexpr-&gt;args) == <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; leftop = linitial(fexpr-&gt;args);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rightop = lsecond(fexpr-&gt;args);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ret = <a href="#L2786" title="utils/adt/rangetypes.c:2786">find_simplified_clause</a>(req-&gt;root, leftop, rightop);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(ret);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *----------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * STATIC FUNCTIONS<br/></li>
<li></span><span class="Comment"> *----------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Given a string representing the flags for the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> type, return the flags<br/></li>
<li></span><span class="Comment"> * represented as a char.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char<br/></li>
<li><a id="L2247">&#x200c;</a></span><span class="linkable">range_parse_flags</span>(<span class="Type">const</span> <span class="Type">char</span> *flags_str)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; flags = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (flags_str[<span class="Constant">0</span>] == <span class="Special">'\0'</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; flags_str[<span class="Constant">1</span>] == <span class="Special">'\0'</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; flags_str[<span class="Constant">2</span>] != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> bound flags&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Valid <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are </span><span class="Special">\&quot;</span><span class="Constant">[]</span><span class="Special">\&quot;</span><span class="Constant">, </span><span class="Special">\&quot;</span><span class="Constant">[)</span><span class="Special">\&quot;</span><span class="Constant">, </span><span class="Special">\&quot;</span><span class="Constant">(]</span><span class="Special">\&quot;</span><span class="Constant">, and </span><span class="Special">\&quot;</span><span class="Constant">()</span><span class="Special">\&quot;</span><span class="Constant">.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (flags_str[<span class="Constant">0</span>])<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'['</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags |= RANGE_LB_INC;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'('</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> bound flags&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Valid <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are </span><span class="Special">\&quot;</span><span class="Constant">[]</span><span class="Special">\&quot;</span><span class="Constant">, </span><span class="Special">\&quot;</span><span class="Constant">[)</span><span class="Special">\&quot;</span><span class="Constant">, </span><span class="Special">\&quot;</span><span class="Constant">(]</span><span class="Special">\&quot;</span><span class="Constant">, and </span><span class="Special">\&quot;</span><span class="Constant">()</span><span class="Special">\&quot;</span><span class="Constant">.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (flags_str[<span class="Constant">1</span>])<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">']'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags |= RANGE_UB_INC;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">')'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> bound flags&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Valid <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are </span><span class="Special">\&quot;</span><span class="Constant">[]</span><span class="Special">\&quot;</span><span class="Constant">, </span><span class="Special">\&quot;</span><span class="Constant">[)</span><span class="Special">\&quot;</span><span class="Constant">, </span><span class="Special">\&quot;</span><span class="Constant">(]</span><span class="Special">\&quot;</span><span class="Constant">, and </span><span class="Special">\&quot;</span><span class="Constant">()</span><span class="Special">\&quot;</span><span class="Constant">.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> flags;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Parse <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> input.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Input parameters:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; string: input string to be parsed<br/></li>
<li></span><span class="Comment"> * Output parameters:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; *flags: receives flags bitmask<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; *lbound_str: receives <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound string, or NULL if <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; *ubound_str: receives <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound string, or NULL if <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is modeled somewhat after <a href="rowtypes.c.html#L74" title="utils/adt/rowtypes.c:74">record_in</a> in rowtypes.c.<br/></li>
<li></span><span class="Comment"> * The input syntax is:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &lt;<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&gt;&nbsp;&nbsp; := <a href="../../regex/regcomp.c.html#L328" title="regex/regcomp.c:328">EMPTY</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; | &lt;lb-inc&gt; &lt;string&gt;, &lt;string&gt; &lt;ub-inc&gt;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &lt;lb-inc&gt;&nbsp; := '[' | '('<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &lt;ub-inc&gt;&nbsp; := ']' | ')'<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Whitespace <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> or after &lt;<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&gt; is ignored.&nbsp; Whitespace within a &lt;string&gt;<br/></li>
<li></span><span class="Comment"> * is taken literally and becomes part of the input string for that bound.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A &lt;string&gt; of length zero is taken as &quot;infinite&quot; (i.e. no bound), unless it<br/></li>
<li></span><span class="Comment"> * is surrounded by double-quotes, in which case it is the literal empty<br/></li>
<li></span><span class="Comment"> * string.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Within a &lt;string&gt;, special characters (such as comma, parenthesis, or<br/></li>
<li></span><span class="Comment"> * brackets) can be enclosed in double-quotes or escaped with backslash. Within<br/></li>
<li></span><span class="Comment"> * double-quotes, a double-quote can be escaped with double-quote or backslash.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true on success, false on failure (but failures will return only if<br/></li>
<li></span><span class="Comment"> * escontext is an ErrorSaveContext).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2322">&#x200c;</a></span><span class="linkable">range_parse</span>(<span class="Type">const</span> <span class="Type">char</span> *string, <span class="Type">char</span> *flags, <span class="Type">char</span> **lbound_str,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span> **ubound_str, Node *escontext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *ptr = string;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; infinite;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *flags = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* consume whitespace */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (*ptr != <span class="Special">'\0'</span> &amp;&amp; isspace((<span class="Type">unsigned</span> <span class="Type">char</span>) *ptr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check for empty <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pg_strncasecmp(ptr, RANGE_EMPTY_LITERAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; strlen(RANGE_EMPTY_LITERAL)) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *flags = RANGE_EMPTY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *lbound_str = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *ubound_str = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr += strlen(RANGE_EMPTY_LITERAL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the rest should be whitespace */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (*ptr != <span class="Special">'\0'</span> &amp;&amp; isspace((<span class="Type">unsigned</span> <span class="Type">char</span>) *ptr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* should have consumed everything */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*ptr != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;malformed <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> literal: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; string),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Junk after </span><span class="Special">\&quot;</span><span class="Constant">empty</span><span class="Special">\&quot;</span><span class="Constant"> key <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a>.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*ptr == <span class="Constant">'['</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *flags |= RANGE_LB_INC;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*ptr == <span class="Constant">'('</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr++;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;malformed <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> literal: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; string),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Missing left parenthesis or <a href="../../regex/regcomp.c.html#L1671" title="regex/regcomp.c:1671">bracket</a>.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ptr = <a href="#L2438" title="utils/adt/rangetypes.c:2438">range_parse_bound</a>(string, ptr, lbound_str, &amp;infinite, escontext);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ptr == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (infinite)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *flags |= RANGE_LB_INF;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*ptr == <span class="Constant">','</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr++;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;malformed <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> literal: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; string),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Missing comma after <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ptr = <a href="#L2438" title="utils/adt/rangetypes.c:2438">range_parse_bound</a>(string, ptr, ubound_str, &amp;infinite, escontext);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ptr == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (infinite)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *flags |= RANGE_UB_INF;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*ptr == <span class="Constant">']'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *flags |= RANGE_UB_INC;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*ptr == <span class="Constant">')'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr++;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* must be a comma */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;malformed <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> literal: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; string),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Too many commas.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* consume whitespace */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (*ptr != <span class="Special">'\0'</span> &amp;&amp; isspace((<span class="Type">unsigned</span> <span class="Type">char</span>) *ptr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*ptr != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;malformed <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> literal: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; string),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Junk after right parenthesis or <a href="../../regex/regcomp.c.html#L1671" title="regex/regcomp.c:1671">bracket</a>.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Helper for <a href="#L2322" title="utils/adt/rangetypes.c:2322">range_parse</a>: <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> and de-quote one bound string.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We scan until finding comma, right parenthesis, or right <a href="../../regex/regcomp.c.html#L1671" title="regex/regcomp.c:1671">bracket</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Input parameters:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; string: entire input string (used only for error reports)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; ptr: where to start parsing bound<br/></li>
<li></span><span class="Comment"> * Output parameters:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; *bound_str: receives <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d bound string, or NULL if <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; *infinite: set true if no bound, else false<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The return value is the scan ptr, advanced past the bound string.<br/></li>
<li></span><span class="Comment"> * However, if escontext is an ErrorSaveContext, we return NULL on failure.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">const</span> <span class="Type">char</span> *<br/></li>
<li><a id="L2438">&#x200c;</a><span class="linkable">range_parse_bound</span>(<span class="Type">const</span> <span class="Type">char</span> *string, <span class="Type">const</span> <span class="Type">char</span> *ptr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span> **bound_str, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *infinite, Node *escontext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for null: completely empty input means null */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (*ptr == <span class="Constant">','</span> || *ptr == <span class="Constant">')'</span> || *ptr == <span class="Constant">']'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *bound_str = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *infinite = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Extract string for this bound */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; inquote = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; initStringInfo(&amp;buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (inquote || !(*ptr == <span class="Constant">','</span> || *ptr == <span class="Constant">')'</span> || *ptr == <span class="Constant">']'</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; ch = *ptr++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ch == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;malformed <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> literal: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; string),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Unexpected end of input.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ch == <span class="Special">'\\'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*ptr == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;malformed <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> literal: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; string),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Unexpected end of input.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(&amp;buf, *ptr++);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (ch == <span class="Constant">'&quot;'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!inquote)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inquote = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*ptr == <span class="Constant">'&quot;'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* doubled quote within quote sequence */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(&amp;buf, *ptr++);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inquote = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(&amp;buf, ch);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *bound_str = buf.data;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *infinite = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ptr;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert a deserialized <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> value to text form<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Inputs are the flags byte, and the two bound <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> already converted to<br/></li>
<li></span><span class="Comment"> * text (but not yet quoted).&nbsp; If no bound value, pass NULL.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Result is a <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d string<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L2507">&#x200c;</a><span class="linkable">range_deparse</span>(<span class="Type">char</span> flags, <span class="Type">const</span> <span class="Type">char</span> *lbound_str, <span class="Type">const</span> <span class="Type">char</span> *ubound_str)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (flags &amp; RANGE_EMPTY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(RANGE_EMPTY_LITERAL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfoChar(&amp;buf, (flags &amp; RANGE_LB_INC) ? <span class="Constant">'['</span> : <span class="Constant">'('</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (RANGE_HAS_LBOUND(flags))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;buf, <a href="#L2537" title="utils/adt/rangetypes.c:2537">range_bound_escape</a>(lbound_str));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfoChar(&amp;buf, <span class="Constant">','</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (RANGE_HAS_UBOUND(flags))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;buf, <a href="#L2537" title="utils/adt/rangetypes.c:2537">range_bound_escape</a>(ubound_str));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfoChar(&amp;buf, (flags &amp; RANGE_UB_INC) ? <span class="Constant">']'</span> : <span class="Constant">')'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> buf.data;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Helper for <a href="#L2507" title="utils/adt/rangetypes.c:2507">range_deparse</a>: quote a bound value as needed<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Result is a <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d string<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L2537">&#x200c;</a><span class="linkable">range_bound_escape</span>(<span class="Type">const</span> <span class="Type">char</span> *value)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nq;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *ptr;<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Detect whether we need double quotes for this value */<br/></li>
<li></span>&nbsp; &nbsp; nq = (value[<span class="Constant">0</span>] == <span class="Special">'\0'</span>);&nbsp; &nbsp; <span class="Comment">/* force quotes for empty string */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (ptr = value; *ptr; ptr++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; ch = *ptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ch == <span class="Constant">'&quot;'</span> || ch == <span class="Special">'\\'</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ch == <span class="Constant">'('</span> || ch == <span class="Constant">')'</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ch == <span class="Constant">'['</span> || ch == <span class="Constant">']'</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ch == <span class="Constant">','</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isspace((<span class="Type">unsigned</span> <span class="Type">char</span>) ch))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nq = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And emit the string */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nq)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(&amp;buf, <span class="Constant">'&quot;'</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (ptr = value; *ptr; ptr++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; ch = *ptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ch == <span class="Constant">'&quot;'</span> || ch == <span class="Special">'\\'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(&amp;buf, ch);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(&amp;buf, ch);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nq)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(&amp;buf, <span class="Constant">'&quot;'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> buf.data;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Test whether <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> r1 contains <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> r2.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller has already checked that they are the same <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> type, and looked up<br/></li>
<li></span><span class="Comment"> * the necessary typcache entry.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2586">&#x200c;</a></span><span class="linkable">range_contains_internal</span>(TypeCacheEntry *typcache, <span class="Type">const</span> RangeType *r1, <span class="Type">const</span> RangeType *r2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; lower1;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; upper1;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; empty1;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; lower2;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; upper2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; empty2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Different types should be prevented by ANYRANGE matching rules */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> types do not match&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(typcache, r1, &amp;lower1, &amp;upper1, &amp;empty1);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(typcache, r2, &amp;lower2, &amp;upper2, &amp;empty2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If either <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> is empty, the answer is easy */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (empty2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (empty1)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Else we must have lower1 &lt;= lower2 and upper1 &gt;= upper2 */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache, &amp;lower1, &amp;lower2) &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache, &amp;upper1, &amp;upper2) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2618">&#x200c;</a></span><span class="linkable">range_contained_by_internal</span>(TypeCacheEntry *typcache, <span class="Type">const</span> RangeType *r1, <span class="Type">const</span> RangeType *r2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2586" title="utils/adt/rangetypes.c:2586">range_contains_internal</a>(typcache, r2, r1);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Test whether <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> r contains a specific <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> value.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2627">&#x200c;</a></span><span class="linkable">range_contains_elem_internal</span>(TypeCacheEntry *typcache, <span class="Type">const</span> RangeType *r, Datum val)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; empty;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(typcache, r, &amp;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, &amp;<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>, &amp;empty);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (empty)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.infinite)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = DatumGetInt32(<a href="../fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(&amp;typcache-&gt;rng_cmp_proc_finfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typcache-&gt;rng_collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.val, val));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> == <span class="Constant">0</span> &amp;&amp; !<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.inclusive)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.infinite)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = DatumGetInt32(<a href="../fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(&amp;typcache-&gt;rng_cmp_proc_finfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typcache-&gt;rng_collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.val, val));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> == <span class="Constant">0</span> &amp;&amp; !<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.inclusive)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2683" title="utils/adt/rangetypes.c:2683">datum_compute_size</a>() and <a href="#L2709" title="utils/adt/rangetypes.c:2709">datum_write</a>() are used to insert the bound<br/></li>
<li></span><span class="Comment"> * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> into a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> object.&nbsp; They are modeled after heaptuple.c's<br/></li>
<li></span><span class="Comment"> * <a href="../../access/common/heaptuple.c.html#L215" title="access/common/heaptuple.c:215">heap_compute_data_size</a>() and <a href="../../access/common/heaptuple.c.html#L400" title="access/common/heaptuple.c:400">heap_fill_tuple</a>(), but we need not handle<br/></li>
<li></span><span class="Comment"> * null <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> here.&nbsp; <a href="#L2675" title="utils/adt/rangetypes.c:2675">TYPE_IS_PACKABLE</a> must test the same conditions as<br/></li>
<li></span><span class="Comment"> * heaptuple.c's <a href="../../access/common/heaptuple.c.html#L80" title="access/common/heaptuple.c:80">ATT_IS_PACKABLE</a> macro.&nbsp; See the comments there for more<br/></li>
<li></span><span class="Comment"> * details.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Does datatype allow packing into the 1-byte-header varlena format? */<br/></li>
<li><a id="L2675">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">TYPE_IS_PACKABLE</span>(typlen, typstorage) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((typlen) == -</span><span class="Constant">1</span><span class="PreProc"> &amp;&amp; (typstorage) != TYPSTORAGE_PLAIN)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Increment data_length by the space needed by the datum, including <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * preceding alignment padding.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Size<br/></li>
<li><a id="L2683">&#x200c;</a><span class="linkable">datum_compute_size</span>(Size data_length, Datum val, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> typbyval, <span class="Type">char</span> typalign,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; int16 typlen, <span class="Type">char</span> typstorage)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2675" title="utils/adt/rangetypes.c:2675">TYPE_IS_PACKABLE</a>(typlen, typstorage) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; VARATT_CAN_MAKE_SHORT(DatumGetPointer(val)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we're anticipating converting to a short varlena header, so adjust<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * length and don't count <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> alignment<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; data_length += VARATT_CONVERTED_SHORT_SIZE(DatumGetPointer(val));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; data_length = att_align_datum(data_length, typalign, typlen, val);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; data_length = att_addlength_datum(data_length, typlen, val);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> data_length;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write the given datum beginning at ptr (after advancing to correct<br/></li>
<li></span><span class="Comment"> * alignment, if needed).&nbsp; Return the pointer incremented by space used.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Pointer<br/></li>
<li><a id="L2709">&#x200c;</a><span class="linkable">datum_write</span>(Pointer ptr, Datum datum, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> typbyval, <span class="Type">char</span> typalign,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int16 typlen, <span class="Type">char</span> typstorage)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; data_length;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (typbyval)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* pass-by-value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ptr = (<span class="Type">char</span> *) att_align_nominal(ptr, typalign);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; store_att_byval(ptr, datum, typlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; data_length = typlen;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (typlen == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* varlena */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Pointer&nbsp; &nbsp; &nbsp; &nbsp; val = DatumGetPointer(datum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (VARATT_IS_EXTERNAL(val))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Throw error, because we must never put a toast pointer inside a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> object.&nbsp; Caller should have detoasted it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot store a toast pointer inside a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data_length = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (VARATT_IS_SHORT(val))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no alignment for short varlenas */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data_length = VARSIZE_SHORT(val);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(ptr, val, data_length);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L2675" title="utils/adt/rangetypes.c:2675">TYPE_IS_PACKABLE</a>(typlen, typstorage) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VARATT_CAN_MAKE_SHORT(val))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* convert to short varlena -- no alignment */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data_length = VARATT_CONVERTED_SHORT_SIZE(val);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_VARSIZE_SHORT(ptr, data_length);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(ptr + <span class="Constant">1</span>, VARDATA(val), data_length - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* full 4-byte header varlena */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr = (<span class="Type">char</span> *) att_align_nominal(ptr, typalign);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data_length = VARSIZE(val);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(ptr, val, data_length);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (typlen == -<span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* cstring ... never needs alignment */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(typalign == TYPALIGN_CHAR);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; data_length = strlen(DatumGetCString(datum)) + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(ptr, DatumGetPointer(datum), data_length);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fixed-length pass-by-reference */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ptr = (<span class="Type">char</span> *) att_align_nominal(ptr, typalign);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(typlen &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; data_length = typlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(ptr, DatumGetPointer(datum), data_length);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ptr += data_length;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ptr;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Common code for the <a href="#L557" title="utils/adt/rangetypes.c:557">elem_contained_by_range</a> and <a href="#L544" title="utils/adt/rangetypes.c:544">range_contains_elem</a><br/></li>
<li></span><span class="Comment"> * support <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.&nbsp; The caller has extracted the function argument<br/></li>
<li></span><span class="Comment"> * expressions, and swapped them if necessary to pass the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> first.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns a simplified replacement expression, or NULL if we can't simplify.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Node *<br/></li>
<li><a id="L2786">&#x200c;</a><span class="linkable">find_simplified_clause</span>(PlannerInfo *root, Expr *rangeExpr, Expr *elemExpr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>;<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *rangetypcache;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; empty;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* can't do anything unless the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> is a non-null constant */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!IsA(rangeExpr, Const) || ((Const *) rangeExpr)-&gt;constisnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> = DatumGetRangeTypeP(((Const *) rangeExpr)-&gt;constvalue);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rangetypcache = <a href="../cache/typcache.c.html#L346" title="utils/cache/typcache.c:346">lookup_type_cache</a>(RangeTypeGetOid(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TYPECACHE_RANGE_INFO);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rangetypcache-&gt;rngelemtype == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;type </span><span class="Special">%u</span><span class="Constant"> is not a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> type&quot;</span>, RangeTypeGetOid(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(rangetypcache, <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, &amp;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, &amp;<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>, &amp;empty);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (empty)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> is empty, then there can be no matches */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../nodes/makefuncs.c.html#L359" title="nodes/makefuncs.c:359">makeBoolConst</a>(<span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.infinite &amp;&amp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.infinite)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> has infinite bounds, so it matches everything */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../nodes/makefuncs.c.html#L359" title="nodes/makefuncs.c:359">makeBoolConst</a>(<span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* at least one bound is available, we have something to work with */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; TypeCacheEntry *elemTypcache = rangetypcache-&gt;rngelemtype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opfamily = rangetypcache-&gt;rng_opfamily;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rng_collation = rangetypcache-&gt;rng_collation;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *lowerExpr = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *upperExpr = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.infinite &amp;&amp; !<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.infinite)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When both bounds are present, we have a problem: the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * &quot;simplified&quot; clause would need to evaluate the elemExpr twice.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * That's definitely not okay if the elemExpr is volatile, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it's also unattractive if the elemExpr is expensive.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QualCost&nbsp; &nbsp; eval_cost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../optimizer/util/clauses.c.html#L538" title="optimizer/util/clauses.c:538">contain_volatile_functions</a>((Node *) elemExpr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We define &quot;expensive&quot; as &quot;contains <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> subplan or more than 10<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * operators&quot;.&nbsp; Note that the subplan search has to be done<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * explicitly, since <a href="../../optimizer/path/costsize.c.html#L4640" title="optimizer/path/costsize.c:4640">cost_qual_eval</a>() will barf on unplanned<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * subselects.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../optimizer/util/clauses.c.html#L330" title="optimizer/util/clauses.c:330">contain_subplans</a>((Node *) elemExpr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../optimizer/path/costsize.c.html#L4666" title="optimizer/path/costsize.c:4666">cost_qual_eval_node</a>(&amp;eval_cost, (Node *) elemExpr, root);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (eval_cost.startup + eval_cost.per_tuple &gt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">10</span> * <a href="../../optimizer/path/costsize.c.html#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Okay, try to build boundary comparison expressions */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.infinite)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lowerExpr = <a href="#L2908" title="utils/adt/rangetypes.c:2908">build_bound_expr</a>(elemExpr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.val,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.inclusive,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; elemTypcache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; opfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rng_collation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lowerExpr == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.infinite)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Copy the elemExpr if we need two copies */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.infinite)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elemExpr = copyObject(elemExpr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upperExpr = <a href="#L2908" title="utils/adt/rangetypes.c:2908">build_bound_expr</a>(elemExpr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.val,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.inclusive,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; elemTypcache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; opfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rng_collation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (upperExpr == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lowerExpr != <span class="Constant">NULL</span> &amp;&amp; upperExpr != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) <a href="../../nodes/makefuncs.c.html#L654" title="nodes/makefuncs.c:654">make_andclause</a>(list_make2(lowerExpr, upperExpr));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (lowerExpr != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) lowerExpr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (upperExpr != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) upperExpr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Helper function for <a href="#L2786" title="utils/adt/rangetypes.c:2786">find_simplified_clause</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Build the expression (elemExpr Operator val), where the operator is<br/></li>
<li></span><span class="Comment"> * the appropriate member of the given opfamily depending on<br/></li>
<li></span><span class="Comment"> * isLowerBound and isInclusive.&nbsp; typeCache is the typcache entry for<br/></li>
<li></span><span class="Comment"> * the &quot;val&quot; value (presently, this will be the same type as elemExpr).<br/></li>
<li></span><span class="Comment"> * rng_collation is the collation to use in the comparison.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return NULL on failure (if, for some reason, we can't <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the operator).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Expr *<br/></li>
<li><a id="L2908">&#x200c;</a><span class="linkable">build_bound_expr</span>(Expr *elemExpr, Datum val,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isLowerBound, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isInclusive,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TypeCacheEntry *typeCache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid opfamily, Oid rng_collation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elemType = typeCache-&gt;type_id;<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; elemTypeLen = typeCache-&gt;typlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; elemByValue = typeCache-&gt;typbyval;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elemCollation = typeCache-&gt;typcollation;<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; strategy;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oproid;<br/></li>
<li>&nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *constExpr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Identify the comparison operator to use */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isLowerBound)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; strategy = isInclusive ? BTGreaterEqualStrategyNumber : BTGreaterStrategyNumber;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; strategy = isInclusive ? BTLessEqualStrategyNumber : BTLessStrategyNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We could use <a href="../../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>(elemExpr) here, if it ever becomes possible that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * elemExpr is not the exact same type as the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> elements.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; oproid = <a href="../cache/lsyscache.c.html#L166" title="utils/cache/lsyscache.c:166">get_opfamily_member</a>(opfamily, elemType, elemType, strategy);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We don't really expect failure here, but just in case ... */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(oproid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* OK, convert &quot;val&quot; to a full-fledged Const node, and make the OpExpr */<br/></li>
<li></span>&nbsp; &nbsp; constExpr = (Expr *) <a href="../../nodes/makefuncs.c.html#L301" title="nodes/makefuncs.c:301">makeConst</a>(elemType,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; elemCollation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; elemTypeLen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; val,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; elemByValue);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../nodes/makefuncs.c.html#L628" title="nodes/makefuncs.c:628">make_opclause</a>(oproid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BOOLOID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; elemExpr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; constExpr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rng_collation);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
