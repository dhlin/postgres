<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/adt/amutils.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/adt/amutils.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L31">am_propnames</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L25">am_propname</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L151">indexam_property</a></li>
<li><a href="#L90">lookup_prop_name</a></li>
<li><a href="#L433">pg_index_column_has_property</a></li>
<li><a href="#L421">pg_index_has_property</a></li>
<li><a href="#L409">pg_indexam_has_property</a></li>
<li><a href="#L451">pg_indexam_progress_phasename</a></li>
<li><a href="#L117">test_indoption</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * amutils.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; SQL-level APIs related to index access methods.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Copyright (c) 2016-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/adt/amutils.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/amapi.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_class.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_index.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/syscache.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* Convert string property name to enum, for efficiency */<br/></li>
<li><a id="L25">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">am_propname</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *name;<br/></li>
<li>&nbsp; &nbsp; IndexAMProperty prop;<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><a id="L31">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> <span class="Type">struct</span> <a href="#L25" title="utils/adt/amutils.c:25">am_propname</a> <span class="linkable">am_propnames</span>[] =<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;asc&quot;</span>, AMPROP_ASC<br/></li>
<li>&nbsp; &nbsp; },<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;desc&quot;</span>, AMPROP_DESC<br/></li>
<li>&nbsp; &nbsp; },<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;nulls_first&quot;</span>, AMPROP_NULLS_FIRST<br/></li>
<li>&nbsp; &nbsp; },<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;nulls_last&quot;</span>, AMPROP_NULLS_LAST<br/></li>
<li>&nbsp; &nbsp; },<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;orderable&quot;</span>, AMPROP_ORDERABLE<br/></li>
<li>&nbsp; &nbsp; },<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;distance_orderable&quot;</span>, AMPROP_DISTANCE_ORDERABLE<br/></li>
<li>&nbsp; &nbsp; },<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;returnable&quot;</span>, AMPROP_RETURNABLE<br/></li>
<li>&nbsp; &nbsp; },<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;search_array&quot;</span>, AMPROP_SEARCH_ARRAY<br/></li>
<li>&nbsp; &nbsp; },<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;search_nulls&quot;</span>, AMPROP_SEARCH_NULLS<br/></li>
<li>&nbsp; &nbsp; },<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;clusterable&quot;</span>, AMPROP_CLUSTERABLE<br/></li>
<li>&nbsp; &nbsp; },<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;index_scan&quot;</span>, AMPROP_INDEX_SCAN<br/></li>
<li>&nbsp; &nbsp; },<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;bitmap_scan&quot;</span>, AMPROP_BITMAP_SCAN<br/></li>
<li>&nbsp; &nbsp; },<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;backward_scan&quot;</span>, AMPROP_BACKWARD_SCAN<br/></li>
<li>&nbsp; &nbsp; },<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;can_order&quot;</span>, AMPROP_CAN_ORDER<br/></li>
<li>&nbsp; &nbsp; },<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;can_unique&quot;</span>, AMPROP_CAN_UNIQUE<br/></li>
<li>&nbsp; &nbsp; },<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;can_multi_col&quot;</span>, AMPROP_CAN_MULTI_COL<br/></li>
<li>&nbsp; &nbsp; },<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;can_exclude&quot;</span>, AMPROP_CAN_EXCLUDE<br/></li>
<li>&nbsp; &nbsp; },<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;can_include&quot;</span>, AMPROP_CAN_INCLUDE<br/></li>
<li>&nbsp; &nbsp; },<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><span class="Type">static</span> IndexAMProperty<br/></li>
<li><a id="L90">&#x200c;</a><span class="linkable">lookup_prop_name</span>(<span class="Type">const</span> <span class="Type">char</span> *name)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; lengthof(<a href="#L31" title="utils/adt/amutils.c:31">am_propnames</a>); i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pg_strcasecmp(<a href="#L31" title="utils/adt/amutils.c:31">am_propnames</a>[i].name, name) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L31" title="utils/adt/amutils.c:31">am_propnames</a>[i].prop;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We do not throw an error, so that AMs can define their own properties */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> AMPROP_UNKNOWN;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Common code for properties that are just <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> tests of indoptions.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * tuple: the pg_index heaptuple<br/></li>
<li></span><span class="Comment"> * attno: identify the index column to test the indoptions of.<br/></li>
<li></span><span class="Comment"> * guard: if false, a boolean false result is forced (saves code in caller).<br/></li>
<li></span><span class="Comment"> * iopt_mask: mask for interesting indoption <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>.<br/></li>
<li></span><span class="Comment"> * iopt_expect: value for a &quot;true&quot; result (should be 0 or iopt_mask).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns false to indicate a NULL result (for &quot;unknown/inapplicable&quot;),<br/></li>
<li></span><span class="Comment"> * otherwise sets *res to the boolean value to return.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L117">&#x200c;</a></span><span class="linkable">test_indoption</span>(HeapTuple tuple, <span class="Type">int</span> attno, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> guard,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; int16 iopt_mask, int16 iopt_expect,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *res)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; datum;<br/></li>
<li>&nbsp; &nbsp; int2vector *indoption;<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; indoption_val;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!guard)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *res = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; datum = <a href="../cache/syscache.c.html#L510" title="utils/cache/syscache.c:510">SysCacheGetAttrNotNull</a>(INDEXRELID, tuple, Anum_pg_index_indoption);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; indoption = ((int2vector *) DatumGetPointer(datum));<br/></li>
<li>&nbsp; &nbsp; indoption_val = indoption-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[attno - <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *res = (indoption_val &amp; iopt_mask) == iopt_expect;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Test property of an index AM, index, or index column.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is common code for different SQL-level funcs, so the amoid and<br/></li>
<li></span><span class="Comment"> * index_oid parameters are mutually exclusive; we look up the amoid from the<br/></li>
<li></span><span class="Comment"> * index_oid if needed, or if no index oid is given, we're looking at AM-wide<br/></li>
<li></span><span class="Comment"> * properties.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Datum<br/></li>
<li><a id="L151">&#x200c;</a><span class="linkable">indexam_property</span>(FunctionCallInfo fcinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *propname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid amoid, Oid index_oid, <span class="Type">int</span> attno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; res = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; natts = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; IndexAMProperty prop;<br/></li>
<li>&nbsp; &nbsp; IndexAmRoutine *routine;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Try to convert property name to enum (no error if not known) */<br/></li>
<li></span>&nbsp; &nbsp; prop = <a href="#L90" title="utils/adt/amutils.c:90">lookup_prop_name</a>(propname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we have an index OID, look up the AM, and get # of columns too */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(index_oid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_class rd_rel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!OidIsValid(amoid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple = <a href="../cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(RELOID, ObjectIdGetDatum(index_oid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rd_rel = (Form_pg_class) GETSTRUCT(tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rd_rel-&gt;relkind != RELKIND_INDEX &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rd_rel-&gt;relkind != RELKIND_PARTITIONED_INDEX)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; amoid = rd_rel-&gt;relam;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; natts = rd_rel-&gt;relnatts;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * At this point, either index_oid == InvalidOid or it's a valid index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * OID. Also, after this test and the one below, either attno == 0 for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * index-wide or AM-wide tests, or it's a valid column number in a valid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (attno &lt; <span class="Constant">0</span> || attno &gt; natts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get AM information.&nbsp; If we don't have a valid AM OID, return NULL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; routine = <a href="../../access/index/amapi.c.html#L56" title="access/index/amapi.c:56">GetIndexAmRoutineByAmId</a>(amoid, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (routine == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there's an AM property routine, give it a chance to override the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * generic logic.&nbsp; Proceed if it returns false.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (routine-&gt;amproperty &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; routine-&gt;amproperty(index_oid, attno, prop, propname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;res, &amp;isnull))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(res);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (attno &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_index rd_index;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; iskey = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Handle column-level properties. Many of these need the pg_index row<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (which we also need to use to check for nonkey atts) so we fetch<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that first.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tuple = <a href="../cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(INDEXRELID, ObjectIdGetDatum(index_oid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rd_index = (Form_pg_index) GETSTRUCT(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(index_oid == rd_index-&gt;indexrelid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(attno &gt; <span class="Constant">0</span> &amp;&amp; attno &lt;= rd_index-&gt;indnatts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; isnull = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If amcaninclude, we might be looking at an attno for a nonkey<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * column, for which we (generically) assume that most properties are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * null.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (routine-&gt;amcaninclude<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; attno &gt; rd_index-&gt;indnkeyatts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iskey = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (prop)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AMPROP_ASC:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (iskey &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L117" title="utils/adt/amutils.c:117">test_indoption</a>(tuple, attno, routine-&gt;amcanorder,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; INDOPTION_DESC, <span class="Constant">0</span>, &amp;res))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AMPROP_DESC:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (iskey &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L117" title="utils/adt/amutils.c:117">test_indoption</a>(tuple, attno, routine-&gt;amcanorder,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; INDOPTION_DESC, INDOPTION_DESC, &amp;res))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AMPROP_NULLS_FIRST:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (iskey &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L117" title="utils/adt/amutils.c:117">test_indoption</a>(tuple, attno, routine-&gt;amcanorder,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; INDOPTION_NULLS_FIRST, INDOPTION_NULLS_FIRST, &amp;res))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AMPROP_NULLS_LAST:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (iskey &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L117" title="utils/adt/amutils.c:117">test_indoption</a>(tuple, attno, routine-&gt;amcanorder,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; INDOPTION_NULLS_FIRST, <span class="Constant">0</span>, &amp;res))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AMPROP_ORDERABLE:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * generic assumption is that nonkey columns are not orderable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = iskey ? routine-&gt;amcanorder : <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AMPROP_DISTANCE_ORDERABLE:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The conditions for whether a column is distance-orderable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * are really up to the AM (at time of writing, only GiST<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * supports it at all). The <a href="../../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> has its own idea based on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * whether it finds an operator with amoppurpose 'o', but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * getting there from just the index column type seems like a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lot of work. So instead we expect the AM to handle this in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * its amproperty routine. The generic result is to return<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * false if the AM says it never supports this, or if this is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a nonkey column, and null otherwise (meaning we don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * know).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!iskey || !routine-&gt;amcanorderbyop)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AMPROP_RETURNABLE:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* note that we ignore iskey for this property */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (routine-&gt;amcanreturn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If possible, the AM should handle this test in its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * amproperty function without opening the rel. But this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is the generic fallback if it does not.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; indexrel = <a href="../../access/index/indexam.c.html#L133" title="access/index/indexam.c:133">index_open</a>(index_oid, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <a href="../../access/index/indexam.c.html#L788" title="access/index/indexam.c:788">index_can_return</a>(indexrel, attno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/index/indexam.c.html#L177" title="access/index/indexam.c:177">index_close</a>(indexrel, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AMPROP_SEARCH_ARRAY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (iskey)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = routine-&gt;amsearcharray;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AMPROP_SEARCH_NULLS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (iskey)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = routine-&gt;amsearchnulls;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(res);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(index_oid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Handle index-level properties.&nbsp; Currently, these only depend on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * AM, but that might not be true forever, so we make users name an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * index not just an AM.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (prop)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AMPROP_CLUSTERABLE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(routine-&gt;amclusterable);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AMPROP_INDEX_SCAN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(routine-&gt;amgettuple ? <span class="Constant">true</span> : <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AMPROP_BITMAP_SCAN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(routine-&gt;amgetbitmap ? <span class="Constant">true</span> : <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AMPROP_BACKWARD_SCAN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(routine-&gt;amcanbackward);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Handle AM-level properties (those that control what you can say in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * CREATE INDEX).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (prop)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AMPROP_CAN_ORDER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(routine-&gt;amcanorder);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AMPROP_CAN_UNIQUE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(routine-&gt;amcanunique);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AMPROP_CAN_MULTI_COL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(routine-&gt;amcanmulticol);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AMPROP_CAN_EXCLUDE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(routine-&gt;amgettuple ? <span class="Constant">true</span> : <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AMPROP_CAN_INCLUDE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(routine-&gt;amcaninclude);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Test property of an AM specified by AM OID<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L409">&#x200c;</a><span class="linkable">pg_indexam_has_property</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; amoid = PG_GETARG_OID(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *propname = <a href="varlena.c.html#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>(PG_GETARG_TEXT_PP(<span class="Constant">1</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L151" title="utils/adt/amutils.c:151">indexam_property</a>(fcinfo, propname, amoid, InvalidOid, <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Test property of an index specified by index OID<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L421">&#x200c;</a><span class="linkable">pg_index_has_property</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid = PG_GETARG_OID(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *propname = <a href="varlena.c.html#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>(PG_GETARG_TEXT_PP(<span class="Constant">1</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L151" title="utils/adt/amutils.c:151">indexam_property</a>(fcinfo, propname, InvalidOid, relid, <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Test property of an index column specified by index OID and column number<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L433">&#x200c;</a><span class="linkable">pg_index_column_has_property</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid = PG_GETARG_OID(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; attno = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *propname = <a href="varlena.c.html#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>(PG_GETARG_TEXT_PP(<span class="Constant">2</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reject attno 0 immediately, so that attno &gt; 0 identifies this case */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (attno &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L151" title="utils/adt/amutils.c:151">indexam_property</a>(fcinfo, propname, InvalidOid, relid, attno);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the name of the given phase, as used for progress reporting by the<br/></li>
<li></span><span class="Comment"> * given AM.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L451">&#x200c;</a><span class="linkable">pg_indexam_progress_phasename</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; amoid = PG_GETARG_OID(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; phasenum = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; IndexAmRoutine *routine;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *name;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; routine = <a href="../../access/index/amapi.c.html#L56" title="access/index/amapi.c:56">GetIndexAmRoutineByAmId</a>(amoid, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (routine == <span class="Constant">NULL</span> || !routine-&gt;ambuildphasename)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; name = routine-&gt;ambuildphasename(phasenum);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!name)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_DATUM(CStringGetTextDatum(name));<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
