<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/adt/uuid.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/adt/uuid.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L33">uuid_sortsupport_state</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L411">gen_random_uuid</a></li>
<li><a href="#L95">string_to_uuid</a></li>
<li><a href="#L292">uuid_abbrev_abort</a></li>
<li><a href="#L358">uuid_abbrev_convert</a></li>
<li><a href="#L229">uuid_cmp</a></li>
<li><a href="#L192">uuid_eq</a></li>
<li><a href="#L438">uuid_extract_timestamp</a></li>
<li><a href="#L479">uuid_extract_version</a></li>
<li><a href="#L277">uuid_fast_cmp</a></li>
<li><a href="#L201">uuid_ge</a></li>
<li><a href="#L210">uuid_gt</a></li>
<li><a href="#L395">uuid_hash</a></li>
<li><a href="#L403">uuid_hash_extended</a></li>
<li><a href="#L42">uuid_in</a></li>
<li><a href="#L168">uuid_internal_cmp</a></li>
<li><a href="#L183">uuid_le</a></li>
<li><a href="#L174">uuid_lt</a></li>
<li><a href="#L219">uuid_ne</a></li>
<li><a href="#L53">uuid_out</a></li>
<li><a href="#L145">uuid_recv</a></li>
<li><a href="#L156">uuid_send</a></li>
<li><a href="#L241">uuid_sortsupport</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L430">UUIDV1_EPOCH_JDATE</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * uuid.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Functions for the built-in type &quot;uuid&quot;.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Copyright (c) 2007-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/adt/uuid.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;common/hashfn.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lib/hyperloglog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/pqformat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;port/pg_bswap.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgrprotos.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/guc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/sortsupport.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/timestamp.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/uuid.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* sortsupport for uuid */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; input_count;&nbsp; &nbsp; <span class="Comment">/* number of non-null <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> seen */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; estimating;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* true if estimating cardinality */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; hyperLogLogState abbr_card; <span class="Comment">/* cardinality estimator */<br/></li>
<li><a id="L33">&#x200c;</a></span>} <span class="linkable">uuid_sortsupport_state</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L95" title="utils/adt/uuid.c:95">string_to_uuid</a>(<span class="Type">const</span> <span class="Type">char</span> *source, pg_uuid_t *uuid, Node *escontext);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L168" title="utils/adt/uuid.c:168">uuid_internal_cmp</a>(<span class="Type">const</span> pg_uuid_t *arg1, <span class="Type">const</span> pg_uuid_t *arg2);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L277" title="utils/adt/uuid.c:277">uuid_fast_cmp</a>(Datum x, Datum y, SortSupport ssup);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L292" title="utils/adt/uuid.c:292">uuid_abbrev_abort</a>(<span class="Type">int</span> memtupcount, SortSupport ssup);<br/></li>
<li><span class="Type">static</span> Datum <a href="#L358" title="utils/adt/uuid.c:358">uuid_abbrev_convert</a>(Datum original, SortSupport ssup);<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L42">&#x200c;</a><span class="linkable">uuid_in</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *uuid_str = PG_GETARG_CSTRING(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; pg_uuid_t&nbsp; *uuid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; uuid = (pg_uuid_t *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(*uuid));<br/></li>
<li>&nbsp; &nbsp; <a href="#L95" title="utils/adt/uuid.c:95">string_to_uuid</a>(uuid_str, uuid, fcinfo-&gt;context);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_UUID_P(uuid);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L53">&#x200c;</a><span class="linkable">uuid_out</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pg_uuid_t&nbsp; *uuid = PG_GETARG_UUID_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">const</span> <span class="Type">char</span> hex_chars[] = <span class="Constant">&quot;0123456789abcdef&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *p;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* counts for the four hyphens and the zero-terminator */<br/></li>
<li></span>&nbsp; &nbsp; buf = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Constant">2</span> * UUID_LEN + <span class="Constant">5</span>);<br/></li>
<li>&nbsp; &nbsp; p = buf;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; UUID_LEN; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hi;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We <a href="../../nodes/print.c.html#L36" title="nodes/print.c:36">print</a> uuid <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> as a string of 8, 4, 4, 4, and then 12<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * hexadecimal characters, with each group is separated by a hyphen<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (&quot;-&quot;). Therefore, add the hyphens at the appropriate places here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i == <span class="Constant">4</span> || i == <span class="Constant">6</span> || i == <span class="Constant">8</span> || i == <span class="Constant">10</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *p++ = <span class="Constant">'-'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hi = uuid-&gt;data[i] &gt;&gt; <span class="Constant">4</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lo = uuid-&gt;data[i] &amp; <span class="Constant">0x0F</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *p++ = hex_chars[hi];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *p++ = hex_chars[lo];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; *p = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CSTRING(buf);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * We allow UUIDs as a series of 32 hexadecimal digits with an optional dash<br/></li>
<li></span><span class="Comment"> * after each group of 4 hexadecimal digits, and optionally surrounded by {}.<br/></li>
<li></span><span class="Comment"> * (The canonical format 8x-4x-4x-4x-12x, where &quot;nx&quot; means n hexadecimal<br/></li>
<li></span><span class="Comment"> * digits, is the only one used for output.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L95">&#x200c;</a></span><span class="linkable">string_to_uuid</span>(<span class="Type">const</span> <span class="Type">char</span> *source, pg_uuid_t *uuid, Node *escontext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *src = source;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; braces = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (src[<span class="Constant">0</span>] == <span class="Constant">'{'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; src++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; braces = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; UUID_LEN; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; str_buf[<span class="Constant">3</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (src[<span class="Constant">0</span>] == <span class="Special">'\0'</span> || src[<span class="Constant">1</span>] == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> syntax_error;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(str_buf, src, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!isxdigit((<span class="Type">unsigned</span> <span class="Type">char</span>) str_buf[<span class="Constant">0</span>]) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !isxdigit((<span class="Type">unsigned</span> <span class="Type">char</span>) str_buf[<span class="Constant">1</span>]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> syntax_error;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; str_buf[<span class="Constant">2</span>] = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uuid-&gt;data[i] = (<span class="Type">unsigned</span> <span class="Type">char</span>) strtoul(str_buf, <span class="Constant">NULL</span>, <span class="Constant">16</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; src += <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (src[<span class="Constant">0</span>] == <span class="Constant">'-'</span> &amp;&amp; (i % <span class="Constant">2</span>) == <span class="Constant">1</span> &amp;&amp; i &lt; UUID_LEN - <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; src++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (braces)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*src != <span class="Constant">'}'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> syntax_error;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; src++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*src != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> syntax_error;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li><span class="Statement">syntax_error</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; ereturn(escontext,,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid input syntax for type </span><span class="Special">%s</span><span class="Constant">: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;uuid&quot;</span>, source)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L145">&#x200c;</a><span class="linkable">uuid_recv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; buffer = (StringInfo) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; pg_uuid_t&nbsp; *uuid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; uuid = (pg_uuid_t *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(UUID_LEN);<br/></li>
<li>&nbsp; &nbsp; memcpy(uuid-&gt;data, <a href="../../libpq/pqformat.c.html#L508" title="libpq/pqformat.c:508">pq_getmsgbytes</a>(buffer, UUID_LEN), UUID_LEN);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(uuid);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L156">&#x200c;</a><span class="linkable">uuid_send</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pg_uuid_t&nbsp; *uuid = PG_GETARG_UUID_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; StringInfoData buffer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L326" title="libpq/pqformat.c:326">pq_begintypsend</a>(&amp;buffer);<br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L126" title="libpq/pqformat.c:126">pq_sendbytes</a>(&amp;buffer, uuid-&gt;data, UUID_LEN);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BYTEA_P(<a href="../../libpq/pqformat.c.html#L346" title="libpq/pqformat.c:346">pq_endtypsend</a>(&amp;buffer));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> uuid <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> function */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L168">&#x200c;</a></span><span class="linkable">uuid_internal_cmp</span>(<span class="Type">const</span> pg_uuid_t *arg1, <span class="Type">const</span> pg_uuid_t *arg2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> memcmp(arg1-&gt;data, arg2-&gt;data, UUID_LEN);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L174">&#x200c;</a><span class="linkable">uuid_lt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pg_uuid_t&nbsp; *arg1 = PG_GETARG_UUID_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; pg_uuid_t&nbsp; *arg2 = PG_GETARG_UUID_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L168" title="utils/adt/uuid.c:168">uuid_internal_cmp</a>(arg1, arg2) &lt; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L183">&#x200c;</a><span class="linkable">uuid_le</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pg_uuid_t&nbsp; *arg1 = PG_GETARG_UUID_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; pg_uuid_t&nbsp; *arg2 = PG_GETARG_UUID_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L168" title="utils/adt/uuid.c:168">uuid_internal_cmp</a>(arg1, arg2) &lt;= <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L192">&#x200c;</a><span class="linkable">uuid_eq</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pg_uuid_t&nbsp; *arg1 = PG_GETARG_UUID_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; pg_uuid_t&nbsp; *arg2 = PG_GETARG_UUID_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L168" title="utils/adt/uuid.c:168">uuid_internal_cmp</a>(arg1, arg2) == <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L201">&#x200c;</a><span class="linkable">uuid_ge</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pg_uuid_t&nbsp; *arg1 = PG_GETARG_UUID_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; pg_uuid_t&nbsp; *arg2 = PG_GETARG_UUID_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L168" title="utils/adt/uuid.c:168">uuid_internal_cmp</a>(arg1, arg2) &gt;= <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L210">&#x200c;</a><span class="linkable">uuid_gt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pg_uuid_t&nbsp; *arg1 = PG_GETARG_UUID_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; pg_uuid_t&nbsp; *arg2 = PG_GETARG_UUID_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L168" title="utils/adt/uuid.c:168">uuid_internal_cmp</a>(arg1, arg2) &gt; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L219">&#x200c;</a><span class="linkable">uuid_ne</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pg_uuid_t&nbsp; *arg1 = PG_GETARG_UUID_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; pg_uuid_t&nbsp; *arg2 = PG_GETARG_UUID_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L168" title="utils/adt/uuid.c:168">uuid_internal_cmp</a>(arg1, arg2) != <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* handler for btree index operator */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L229">&#x200c;</a><span class="linkable">uuid_cmp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pg_uuid_t&nbsp; *arg1 = PG_GETARG_UUID_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; pg_uuid_t&nbsp; *arg2 = PG_GETARG_UUID_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(<a href="#L168" title="utils/adt/uuid.c:168">uuid_internal_cmp</a>(arg1, arg2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Sort support strategy routine<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L241">&#x200c;</a><span class="linkable">uuid_sortsupport</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SortSupport ssup = (SortSupport) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ssup-&gt;comparator = <a href="#L277" title="utils/adt/uuid.c:277">uuid_fast_cmp</a>;<br/></li>
<li>&nbsp; &nbsp; ssup-&gt;ssup_extra = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ssup-&gt;abbreviate)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L33" title="utils/adt/uuid.c:33">uuid_sortsupport_state</a> *uss;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(ssup-&gt;ssup_cxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uss = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L33" title="utils/adt/uuid.c:33">uuid_sortsupport_state</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uss-&gt;input_count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uss-&gt;estimating = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../lib/hyperloglog.c.html#L66" title="lib/hyperloglog.c:66">initHyperLogLog</a>(&amp;uss-&gt;abbr_card, <span class="Constant">10</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ssup-&gt;ssup_extra = uss;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ssup-&gt;comparator = <a href="../sort/tuplesort.c.html#L3177" title="utils/sort/tuplesort.c:3177">ssup_datum_unsigned_cmp</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ssup-&gt;abbrev_converter = <a href="#L358" title="utils/adt/uuid.c:358">uuid_abbrev_convert</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ssup-&gt;abbrev_abort = <a href="#L292" title="utils/adt/uuid.c:292">uuid_abbrev_abort</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ssup-&gt;abbrev_full_comparator = <a href="#L277" title="utils/adt/uuid.c:277">uuid_fast_cmp</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VOID();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * SortSupport comparison func<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L277">&#x200c;</a></span><span class="linkable">uuid_fast_cmp</span>(Datum x, Datum y, SortSupport ssup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pg_uuid_t&nbsp; *arg1 = DatumGetUUIDP(x);<br/></li>
<li>&nbsp; &nbsp; pg_uuid_t&nbsp; *arg2 = DatumGetUUIDP(y);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L168" title="utils/adt/uuid.c:168">uuid_internal_cmp</a>(arg1, arg2);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Callback for estimating effectiveness of abbreviated key optimization.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We pay no attention to the cardinality of the non-abbreviated data, because<br/></li>
<li></span><span class="Comment"> * there is no equality fast-path within authoritative uuid comparator.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L292">&#x200c;</a></span><span class="linkable">uuid_abbrev_abort</span>(<span class="Type">int</span> memtupcount, SortSupport ssup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L33" title="utils/adt/uuid.c:33">uuid_sortsupport_state</a> *uss = ssup-&gt;ssup_extra;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; abbr_card;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (memtupcount &lt; <span class="Constant">10000</span> || uss-&gt;input_count &lt; <span class="Constant">10000</span> || !uss-&gt;estimating)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; abbr_card = <a href="../../lib/hyperloglog.c.html#L186" title="lib/hyperloglog.c:186">estimateHyperLogLog</a>(&amp;uss-&gt;abbr_card);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we have &gt;100k distinct <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, then even if we were sorting many<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * billion rows we'd likely still break even, and the penalty of undoing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that many rows of abbrevs would probably not be worth it.&nbsp; Stop even<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * counting at that point.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (abbr_card &gt; <span class="Constant">100000.0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li><span class="PreProc">#ifdef TRACE_SORT<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../sort/tuplesort.c.html#L124" title="utils/sort/tuplesort.c:124">trace_sort</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;uuid_abbrev: estimation ends at cardinality </span><span class="Special">%f</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot; after &quot;</span> INT64_FORMAT <span class="Constant">&quot; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> (</span><span class="Special">%d</span><span class="Constant"> rows)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; abbr_card, uss-&gt;input_count, memtupcount);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; uss-&gt;estimating = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Target minimum cardinality is 1 per ~2k of non-null inputs.&nbsp; 0.5 row<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fudge factor allows us to abort earlier on genuinely pathological data<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * where we've had exactly one abbreviated value in the first 2k<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (non-null) rows.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (abbr_card &lt; uss-&gt;input_count / <span class="Constant">2000.0</span> + <span class="Constant">0.5</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li><span class="PreProc">#ifdef TRACE_SORT<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../sort/tuplesort.c.html#L124" title="utils/sort/tuplesort.c:124">trace_sort</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;uuid_abbrev: aborting abbreviation at cardinality </span><span class="Special">%f</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot; below threshold </span><span class="Special">%f</span><span class="Constant"> after &quot;</span> INT64_FORMAT <span class="Constant">&quot; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> (</span><span class="Special">%d</span><span class="Constant"> rows)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; abbr_card, uss-&gt;input_count / <span class="Constant">2000.0</span> + <span class="Constant">0.5</span>, uss-&gt;input_count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; memtupcount);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef TRACE_SORT<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../sort/tuplesort.c.html#L124" title="utils/sort/tuplesort.c:124">trace_sort</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;uuid_abbrev: cardinality </span><span class="Special">%f</span><span class="Constant"> after &quot;</span> INT64_FORMAT<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> (</span><span class="Special">%d</span><span class="Constant"> rows)&quot;</span>, abbr_card, uss-&gt;input_count, memtupcount);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Conversion routine for sortsupport.&nbsp; Converts original uuid representation<br/></li>
<li></span><span class="Comment"> * to abbreviated key representation.&nbsp; Our encoding strategy is simple -- pack<br/></li>
<li></span><span class="Comment"> * the first `<a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a>(Datum)` bytes of uuid data into a Datum (on little-endian<br/></li>
<li></span><span class="Comment"> * machines, the bytes are stored in reverse order), and treat it as an<br/></li>
<li></span><span class="Comment"> * unsigned integer.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Datum<br/></li>
<li><a id="L358">&#x200c;</a><span class="linkable">uuid_abbrev_convert</span>(Datum original, SortSupport ssup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L33" title="utils/adt/uuid.c:33">uuid_sortsupport_state</a> *uss = ssup-&gt;ssup_extra;<br/></li>
<li>&nbsp; &nbsp; pg_uuid_t&nbsp; *authoritative = DatumGetUUIDP(original);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memcpy(&amp;res, authoritative-&gt;data, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li>&nbsp; &nbsp; uss-&gt;input_count += <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (uss-&gt;estimating)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; tmp;<br/></li>
<li><br/></li>
<li><span class="PreProc">#if SIZEOF_DATUM == </span><span class="Constant">8<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tmp = (uint32) res ^ (uint32) ((uint64) res &gt;&gt; <span class="Constant">32</span>);<br/></li>
<li><span class="PreProc">#else</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* SIZEOF_DATUM != 8 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tmp = (uint32) res;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../lib/hyperloglog.c.html#L167" title="lib/hyperloglog.c:167">addHyperLogLog</a>(&amp;uss-&gt;abbr_card, DatumGetUInt32(hash_uint32(tmp)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Byteswap on little-endian machines.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is needed so that <a href="../sort/tuplesort.c.html#L3177" title="utils/sort/tuplesort.c:3177">ssup_datum_unsigned_cmp</a>() (an unsigned integer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 3-way comparator) works correctly on all platforms.&nbsp; If we didn't do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this, the comparator would have to call memcmp() with a pair of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pointers to the first byte of each abbreviated key, which is slower.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; res = DatumBigEndianToNative(res);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> index support */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L395">&#x200c;</a><span class="linkable">uuid_hash</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pg_uuid_t&nbsp; *key = PG_GETARG_UUID_P(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> hash_any(key-&gt;data, UUID_LEN);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L403">&#x200c;</a><span class="linkable">uuid_hash_extended</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pg_uuid_t&nbsp; *key = PG_GETARG_UUID_P(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> hash_any_extended(key-&gt;data, UUID_LEN, PG_GETARG_INT64(<span class="Constant">1</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L411">&#x200c;</a><span class="linkable">gen_random_uuid</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pg_uuid_t&nbsp; *uuid = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(UUID_LEN);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!pg_strong_random(uuid, UUID_LEN))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INTERNAL_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not generate random <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set magic numbers for a &quot;version 4&quot; (pseudorandom) UUID, see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * http://tools.ietf.org/html/rfc4122#section-4.4<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; uuid-&gt;data[<span class="Constant">6</span>] = (uuid-&gt;data[<span class="Constant">6</span>] &amp; <span class="Constant">0x0f</span>) | <span class="Constant">0x40</span>;&nbsp; &nbsp; <span class="Comment">/* time_hi_and_version */<br/></li>
<li></span>&nbsp; &nbsp; uuid-&gt;data[<span class="Constant">8</span>] = (uuid-&gt;data[<span class="Constant">8</span>] &amp; <span class="Constant">0x3f</span>) | <span class="Constant">0x80</span>;&nbsp; &nbsp; <span class="Comment">/* clock_seq_hi_and_reserved */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_UUID_P(uuid);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L430">&#x200c;</a><span class="PreProc">#define <span class="linkable">UUIDV1_EPOCH_JDATE</span>&nbsp; </span><span class="Constant">2299161</span><span class="PreProc"> </span><span class="Comment">/* == <a href="datetime.c.html#L286" title="utils/adt/datetime.c:286">date2j</a>(1582,10,15) */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Extract timestamp from UUID.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns null if not RFC 4122 variant or not a version that has a timestamp.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L438">&#x200c;</a><span class="linkable">uuid_extract_timestamp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pg_uuid_t&nbsp; *uuid = PG_GETARG_UUID_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; version;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; tms;<br/></li>
<li>&nbsp; &nbsp; TimestampTz ts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check if RFC 4122 variant */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((uuid-&gt;data[<span class="Constant">8</span>] &amp; <span class="Constant">0xc0</span>) != <span class="Constant">0x80</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; version = uuid-&gt;data[<span class="Constant">6</span>] &gt;&gt; <span class="Constant">4</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (version == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tms = ((uint64) uuid-&gt;data[<span class="Constant">0</span>] &lt;&lt; <span class="Constant">24</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; + ((uint64) uuid-&gt;data[<span class="Constant">1</span>] &lt;&lt; <span class="Constant">16</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; + ((uint64) uuid-&gt;data[<span class="Constant">2</span>] &lt;&lt; <span class="Constant">8</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; + ((uint64) uuid-&gt;data[<span class="Constant">3</span>])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; + ((uint64) uuid-&gt;data[<span class="Constant">4</span>] &lt;&lt; <span class="Constant">40</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; + ((uint64) uuid-&gt;data[<span class="Constant">5</span>] &lt;&lt; <span class="Constant">32</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; + (((uint64) uuid-&gt;data[<span class="Constant">6</span>] &amp; <span class="Constant">0xf</span>) &lt;&lt; <span class="Constant">56</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; + ((uint64) uuid-&gt;data[<span class="Constant">7</span>] &lt;&lt; <span class="Constant">48</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* convert 100-ns intervals to us, then adjust */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ts = (TimestampTz) (tms / <span class="Constant">10</span>) -<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((uint64) POSTGRES_EPOCH_JDATE - <a href="#L430" title="utils/adt/uuid.c:430">UUIDV1_EPOCH_JDATE</a>) * SECS_PER_DAY * USECS_PER_SEC;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_TIMESTAMPTZ(ts);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* not a timestamp-containing UUID version */<br/></li>
<li></span>&nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Extract UUID version.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns null if not RFC 4122 variant.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L479">&#x200c;</a><span class="linkable">uuid_extract_version</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pg_uuid_t&nbsp; *uuid = PG_GETARG_UUID_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; version;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check if RFC 4122 variant */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((uuid-&gt;data[<span class="Constant">8</span>] &amp; <span class="Constant">0xc0</span>) != <span class="Constant">0x80</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; version = uuid-&gt;data[<span class="Constant">6</span>] &gt;&gt; <span class="Constant">4</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_UINT16(version);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
