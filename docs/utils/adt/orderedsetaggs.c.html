<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/adt/orderedsetaggs.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/adt/orderedsetaggs.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L500">LerpFunc</a></li>
<li><a href="#L92">OSAPerGroupState</a></li>
<li><a href="#L104">OSAPerGroupState</a></li>
<li><a href="#L49">OSAPerQueryState</a></li>
<li><a href="#L90">OSAPerQueryState</a></li>
<li><a href="#L634">pct_info</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L503">float8_lerp</a></li>
<li><a href="#L1142">hypothetical_check_argtypes</a></li>
<li><a href="#L1278">hypothetical_cume_dist_final</a></li>
<li><a href="#L1295">hypothetical_dense_rank_final</a></li>
<li><a href="#L1258">hypothetical_percent_rank_final</a></li>
<li><a href="#L1171">hypothetical_rank_common</a></li>
<li><a href="#L1244">hypothetical_rank_final</a></li>
<li><a href="#L512">interval_lerp</a></li>
<li><a href="#L1033">mode_final</a></li>
<li><a href="#L339">ordered_set_shutdown</a></li>
<li><a href="#L113">ordered_set_startup</a></li>
<li><a href="#L358">ordered_set_transition</a></li>
<li><a href="#L383">ordered_set_transition_multi</a></li>
<li><a href="#L646">pct_info_cmp</a></li>
<li><a href="#L526">percentile_cont_final_common</a></li>
<li><a href="#L613">percentile_cont_float8_final</a></li>
<li><a href="#L1004">percentile_cont_float8_multi_final</a></li>
<li><a href="#L622">percentile_cont_interval_final</a></li>
<li><a href="#L1019">percentile_cont_interval_multi_final</a></li>
<li><a href="#L848">percentile_cont_multi_final_common</a></li>
<li><a href="#L427">percentile_disc_final</a></li>
<li><a href="#L731">percentile_disc_multi_final</a></li>
<li><a href="#L662">setup_pct_info</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * orderedsetaggs.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Ordered-set aggregate <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/adt/orderedsetaggs.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;math.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_aggregate.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_operator.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/executor.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/nodeFuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/optimizer.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/array.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgrprotos.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/tuplesort.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Generic support for ordered-set aggregates<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The state for an ordered-set aggregate is divided into a per-group struct<br/></li>
<li></span><span class="Comment"> * (which is the <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a>-type transition state datum returned to nodeAgg.c)<br/></li>
<li></span><span class="Comment"> * and a per-query struct, which contains data and sub-objects that we can<br/></li>
<li></span><span class="Comment"> * create just once per query because they will not change across groups.<br/></li>
<li></span><span class="Comment"> * The per-query struct and subsidiary data live in the executor's per-query<br/></li>
<li></span><span class="Comment"> * memory context, and go away implicitly at <a href="../../executor/execMain.c.html#L467" title="executor/execMain.c:467">ExecutorEnd</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * These structs are set up during the first call of the transition function.<br/></li>
<li></span><span class="Comment"> * Because we allow nodeAgg.c to <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> ordered-set aggregates (but not<br/></li>
<li></span><span class="Comment"> * hypothetical aggregates) with identical inputs and transition <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>,<br/></li>
<li></span><span class="Comment"> * this info must not depend on the particular aggregate (ie, particular<br/></li>
<li></span><span class="Comment"> * final-function), nor on the direct argument(s) of the aggregate.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><a id="L49">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">OSAPerQueryState</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Representative Aggref for this aggregate: */<br/></li>
<li></span>&nbsp; &nbsp; Aggref&nbsp; &nbsp; &nbsp;&nbsp; *aggref;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Memory context containing this struct and other per-query data: */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContext qcontext;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Context for expression evaluation */<br/></li>
<li></span>&nbsp; &nbsp; ExprContext *econtext;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Do we expect multiple final-function calls within one group? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; rescan_needed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* These fields are used only when accumulating tuples: */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Tuple descriptor for tuples inserted into sortstate: */<br/></li>
<li></span>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Tuple slot we can use for inserting/extracting tuples: */<br/></li>
<li></span>&nbsp; &nbsp; TupleTableSlot *tupslot;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Per-sort-column sorting information */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numSortCols;<br/></li>
<li>&nbsp; &nbsp; AttrNumber *sortColIdx;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *sortOperators;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *eqOperators;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *sortCollations;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *sortNullsFirsts;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Equality operator call info, created only if needed: */<br/></li>
<li></span>&nbsp; &nbsp; ExprState&nbsp; *compareTuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* These fields are used only when accumulating datums: */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Info about datatype of datums being sorted: */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortColType;<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; typLen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; typByVal;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; typAlign;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Info about sort ordering: */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortOperator;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eqOperator;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortCollation;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; sortNullsFirst;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Equality operator call info, created only if needed: */<br/></li>
<li></span>&nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; equalfn;<br/></li>
<li><a id="L90">&#x200c;</a>} <span class="linkable">OSAPerQueryState</span>;<br/></li>
<li><br/></li>
<li><a id="L92">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">OSAPerGroupState</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Link to the per-query state for this aggregate: */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L49" title="utils/adt/orderedsetaggs.c:49">OSAPerQueryState</a> *qstate;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Memory context containing per-group data: */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContext gcontext;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Sort object we're accumulating data in: */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../sort/tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *sortstate;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Number of normal rows inserted into sortstate: */<br/></li>
<li></span>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; number_of_rows;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Have we already done <a href="../sort/tuplesort.c.html#L1385" title="utils/sort/tuplesort.c:1385">tuplesort_performsort</a>? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; sort_done;<br/></li>
<li><a id="L104">&#x200c;</a>} <span class="linkable">OSAPerGroupState</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L339" title="utils/adt/orderedsetaggs.c:339">ordered_set_shutdown</a>(Datum arg);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Set up working state for an ordered-set aggregate<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L92" title="utils/adt/orderedsetaggs.c:92">OSAPerGroupState</a> *<br/></li>
<li><a id="L113">&#x200c;</a><span class="linkable">ordered_set_startup</span>(FunctionCallInfo fcinfo, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> use_tuples)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L92" title="utils/adt/orderedsetaggs.c:92">OSAPerGroupState</a> *osastate;<br/></li>
<li>&nbsp; &nbsp; <a href="#L49" title="utils/adt/orderedsetaggs.c:49">OSAPerQueryState</a> *qstate;<br/></li>
<li>&nbsp; &nbsp; MemoryContext gcontext;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuplesortopt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check we're called as aggregate (and not a window function), and get<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the Agg node's group-lifespan context (which might change from group to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * group, so we shouldn't cache it in the per-query state).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../executor/nodeAgg.c.html#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>(fcinfo, &amp;gcontext) != AGG_CONTEXT_AGGREGATE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;ordered-set aggregate called in non-aggregate context&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We keep a link to the per-query state in fn_extra; if it's not there,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * create it, and do the per-query setup we need.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; qstate = (<a href="#L49" title="utils/adt/orderedsetaggs.c:49">OSAPerQueryState</a> *) fcinfo-&gt;flinfo-&gt;fn_extra;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (qstate == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Aggref&nbsp; &nbsp; &nbsp;&nbsp; *aggref;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext qcontext;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *sortlist;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numSortCols;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get the Aggref so we can examine aggregate's arguments */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; aggref = <a href="../../executor/nodeAgg.c.html#L4555" title="executor/nodeAgg.c:4555">AggGetAggref</a>(fcinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!aggref)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;ordered-set aggregate called in non-aggregate context&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!AGGKIND_IS_ORDERED_SET(aggref-&gt;aggkind))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;ordered-set aggregate support function called for non-ordered-set aggregate&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Prepare per-query structures in the fn_mcxt, which we assume is the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * executor's per-query context; in <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case it's the right place to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * keep anything found via fn_extra.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; qcontext = fcinfo-&gt;flinfo-&gt;fn_mcxt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(qcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qstate = (<a href="#L49" title="utils/adt/orderedsetaggs.c:49">OSAPerQueryState</a> *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L49" title="utils/adt/orderedsetaggs.c:49">OSAPerQueryState</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qstate-&gt;aggref = aggref;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qstate-&gt;qcontext = qcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We need to support rescans if the trans state is shared */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; qstate-&gt;rescan_needed = <a href="../../executor/nodeAgg.c.html#L4615" title="executor/nodeAgg.c:4615">AggStateIsShared</a>(fcinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Extract the sort information */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sortlist = aggref-&gt;aggorder;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; numSortCols = list_length(sortlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (use_tuples)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; ishypothetical = (aggref-&gt;aggkind == AGGKIND_HYPOTHETICAL);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ishypothetical)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numSortCols++;&nbsp; &nbsp; <span class="Comment">/* make space for flag column */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qstate-&gt;numSortCols = numSortCols;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qstate-&gt;sortColIdx = (AttrNumber *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(numSortCols * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AttrNumber));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qstate-&gt;sortOperators = (Oid *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(numSortCols * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qstate-&gt;eqOperators = (Oid *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(numSortCols * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qstate-&gt;sortCollations = (Oid *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(numSortCols * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qstate-&gt;sortNullsFirsts = (<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(numSortCols * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, sortlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SortGroupClause *sortcl = (SortGroupClause *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle = <a href="../../optimizer/util/tlist.c.html#L367" title="optimizer/util/tlist.c:367">get_sortgroupclause_tle</a>(sortcl,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; aggref-&gt;args);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the parser should have made sure of this */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(OidIsValid(sortcl-&gt;sortop));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qstate-&gt;sortColIdx[i] = tle-&gt;resno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qstate-&gt;sortOperators[i] = sortcl-&gt;sortop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qstate-&gt;eqOperators[i] = sortcl-&gt;eqop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qstate-&gt;sortCollations[i] = <a href="../../nodes/nodeFuncs.c.html#L816" title="nodes/nodeFuncs.c:816">exprCollation</a>((Node *) tle-&gt;expr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qstate-&gt;sortNullsFirsts[i] = sortcl-&gt;nulls_first;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ishypothetical)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Add an integer flag column as the last sort column */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qstate-&gt;sortColIdx[i] = list_length(aggref-&gt;args) + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qstate-&gt;sortOperators[i] = Int4LessOperator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qstate-&gt;eqOperators[i] = Int4EqualOperator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qstate-&gt;sortCollations[i] = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qstate-&gt;sortNullsFirsts[i] = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(i == numSortCols);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Get a tupledesc corresponding to the aggregated inputs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (including sort expressions) of the agg.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qstate-&gt;tupdesc = <a href="../../executor/execTuples.c.html#L2025" title="executor/execTuples.c:2025">ExecTypeFromTL</a>(aggref-&gt;args);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we need a flag column, hack the tupledesc to include that */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ishypothetical)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleDesc&nbsp; &nbsp; newdesc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; natts = qstate-&gt;tupdesc-&gt;natts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newdesc = <a href="../../access/common/tupdesc.c.html#L67" title="access/common/tupdesc.c:67">CreateTemplateTupleDesc</a>(natts + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt;= natts; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/common/tupdesc.c.html#L289" title="access/common/tupdesc.c:289">TupleDescCopyEntry</a>(newdesc, i, qstate-&gt;tupdesc, i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/common/tupdesc.c.html#L651" title="access/common/tupdesc.c:651">TupleDescInitEntry</a>(newdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (AttrNumber) ++natts,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;flag&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; INT4OID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/common/tupdesc.c.html#L331" title="access/common/tupdesc.c:331">FreeTupleDesc</a>(qstate-&gt;tupdesc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qstate-&gt;tupdesc = newdesc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Create slot we'll use to store/retrieve rows */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qstate-&gt;tupslot = <a href="../../executor/execTuples.c.html#L1325" title="executor/execTuples.c:1325">MakeSingleTupleTableSlot</a>(qstate-&gt;tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;<a href="../../executor/execTuples.c.html#L86" title="executor/execTuples.c:86">TTSOpsMinimalTuple</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Sort single datums */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SortGroupClause *sortcl;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (numSortCols != <span class="Constant">1</span> || aggref-&gt;aggkind == AGGKIND_HYPOTHETICAL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;ordered-set aggregate support function does not support multiple aggregated columns&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortcl = (SortGroupClause *) linitial(sortlist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tle = <a href="../../optimizer/util/tlist.c.html#L367" title="optimizer/util/tlist.c:367">get_sortgroupclause_tle</a>(sortcl, aggref-&gt;args);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the parser should have made sure of this */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(OidIsValid(sortcl-&gt;sortop));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Save sort ordering info */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qstate-&gt;sortColType = <a href="../../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>((Node *) tle-&gt;expr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qstate-&gt;sortOperator = sortcl-&gt;sortop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qstate-&gt;eqOperator = sortcl-&gt;eqop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qstate-&gt;sortCollation = <a href="../../nodes/nodeFuncs.c.html#L816" title="nodes/nodeFuncs.c:816">exprCollation</a>((Node *) tle-&gt;expr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qstate-&gt;sortNullsFirst = sortcl-&gt;nulls_first;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Save datatype info */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L2271" title="utils/cache/lsyscache.c:2271">get_typlenbyvalalign</a>(qstate-&gt;sortColType,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;qstate-&gt;typLen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;qstate-&gt;typByVal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;qstate-&gt;typAlign);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;flinfo-&gt;fn_extra = (<span class="Type">void</span> *) qstate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now build the stuff we need in group-lifespan context */<br/></li>
<li></span>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(gcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; osastate = (<a href="#L92" title="utils/adt/orderedsetaggs.c:92">OSAPerGroupState</a> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L92" title="utils/adt/orderedsetaggs.c:92">OSAPerGroupState</a>));<br/></li>
<li>&nbsp; &nbsp; osastate-&gt;qstate = qstate;<br/></li>
<li>&nbsp; &nbsp; osastate-&gt;gcontext = gcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuplesortopt = TUPLESORT_NONE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (qstate-&gt;rescan_needed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuplesortopt |= TUPLESORT_RANDOMACCESS;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize tuplesort object.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (use_tuples)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; osastate-&gt;sortstate = <a href="../sort/tuplesortvariants.c.html#L168" title="utils/sort/tuplesortvariants.c:168">tuplesort_begin_heap</a>(qstate-&gt;tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; qstate-&gt;numSortCols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; qstate-&gt;sortColIdx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; qstate-&gt;sortOperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; qstate-&gt;sortCollations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; qstate-&gt;sortNullsFirsts,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tuplesortopt);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; osastate-&gt;sortstate = <a href="../sort/tuplesortvariants.c.html#L584" title="utils/sort/tuplesortvariants.c:584">tuplesort_begin_datum</a>(qstate-&gt;sortColType,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qstate-&gt;sortOperator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qstate-&gt;sortCollation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qstate-&gt;sortNullsFirst,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuplesortopt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; osastate-&gt;number_of_rows = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; osastate-&gt;sort_done = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now register a shutdown callback to clean things up at end of group */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../executor/nodeAgg.c.html#L4654" title="executor/nodeAgg.c:4654">AggRegisterCallback</a>(fcinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L339" title="utils/adt/orderedsetaggs.c:339">ordered_set_shutdown</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(osastate));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> osastate;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Clean up when evaluation of an ordered-set aggregate is complete.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We don't need to bother freeing objects in the per-group memory context,<br/></li>
<li></span><span class="Comment"> * since that will get reset anyway by nodeAgg.c; nor should we free anything<br/></li>
<li></span><span class="Comment"> * in the per-query context, which will get cleared (if this was the last<br/></li>
<li></span><span class="Comment"> * group) by <a href="../../executor/execMain.c.html#L467" title="executor/execMain.c:467">ExecutorEnd</a>.&nbsp; But we must take care to release <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> potential<br/></li>
<li></span><span class="Comment"> * non-memory resources.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In the case where we're not expecting multiple finalfn calls, we could<br/></li>
<li></span><span class="Comment"> * arguably rely on the finalfn to clean up; but it's easier and more testable<br/></li>
<li></span><span class="Comment"> * if we just do it the same way in either case.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L339">&#x200c;</a></span><span class="linkable">ordered_set_shutdown</span>(Datum arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L92" title="utils/adt/orderedsetaggs.c:92">OSAPerGroupState</a> *osastate = (<a href="#L92" title="utils/adt/orderedsetaggs.c:92">OSAPerGroupState</a> *) DatumGetPointer(arg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Tuplesort object might have temp files. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (osastate-&gt;sortstate)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../sort/tuplesort.c.html#L971" title="utils/sort/tuplesort.c:971">tuplesort_end</a>(osastate-&gt;sortstate);<br/></li>
<li>&nbsp; &nbsp; osastate-&gt;sortstate = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The tupleslot probably can't be holding a pin, but let's be safe. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (osastate-&gt;qstate-&gt;tupslot)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ExecClearTuple(osastate-&gt;qstate-&gt;tupslot);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Generic transition function for ordered-set aggregates<br/></li>
<li></span><span class="Comment"> * with a single input column in which we want to suppress nulls<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L358">&#x200c;</a><span class="linkable">ordered_set_transition</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L92" title="utils/adt/orderedsetaggs.c:92">OSAPerGroupState</a> *osastate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If first call, create the transition state workspace */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PG_ARGISNULL(<span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; osastate = <a href="#L113" title="utils/adt/orderedsetaggs.c:113">ordered_set_startup</a>(fcinfo, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; osastate = (<a href="#L92" title="utils/adt/orderedsetaggs.c:92">OSAPerGroupState</a> *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Load the datum into the tuplesort object, but only if it's not null */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!PG_ARGISNULL(<span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../sort/tuplesortvariants.c.html#L826" title="utils/sort/tuplesortvariants.c:826">tuplesort_putdatum</a>(osastate-&gt;sortstate, PG_GETARG_DATUM(<span class="Constant">1</span>), <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; osastate-&gt;number_of_rows++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(osastate);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Generic transition function for ordered-set aggregates<br/></li>
<li></span><span class="Comment"> * with (potentially) multiple aggregated input columns<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L383">&#x200c;</a><span class="linkable">ordered_set_transition_multi</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L92" title="utils/adt/orderedsetaggs.c:92">OSAPerGroupState</a> *osastate;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *slot;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nargs;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If first call, create the transition state workspace */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PG_ARGISNULL(<span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; osastate = <a href="#L113" title="utils/adt/orderedsetaggs.c:113">ordered_set_startup</a>(fcinfo, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; osastate = (<a href="#L92" title="utils/adt/orderedsetaggs.c:92">OSAPerGroupState</a> *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Form a tuple from all the other inputs besides the transition value */<br/></li>
<li></span>&nbsp; &nbsp; slot = osastate-&gt;qstate-&gt;tupslot;<br/></li>
<li>&nbsp; &nbsp; ExecClearTuple(slot);<br/></li>
<li>&nbsp; &nbsp; nargs = PG_NARGS() - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nargs; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;tts_values[i] = PG_GETARG_DATUM(i + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;tts_isnull[i] = PG_ARGISNULL(i + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (osastate-&gt;qstate-&gt;aggref-&gt;aggkind == AGGKIND_HYPOTHETICAL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Add a zero flag value to mark this row as a normal input row */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;tts_values[i] = Int32GetDatum(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;tts_isnull[i] = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; Assert(i == slot-&gt;tts_tupleDescriptor-&gt;natts);<br/></li>
<li>&nbsp; &nbsp; <a href="../../executor/execTuples.c.html#L1639" title="executor/execTuples.c:1639">ExecStoreVirtualTuple</a>(slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Load the row into the tuplesort object */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../sort/tuplesortvariants.c.html#L669" title="utils/sort/tuplesortvariants.c:669">tuplesort_puttupleslot</a>(osastate-&gt;sortstate, slot);<br/></li>
<li>&nbsp; &nbsp; osastate-&gt;number_of_rows++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(osastate);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * percentile_disc(float8) within group(<a href="pseudotypes.c.html#L374" title="utils/adt/pseudotypes.c:374">anyelement</a>) - discrete percentile<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L427">&#x200c;</a><span class="linkable">percentile_disc_final</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L92" title="utils/adt/orderedsetaggs.c:92">OSAPerGroupState</a> *osastate;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; percentile;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; rownum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../executor/nodeAgg.c.html#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>(fcinfo, <span class="Constant">NULL</span>) == AGG_CONTEXT_AGGREGATE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get and check the percentile argument */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PG_ARGISNULL(<span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; percentile = PG_GETARG_FLOAT8(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (percentile &lt; <span class="Constant">0</span> || percentile &gt; <span class="Constant">1</span> || isnan(percentile))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;percentile value </span><span class="Special">%g</span><span class="Constant"> is not between 0 and 1&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; percentile)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If there were no regular rows, the result is NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PG_ARGISNULL(<span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; osastate = (<a href="#L92" title="utils/adt/orderedsetaggs.c:92">OSAPerGroupState</a> *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* number_of_rows could be zero if we only saw NULL input <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (osastate-&gt;number_of_rows == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Finish the sort, or rescan if we already did */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!osastate-&gt;sort_done)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../sort/tuplesort.c.html#L1385" title="utils/sort/tuplesort.c:1385">tuplesort_performsort</a>(osastate-&gt;sortstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; osastate-&gt;sort_done = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../sort/tuplesort.c.html#L2440" title="utils/sort/tuplesort.c:2440">tuplesort_rescan</a>(osastate-&gt;sortstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need the smallest K such that (K/N) &gt;= percentile.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * N&gt;0, therefore K &gt;= N*percentile, therefore K = ceil(N*percentile).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * So we <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> K-1 rows (if K&gt;0) and return the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> row fetched.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rownum = (int64) ceil(percentile * osastate-&gt;number_of_rows);<br/></li>
<li>&nbsp; &nbsp; Assert(rownum &lt;= osastate-&gt;number_of_rows);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rownum &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../sort/tuplesort.c.html#L1736" title="utils/sort/tuplesort.c:1736">tuplesort_skiptuples</a>(osastate-&gt;sortstate, rownum - <span class="Constant">1</span>, <span class="Constant">true</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;missing row in percentile_disc&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../sort/tuplesortvariants.c.html#L1018" title="utils/sort/tuplesortvariants.c:1018">tuplesort_getdatum</a>(osastate-&gt;sortstate, <span class="Constant">true</span>, <span class="Constant">true</span>, &amp;val, &amp;isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;missing row in percentile_disc&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We shouldn't have stored <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> nulls, but do the right thing anyway */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_DATUM(val);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * For percentile_cont, we need a way to interpolate between consecutive<br/></li>
<li></span><span class="Comment"> * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>. Use a helper function for that, so that we can share the rest<br/></li>
<li></span><span class="Comment"> * of the code between types.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L500">&#x200c;</a></span><span class="Type">typedef</span> Datum (*<span class="linkable">LerpFunc</span>) (Datum lo, Datum hi, <span class="Type">double</span> pct);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> Datum<br/></li>
<li><a id="L503">&#x200c;</a><span class="linkable">float8_lerp</span>(Datum lo, Datum hi, <span class="Type">double</span> pct)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; loval = DatumGetFloat8(lo);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; hival = DatumGetFloat8(hi);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../fmgr/fmgr.c.html#L1816" title="utils/fmgr/fmgr.c:1816">Float8GetDatum</a>(loval + (pct * (hival - loval)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> Datum<br/></li>
<li><a id="L512">&#x200c;</a><span class="linkable">interval_lerp</span>(Datum lo, Datum hi, <span class="Type">double</span> pct)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; diff_result = DirectFunctionCall2(<a href="timestamp.c.html#L3506" title="utils/adt/timestamp.c:3506">interval_mi</a>, hi, lo);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; mul_result = DirectFunctionCall2(<a href="timestamp.c.html#L3555" title="utils/adt/timestamp.c:3555">interval_mul</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; diff_result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Float8GetDatumFast(pct));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> DirectFunctionCall2(<a href="timestamp.c.html#L3450" title="utils/adt/timestamp.c:3450">interval_pl</a>, mul_result, lo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Continuous percentile<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Datum<br/></li>
<li><a id="L526">&#x200c;</a><span class="linkable">percentile_cont_final_common</span>(FunctionCallInfo fcinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid expect_type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L500" title="utils/adt/orderedsetaggs.c:500">LerpFunc</a> lerpfunc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L92" title="utils/adt/orderedsetaggs.c:92">OSAPerGroupState</a> *osastate;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; percentile;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; first_row = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; second_row = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; first_val;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; second_val;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; proportion;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../executor/nodeAgg.c.html#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>(fcinfo, <span class="Constant">NULL</span>) == AGG_CONTEXT_AGGREGATE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get and check the percentile argument */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PG_ARGISNULL(<span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; percentile = PG_GETARG_FLOAT8(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (percentile &lt; <span class="Constant">0</span> || percentile &gt; <span class="Constant">1</span> || isnan(percentile))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;percentile value </span><span class="Special">%g</span><span class="Constant"> is not between 0 and 1&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; percentile)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If there were no regular rows, the result is NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PG_ARGISNULL(<span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; osastate = (<a href="#L92" title="utils/adt/orderedsetaggs.c:92">OSAPerGroupState</a> *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* number_of_rows could be zero if we only saw NULL input <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (osastate-&gt;number_of_rows == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(expect_type == osastate-&gt;qstate-&gt;sortColType);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Finish the sort, or rescan if we already did */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!osastate-&gt;sort_done)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../sort/tuplesort.c.html#L1385" title="utils/sort/tuplesort.c:1385">tuplesort_performsort</a>(osastate-&gt;sortstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; osastate-&gt;sort_done = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../sort/tuplesort.c.html#L2440" title="utils/sort/tuplesort.c:2440">tuplesort_rescan</a>(osastate-&gt;sortstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; first_row = floor(percentile * (osastate-&gt;number_of_rows - <span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; second_row = ceil(percentile * (osastate-&gt;number_of_rows - <span class="Constant">1</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(first_row &lt; osastate-&gt;number_of_rows);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../sort/tuplesort.c.html#L1736" title="utils/sort/tuplesort.c:1736">tuplesort_skiptuples</a>(osastate-&gt;sortstate, first_row, <span class="Constant">true</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;missing row in percentile_cont&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../sort/tuplesortvariants.c.html#L1018" title="utils/sort/tuplesortvariants.c:1018">tuplesort_getdatum</a>(osastate-&gt;sortstate, <span class="Constant">true</span>, <span class="Constant">true</span>, &amp;first_val,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;isnull, <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;missing row in percentile_cont&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (first_row == second_row)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; val = first_val;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../sort/tuplesortvariants.c.html#L1018" title="utils/sort/tuplesortvariants.c:1018">tuplesort_getdatum</a>(osastate-&gt;sortstate, <span class="Constant">true</span>, <span class="Constant">true</span>, &amp;second_val,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;isnull, <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;missing row in percentile_cont&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; proportion = (percentile * (osastate-&gt;number_of_rows - <span class="Constant">1</span>)) - first_row;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; val = lerpfunc(first_val, second_val, proportion);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_DATUM(val);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * percentile_cont(float8) within group (float8)&nbsp; &nbsp; - continuous percentile<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L613">&#x200c;</a><span class="linkable">percentile_cont_float8_final</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L526" title="utils/adt/orderedsetaggs.c:526">percentile_cont_final_common</a>(fcinfo, FLOAT8OID, <a href="#L503" title="utils/adt/orderedsetaggs.c:503">float8_lerp</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * percentile_cont(float8) within group (interval)&nbsp; &nbsp; - continuous percentile<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L622">&#x200c;</a><span class="linkable">percentile_cont_interval_final</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L526" title="utils/adt/orderedsetaggs.c:526">percentile_cont_final_common</a>(fcinfo, INTERVALOID, <a href="#L512" title="utils/adt/orderedsetaggs.c:512">interval_lerp</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Support code for handling arrays of percentiles<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: in each <a href="#L634" title="utils/adt/orderedsetaggs.c:634">pct_info</a> entry, second_row should be <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to or<br/></li>
<li></span><span class="Comment"> * exactly one more than first_row.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L634">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">pct_info</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; first_row;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* first row to sample */<br/></li>
<li></span>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; second_row;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* possible second row to sample */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; proportion;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* interpolation fraction */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idx;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* index of this item in original array */<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Sort comparator to sort pct_infos by first_row then second_row<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L646">&#x200c;</a></span><span class="linkable">pct_info_cmp</span>(<span class="Type">const</span> <span class="Type">void</span> *pa, <span class="Type">const</span> <span class="Type">void</span> *pb)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">struct</span> <a href="#L634" title="utils/adt/orderedsetaggs.c:634">pct_info</a> *a = (<span class="Type">const</span> <span class="Type">struct</span> <a href="#L634" title="utils/adt/orderedsetaggs.c:634">pct_info</a> *) pa;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">struct</span> <a href="#L634" title="utils/adt/orderedsetaggs.c:634">pct_info</a> *b = (<span class="Type">const</span> <span class="Type">struct</span> <a href="#L634" title="utils/adt/orderedsetaggs.c:634">pct_info</a> *) pb;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;first_row != b-&gt;first_row)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (a-&gt;first_row &lt; b-&gt;first_row) ? -<span class="Constant">1</span> : <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;second_row != b-&gt;second_row)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (a-&gt;second_row &lt; b-&gt;second_row) ? -<span class="Constant">1</span> : <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Construct array showing which rows to sample for percentiles.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">struct</span> <a href="#L634" title="utils/adt/orderedsetaggs.c:634">pct_info</a> *<br/></li>
<li><a id="L662">&#x200c;</a><span class="linkable">setup_pct_info</span>(<span class="Type">int</span> num_percentiles,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum *percentiles_datum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *percentiles_null,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; int64 rowcount,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> continuous)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L634" title="utils/adt/orderedsetaggs.c:634">pct_info</a> *<a href="#L634" title="utils/adt/orderedsetaggs.c:634">pct_info</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L634" title="utils/adt/orderedsetaggs.c:634">pct_info</a> = (<span class="Type">struct</span> <a href="#L634" title="utils/adt/orderedsetaggs.c:634">pct_info</a> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(num_percentiles * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">struct</span> <a href="#L634" title="utils/adt/orderedsetaggs.c:634">pct_info</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; num_percentiles; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L634" title="utils/adt/orderedsetaggs.c:634">pct_info</a>[i].idx = i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (percentiles_null[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* dummy entry for <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> NULL in array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L634" title="utils/adt/orderedsetaggs.c:634">pct_info</a>[i].first_row = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L634" title="utils/adt/orderedsetaggs.c:634">pct_info</a>[i].second_row = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L634" title="utils/adt/orderedsetaggs.c:634">pct_info</a>[i].proportion = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; p = DatumGetFloat8(percentiles_datum[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (p &lt; <span class="Constant">0</span> || p &gt; <span class="Constant">1</span> || isnan(p))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;percentile value </span><span class="Special">%g</span><span class="Constant"> is not between 0 and 1&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (continuous)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L634" title="utils/adt/orderedsetaggs.c:634">pct_info</a>[i].first_row = <span class="Constant">1</span> + floor(p * (rowcount - <span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L634" title="utils/adt/orderedsetaggs.c:634">pct_info</a>[i].second_row = <span class="Constant">1</span> + ceil(p * (rowcount - <span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L634" title="utils/adt/orderedsetaggs.c:634">pct_info</a>[i].proportion = (p * (rowcount - <span class="Constant">1</span>)) - floor(p * (rowcount - <span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We need the smallest K such that (K/N) &gt;= percentile.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * N&gt;0, therefore K &gt;= N*percentile, therefore<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * K = ceil(N*percentile); but not less than 1.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; row = (int64) ceil(p * rowcount);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; row = Max(<span class="Constant">1</span>, row);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L634" title="utils/adt/orderedsetaggs.c:634">pct_info</a>[i].first_row = row;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L634" title="utils/adt/orderedsetaggs.c:634">pct_info</a>[i].second_row = row;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L634" title="utils/adt/orderedsetaggs.c:634">pct_info</a>[i].proportion = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The parameter array wasn't necessarily in sorted order, but we need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * visit the rows in order, so sort by first_row/second_row.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; qsort(<a href="#L634" title="utils/adt/orderedsetaggs.c:634">pct_info</a>, num_percentiles, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">struct</span> <a href="#L634" title="utils/adt/orderedsetaggs.c:634">pct_info</a>), <a href="#L646" title="utils/adt/orderedsetaggs.c:646">pct_info_cmp</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L634" title="utils/adt/orderedsetaggs.c:634">pct_info</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * percentile_disc(float8[]) within group (<a href="pseudotypes.c.html#L374" title="utils/adt/pseudotypes.c:374">anyelement</a>)&nbsp; &nbsp; - discrete percentiles<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L731">&#x200c;</a><span class="linkable">percentile_disc_multi_final</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L92" title="utils/adt/orderedsetaggs.c:92">OSAPerGroupState</a> *osastate;<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *param;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *percentiles_datum;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *percentiles_null;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_percentiles;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L634" title="utils/adt/orderedsetaggs.c:634">pct_info</a> *<a href="#L634" title="utils/adt/orderedsetaggs.c:634">pct_info</a>;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *result_datum;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *result_isnull;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; rownum = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; val = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../executor/nodeAgg.c.html#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>(fcinfo, <span class="Constant">NULL</span>) == AGG_CONTEXT_AGGREGATE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If there were no regular rows, the result is NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PG_ARGISNULL(<span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; osastate = (<a href="#L92" title="utils/adt/orderedsetaggs.c:92">OSAPerGroupState</a> *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* number_of_rows could be zero if we only saw NULL input <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (osastate-&gt;number_of_rows == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Deconstruct the percentile-array input */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PG_ARGISNULL(<span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; param = PG_GETARG_ARRAYTYPE_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="arrayfuncs.c.html#L3678" title="utils/adt/arrayfuncs.c:3678">deconstruct_array_builtin</a>(param, FLOAT8OID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;percentiles_datum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;percentiles_null,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;num_percentiles);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (num_percentiles == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_POINTER(<a href="arrayfuncs.c.html#L3561" title="utils/adt/arrayfuncs.c:3561">construct_empty_array</a>(osastate-&gt;qstate-&gt;sortColType));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L634" title="utils/adt/orderedsetaggs.c:634">pct_info</a> = <a href="#L662" title="utils/adt/orderedsetaggs.c:662">setup_pct_info</a>(num_percentiles,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; percentiles_datum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; percentiles_null,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; osastate-&gt;number_of_rows,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result_datum = (Datum *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(num_percentiles * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li>&nbsp; &nbsp; result_isnull = (<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(num_percentiles * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Start by dealing with <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> nulls in the param array - those are sorted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to the front on row=0, so set the corresponding result indexes to null<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; num_percentiles; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idx = <a href="#L634" title="utils/adt/orderedsetaggs.c:634">pct_info</a>[i].idx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L634" title="utils/adt/orderedsetaggs.c:634">pct_info</a>[i].first_row &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result_datum[idx] = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result_isnull[idx] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there's anything left after doing the nulls, then grind the input<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and extract the needed <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (i &lt; num_percentiles)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Finish the sort, or rescan if we already did */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!osastate-&gt;sort_done)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../sort/tuplesort.c.html#L1385" title="utils/sort/tuplesort.c:1385">tuplesort_performsort</a>(osastate-&gt;sortstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; osastate-&gt;sort_done = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../sort/tuplesort.c.html#L2440" title="utils/sort/tuplesort.c:2440">tuplesort_rescan</a>(osastate-&gt;sortstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (; i &lt; num_percentiles; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; target_row = <a href="#L634" title="utils/adt/orderedsetaggs.c:634">pct_info</a>[i].first_row;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idx = <a href="#L634" title="utils/adt/orderedsetaggs.c:634">pct_info</a>[i].idx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Advance to target row, if not already there */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (target_row &gt; rownum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../sort/tuplesort.c.html#L1736" title="utils/sort/tuplesort.c:1736">tuplesort_skiptuples</a>(osastate-&gt;sortstate, target_row - rownum - <span class="Constant">1</span>, <span class="Constant">true</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;missing row in percentile_disc&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../sort/tuplesortvariants.c.html#L1018" title="utils/sort/tuplesortvariants.c:1018">tuplesort_getdatum</a>(osastate-&gt;sortstate, <span class="Constant">true</span>, <span class="Constant">true</span>, &amp;val,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;isnull, <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;missing row in percentile_disc&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rownum = target_row;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result_datum[idx] = val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result_isnull[idx] = isnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We make the output array the same shape as the input */<br/></li>
<li></span>&nbsp; &nbsp; PG_RETURN_POINTER(<a href="arrayfuncs.c.html#L3475" title="utils/adt/arrayfuncs.c:3475">construct_md_array</a>(result_datum, result_isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ARR_NDIM(param),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ARR_DIMS(param),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ARR_LBOUND(param),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; osastate-&gt;qstate-&gt;sortColType,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; osastate-&gt;qstate-&gt;typLen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; osastate-&gt;qstate-&gt;typByVal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; osastate-&gt;qstate-&gt;typAlign));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * percentile_cont(float8[]) within group ()&nbsp; &nbsp; - continuous percentiles<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Datum<br/></li>
<li><a id="L848">&#x200c;</a><span class="linkable">percentile_cont_multi_final_common</span>(FunctionCallInfo fcinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid expect_type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; int16 typLen, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> typByVal, <span class="Type">char</span> typAlign,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L500" title="utils/adt/orderedsetaggs.c:500">LerpFunc</a> lerpfunc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L92" title="utils/adt/orderedsetaggs.c:92">OSAPerGroupState</a> *osastate;<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *param;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *percentiles_datum;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *percentiles_null;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_percentiles;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L634" title="utils/adt/orderedsetaggs.c:634">pct_info</a> *<a href="#L634" title="utils/adt/orderedsetaggs.c:634">pct_info</a>;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *result_datum;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *result_isnull;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; rownum = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; first_val = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; second_val = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../executor/nodeAgg.c.html#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>(fcinfo, <span class="Constant">NULL</span>) == AGG_CONTEXT_AGGREGATE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If there were no regular rows, the result is NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PG_ARGISNULL(<span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; osastate = (<a href="#L92" title="utils/adt/orderedsetaggs.c:92">OSAPerGroupState</a> *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* number_of_rows could be zero if we only saw NULL input <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (osastate-&gt;number_of_rows == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(expect_type == osastate-&gt;qstate-&gt;sortColType);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Deconstruct the percentile-array input */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PG_ARGISNULL(<span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; param = PG_GETARG_ARRAYTYPE_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="arrayfuncs.c.html#L3678" title="utils/adt/arrayfuncs.c:3678">deconstruct_array_builtin</a>(param, FLOAT8OID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;percentiles_datum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;percentiles_null,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;num_percentiles);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (num_percentiles == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_POINTER(<a href="arrayfuncs.c.html#L3561" title="utils/adt/arrayfuncs.c:3561">construct_empty_array</a>(osastate-&gt;qstate-&gt;sortColType));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L634" title="utils/adt/orderedsetaggs.c:634">pct_info</a> = <a href="#L662" title="utils/adt/orderedsetaggs.c:662">setup_pct_info</a>(num_percentiles,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; percentiles_datum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; percentiles_null,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; osastate-&gt;number_of_rows,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result_datum = (Datum *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(num_percentiles * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li>&nbsp; &nbsp; result_isnull = (<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(num_percentiles * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Start by dealing with <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> nulls in the param array - those are sorted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to the front on row=0, so set the corresponding result indexes to null<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; num_percentiles; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idx = <a href="#L634" title="utils/adt/orderedsetaggs.c:634">pct_info</a>[i].idx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L634" title="utils/adt/orderedsetaggs.c:634">pct_info</a>[i].first_row &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result_datum[idx] = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result_isnull[idx] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there's anything left after doing the nulls, then grind the input<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and extract the needed <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (i &lt; num_percentiles)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Finish the sort, or rescan if we already did */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!osastate-&gt;sort_done)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../sort/tuplesort.c.html#L1385" title="utils/sort/tuplesort.c:1385">tuplesort_performsort</a>(osastate-&gt;sortstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; osastate-&gt;sort_done = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../sort/tuplesort.c.html#L2440" title="utils/sort/tuplesort.c:2440">tuplesort_rescan</a>(osastate-&gt;sortstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (; i &lt; num_percentiles; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; first_row = <a href="#L634" title="utils/adt/orderedsetaggs.c:634">pct_info</a>[i].first_row;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; second_row = <a href="#L634" title="utils/adt/orderedsetaggs.c:634">pct_info</a>[i].second_row;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idx = <a href="#L634" title="utils/adt/orderedsetaggs.c:634">pct_info</a>[i].idx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Advance to first_row, if not already there.&nbsp; Note that we might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already have rownum beyond first_row, in which case first_val<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is already correct.&nbsp; (This occurs when interpolating between<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the same two input rows as for the previous percentile.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (first_row &gt; rownum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../sort/tuplesort.c.html#L1736" title="utils/sort/tuplesort.c:1736">tuplesort_skiptuples</a>(osastate-&gt;sortstate, first_row - rownum - <span class="Constant">1</span>, <span class="Constant">true</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;missing row in percentile_cont&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../sort/tuplesortvariants.c.html#L1018" title="utils/sort/tuplesortvariants.c:1018">tuplesort_getdatum</a>(osastate-&gt;sortstate, <span class="Constant">true</span>, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;first_val, &amp;isnull, <span class="Constant">NULL</span>) || isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;missing row in percentile_cont&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rownum = first_row;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Always advance second_val to be latest input value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; second_val = first_val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (first_row == rownum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We are already at the desired row, so we must previously<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have read its value into second_val (and perhaps first_val<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * as well, but this assignment is harmless in that case).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; first_val = second_val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fetch second_row if needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (second_row &gt; rownum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../sort/tuplesortvariants.c.html#L1018" title="utils/sort/tuplesortvariants.c:1018">tuplesort_getdatum</a>(osastate-&gt;sortstate, <span class="Constant">true</span>, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;second_val, &amp;isnull, <span class="Constant">NULL</span>) || isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;missing row in percentile_cont&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rownum++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We should <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> certainly be on second_row exactly */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(second_row == rownum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Compute appropriate result */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (second_row &gt; first_row)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result_datum[idx] = lerpfunc(first_val, second_val,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L634" title="utils/adt/orderedsetaggs.c:634">pct_info</a>[i].proportion);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result_datum[idx] = first_val;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result_isnull[idx] = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We make the output array the same shape as the input */<br/></li>
<li></span>&nbsp; &nbsp; PG_RETURN_POINTER(<a href="arrayfuncs.c.html#L3475" title="utils/adt/arrayfuncs.c:3475">construct_md_array</a>(result_datum, result_isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ARR_NDIM(param),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ARR_DIMS(param), ARR_LBOUND(param),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; expect_type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typLen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typByVal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typAlign));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * percentile_cont(float8[]) within group (float8)&nbsp; &nbsp; - continuous percentiles<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1004">&#x200c;</a><span class="linkable">percentile_cont_float8_multi_final</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L848" title="utils/adt/orderedsetaggs.c:848">percentile_cont_multi_final_common</a>(fcinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FLOAT8OID,<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* hard-wired info on type float8 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(float8),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FLOAT8PASSBYVAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TYPALIGN_DOUBLE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L503" title="utils/adt/orderedsetaggs.c:503">float8_lerp</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * percentile_cont(float8[]) within group (interval)&nbsp; - continuous percentiles<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1019">&#x200c;</a><span class="linkable">percentile_cont_interval_multi_final</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L848" title="utils/adt/orderedsetaggs.c:848">percentile_cont_multi_final_common</a>(fcinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INTERVALOID,<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* hard-wired info on type interval */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">16</span>, <span class="Constant">false</span>, TYPALIGN_DOUBLE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L512" title="utils/adt/orderedsetaggs.c:512">interval_lerp</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * mode() within group (<a href="pseudotypes.c.html#L374" title="utils/adt/pseudotypes.c:374">anyelement</a>) - most common value<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1033">&#x200c;</a><span class="linkable">mode_final</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L92" title="utils/adt/orderedsetaggs.c:92">OSAPerGroupState</a> *osastate;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; mode_val = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; mode_freq = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; last_val = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; last_val_freq = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; last_val_is_mode = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp;&nbsp; *equalfn;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; abbrev_val = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; last_abbrev_val = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; shouldfree;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../executor/nodeAgg.c.html#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>(fcinfo, <span class="Constant">NULL</span>) == AGG_CONTEXT_AGGREGATE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If there were no regular rows, the result is NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PG_ARGISNULL(<span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; osastate = (<a href="#L92" title="utils/adt/orderedsetaggs.c:92">OSAPerGroupState</a> *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* number_of_rows could be zero if we only saw NULL input <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (osastate-&gt;number_of_rows == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Look up the equality function for the datatype, if we didn't already */<br/></li>
<li></span>&nbsp; &nbsp; equalfn = &amp;(osastate-&gt;qstate-&gt;equalfn);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(equalfn-&gt;fn_oid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../fmgr/fmgr.c.html#L137" title="utils/fmgr/fmgr.c:137">fmgr_info_cxt</a>(<a href="../cache/lsyscache.c.html#L1285" title="utils/cache/lsyscache.c:1285">get_opcode</a>(osastate-&gt;qstate-&gt;eqOperator), equalfn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; osastate-&gt;qstate-&gt;qcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; shouldfree = !(osastate-&gt;qstate-&gt;typByVal);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Finish the sort, or rescan if we already did */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!osastate-&gt;sort_done)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../sort/tuplesort.c.html#L1385" title="utils/sort/tuplesort.c:1385">tuplesort_performsort</a>(osastate-&gt;sortstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; osastate-&gt;sort_done = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../sort/tuplesort.c.html#L2440" title="utils/sort/tuplesort.c:2440">tuplesort_rescan</a>(osastate-&gt;sortstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Scan tuples and count frequencies */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="../sort/tuplesortvariants.c.html#L1018" title="utils/sort/tuplesortvariants.c:1018">tuplesort_getdatum</a>(osastate-&gt;sortstate, <span class="Constant">true</span>, <span class="Constant">true</span>, &amp;val, &amp;isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;abbrev_val))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we don't expect <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> nulls, but ignore them if found */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (last_val_freq == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* first nonnull value - it's the mode for <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mode_val = last_val = val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mode_freq = last_val_freq = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last_val_is_mode = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last_abbrev_val = abbrev_val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (abbrev_val == last_abbrev_val &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; DatumGetBool(<a href="../fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(equalfn, PG_GET_COLLATION(), val, last_val)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* value <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to previous value, count it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (last_val_is_mode)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mode_freq++;&nbsp; &nbsp; <span class="Comment">/* needn't maintain last_val_freq */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (++last_val_freq &gt; mode_freq)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* last_val becomes new mode */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (shouldfree)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(DatumGetPointer(mode_val));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mode_val = last_val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mode_freq = last_val_freq;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last_val_is_mode = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (shouldfree)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(DatumGetPointer(val));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* val should replace last_val */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (shouldfree &amp;&amp; !last_val_is_mode)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(DatumGetPointer(last_val));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last_val = val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* avoid equality function calls by reusing abbreviated keys */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last_abbrev_val = abbrev_val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last_val_freq = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last_val_is_mode = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (shouldfree &amp;&amp; !last_val_is_mode)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(DatumGetPointer(last_val));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (mode_freq)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_DATUM(mode_val);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Common code to sanity-check args for hypothetical-set <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>. No need<br/></li>
<li></span><span class="Comment"> * for friendly errors, these can only happen if someone's messing up the<br/></li>
<li></span><span class="Comment"> * aggregate definitions. The checks are needed for security, however.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1142">&#x200c;</a></span><span class="linkable">hypothetical_check_argtypes</span>(FunctionCallInfo fcinfo, <span class="Type">int</span> nargs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleDesc tupdesc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check that we have an int4 flag column */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!tupdesc ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (nargs + <span class="Constant">1</span>) != tupdesc-&gt;natts ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleDescAttr(tupdesc, nargs)-&gt;atttypid != INT4OID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;type mismatch in hypothetical-set function&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check that direct args match in type with aggregated args */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nargs; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute attr = TupleDescAttr(tupdesc, i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../fmgr/fmgr.c.html#L1910" title="utils/fmgr/fmgr.c:1910">get_fn_expr_argtype</a>(fcinfo-&gt;flinfo, i + <span class="Constant">1</span>) != attr-&gt;atttypid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;type mismatch in hypothetical-set function&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * compute rank of hypothetical row<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * flag should be -1 to sort hypothetical row ahead of its peers, or +1<br/></li>
<li></span><span class="Comment"> * to sort behind.<br/></li>
<li></span><span class="Comment"> * total number of regular rows is returned into *number_of_rows.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> int64<br/></li>
<li><a id="L1171">&#x200c;</a><span class="linkable">hypothetical_rank_common</span>(FunctionCallInfo fcinfo, <span class="Type">int</span> flag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; int64 *number_of_rows)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nargs = PG_NARGS() - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; rank = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L92" title="utils/adt/orderedsetaggs.c:92">OSAPerGroupState</a> *osastate;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *slot;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../executor/nodeAgg.c.html#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>(fcinfo, <span class="Constant">NULL</span>) == AGG_CONTEXT_AGGREGATE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If there were no regular rows, the rank is always 1 */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PG_ARGISNULL(<span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *number_of_rows = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; osastate = (<a href="#L92" title="utils/adt/orderedsetaggs.c:92">OSAPerGroupState</a> *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; *number_of_rows = osastate-&gt;number_of_rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Adjust nargs to be the number of direct (or aggregated) args */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nargs % <span class="Constant">2</span> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;wrong number of arguments in hypothetical-set function&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; nargs /= <span class="Constant">2</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1142" title="utils/adt/orderedsetaggs.c:1142">hypothetical_check_argtypes</a>(fcinfo, nargs, osastate-&gt;qstate-&gt;tupdesc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* because we need a hypothetical row, we can't share transition state */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!osastate-&gt;sort_done);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* insert the hypothetical row into the sort */<br/></li>
<li></span>&nbsp; &nbsp; slot = osastate-&gt;qstate-&gt;tupslot;<br/></li>
<li>&nbsp; &nbsp; ExecClearTuple(slot);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nargs; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;tts_values[i] = PG_GETARG_DATUM(i + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;tts_isnull[i] = PG_ARGISNULL(i + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; slot-&gt;tts_values[i] = Int32GetDatum(flag);<br/></li>
<li>&nbsp; &nbsp; slot-&gt;tts_isnull[i] = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../executor/execTuples.c.html#L1639" title="executor/execTuples.c:1639">ExecStoreVirtualTuple</a>(slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../sort/tuplesortvariants.c.html#L669" title="utils/sort/tuplesortvariants.c:669">tuplesort_puttupleslot</a>(osastate-&gt;sortstate, slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* finish the sort */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../sort/tuplesort.c.html#L1385" title="utils/sort/tuplesort.c:1385">tuplesort_performsort</a>(osastate-&gt;sortstate);<br/></li>
<li>&nbsp; &nbsp; osastate-&gt;sort_done = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* iterate till we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the hypothetical row */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="../sort/tuplesortvariants.c.html#L890" title="utils/sort/tuplesortvariants.c:890">tuplesort_gettupleslot</a>(osastate-&gt;sortstate, <span class="Constant">true</span>, <span class="Constant">true</span>, slot, <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; d = slot_getattr(slot, nargs + <span class="Constant">1</span>, &amp;isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!isnull &amp;&amp; DatumGetInt32(d) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rank++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ExecClearTuple(slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> rank;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * rank()&nbsp; - rank of hypothetical row<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1244">&#x200c;</a><span class="linkable">hypothetical_rank_final</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; rank;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; rowcount;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rank = <a href="#L1171" title="utils/adt/orderedsetaggs.c:1171">hypothetical_rank_common</a>(fcinfo, -<span class="Constant">1</span>, &amp;rowcount);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT64(rank);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * percent_rank()&nbsp; &nbsp; - percentile rank of hypothetical row<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1258">&#x200c;</a><span class="linkable">hypothetical_percent_rank_final</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; rank;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; rowcount;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; result_val;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rank = <a href="#L1171" title="utils/adt/orderedsetaggs.c:1171">hypothetical_rank_common</a>(fcinfo, -<span class="Constant">1</span>, &amp;rowcount);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rowcount == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result_val = (<span class="Type">double</span>) (rank - <span class="Constant">1</span>) / (<span class="Type">double</span>) (rowcount);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(result_val);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * cume_dist()&nbsp; &nbsp; - cumulative distribution of hypothetical row<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1278">&#x200c;</a><span class="linkable">hypothetical_cume_dist_final</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; rank;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; rowcount;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; result_val;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rank = <a href="#L1171" title="utils/adt/orderedsetaggs.c:1171">hypothetical_rank_common</a>(fcinfo, <span class="Constant">1</span>, &amp;rowcount);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result_val = (<span class="Type">double</span>) (rank) / (<span class="Type">double</span>) (rowcount + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(result_val);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * dense_rank() - rank of hypothetical row without gaps in ranking<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1295">&#x200c;</a><span class="linkable">hypothetical_dense_rank_final</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ExprContext *econtext;<br/></li>
<li>&nbsp; &nbsp; ExprState&nbsp; *compareTuple;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nargs = PG_NARGS() - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; rank = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; duplicate_count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L92" title="utils/adt/orderedsetaggs.c:92">OSAPerGroupState</a> *osastate;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numDistinctCols;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; abbrevVal = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; abbrevOld = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *slot;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *extraslot;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *slot2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../executor/nodeAgg.c.html#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>(fcinfo, <span class="Constant">NULL</span>) == AGG_CONTEXT_AGGREGATE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If there were no regular rows, the rank is always 1 */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PG_ARGISNULL(<span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_INT64(rank);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; osastate = (<a href="#L92" title="utils/adt/orderedsetaggs.c:92">OSAPerGroupState</a> *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; econtext = osastate-&gt;qstate-&gt;econtext;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!econtext)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make sure to we create econtext under correct parent context. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(osastate-&gt;qstate-&gt;qcontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; osastate-&gt;qstate-&gt;econtext = <a href="../../executor/execUtils.c.html#L355" title="executor/execUtils.c:355">CreateStandaloneExprContext</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; econtext = osastate-&gt;qstate-&gt;econtext;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Adjust nargs to be the number of direct (or aggregated) args */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nargs % <span class="Constant">2</span> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;wrong number of arguments in hypothetical-set function&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; nargs /= <span class="Constant">2</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1142" title="utils/adt/orderedsetaggs.c:1142">hypothetical_check_argtypes</a>(fcinfo, nargs, osastate-&gt;qstate-&gt;tupdesc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When comparing tuples, we can omit the flag column since we will only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> rows with flag == 0.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; numDistinctCols = osastate-&gt;qstate-&gt;numSortCols - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Build tuple comparator, if we didn't already */<br/></li>
<li></span>&nbsp; &nbsp; compareTuple = osastate-&gt;qstate-&gt;compareTuple;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (compareTuple == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AttrNumber *sortColIdx = osastate-&gt;qstate-&gt;sortColIdx;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldContext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldContext = MemoryContextSwitchTo(osastate-&gt;qstate-&gt;qcontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; compareTuple = <a href="../../executor/execGrouping.c.html#L58" title="executor/execGrouping.c:58">execTuplesMatchPrepare</a>(osastate-&gt;qstate-&gt;tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numDistinctCols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortColIdx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; osastate-&gt;qstate-&gt;eqOperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; osastate-&gt;qstate-&gt;sortCollations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldContext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; osastate-&gt;qstate-&gt;compareTuple = compareTuple;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* because we need a hypothetical row, we can't share transition state */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!osastate-&gt;sort_done);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* insert the hypothetical row into the sort */<br/></li>
<li></span>&nbsp; &nbsp; slot = osastate-&gt;qstate-&gt;tupslot;<br/></li>
<li>&nbsp; &nbsp; ExecClearTuple(slot);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nargs; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;tts_values[i] = PG_GETARG_DATUM(i + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;tts_isnull[i] = PG_ARGISNULL(i + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; slot-&gt;tts_values[i] = Int32GetDatum(-<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; slot-&gt;tts_isnull[i] = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../executor/execTuples.c.html#L1639" title="executor/execTuples.c:1639">ExecStoreVirtualTuple</a>(slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../sort/tuplesortvariants.c.html#L669" title="utils/sort/tuplesortvariants.c:669">tuplesort_puttupleslot</a>(osastate-&gt;sortstate, slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* finish the sort */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../sort/tuplesort.c.html#L1385" title="utils/sort/tuplesort.c:1385">tuplesort_performsort</a>(osastate-&gt;sortstate);<br/></li>
<li>&nbsp; &nbsp; osastate-&gt;sort_done = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We alternate fetching into tupslot and extraslot so that we have the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * previous row available for comparisons.&nbsp; This is accomplished by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * swapping the slot pointer variables after each row.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; extraslot = <a href="../../executor/execTuples.c.html#L1325" title="executor/execTuples.c:1325">MakeSingleTupleTableSlot</a>(osastate-&gt;qstate-&gt;tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;<a href="../../executor/execTuples.c.html#L86" title="executor/execTuples.c:86">TTSOpsMinimalTuple</a>);<br/></li>
<li>&nbsp; &nbsp; slot2 = extraslot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* iterate till we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the hypothetical row */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="../sort/tuplesortvariants.c.html#L890" title="utils/sort/tuplesortvariants.c:890">tuplesort_gettupleslot</a>(osastate-&gt;sortstate, <span class="Constant">true</span>, <span class="Constant">true</span>, slot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;abbrevVal))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; d = slot_getattr(slot, nargs + <span class="Constant">1</span>, &amp;isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot *tmpslot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!isnull &amp;&amp; DatumGetInt32(d) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* count non-distinct tuples */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; econtext-&gt;ecxt_outertuple = slot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; econtext-&gt;ecxt_innertuple = slot2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!TupIsNull(slot2) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; abbrevVal == abbrevOld &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExecQualAndReset(compareTuple, econtext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; duplicate_count++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tmpslot = slot2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot2 = slot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot = tmpslot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* avoid ExecQual() calls by reusing abbreviated keys */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; abbrevOld = abbrevVal;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rank++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ExecClearTuple(slot);<br/></li>
<li>&nbsp; &nbsp; ExecClearTuple(slot2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../executor/execTuples.c.html#L1341" title="executor/execTuples.c:1341">ExecDropSingleTupleTableSlot</a>(extraslot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rank = rank - duplicate_count;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT64(rank);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
