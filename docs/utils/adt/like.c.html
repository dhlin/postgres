<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/adt/like.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/adt/like.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L150">GenericMatchText</a></li>
<li><a href="#L171">Generic_Text_IC_like</a></li>
<li><a href="#L94">SB_lower_char</a></li>
<li><a href="#L324">bytealike</a></li>
<li><a href="#L345">byteanlike</a></li>
<li><a href="#L428">like_escape</a></li>
<li><a href="#L447">like_escape_bytea</a></li>
<li><a href="#L370">nameiclike</a></li>
<li><a href="#L385">nameicnlike</a></li>
<li><a href="#L240">namelike</a></li>
<li><a href="#L261">namenlike</a></li>
<li><a href="#L400">texticlike</a></li>
<li><a href="#L412">texticnlike</a></li>
<li><a href="#L282">textlike</a></li>
<li><a href="#L303">textnlike</a></li>
<li><a href="#L58">wchareq</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L108">CHAREQ</a></li>
<li><a href="#L124">CHAREQ</a></li>
<li><a href="#L111">CopyAdvChar</a></li>
<li><a href="#L126">CopyAdvChar</a></li>
<li><a href="#L32">LIKE_ABORT</a></li>
<li><a href="#L31">LIKE_FALSE</a></li>
<li><a href="#L30">LIKE_TRUE</a></li>
<li><a href="#L134">MATCH_LOWER</a></li>
<li><a href="#L118">MatchText</a></li>
<li><a href="#L128">MatchText</a></li>
<li><a href="#L136">MatchText</a></li>
<li><a href="#L144">MatchText</a></li>
<li><a href="#L105">NextByte</a></li>
<li><a href="#L109">NextChar</a></li>
<li><a href="#L125">NextChar</a></li>
<li><a href="#L135">NextChar</a></li>
<li><a href="#L142">NextChar</a></li>
<li><a href="#L119">do_like_escape</a></li>
<li><a href="#L129">do_like_escape</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * like.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; like expression handling code.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; NOTES<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; A big hack of the regexp.c code!! Contributed by<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Keith Parks &lt;emkxp01@mtcc.demon.co.uk&gt; (7/95).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; src/backend/utils/adt/like.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;ctype.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_collation.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;mb/pg_wchar.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgrprotos.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/pg_locale.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;varatt.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><a id="L30">&#x200c;</a><span class="PreProc">#define <span class="linkable">LIKE_TRUE</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">1<br/></li>
<li><a id="L31">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">LIKE_FALSE</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0<br/></li>
<li><a id="L32">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">LIKE_ABORT</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (-</span><span class="Constant">1</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; SB_MatchText(<span class="Type">const</span> <span class="Type">char</span> *t, <span class="Type">int</span> tlen, <span class="Type">const</span> <span class="Type">char</span> *p, <span class="Type">int</span> plen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pg_locale_t locale, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> locale_is_c);<br/></li>
<li><span class="Type">static</span> text *SB_do_like_escape(text *pat, text *esc);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; MB_MatchText(<span class="Type">const</span> <span class="Type">char</span> *t, <span class="Type">int</span> tlen, <span class="Type">const</span> <span class="Type">char</span> *p, <span class="Type">int</span> plen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pg_locale_t locale, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> locale_is_c);<br/></li>
<li><span class="Type">static</span> text *MB_do_like_escape(text *pat, text *esc);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; UTF8_MatchText(<span class="Type">const</span> <span class="Type">char</span> *t, <span class="Type">int</span> tlen, <span class="Type">const</span> <span class="Type">char</span> *p, <span class="Type">int</span> plen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pg_locale_t locale, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> locale_is_c);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; SB_IMatchText(<span class="Type">const</span> <span class="Type">char</span> *t, <span class="Type">int</span> tlen, <span class="Type">const</span> <span class="Type">char</span> *p, <span class="Type">int</span> plen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_locale_t locale, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> locale_is_c);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L150" title="utils/adt/like.c:150">GenericMatchText</a>(<span class="Type">const</span> <span class="Type">char</span> *s, <span class="Type">int</span> slen, <span class="Type">const</span> <span class="Type">char</span> *p, <span class="Type">int</span> plen, Oid collation);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L171" title="utils/adt/like.c:171">Generic_Text_IC_like</a>(text *str, text *pat, Oid collation);<br/></li>
<li><br/></li>
<li><span class="Comment">/*--------------------<br/></li>
<li></span><span class="Comment"> * Support routine for <a href="#L118" title="utils/adt/like.c:118">MatchText</a>. Compares given multibyte streams<br/></li>
<li></span><span class="Comment"> * as wide characters. If they match, returns 1 otherwise returns 0.<br/></li>
<li></span><span class="Comment"> *--------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">int<br/></li>
<li><a id="L58">&#x200c;</a></span><span class="linkable">wchareq</span>(<span class="Type">const</span> <span class="Type">char</span> *p1, <span class="Type">const</span> <span class="Type">char</span> *p2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p1_len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Optimization:&nbsp; quickly <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> the first byte. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (*p1 != *p2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; p1_len = <a href="../mb/mbutils.c.html#L1023" title="utils/mb/mbutils.c:1023">pg_mblen</a>(p1);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../mb/mbutils.c.html#L1023" title="utils/mb/mbutils.c:1023">pg_mblen</a>(p2) != p1_len)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* They are the same length */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (p1_len--)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*p1++ != *p2++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Formerly we had a routine iwchareq() here that tried to do case-insensitive<br/></li>
<li></span><span class="Comment"> * comparison of multibyte characters.&nbsp; It did not work at all, however,<br/></li>
<li></span><span class="Comment"> * because it relied on tolower() which has a single-byte API ... and<br/></li>
<li></span><span class="Comment"> * towlower() wouldn't be much better since we have no suitably cheap way<br/></li>
<li></span><span class="Comment"> * of getting a single character transformed to the system's wchar_t format.<br/></li>
<li></span><span class="Comment"> * So <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, we just downcase the strings using <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>() and apply regular LIKE<br/></li>
<li></span><span class="Comment"> * comparison.&nbsp; This should be revisited when we install better locale support.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * We do handle case-insensitive matching for single-byte encodings using<br/></li>
<li></span><span class="Comment"> * fold-on-the-fly processing, however.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char<br/></li>
<li><a id="L94">&#x200c;</a></span><span class="linkable">SB_lower_char</span>(<span class="Type">unsigned</span> <span class="Type">char</span> c, pg_locale_t locale, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> locale_is_c)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (locale_is_c)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> pg_ascii_tolower(c);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (locale)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> tolower_l(c, locale-&gt;info.lt);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> pg_tolower(c);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L105">&#x200c;</a><span class="PreProc">#define <span class="linkable">NextByte</span>(p, plen)&nbsp; &nbsp; ((p)++, (plen)--)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Set up to compile like_match.c for multibyte characters */<br/></li>
<li><a id="L108">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">CHAREQ</span>(p1, p2) <a href="#L58" title="utils/adt/like.c:58">wchareq</a>((p1), (p2))<br/></li>
<li><a id="L109">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NextChar</span>(p, plen) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">do</span><span class="PreProc"> { </span><span class="Type">int</span><span class="PreProc"> __l = <a href="../mb/mbutils.c.html#L1023" title="utils/mb/mbutils.c:1023">pg_mblen</a>(p); (p) +=__l; (plen) -=__l; } </span><span class="Statement">while</span><span class="PreProc"> (</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li><a id="L111">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">CopyAdvChar</span>(dst, src, srclen) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">do</span><span class="PreProc"> { </span><span class="Type">int</span><span class="PreProc"> __l = <a href="../mb/mbutils.c.html#L1023" title="utils/mb/mbutils.c:1023">pg_mblen</a>(src); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (srclen) -= __l; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="Statement">while</span><span class="PreProc"> (__l-- &gt; </span><span class="Constant">0</span><span class="PreProc">) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *(dst)++ = *(src)++; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp;&nbsp; } </span><span class="Statement">while</span><span class="PreProc"> (</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><a id="L118">&#x200c;</a><span class="PreProc">#define <span class="linkable">MatchText</span>&nbsp; &nbsp; MB_MatchText<br/></li>
<li><a id="L119">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">do_like_escape</span>&nbsp; &nbsp; MB_do_like_escape<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;like_match.c&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Set up to compile like_match.c for single-byte characters */<br/></li>
<li><a id="L124">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">CHAREQ</span>(p1, p2) (*(p1) == *(p2))<br/></li>
<li><a id="L125">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NextChar</span>(p, plen) <a href="#L105" title="utils/adt/like.c:105">NextByte</a>((p), (plen))<br/></li>
<li><a id="L126">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">CopyAdvChar</span>(dst, src, srclen) (*(dst)++ = *(src)++, (srclen)--)<br/></li>
<li></span><br/></li>
<li><a id="L128">&#x200c;</a><span class="PreProc">#define <span class="linkable">MatchText</span>&nbsp; &nbsp; SB_MatchText<br/></li>
<li><a id="L129">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">do_like_escape</span>&nbsp; &nbsp; SB_do_like_escape<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;like_match.c&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* setup to compile like_match.c for single byte case insensitive matches */<br/></li>
<li><a id="L134">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MATCH_LOWER</span>(t) <a href="#L94" title="utils/adt/like.c:94">SB_lower_char</a>((</span><span class="Type">unsigned</span><span class="PreProc"> </span><span class="Type">char</span><span class="PreProc">) (t), locale, locale_is_c)<br/></li>
<li><a id="L135">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NextChar</span>(p, plen) <a href="#L105" title="utils/adt/like.c:105">NextByte</a>((p), (plen))<br/></li>
<li><a id="L136">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MatchText</span> SB_IMatchText<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;like_match.c&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* setup to compile like_match.c for UTF8 encoding, using fast <a href="#L109" title="utils/adt/like.c:109">NextChar</a> */<br/></li>
<li></span><br/></li>
<li><a id="L142">&#x200c;</a><span class="PreProc">#define <span class="linkable">NextChar</span>(p, plen) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">do</span><span class="PreProc"> { (p)++; (plen)--; } </span><span class="Statement">while</span><span class="PreProc"> ((plen) &gt; </span><span class="Constant">0</span><span class="PreProc"> &amp;&amp; (*(p) &amp; </span><span class="Constant">0xC0</span><span class="PreProc">) == </span><span class="Constant">0x80</span><span class="PreProc"> )<br/></li>
<li><a id="L144">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MatchText</span>&nbsp; &nbsp; UTF8_MatchText<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;like_match.c&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Generic for all cases not requiring inline case-folding */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">int<br/></li>
<li><a id="L150">&#x200c;</a></span><span class="linkable">GenericMatchText</span>(<span class="Type">const</span> <span class="Type">char</span> *s, <span class="Type">int</span> slen, <span class="Type">const</span> <span class="Type">char</span> *p, <span class="Type">int</span> plen, Oid collation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (collation &amp;&amp; !<a href="pg_locale.c.html#L1384" title="utils/adt/pg_locale.c:1384">lc_ctype_is_c</a>(collation))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_locale_t locale = <a href="pg_locale.c.html#L1551" title="utils/adt/pg_locale.c:1551">pg_newlocale_from_collation</a>(collation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="pg_locale.c.html#L1531" title="utils/adt/pg_locale.c:1531">pg_locale_deterministic</a>(locale))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;nondeterministic collations are not supported for LIKE&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../mb/mbutils.c.html#L1546" title="utils/mb/mbutils.c:1546">pg_database_encoding_max_length</a>() == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> SB_MatchText(s, slen, p, plen, <span class="Constant">0</span>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../mb/mbutils.c.html#L1261" title="utils/mb/mbutils.c:1261">GetDatabaseEncoding</a>() == PG_UTF8)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> UTF8_MatchText(s, slen, p, plen, <span class="Constant">0</span>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> MB_MatchText(s, slen, p, plen, <span class="Constant">0</span>, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">int<br/></li>
<li><a id="L171">&#x200c;</a></span><span class="linkable">Generic_Text_IC_like</span>(text *str, text *pat, Oid collation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *s,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *p;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plen;<br/></li>
<li>&nbsp; &nbsp; pg_locale_t locale = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; locale_is_c = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(collation))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This typically means that the parser could not resolve a conflict<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of implicit collations, so report it that way.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INDETERMINATE_COLLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not determine which collation to use for ILIKE&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Use the COLLATE clause to set the collation explicitly.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="pg_locale.c.html#L1384" title="utils/adt/pg_locale.c:1384">lc_ctype_is_c</a>(collation))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; locale_is_c = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; locale = <a href="pg_locale.c.html#L1551" title="utils/adt/pg_locale.c:1551">pg_newlocale_from_collation</a>(collation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="pg_locale.c.html#L1531" title="utils/adt/pg_locale.c:1531">pg_locale_deterministic</a>(locale))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;nondeterministic collations are not supported for ILIKE&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For efficiency reasons, in the single byte case we don't call <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on the pattern and text, but instead call <a href="#L94" title="utils/adt/like.c:94">SB_lower_char</a> on each<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * character.&nbsp; In the multi-byte case we don't have much choice :-(. Also,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ICU does not support single-character case folding, so we go the long<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * way.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../mb/mbutils.c.html#L1546" title="utils/mb/mbutils.c:1546">pg_database_encoding_max_length</a>() &gt; <span class="Constant">1</span> || (locale &amp;&amp; locale-&gt;<a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a> == COLLPROVIDER_ICU))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pat = DatumGetTextPP(<a href="../fmgr/fmgr.c.html#L792" title="utils/fmgr/fmgr.c:792">DirectFunctionCall1Coll</a>(<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PointerGetDatum(pat)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; p = VARDATA_ANY(pat);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plen = VARSIZE_ANY_EXHDR(pat);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; str = DatumGetTextPP(<a href="../fmgr/fmgr.c.html#L792" title="utils/fmgr/fmgr.c:792">DirectFunctionCall1Coll</a>(<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PointerGetDatum(str)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s = VARDATA_ANY(str);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slen = VARSIZE_ANY_EXHDR(str);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../mb/mbutils.c.html#L1261" title="utils/mb/mbutils.c:1261">GetDatabaseEncoding</a>() == PG_UTF8)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> UTF8_MatchText(s, slen, p, plen, <span class="Constant">0</span>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> MB_MatchText(s, slen, p, plen, <span class="Constant">0</span>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; p = VARDATA_ANY(pat);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plen = VARSIZE_ANY_EXHDR(pat);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s = VARDATA_ANY(str);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slen = VARSIZE_ANY_EXHDR(str);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> SB_IMatchText(s, slen, p, plen, locale, locale_is_c);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; interface routines called by the function manager<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L240">&#x200c;</a><span class="linkable">namelike</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Name&nbsp; &nbsp; &nbsp; &nbsp; str = PG_GETARG_NAME(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *pat = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *s,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *p;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; s = NameStr(*str);<br/></li>
<li>&nbsp; &nbsp; slen = strlen(s);<br/></li>
<li>&nbsp; &nbsp; p = VARDATA_ANY(pat);<br/></li>
<li>&nbsp; &nbsp; plen = VARSIZE_ANY_EXHDR(pat);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (<a href="#L150" title="utils/adt/like.c:150">GenericMatchText</a>(s, slen, p, plen, PG_GET_COLLATION()) == <a href="#L30" title="utils/adt/like.c:30">LIKE_TRUE</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L261">&#x200c;</a><span class="linkable">namenlike</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Name&nbsp; &nbsp; &nbsp; &nbsp; str = PG_GETARG_NAME(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *pat = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *s,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *p;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; s = NameStr(*str);<br/></li>
<li>&nbsp; &nbsp; slen = strlen(s);<br/></li>
<li>&nbsp; &nbsp; p = VARDATA_ANY(pat);<br/></li>
<li>&nbsp; &nbsp; plen = VARSIZE_ANY_EXHDR(pat);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (<a href="#L150" title="utils/adt/like.c:150">GenericMatchText</a>(s, slen, p, plen, PG_GET_COLLATION()) != <a href="#L30" title="utils/adt/like.c:30">LIKE_TRUE</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L282">&#x200c;</a><span class="linkable">textlike</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *str = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *pat = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *s,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *p;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; s = VARDATA_ANY(str);<br/></li>
<li>&nbsp; &nbsp; slen = VARSIZE_ANY_EXHDR(str);<br/></li>
<li>&nbsp; &nbsp; p = VARDATA_ANY(pat);<br/></li>
<li>&nbsp; &nbsp; plen = VARSIZE_ANY_EXHDR(pat);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (<a href="#L150" title="utils/adt/like.c:150">GenericMatchText</a>(s, slen, p, plen, PG_GET_COLLATION()) == <a href="#L30" title="utils/adt/like.c:30">LIKE_TRUE</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L303">&#x200c;</a><span class="linkable">textnlike</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *str = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *pat = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *s,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *p;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; s = VARDATA_ANY(str);<br/></li>
<li>&nbsp; &nbsp; slen = VARSIZE_ANY_EXHDR(str);<br/></li>
<li>&nbsp; &nbsp; p = VARDATA_ANY(pat);<br/></li>
<li>&nbsp; &nbsp; plen = VARSIZE_ANY_EXHDR(pat);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (<a href="#L150" title="utils/adt/like.c:150">GenericMatchText</a>(s, slen, p, plen, PG_GET_COLLATION()) != <a href="#L30" title="utils/adt/like.c:30">LIKE_TRUE</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L324">&#x200c;</a><span class="linkable">bytealike</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *str = PG_GETARG_BYTEA_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *pat = PG_GETARG_BYTEA_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *s,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *p;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; s = VARDATA_ANY(str);<br/></li>
<li>&nbsp; &nbsp; slen = VARSIZE_ANY_EXHDR(str);<br/></li>
<li>&nbsp; &nbsp; p = VARDATA_ANY(pat);<br/></li>
<li>&nbsp; &nbsp; plen = VARSIZE_ANY_EXHDR(pat);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (SB_MatchText(s, slen, p, plen, <span class="Constant">0</span>, <span class="Constant">true</span>) == <a href="#L30" title="utils/adt/like.c:30">LIKE_TRUE</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L345">&#x200c;</a><span class="linkable">byteanlike</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *str = PG_GETARG_BYTEA_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *pat = PG_GETARG_BYTEA_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *s,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *p;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; s = VARDATA_ANY(str);<br/></li>
<li>&nbsp; &nbsp; slen = VARSIZE_ANY_EXHDR(str);<br/></li>
<li>&nbsp; &nbsp; p = VARDATA_ANY(pat);<br/></li>
<li>&nbsp; &nbsp; plen = VARSIZE_ANY_EXHDR(pat);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (SB_MatchText(s, slen, p, plen, <span class="Constant">0</span>, <span class="Constant">true</span>) != <a href="#L30" title="utils/adt/like.c:30">LIKE_TRUE</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Case-insensitive versions<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L370">&#x200c;</a><span class="linkable">nameiclike</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Name&nbsp; &nbsp; &nbsp; &nbsp; str = PG_GETARG_NAME(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *pat = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *strtext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; strtext = DatumGetTextPP(DirectFunctionCall1(<a href="varlena.c.html#L3382" title="utils/adt/varlena.c:3382">name_text</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NameGetDatum(str)));<br/></li>
<li>&nbsp; &nbsp; result = (<a href="#L171" title="utils/adt/like.c:171">Generic_Text_IC_like</a>(strtext, pat, PG_GET_COLLATION()) == <a href="#L30" title="utils/adt/like.c:30">LIKE_TRUE</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L385">&#x200c;</a><span class="linkable">nameicnlike</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Name&nbsp; &nbsp; &nbsp; &nbsp; str = PG_GETARG_NAME(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *pat = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *strtext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; strtext = DatumGetTextPP(DirectFunctionCall1(<a href="varlena.c.html#L3382" title="utils/adt/varlena.c:3382">name_text</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NameGetDatum(str)));<br/></li>
<li>&nbsp; &nbsp; result = (<a href="#L171" title="utils/adt/like.c:171">Generic_Text_IC_like</a>(strtext, pat, PG_GET_COLLATION()) != <a href="#L30" title="utils/adt/like.c:30">LIKE_TRUE</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L400">&#x200c;</a><span class="linkable">texticlike</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *str = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *pat = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (<a href="#L171" title="utils/adt/like.c:171">Generic_Text_IC_like</a>(str, pat, PG_GET_COLLATION()) == <a href="#L30" title="utils/adt/like.c:30">LIKE_TRUE</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L412">&#x200c;</a><span class="linkable">texticnlike</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *str = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *pat = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (<a href="#L171" title="utils/adt/like.c:171">Generic_Text_IC_like</a>(str, pat, PG_GET_COLLATION()) != <a href="#L30" title="utils/adt/like.c:30">LIKE_TRUE</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L428" title="utils/adt/like.c:428">like_escape</a>() --- given a pattern and an ESCAPE string,<br/></li>
<li></span><span class="Comment"> * convert the pattern to use Postgres' standard backslash escape convention.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L428">&#x200c;</a><span class="linkable">like_escape</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *pat = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *esc = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../mb/mbutils.c.html#L1546" title="utils/mb/mbutils.c:1546">pg_database_encoding_max_length</a>() == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = SB_do_like_escape(pat, esc);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = MB_do_like_escape(pat, esc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L447" title="utils/adt/like.c:447">like_escape_bytea</a>() --- given a pattern and an ESCAPE string,<br/></li>
<li></span><span class="Comment"> * convert the pattern to use Postgres' standard backslash escape convention.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L447">&#x200c;</a><span class="linkable">like_escape_bytea</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *pat = PG_GETARG_BYTEA_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *esc = PG_GETARG_BYTEA_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *result = SB_do_like_escape((text *) pat, (text *) esc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BYTEA_P((bytea *) result);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
