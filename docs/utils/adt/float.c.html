<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/adt/float.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/adt/float.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L48">acos_0_5</a></li>
<li><a href="#L47">asin_0_5</a></li>
<li><a href="#L49">atan_1_0</a></li>
<li><a href="#L51">cot_45</a></li>
<li><a href="#L60">degree_c_forty_five</a></li>
<li><a href="#L63">degree_c_one</a></li>
<li><a href="#L62">degree_c_one_half</a></li>
<li><a href="#L61">degree_c_sixty</a></li>
<li><a href="#L59">degree_c_thirty</a></li>
<li><a href="#L44">degree_consts_set</a></li>
<li><a href="#L41">extra_float_digits</a></li>
<li><a href="#L46">one_minus_cos_60</a></li>
<li><a href="#L45">sin_30</a></li>
<li><a href="#L50">tan_45</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L2074">acosd_q1</a></li>
<li><a href="#L2041">asind_q1</a></li>
<li><a href="#L994">btfloat48cmp</a></li>
<li><a href="#L873">btfloat4cmp</a></li>
<li><a href="#L882">btfloat4fastcmp</a></li>
<li><a href="#L891">btfloat4sortsupport</a></li>
<li><a href="#L1004">btfloat84cmp</a></li>
<li><a href="#L967">btfloat8cmp</a></li>
<li><a href="#L976">btfloat8fastcmp</a></li>
<li><a href="#L985">btfloat8sortsupport</a></li>
<li><a href="#L2832">check_float8_array</a></li>
<li><a href="#L2259">cosd_0_to_60</a></li>
<li><a href="#L2292">cosd_q1</a></li>
<li><a href="#L1748">dacos</a></li>
<li><a href="#L2101">dacosd</a></li>
<li><a href="#L2682">dacosh</a></li>
<li><a href="#L1779">dasin</a></li>
<li><a href="#L2138">dasind</a></li>
<li><a href="#L2665">dasinh</a></li>
<li><a href="#L1810">datan</a></li>
<li><a href="#L1836">datan2</a></li>
<li><a href="#L2207">datan2d</a></li>
<li><a href="#L2175">datand</a></li>
<li><a href="#L2707">datanh</a></li>
<li><a href="#L1463">dcbrt</a></li>
<li><a href="#L1373">dceil</a></li>
<li><a href="#L1862">dcos</a></li>
<li><a href="#L2311">dcosd</a></li>
<li><a href="#L2620">dcosh</a></li>
<li><a href="#L1903">dcot</a></li>
<li><a href="#L2366">dcotd</a></li>
<li><a href="#L2554">degrees</a></li>
<li><a href="#L2745">derf</a></li>
<li><a href="#L2765">derfc</a></li>
<li><a href="#L1637">dexp</a></li>
<li><a href="#L1385">dfloor</a></li>
<li><a href="#L1683">dlog1</a></li>
<li><a href="#L1715">dlog10</a></li>
<li><a href="#L2566">dpi</a></li>
<li><a href="#L1482">dpow</a></li>
<li><a href="#L1361">dround</a></li>
<li><a href="#L1398">dsign</a></li>
<li><a href="#L1931">dsin</a></li>
<li><a href="#L2432">dsind</a></li>
<li><a href="#L2591">dsinh</a></li>
<li><a href="#L1439">dsqrt</a></li>
<li><a href="#L1958">dtan</a></li>
<li><a href="#L2488">dtand</a></li>
<li><a href="#L2645">dtanh</a></li>
<li><a href="#L1188">dtof</a></li>
<li><a href="#L1232">dtoi2</a></li>
<li><a href="#L1207">dtoi4</a></li>
<li><a href="#L1421">dtrunc</a></li>
<li><a href="#L3804">float48div</a></li>
<li><a href="#L3864">float48eq</a></li>
<li><a href="#L3909">float48ge</a></li>
<li><a href="#L3900">float48gt</a></li>
<li><a href="#L3891">float48le</a></li>
<li><a href="#L3882">float48lt</a></li>
<li><a href="#L3786">float48mi</a></li>
<li><a href="#L3795">float48mul</a></li>
<li><a href="#L3873">float48ne</a></li>
<li><a href="#L3777">float48pl</a></li>
<li><a href="#L3033">float4_accum</a></li>
<li><a href="#L809">float4_cmp_internal</a></li>
<li><a href="#L584">float4abs</a></li>
<li><a href="#L748">float4div</a></li>
<li><a href="#L819">float4eq</a></li>
<li><a href="#L864">float4ge</a></li>
<li><a href="#L855">float4gt</a></li>
<li><a href="#L157">float4in</a></li>
<li><a href="#L176">float4in_internal</a></li>
<li><a href="#L613">float4larger</a></li>
<li><a href="#L846">float4le</a></li>
<li><a href="#L837">float4lt</a></li>
<li><a href="#L730">float4mi</a></li>
<li><a href="#L739">float4mul</a></li>
<li><a href="#L828">float4ne</a></li>
<li><a href="#L312">float4out</a></li>
<li><a href="#L721">float4pl</a></li>
<li><a href="#L332">float4recv</a></li>
<li><a href="#L343">float4send</a></li>
<li><a href="#L627">float4smaller</a></li>
<li><a href="#L595">float4um</a></li>
<li><a href="#L605">float4up</a></li>
<li><a href="#L3846">float84div</a></li>
<li><a href="#L3921">float84eq</a></li>
<li><a href="#L3966">float84ge</a></li>
<li><a href="#L3957">float84gt</a></li>
<li><a href="#L3948">float84le</a></li>
<li><a href="#L3939">float84lt</a></li>
<li><a href="#L3828">float84mi</a></li>
<li><a href="#L3837">float84mul</a></li>
<li><a href="#L3930">float84ne</a></li>
<li><a href="#L3819">float84pl</a></li>
<li><a href="#L2950">float8_accum</a></li>
<li><a href="#L3118">float8_avg</a></li>
<li><a href="#L903">float8_cmp_internal</a></li>
<li><a href="#L2856">float8_combine</a></li>
<li><a href="#L3644">float8_corr</a></li>
<li><a href="#L3606">float8_covar_pop</a></li>
<li><a href="#L3625">float8_covar_samp</a></li>
<li><a href="#L3247">float8_regr_accum</a></li>
<li><a href="#L3568">float8_regr_avgx</a></li>
<li><a href="#L3587">float8_regr_avgy</a></li>
<li><a href="#L3371">float8_regr_combine</a></li>
<li><a href="#L3733">float8_regr_intercept</a></li>
<li><a href="#L3673">float8_regr_r2</a></li>
<li><a href="#L3706">float8_regr_slope</a></li>
<li><a href="#L3505">float8_regr_sxx</a></li>
<li><a href="#L3547">float8_regr_sxy</a></li>
<li><a href="#L3526">float8_regr_syy</a></li>
<li><a href="#L3182">float8_stddev_pop</a></li>
<li><a href="#L3204">float8_stddev_samp</a></li>
<li><a href="#L3138">float8_var_pop</a></li>
<li><a href="#L3160">float8_var_samp</a></li>
<li><a href="#L650">float8abs</a></li>
<li><a href="#L790">float8div</a></li>
<li><a href="#L913">float8eq</a></li>
<li><a href="#L958">float8ge</a></li>
<li><a href="#L949">float8gt</a></li>
<li><a href="#L357">float8in</a></li>
<li><a href="#L388">float8in_internal</a></li>
<li><a href="#L680">float8larger</a></li>
<li><a href="#L940">float8le</a></li>
<li><a href="#L931">float8lt</a></li>
<li><a href="#L772">float8mi</a></li>
<li><a href="#L781">float8mul</a></li>
<li><a href="#L922">float8ne</a></li>
<li><a href="#L515">float8out</a></li>
<li><a href="#L530">float8out_internal</a></li>
<li><a href="#L763">float8pl</a></li>
<li><a href="#L549">float8recv</a></li>
<li><a href="#L560">float8send</a></li>
<li><a href="#L694">float8smaller</a></li>
<li><a href="#L662">float8um</a></li>
<li><a href="#L672">float8up</a></li>
<li><a href="#L79">float_overflow_error</a></li>
<li><a href="#L87">float_underflow_error</a></li>
<li><a href="#L95">float_zero_divide_error</a></li>
<li><a href="#L1176">ftod</a></li>
<li><a href="#L1306">ftoi2</a></li>
<li><a href="#L1281">ftoi4</a></li>
<li><a href="#L1269">i2tod</a></li>
<li><a href="#L1343">i2tof</a></li>
<li><a href="#L1257">i4tod</a></li>
<li><a href="#L1331">i4tof</a></li>
<li><a href="#L1096">in_range_float4_float8</a></li>
<li><a href="#L1020">in_range_float8_float8</a></li>
<li><a href="#L2012">init_degree_constants</a></li>
<li><a href="#L111">is_infinite</a></li>
<li><a href="#L2576">radians</a></li>
<li><a href="#L2245">sind_0_to_30</a></li>
<li><a href="#L2272">sind_q1</a></li>
<li><a href="#L3989">width_bucket_float8</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L2024">INIT_DEGREE_CONSTANTS</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * float.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Functions for the built-in floating-point types.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/adt/float.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;ctype.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;float.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;math.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;limits.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/int.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/shortest_dec.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/pqformat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/array.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/float.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgrprotos.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/sortsupport.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/timestamp.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Configurable GUC parameter<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If &gt;0, use <a href="../../regex/rege_dfa.c.html#L204" title="regex/rege_dfa.c:204">shortest</a>-decimal format for output; this is both the default and<br/></li>
<li></span><span class="Comment"> * allows for compatibility with clients that explicitly set a value here to<br/></li>
<li></span><span class="Comment"> * get round-trip-accurate results. If 0 or less, then use the old, slow,<br/></li>
<li></span><span class="Comment"> * decimal rounding method.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L41">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">extra_float_digits</span> = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Cached constants for degree-based trig <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li><a id="L44">&#x200c;</a></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">degree_consts_set</span> = <span class="Constant">false</span>;<br/></li>
<li><a id="L45">&#x200c;</a><span class="Type">static</span> float8 <span class="linkable">sin_30</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L46">&#x200c;</a><span class="Type">static</span> float8 <span class="linkable">one_minus_cos_60</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L47">&#x200c;</a><span class="Type">static</span> float8 <span class="linkable">asin_0_5</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L48">&#x200c;</a><span class="Type">static</span> float8 <span class="linkable">acos_0_5</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L49">&#x200c;</a><span class="Type">static</span> float8 <span class="linkable">atan_1_0</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L50">&#x200c;</a><span class="Type">static</span> float8 <span class="linkable">tan_45</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L51">&#x200c;</a><span class="Type">static</span> float8 <span class="linkable">cot_45</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * These are intentionally not static; don't &quot;fix&quot; them.&nbsp; They will never<br/></li>
<li></span><span class="Comment"> * be referenced by other files, much less changed; but we don't want the<br/></li>
<li></span><span class="Comment"> * compiler to know that, else it might try to precompute expressions<br/></li>
<li></span><span class="Comment"> * involving them.&nbsp; See comments for <a href="#L2012" title="utils/adt/float.c:2012">init_degree_constants</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L59">&#x200c;</a></span>float8&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">degree_c_thirty</span> = <span class="Constant">30.0</span>;<br/></li>
<li><a id="L60">&#x200c;</a>float8&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">degree_c_forty_five</span> = <span class="Constant">45.0</span>;<br/></li>
<li><a id="L61">&#x200c;</a>float8&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">degree_c_sixty</span> = <span class="Constant">60.0</span>;<br/></li>
<li><a id="L62">&#x200c;</a>float8&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">degree_c_one_half</span> = <span class="Constant">0.5</span>;<br/></li>
<li><a id="L63">&#x200c;</a>float8&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">degree_c_one</span> = <span class="Constant">1.0</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Local function prototypes */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">double</span> <a href="#L2272" title="utils/adt/float.c:2272">sind_q1</a>(<span class="Type">double</span> x);<br/></li>
<li><span class="Type">static</span> <span class="Type">double</span> <a href="#L2292" title="utils/adt/float.c:2292">cosd_q1</a>(<span class="Type">double</span> x);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2012" title="utils/adt/float.c:2012">init_degree_constants</a>(<span class="Type">void</span>);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * We use these out-of-line ereport() calls to report float overflow,<br/></li>
<li></span><span class="Comment"> * underflow, and zero-divide, because following our usual practice of<br/></li>
<li></span><span class="Comment"> * repeating them at each call site would lead to a lot of code bloat.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This does mean that you don't get a useful error location indicator.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>pg_noinline <span class="Type">void<br/></li>
<li><a id="L79">&#x200c;</a></span><span class="linkable">float_overflow_error</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;value out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>: overflow&quot;</span>)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>pg_noinline <span class="Type">void<br/></li>
<li><a id="L87">&#x200c;</a></span><span class="linkable">float_underflow_error</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;value out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>: underflow&quot;</span>)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>pg_noinline <span class="Type">void<br/></li>
<li><a id="L95">&#x200c;</a></span><span class="linkable">float_zero_divide_error</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DIVISION_BY_ZERO),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;division by zero&quot;</span>)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns -1 if 'val' represents negative infinity, 1 if 'val'<br/></li>
<li></span><span class="Comment"> * represents (positive) infinity, and 0 otherwise. On some platforms,<br/></li>
<li></span><span class="Comment"> * this is equivalent to the isinf() macro, but not everywhere: C99<br/></li>
<li></span><span class="Comment"> * does not specify that isinf() needs to distinguish between positive<br/></li>
<li></span><span class="Comment"> * and negative infinity.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L111">&#x200c;</a></span><span class="linkable">is_infinite</span>(<span class="Type">double</span> val)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inf = isinf(val);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (inf == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (val &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ========== USER I/O ROUTINES ========== */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L157" title="utils/adt/float.c:157">float4in</a>&nbsp; &nbsp; &nbsp; &nbsp; - converts &quot;num&quot; to float4<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that this code <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> uses strtof(), where it used to use strtod().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The motivation for using strtof() is to avoid a double-rounding problem:<br/></li>
<li></span><span class="Comment"> * for certain decimal inputs, if you round the input correctly to a double,<br/></li>
<li></span><span class="Comment"> * and then round the double to a float, the result is incorrect in that it<br/></li>
<li></span><span class="Comment"> * does not match the result of rounding the decimal value to float directly.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * One of the best examples is 7.038531e-26:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 0xAE43FDp-107 = 7.03853069185120912085...e-26<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; midpoint&nbsp;&nbsp; 7.03853100000000022281...e-26<br/></li>
<li></span><span class="Comment"> * 0xAE43FEp-107 = 7.03853130814879132477...e-26<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * making 0xAE43FDp-107 the correct float result, but if you do the conversion<br/></li>
<li></span><span class="Comment"> * via a double, you get<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 0xAE43FD.7FFFFFF8p-107 = 7.03853099999999907487...e-26<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; midpoint&nbsp;&nbsp; 7.03853099999999964884...e-26<br/></li>
<li></span><span class="Comment"> * 0xAE43FD.80000000p-107 = 7.03853100000000022281...e-26<br/></li>
<li></span><span class="Comment"> * 0xAE43FD.80000008p-107 = 7.03853100000000137076...e-26<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * so the value rounds to the double exactly on the midpoint between the two<br/></li>
<li></span><span class="Comment"> * nearest floats, and then rounding again to a float gives the incorrect<br/></li>
<li></span><span class="Comment"> * result of 0xAE43FEp-107.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L157">&#x200c;</a><span class="linkable">float4in</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *num = PG_GETARG_CSTRING(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT4(<a href="#L176" title="utils/adt/float.c:176">float4in_internal</a>(num, <span class="Constant">NULL</span>, <span class="Constant">&quot;real&quot;</span>, num,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fcinfo-&gt;context));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L176" title="utils/adt/float.c:176">float4in_internal</a> - guts of <a href="#L157" title="utils/adt/float.c:157">float4in</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is exposed for use by <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> that want a reasonably<br/></li>
<li></span><span class="Comment"> * platform-independent way of inputting floats. The behavior is<br/></li>
<li></span><span class="Comment"> * essentially like strtof + ereturn on error.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Uses the same API as <a href="#L388" title="utils/adt/float.c:388">float8in_internal</a> below, so most of its<br/></li>
<li></span><span class="Comment"> * comments also apply here, except regarding use in geometric types.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>float4<br/></li>
<li><a id="L176">&#x200c;</a><span class="linkable">float4in_internal</span>(<span class="Type">char</span> *num, <span class="Type">char</span> **endptr_p,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *type_name, <span class="Type">const</span> <span class="Type">char</span> *orig_string,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> Node *escontext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">float</span>&nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *endptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * endptr points to the first character _after_ the sequence we recognized<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as a valid floating point number. orig_string points to the original<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * input string.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> leading whitespace */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (*num != <span class="Special">'\0'</span> &amp;&amp; isspace((<span class="Type">unsigned</span> <span class="Type">char</span>) *num))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; num++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check for an empty-string input to begin with, to avoid the vagaries of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * strtod() on different platforms.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (*num == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid input syntax for type </span><span class="Special">%s</span><span class="Constant">: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type_name, orig_string)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; val = strtof(num, &amp;endptr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* did we not see anything that looks like a double? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (endptr == num || errno != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno = errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * C99 requires that strtof() <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> NaN, [+-]Infinity, and [+-]Inf,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but not all platforms support all of these (and some <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> them<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but set ERANGE anyway...)&nbsp; Therefore, we check for these inputs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ourselves if strtof() fails.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: C99 also requires hexadecimal input as well as some extended<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * forms of NaN, but we consider these forms unportable and don't try<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to support them.&nbsp; You can use 'em if your strtof() takes 'em.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pg_strncasecmp(num, <span class="Constant">&quot;NaN&quot;</span>, <span class="Constant">3</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val = get_float4_nan();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; endptr = num + <span class="Constant">3</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (pg_strncasecmp(num, <span class="Constant">&quot;Infinity&quot;</span>, <span class="Constant">8</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val = get_float4_infinity();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; endptr = num + <span class="Constant">8</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (pg_strncasecmp(num, <span class="Constant">&quot;+Infinity&quot;</span>, <span class="Constant">9</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val = get_float4_infinity();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; endptr = num + <span class="Constant">9</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (pg_strncasecmp(num, <span class="Constant">&quot;-Infinity&quot;</span>, <span class="Constant">9</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val = -get_float4_infinity();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; endptr = num + <span class="Constant">9</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (pg_strncasecmp(num, <span class="Constant">&quot;inf&quot;</span>, <span class="Constant">3</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val = get_float4_infinity();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; endptr = num + <span class="Constant">3</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (pg_strncasecmp(num, <span class="Constant">&quot;+inf&quot;</span>, <span class="Constant">4</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val = get_float4_infinity();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; endptr = num + <span class="Constant">4</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (pg_strncasecmp(num, <span class="Constant">&quot;-inf&quot;</span>, <span class="Constant">4</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val = -get_float4_infinity();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; endptr = num + <span class="Constant">4</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (save_errno == <span class="Constant">ERANGE</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Some platforms return ERANGE for denormalized numbers (those<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that are not zero, but are too close to zero to have full<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * precision).&nbsp; We'd prefer not to throw error for that, so try to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * detect whether it's a &quot;real&quot; out-of-<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> condition by checking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to see if the result is zero or huge.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (val == <span class="Constant">0.0</span> ||<br/></li>
<li><span class="PreProc">#if !defined(HUGE_VALF)<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isinf(val)<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (val &gt;= HUGE_VALF || val &lt;= -HUGE_VALF)<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; )<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* see comments in <a href="#L388" title="utils/adt/float.c:388">float8in_internal</a> for rationale */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *errnumber = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(num);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errnumber[endptr - num] = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> for type real&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errnumber)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid input syntax for type </span><span class="Special">%s</span><span class="Constant">: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type_name, orig_string)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> trailing whitespace */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (*endptr != <span class="Special">'\0'</span> &amp;&amp; isspace((<span class="Type">unsigned</span> <span class="Type">char</span>) *endptr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; endptr++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* report stopping point if wanted, else complain if not end of string */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (endptr_p)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *endptr_p = endptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*endptr != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid input syntax for type </span><span class="Special">%s</span><span class="Constant">: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type_name, orig_string)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> val;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L312" title="utils/adt/float.c:312">float4out</a>&nbsp; &nbsp; &nbsp; &nbsp; - converts a float4 number to a string<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; using a standard output format<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L312">&#x200c;</a><span class="linkable">float4out</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; num = PG_GETARG_FLOAT4(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *<a href="oracle_compat.c.html#L925" title="utils/adt/oracle_compat.c:925">ascii</a> = (<span class="Type">char</span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Constant">32</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndig = <span class="Constant">FLT_DIG</span> + <a href="#L41" title="utils/adt/float.c:41">extra_float_digits</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L41" title="utils/adt/float.c:41">extra_float_digits</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; float_to_shortest_decimal_buf(num, <a href="oracle_compat.c.html#L925" title="utils/adt/oracle_compat.c:925">ascii</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_CSTRING(<a href="oracle_compat.c.html#L925" title="utils/adt/oracle_compat.c:925">ascii</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) pg_strfromd(<a href="oracle_compat.c.html#L925" title="utils/adt/oracle_compat.c:925">ascii</a>, <span class="Constant">32</span>, ndig, num);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CSTRING(<a href="oracle_compat.c.html#L925" title="utils/adt/oracle_compat.c:925">ascii</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L332" title="utils/adt/float.c:332">float4recv</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts external binary format to float4<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L332">&#x200c;</a><span class="linkable">float4recv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; buf = (StringInfo) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT4(<a href="../../libpq/pqformat.c.html#L469" title="libpq/pqformat.c:469">pq_getmsgfloat4</a>(buf));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L343" title="utils/adt/float.c:343">float4send</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts float4 to binary format<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L343">&#x200c;</a><span class="linkable">float4send</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; num = PG_GETARG_FLOAT4(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L326" title="libpq/pqformat.c:326">pq_begintypsend</a>(&amp;buf);<br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L252" title="libpq/pqformat.c:252">pq_sendfloat4</a>(&amp;buf, num);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BYTEA_P(<a href="../../libpq/pqformat.c.html#L346" title="libpq/pqformat.c:346">pq_endtypsend</a>(&amp;buf));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L357" title="utils/adt/float.c:357">float8in</a>&nbsp; &nbsp; &nbsp; &nbsp; - converts &quot;num&quot; to float8<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L357">&#x200c;</a><span class="linkable">float8in</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *num = PG_GETARG_CSTRING(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(<a href="#L388" title="utils/adt/float.c:388">float8in_internal</a>(num, <span class="Constant">NULL</span>, <span class="Constant">&quot;double precision&quot;</span>, num,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fcinfo-&gt;context));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L388" title="utils/adt/float.c:388">float8in_internal</a> - guts of <a href="#L357" title="utils/adt/float.c:357">float8in</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is exposed for use by <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> that want a reasonably<br/></li>
<li></span><span class="Comment"> * platform-independent way of inputting doubles.&nbsp; The behavior is<br/></li>
<li></span><span class="Comment"> * essentially like strtod + ereturn on error, but note the following<br/></li>
<li></span><span class="Comment"> * differences:<br/></li>
<li></span><span class="Comment"> * 1. Both leading and trailing whitespace are skipped.<br/></li>
<li></span><span class="Comment"> * 2. If endptr_p is NULL, we report error if there's trailing junk.<br/></li>
<li></span><span class="Comment"> * Otherwise, it's up to the caller to complain about trailing junk.<br/></li>
<li></span><span class="Comment"> * 3. In event of a syntax error, the report mentions the given type_name<br/></li>
<li></span><span class="Comment"> * and prints orig_string as the input; this is meant to support use of<br/></li>
<li></span><span class="Comment"> * this function with types such as &quot;box&quot; and &quot;point&quot;, where what we are<br/></li>
<li></span><span class="Comment"> * parsing here is just a substring of orig_string.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If escontext points to an ErrorSaveContext node, that is filled instead<br/></li>
<li></span><span class="Comment"> * of throwing an error; the caller must check SOFT_ERROR_OCCURRED()<br/></li>
<li></span><span class="Comment"> * to detect errors.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * &quot;num&quot; could validly be declared &quot;const char *&quot;, but that results in an<br/></li>
<li></span><span class="Comment"> * unreasonable amount of extra casting both here and in callers, so we don't.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>float8<br/></li>
<li><a id="L388">&#x200c;</a><span class="linkable">float8in_internal</span>(<span class="Type">char</span> *num, <span class="Type">char</span> **endptr_p,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *type_name, <span class="Type">const</span> <span class="Type">char</span> *orig_string,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> Node *escontext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *endptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> leading whitespace */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (*num != <span class="Special">'\0'</span> &amp;&amp; isspace((<span class="Type">unsigned</span> <span class="Type">char</span>) *num))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; num++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check for an empty-string input to begin with, to avoid the vagaries of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * strtod() on different platforms.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (*num == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid input syntax for type </span><span class="Special">%s</span><span class="Constant">: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type_name, orig_string)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; val = strtod(num, &amp;endptr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* did we not see anything that looks like a double? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (endptr == num || errno != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno = errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * C99 requires that strtod() <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> NaN, [+-]Infinity, and [+-]Inf,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but not all platforms support all of these (and some <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> them<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but set ERANGE anyway...)&nbsp; Therefore, we check for these inputs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ourselves if strtod() fails.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: C99 also requires hexadecimal input as well as some extended<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * forms of NaN, but we consider these forms unportable and don't try<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to support them.&nbsp; You can use 'em if your strtod() takes 'em.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pg_strncasecmp(num, <span class="Constant">&quot;NaN&quot;</span>, <span class="Constant">3</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val = get_float8_nan();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; endptr = num + <span class="Constant">3</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (pg_strncasecmp(num, <span class="Constant">&quot;Infinity&quot;</span>, <span class="Constant">8</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val = get_float8_infinity();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; endptr = num + <span class="Constant">8</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (pg_strncasecmp(num, <span class="Constant">&quot;+Infinity&quot;</span>, <span class="Constant">9</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val = get_float8_infinity();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; endptr = num + <span class="Constant">9</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (pg_strncasecmp(num, <span class="Constant">&quot;-Infinity&quot;</span>, <span class="Constant">9</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val = -get_float8_infinity();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; endptr = num + <span class="Constant">9</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (pg_strncasecmp(num, <span class="Constant">&quot;inf&quot;</span>, <span class="Constant">3</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val = get_float8_infinity();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; endptr = num + <span class="Constant">3</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (pg_strncasecmp(num, <span class="Constant">&quot;+inf&quot;</span>, <span class="Constant">4</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val = get_float8_infinity();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; endptr = num + <span class="Constant">4</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (pg_strncasecmp(num, <span class="Constant">&quot;-inf&quot;</span>, <span class="Constant">4</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val = -get_float8_infinity();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; endptr = num + <span class="Constant">4</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (save_errno == <span class="Constant">ERANGE</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Some platforms return ERANGE for denormalized numbers (those<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that are not zero, but are too close to zero to have full<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * precision).&nbsp; We'd prefer not to throw error for that, so try to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * detect whether it's a &quot;real&quot; out-of-<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> condition by checking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to see if the result is zero or huge.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * On error, we intentionally complain about double precision not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the given type name, and we <a href="../../nodes/print.c.html#L36" title="nodes/print.c:36">print</a> only the part of the string<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that is the current number.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (val == <span class="Constant">0.0</span> || val &gt;= <span class="Constant">HUGE_VAL</span> || val &lt;= -<span class="Constant">HUGE_VAL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *errnumber = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(num);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errnumber[endptr - num] = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> for type double precision&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errnumber)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid input syntax for type </span><span class="Special">%s</span><span class="Constant">: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type_name, orig_string)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> trailing whitespace */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (*endptr != <span class="Special">'\0'</span> &amp;&amp; isspace((<span class="Type">unsigned</span> <span class="Type">char</span>) *endptr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; endptr++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* report stopping point if wanted, else complain if not end of string */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (endptr_p)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *endptr_p = endptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*endptr != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid input syntax for type </span><span class="Special">%s</span><span class="Constant">: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type_name, orig_string)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> val;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L515" title="utils/adt/float.c:515">float8out</a>&nbsp; &nbsp; &nbsp; &nbsp; - converts float8 number to a string<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; using a standard output format<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L515">&#x200c;</a><span class="linkable">float8out</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; num = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CSTRING(<a href="#L530" title="utils/adt/float.c:530">float8out_internal</a>(num));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L530" title="utils/adt/float.c:530">float8out_internal</a> - guts of <a href="#L515" title="utils/adt/float.c:515">float8out</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is exposed for use by <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> that want a reasonably<br/></li>
<li></span><span class="Comment"> * platform-independent way of outputting doubles.<br/></li>
<li></span><span class="Comment"> * The result is always <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L530">&#x200c;</a><span class="linkable">float8out_internal</span>(<span class="Type">double</span> num)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *<a href="oracle_compat.c.html#L925" title="utils/adt/oracle_compat.c:925">ascii</a> = (<span class="Type">char</span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Constant">32</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndig = <span class="Constant">DBL_DIG</span> + <a href="#L41" title="utils/adt/float.c:41">extra_float_digits</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L41" title="utils/adt/float.c:41">extra_float_digits</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; double_to_shortest_decimal_buf(num, <a href="oracle_compat.c.html#L925" title="utils/adt/oracle_compat.c:925">ascii</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="oracle_compat.c.html#L925" title="utils/adt/oracle_compat.c:925">ascii</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) pg_strfromd(<a href="oracle_compat.c.html#L925" title="utils/adt/oracle_compat.c:925">ascii</a>, <span class="Constant">32</span>, ndig, num);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="oracle_compat.c.html#L925" title="utils/adt/oracle_compat.c:925">ascii</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L549" title="utils/adt/float.c:549">float8recv</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts external binary format to float8<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L549">&#x200c;</a><span class="linkable">float8recv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; buf = (StringInfo) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(<a href="../../libpq/pqformat.c.html#L488" title="libpq/pqformat.c:488">pq_getmsgfloat8</a>(buf));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L560" title="utils/adt/float.c:560">float8send</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts float8 to binary format<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L560">&#x200c;</a><span class="linkable">float8send</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; num = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L326" title="libpq/pqformat.c:326">pq_begintypsend</a>(&amp;buf);<br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L276" title="libpq/pqformat.c:276">pq_sendfloat8</a>(&amp;buf, num);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BYTEA_P(<a href="../../libpq/pqformat.c.html#L346" title="libpq/pqformat.c:346">pq_endtypsend</a>(&amp;buf));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ========== PUBLIC ROUTINES ========== */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; ======================<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; FLOAT4 BASE OPERATIONS<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; ======================<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L584" title="utils/adt/float.c:584">float4abs</a>&nbsp; &nbsp; &nbsp; &nbsp; - returns |arg1| (absolute value)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L584">&#x200c;</a><span class="linkable">float4abs</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT4(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT4(fabsf(arg1));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L595" title="utils/adt/float.c:595">float4um</a>&nbsp; &nbsp; &nbsp; &nbsp; - returns -arg1 (unary minus)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L595">&#x200c;</a><span class="linkable">float4um</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT4(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = -arg1;<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT4(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L605">&#x200c;</a><span class="linkable">float4up</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; arg = PG_GETARG_FLOAT4(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT4(arg);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L613">&#x200c;</a><span class="linkable">float4larger</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT4(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_FLOAT4(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (float4_gt(arg1, arg2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = arg1;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = arg2;<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT4(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L627">&#x200c;</a><span class="linkable">float4smaller</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT4(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_FLOAT4(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (float4_lt(arg1, arg2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = arg1;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = arg2;<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT4(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; ======================<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; FLOAT8 BASE OPERATIONS<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; ======================<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L650" title="utils/adt/float.c:650">float8abs</a>&nbsp; &nbsp; &nbsp; &nbsp; - returns |arg1| (absolute value)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L650">&#x200c;</a><span class="linkable">float8abs</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(fabs(arg1));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L662" title="utils/adt/float.c:662">float8um</a>&nbsp; &nbsp; &nbsp; &nbsp; - returns -arg1 (unary minus)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L662">&#x200c;</a><span class="linkable">float8um</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = -arg1;<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L672">&#x200c;</a><span class="linkable">float8up</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(arg);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L680">&#x200c;</a><span class="linkable">float8larger</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_FLOAT8(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (float8_gt(arg1, arg2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = arg1;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = arg2;<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L694">&#x200c;</a><span class="linkable">float8smaller</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_FLOAT8(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (float8_lt(arg1, arg2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = arg1;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = arg2;<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; ====================<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; ARITHMETIC OPERATORS<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; ====================<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L721" title="utils/adt/float.c:721">float4pl</a>&nbsp; &nbsp; &nbsp; &nbsp; - returns arg1 + arg2<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L730" title="utils/adt/float.c:730">float4mi</a>&nbsp; &nbsp; &nbsp; &nbsp; - returns arg1 - arg2<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L739" title="utils/adt/float.c:739">float4mul</a>&nbsp; &nbsp; &nbsp; &nbsp; - returns arg1 * arg2<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L748" title="utils/adt/float.c:748">float4div</a>&nbsp; &nbsp; &nbsp; &nbsp; - returns arg1 / arg2<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L721">&#x200c;</a><span class="linkable">float4pl</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT4(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_FLOAT4(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT4(float4_pl(arg1, arg2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L730">&#x200c;</a><span class="linkable">float4mi</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT4(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_FLOAT4(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT4(float4_mi(arg1, arg2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L739">&#x200c;</a><span class="linkable">float4mul</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT4(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_FLOAT4(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT4(float4_mul(arg1, arg2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L748">&#x200c;</a><span class="linkable">float4div</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT4(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_FLOAT4(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT4(float4_div(arg1, arg2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L763" title="utils/adt/float.c:763">float8pl</a>&nbsp; &nbsp; &nbsp; &nbsp; - returns arg1 + arg2<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L772" title="utils/adt/float.c:772">float8mi</a>&nbsp; &nbsp; &nbsp; &nbsp; - returns arg1 - arg2<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L781" title="utils/adt/float.c:781">float8mul</a>&nbsp; &nbsp; &nbsp; &nbsp; - returns arg1 * arg2<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L790" title="utils/adt/float.c:790">float8div</a>&nbsp; &nbsp; &nbsp; &nbsp; - returns arg1 / arg2<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L763">&#x200c;</a><span class="linkable">float8pl</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_FLOAT8(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(float8_pl(arg1, arg2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L772">&#x200c;</a><span class="linkable">float8mi</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_FLOAT8(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(float8_mi(arg1, arg2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L781">&#x200c;</a><span class="linkable">float8mul</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_FLOAT8(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(float8_mul(arg1, arg2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L790">&#x200c;</a><span class="linkable">float8div</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_FLOAT8(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(float8_div(arg1, arg2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; ====================<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; COMPARISON OPERATORS<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; ====================<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; float4{eq,ne,lt,le,gt,ge}&nbsp; &nbsp; &nbsp; &nbsp; - float4/float4 comparison operations<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L809">&#x200c;</a></span><span class="linkable">float4_cmp_internal</span>(float4 a, float4 b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (float4_gt(a, b))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (float4_lt(a, b))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L819">&#x200c;</a><span class="linkable">float4eq</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT4(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_FLOAT4(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(float4_eq(arg1, arg2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L828">&#x200c;</a><span class="linkable">float4ne</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT4(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_FLOAT4(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(float4_ne(arg1, arg2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L837">&#x200c;</a><span class="linkable">float4lt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT4(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_FLOAT4(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(float4_lt(arg1, arg2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L846">&#x200c;</a><span class="linkable">float4le</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT4(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_FLOAT4(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(float4_le(arg1, arg2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L855">&#x200c;</a><span class="linkable">float4gt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT4(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_FLOAT4(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(float4_gt(arg1, arg2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L864">&#x200c;</a><span class="linkable">float4ge</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT4(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_FLOAT4(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(float4_ge(arg1, arg2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L873">&#x200c;</a><span class="linkable">btfloat4cmp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT4(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_FLOAT4(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(<a href="#L809" title="utils/adt/float.c:809">float4_cmp_internal</a>(arg1, arg2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L882">&#x200c;</a></span><span class="linkable">btfloat4fastcmp</span>(Datum x, Datum y, SortSupport ssup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; arg1 = DatumGetFloat4(x);<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; arg2 = DatumGetFloat4(y);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L809" title="utils/adt/float.c:809">float4_cmp_internal</a>(arg1, arg2);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L891">&#x200c;</a><span class="linkable">btfloat4sortsupport</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SortSupport ssup = (SortSupport) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ssup-&gt;comparator = <a href="#L882" title="utils/adt/float.c:882">btfloat4fastcmp</a>;<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VOID();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; float8{eq,ne,lt,le,gt,ge}&nbsp; &nbsp; &nbsp; &nbsp; - float8/float8 comparison operations<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L903">&#x200c;</a></span><span class="linkable">float8_cmp_internal</span>(float8 a, float8 b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (float8_gt(a, b))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (float8_lt(a, b))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L913">&#x200c;</a><span class="linkable">float8eq</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_FLOAT8(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(float8_eq(arg1, arg2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L922">&#x200c;</a><span class="linkable">float8ne</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_FLOAT8(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(float8_ne(arg1, arg2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L931">&#x200c;</a><span class="linkable">float8lt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_FLOAT8(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(float8_lt(arg1, arg2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L940">&#x200c;</a><span class="linkable">float8le</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_FLOAT8(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(float8_le(arg1, arg2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L949">&#x200c;</a><span class="linkable">float8gt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_FLOAT8(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(float8_gt(arg1, arg2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L958">&#x200c;</a><span class="linkable">float8ge</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_FLOAT8(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(float8_ge(arg1, arg2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L967">&#x200c;</a><span class="linkable">btfloat8cmp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_FLOAT8(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(<a href="#L903" title="utils/adt/float.c:903">float8_cmp_internal</a>(arg1, arg2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L976">&#x200c;</a></span><span class="linkable">btfloat8fastcmp</span>(Datum x, Datum y, SortSupport ssup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = DatumGetFloat8(x);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg2 = DatumGetFloat8(y);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L903" title="utils/adt/float.c:903">float8_cmp_internal</a>(arg1, arg2);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L985">&#x200c;</a><span class="linkable">btfloat8sortsupport</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SortSupport ssup = (SortSupport) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ssup-&gt;comparator = <a href="#L976" title="utils/adt/float.c:976">btfloat8fastcmp</a>;<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VOID();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L994">&#x200c;</a><span class="linkable">btfloat48cmp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT4(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_FLOAT8(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* widen float4 to float8 and then <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> */<br/></li>
<li></span>&nbsp; &nbsp; PG_RETURN_INT32(<a href="#L903" title="utils/adt/float.c:903">float8_cmp_internal</a>(arg1, arg2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1004">&#x200c;</a><span class="linkable">btfloat84cmp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_FLOAT4(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* widen float4 to float8 and then <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> */<br/></li>
<li></span>&nbsp; &nbsp; PG_RETURN_INT32(<a href="#L903" title="utils/adt/float.c:903">float8_cmp_internal</a>(arg1, arg2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * in_range support function for float8.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: we needn't supply a float8_float4 variant, as implicit coercion<br/></li>
<li></span><span class="Comment"> * of the offset value takes care of that scenario just as well.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1020">&#x200c;</a><span class="linkable">in_range_float8_float8</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; val = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; base = PG_GETARG_FLOAT8(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; offset = PG_GETARG_FLOAT8(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; sub = PG_GETARG_BOOL(<span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; less = PG_GETARG_BOOL(<span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; sum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reject negative or NaN offset.&nbsp; Negative is per spec, and NaN is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because appropriate semantics for that seem non-obvious.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isnan(offset) || offset &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid preceding or following size in window function&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Deal with cases where val and/or base is NaN, following the rule that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NaN sorts after non-NaN (cf <a href="#L903" title="utils/adt/float.c:903">float8_cmp_internal</a>).&nbsp; The offset cannot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * affect the conclusion.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isnan(val))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnan(base))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">true</span>);&nbsp; &nbsp; <span class="Comment">/* NAN = NAN */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(!less);&nbsp; &nbsp; <span class="Comment">/* NAN &gt; non-NAN */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (isnan(base))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(less);&nbsp; &nbsp; <span class="Comment">/* non-NAN &lt; NAN */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Deal with cases where both base and offset are infinite, and computing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * base +/- offset would produce NaN.&nbsp; This corresponds to a window frame<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * whose boundary infinitely precedes +inf or infinitely follows -inf,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which is not well-defined.&nbsp; For consistency with other cases involving<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * infinities, such as the fact that +inf infinitely follows +inf, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * choose to assume that +inf infinitely precedes +inf and -inf infinitely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * follows -inf, and therefore that all finite and infinite <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * such a window frame.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * offset is known positive, so we need only check the sign of base in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this test.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isinf(offset) &amp;&amp; isinf(base) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (sub ? base &gt; <span class="Constant">0</span> : base &lt; <span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Otherwise it should be safe to compute base +/- offset.&nbsp; We trust the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * FPU to cope if an input is +/-inf or the true sum would overflow, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * produce a suitably signed infinity, which will <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> properly against<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * val whether or not that's infinity.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (sub)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sum = base - offset;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sum = base + offset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (less)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(val &lt;= sum);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(val &gt;= sum);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * in_range support function for float4.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We would need a float4_float8 variant in <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case, so we supply that and<br/></li>
<li></span><span class="Comment"> * let implicit coercion take care of the float4_float4 case.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1096">&#x200c;</a><span class="linkable">in_range_float4_float8</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; val = PG_GETARG_FLOAT4(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; base = PG_GETARG_FLOAT4(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; offset = PG_GETARG_FLOAT8(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; sub = PG_GETARG_BOOL(<span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; less = PG_GETARG_BOOL(<span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; sum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reject negative or NaN offset.&nbsp; Negative is per spec, and NaN is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because appropriate semantics for that seem non-obvious.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isnan(offset) || offset &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid preceding or following size in window function&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Deal with cases where val and/or base is NaN, following the rule that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NaN sorts after non-NaN (cf <a href="#L903" title="utils/adt/float.c:903">float8_cmp_internal</a>).&nbsp; The offset cannot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * affect the conclusion.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isnan(val))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnan(base))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">true</span>);&nbsp; &nbsp; <span class="Comment">/* NAN = NAN */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(!less);&nbsp; &nbsp; <span class="Comment">/* NAN &gt; non-NAN */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (isnan(base))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(less);&nbsp; &nbsp; <span class="Comment">/* non-NAN &lt; NAN */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Deal with cases where both base and offset are infinite, and computing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * base +/- offset would produce NaN.&nbsp; This corresponds to a window frame<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * whose boundary infinitely precedes +inf or infinitely follows -inf,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which is not well-defined.&nbsp; For consistency with other cases involving<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * infinities, such as the fact that +inf infinitely follows +inf, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * choose to assume that +inf infinitely precedes +inf and -inf infinitely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * follows -inf, and therefore that all finite and infinite <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * such a window frame.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * offset is known positive, so we need only check the sign of base in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this test.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isinf(offset) &amp;&amp; isinf(base) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (sub ? base &gt; <span class="Constant">0</span> : base &lt; <span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Otherwise it should be safe to compute base +/- offset.&nbsp; We trust the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * FPU to cope if an input is +/-inf or the true sum would overflow, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * produce a suitably signed infinity, which will <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> properly against<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * val whether or not that's infinity.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (sub)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sum = base - offset;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sum = base + offset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (less)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(val &lt;= sum);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(val &gt;= sum);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; ===================<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; CONVERSION ROUTINES<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; ===================<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1176" title="utils/adt/float.c:1176">ftod</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts a float4 number to a float8 number<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1176">&#x200c;</a><span class="linkable">ftod</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; num = PG_GETARG_FLOAT4(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8((float8) num);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1188" title="utils/adt/float.c:1188">dtof</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts a float8 number to a float4 number<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1188">&#x200c;</a><span class="linkable">dtof</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; num = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (float4) num;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(isinf(result)) &amp;&amp; !isinf(num))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L79" title="utils/adt/float.c:79">float_overflow_error</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(result == <span class="Constant">0.0f</span>) &amp;&amp; num != <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L87" title="utils/adt/float.c:87">float_underflow_error</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT4(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1207" title="utils/adt/float.c:1207">dtoi4</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts a float8 number to an int4 number<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1207">&#x200c;</a><span class="linkable">dtoi4</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; num = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get rid of <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> fractional part in the input.&nbsp; This is so we don't fail<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on just-out-of-<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> that would round into <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.&nbsp; Note<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * assumption that rint() will pass through a NaN or Inf unchanged.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; num = rint(num);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="geo_spgist.c.html#L107" title="utils/adt/geo_spgist.c:107">Range</a> check */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(isnan(num) || !FLOAT8_FITS_IN_INT32(num)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;integer out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32((int32) num);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1232" title="utils/adt/float.c:1232">dtoi2</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts a float8 number to an int2 number<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1232">&#x200c;</a><span class="linkable">dtoi2</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; num = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get rid of <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> fractional part in the input.&nbsp; This is so we don't fail<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on just-out-of-<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> that would round into <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.&nbsp; Note<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * assumption that rint() will pass through a NaN or Inf unchanged.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; num = rint(num);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="geo_spgist.c.html#L107" title="utils/adt/geo_spgist.c:107">Range</a> check */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(isnan(num) || !FLOAT8_FITS_IN_INT16(num)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;smallint out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT16((int16) num);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1257" title="utils/adt/float.c:1257">i4tod</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts an int4 number to a float8 number<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1257">&#x200c;</a><span class="linkable">i4tod</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; num = PG_GETARG_INT32(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8((float8) num);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1269" title="utils/adt/float.c:1269">i2tod</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts an int2 number to a float8 number<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1269">&#x200c;</a><span class="linkable">i2tod</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; num = PG_GETARG_INT16(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8((float8) num);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1281" title="utils/adt/float.c:1281">ftoi4</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts a float4 number to an int4 number<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1281">&#x200c;</a><span class="linkable">ftoi4</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; num = PG_GETARG_FLOAT4(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get rid of <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> fractional part in the input.&nbsp; This is so we don't fail<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on just-out-of-<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> that would round into <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.&nbsp; Note<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * assumption that rint() will pass through a NaN or Inf unchanged.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; num = rint(num);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="geo_spgist.c.html#L107" title="utils/adt/geo_spgist.c:107">Range</a> check */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(isnan(num) || !FLOAT4_FITS_IN_INT32(num)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;integer out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32((int32) num);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1306" title="utils/adt/float.c:1306">ftoi2</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts a float4 number to an int2 number<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1306">&#x200c;</a><span class="linkable">ftoi2</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; num = PG_GETARG_FLOAT4(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get rid of <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> fractional part in the input.&nbsp; This is so we don't fail<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on just-out-of-<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> that would round into <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.&nbsp; Note<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * assumption that rint() will pass through a NaN or Inf unchanged.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; num = rint(num);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="geo_spgist.c.html#L107" title="utils/adt/geo_spgist.c:107">Range</a> check */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(isnan(num) || !FLOAT4_FITS_IN_INT16(num)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;smallint out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT16((int16) num);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1331" title="utils/adt/float.c:1331">i4tof</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts an int4 number to a float4 number<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1331">&#x200c;</a><span class="linkable">i4tof</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; num = PG_GETARG_INT32(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT4((float4) num);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1343" title="utils/adt/float.c:1343">i2tof</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts an int2 number to a float4 number<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1343">&#x200c;</a><span class="linkable">i2tof</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; num = PG_GETARG_INT16(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT4((float4) num);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; =======================<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; RANDOM FLOAT8 OPERATORS<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; =======================<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1361" title="utils/adt/float.c:1361">dround</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - returns&nbsp; &nbsp; ROUND(arg1)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1361">&#x200c;</a><span class="linkable">dround</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(rint(arg1));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1373" title="utils/adt/float.c:1373">dceil</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - returns the smallest integer greater than or<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to the specified float<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1373">&#x200c;</a><span class="linkable">dceil</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(ceil(arg1));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1385" title="utils/adt/float.c:1385">dfloor</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - returns the largest integer lesser than or<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to the specified float<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1385">&#x200c;</a><span class="linkable">dfloor</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(floor(arg1));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1398" title="utils/adt/float.c:1398">dsign</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - returns -1 if the argument is less than 0, 0<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if the argument is <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to 0, and 1 if the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; argument is greater than zero.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1398">&#x200c;</a><span class="linkable">dsign</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (arg1 &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (arg1 &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = -<span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">0.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1421" title="utils/adt/float.c:1421">dtrunc</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - returns truncation-towards-zero of arg1,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arg1 &gt;= 0 ... the greatest integer less<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; than or <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to arg1<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arg1 &lt; 0&nbsp; &nbsp; ... the least integer greater<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; than or <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to arg1<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1421">&#x200c;</a><span class="linkable">dtrunc</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (arg1 &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = floor(arg1);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = -floor(-arg1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1439" title="utils/adt/float.c:1439">dsqrt</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - returns square root of arg1<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1439">&#x200c;</a><span class="linkable">dsqrt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (arg1 &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_ARGUMENT_FOR_POWER_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot take square root of a negative number&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = sqrt(arg1);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(isinf(result)) &amp;&amp; !isinf(arg1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L79" title="utils/adt/float.c:79">float_overflow_error</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(result == <span class="Constant">0.0</span>) &amp;&amp; arg1 != <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L87" title="utils/adt/float.c:87">float_underflow_error</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1463" title="utils/adt/float.c:1463">dcbrt</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - returns cube root of arg1<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1463">&#x200c;</a><span class="linkable">dcbrt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = cbrt(arg1);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(isinf(result)) &amp;&amp; !isinf(arg1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L79" title="utils/adt/float.c:79">float_overflow_error</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(result == <span class="Constant">0.0</span>) &amp;&amp; arg1 != <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L87" title="utils/adt/float.c:87">float_underflow_error</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1482" title="utils/adt/float.c:1482">dpow</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - returns pow(arg1,arg2)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1482">&#x200c;</a><span class="linkable">dpow</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_FLOAT8(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The POSIX spec says that NaN ^ 0 = 1, and 1 ^ NaN = 1, while all other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cases with NaN inputs yield NaN (with no error).&nbsp; Many older platforms<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * get one or more of these cases wrong, so deal with them via explicit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * logic rather than trusting pow(3).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isnan(arg1))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnan(arg2) || arg2 != <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(get_float8_nan());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(<span class="Constant">1.0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isnan(arg2))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (arg1 != <span class="Constant">1.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(get_float8_nan());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(<span class="Constant">1.0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The SQL spec requires that we emit a particular SQLSTATE error code for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * certain error conditions.&nbsp; Specifically, we don't return a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * divide-by-zero error code for 0 ^ -1.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (arg1 == <span class="Constant">0</span> &amp;&amp; arg2 &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_ARGUMENT_FOR_POWER_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;zero raised to a negative power is undefined&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (arg1 &lt; <span class="Constant">0</span> &amp;&amp; floor(arg2) != arg2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_ARGUMENT_FOR_POWER_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;a negative number raised to a non-integer power yields a complex result&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't trust the platform's pow() to handle infinity cases per POSIX<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * spec either, so deal with those explicitly too.&nbsp; It's easier to handle<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * infinite y first, so that it doesn't matter if x is also infinite.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isinf(arg2))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; absx = fabs(arg1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (absx == <span class="Constant">1.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (arg2 &gt; <span class="Constant">0.0</span>)&nbsp; &nbsp; <span class="Comment">/* y = +Inf */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (absx &gt; <span class="Constant">1.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = arg2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* y = -Inf */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (absx &gt; <span class="Constant">1.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = -arg2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (isinf(arg1))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (arg2 == <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (arg1 &gt; <span class="Constant">0.0</span>)&nbsp; &nbsp; <span class="Comment">/* x = +Inf */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (arg2 &gt; <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = arg1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* x = -Inf */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Per POSIX, the sign of the result depends on whether y is an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * odd integer.&nbsp; Since x &lt; 0, we already know from the previous<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * domain check that y is an integer.&nbsp; It is odd if y/2 is not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * also an integer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; halfy = arg2 / <span class="Constant">2</span>;&nbsp; &nbsp; <span class="Comment">/* should be computed exactly */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; yisoddinteger = (floor(halfy) != halfy);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (arg2 &gt; <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = yisoddinteger ? arg1 : -arg1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = yisoddinteger ? -<span class="Constant">0.0</span> : <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pow() sets errno on only some platforms, depending on whether it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * follows _IEEE_, _POSIX_, _XOPEN_, or _SVID_, so we must check both<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * errno and invalid output <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.&nbsp; (We can't rely on just the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * latter, either; some old platforms return a large-but-finite<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * HUGE_VAL when reporting overflow.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = pow(arg1, arg2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">EDOM</span> || isnan(result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We handled all possible domain errors above, so this should be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * impossible.&nbsp; However, old glibc versions on x86 have a bug that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * causes them to fail this way for abs(y) greater than 2^63:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * https://sourceware.org/bugzilla/show_bug.cgi?id=3866<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Hence, if we get here, assume y is finite but large (large<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * enough to be certainly even). The result should be 0 if x == 0,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * 1.0 if abs(x) == 1.0, otherwise an overflow or underflow error.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (arg1 == <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">0.0</span>;&nbsp; &nbsp; <span class="Comment">/* we already verified y is positive */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; absx = fabs(arg1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (absx == <span class="Constant">1.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (arg2 &gt;= <span class="Constant">0.0</span> ? (absx &gt; <span class="Constant">1.0</span>) : (absx &lt; <span class="Constant">1.0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L79" title="utils/adt/float.c:79">float_overflow_error</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L87" title="utils/adt/float.c:87">float_underflow_error</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (errno == <span class="Constant">ERANGE</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result != <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L79" title="utils/adt/float.c:79">float_overflow_error</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L87" title="utils/adt/float.c:87">float_underflow_error</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlikely(isinf(result)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L79" title="utils/adt/float.c:79">float_overflow_error</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlikely(result == <span class="Constant">0.0</span>) &amp;&amp; arg1 != <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L87" title="utils/adt/float.c:87">float_underflow_error</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1637" title="utils/adt/float.c:1637">dexp</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - returns the exponential function of arg1<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1637">&#x200c;</a><span class="linkable">dexp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Handle NaN and Inf cases explicitly.&nbsp; This avoids needing to assume<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that the platform's exp() conforms to POSIX for these cases, and it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * removes some edge cases for the overflow checks below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isnan(arg1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = arg1;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (isinf(arg1))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Per POSIX, exp(-Inf) is 0 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = (arg1 &gt; <span class="Constant">0.0</span>) ? arg1 : <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * On some platforms, exp() will not set errno but just return Inf or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * zero to report overflow/underflow; therefore, test both cases.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = exp(arg1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlikely(errno == <span class="Constant">ERANGE</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result != <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L79" title="utils/adt/float.c:79">float_overflow_error</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L87" title="utils/adt/float.c:87">float_underflow_error</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (unlikely(isinf(result)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L79" title="utils/adt/float.c:79">float_overflow_error</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (unlikely(result == <span class="Constant">0.0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L87" title="utils/adt/float.c:87">float_underflow_error</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1683" title="utils/adt/float.c:1683">dlog1</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - returns the natural logarithm of arg1<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1683">&#x200c;</a><span class="linkable">dlog1</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Emit particular SQLSTATE error codes for ln(). This is required by the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * SQL standard.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (arg1 == <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_ARGUMENT_FOR_LOG),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot take logarithm of zero&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (arg1 &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_ARGUMENT_FOR_LOG),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot take logarithm of a negative number&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = log(arg1);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(isinf(result)) &amp;&amp; !isinf(arg1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L79" title="utils/adt/float.c:79">float_overflow_error</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(result == <span class="Constant">0.0</span>) &amp;&amp; arg1 != <span class="Constant">1.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L87" title="utils/adt/float.c:87">float_underflow_error</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1715" title="utils/adt/float.c:1715">dlog10</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - returns the base 10 logarithm of arg1<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1715">&#x200c;</a><span class="linkable">dlog10</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Emit particular SQLSTATE error codes for log(). The SQL spec doesn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * define log(), but it does define ln(), so it makes sense to emit the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * same error code for an analogous error condition.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (arg1 == <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_ARGUMENT_FOR_LOG),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot take logarithm of zero&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (arg1 &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_ARGUMENT_FOR_LOG),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot take logarithm of a negative number&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = log10(arg1);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(isinf(result)) &amp;&amp; !isinf(arg1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L79" title="utils/adt/float.c:79">float_overflow_error</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(result == <span class="Constant">0.0</span>) &amp;&amp; arg1 != <span class="Constant">1.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L87" title="utils/adt/float.c:87">float_underflow_error</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1748" title="utils/adt/float.c:1748">dacos</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - returns the arccos of arg1 (<a href="#L2576" title="utils/adt/float.c:2576">radians</a>)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1748">&#x200c;</a><span class="linkable">dacos</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Per the POSIX spec, return NaN if the input is NaN */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isnan(arg1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(get_float8_nan());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The principal branch of the inverse cosine function <a href="../mb/conversion_procs/utf8_and_iso8859/utf8_and_iso8859.c.html#L70" title="utils/mb/conversion_procs/utf8_and_iso8859/utf8_and_iso8859.c:70">maps</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> [-1, 1] to <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> [0, Pi], so we should reject <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inputs outside that <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> and the result will always be finite.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (arg1 &lt; -<span class="Constant">1.0</span> || arg1 &gt; <span class="Constant">1.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;input is out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = acos(arg1);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(isinf(result)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L79" title="utils/adt/float.c:79">float_overflow_error</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1779" title="utils/adt/float.c:1779">dasin</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - returns the arcsin of arg1 (<a href="#L2576" title="utils/adt/float.c:2576">radians</a>)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1779">&#x200c;</a><span class="linkable">dasin</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Per the POSIX spec, return NaN if the input is NaN */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isnan(arg1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(get_float8_nan());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The principal branch of the inverse sine function <a href="../mb/conversion_procs/utf8_and_iso8859/utf8_and_iso8859.c.html#L70" title="utils/mb/conversion_procs/utf8_and_iso8859/utf8_and_iso8859.c:70">maps</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> [-1, 1] to <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> [-Pi/2, Pi/2], so we should reject<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> inputs outside that <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> and the result will always be finite.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (arg1 &lt; -<span class="Constant">1.0</span> || arg1 &gt; <span class="Constant">1.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;input is out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = asin(arg1);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(isinf(result)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L79" title="utils/adt/float.c:79">float_overflow_error</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1810" title="utils/adt/float.c:1810">datan</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - returns the arctan of arg1 (<a href="#L2576" title="utils/adt/float.c:2576">radians</a>)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1810">&#x200c;</a><span class="linkable">datan</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Per the POSIX spec, return NaN if the input is NaN */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isnan(arg1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(get_float8_nan());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The principal branch of the inverse tangent function <a href="../mb/conversion_procs/utf8_and_iso8859/utf8_and_iso8859.c.html#L70" title="utils/mb/conversion_procs/utf8_and_iso8859/utf8_and_iso8859.c:70">maps</a> all inputs to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> [-Pi/2, Pi/2], so the result should always be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * finite, even if the input is infinite.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; result = atan(arg1);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(isinf(result)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L79" title="utils/adt/float.c:79">float_overflow_error</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; atan2&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - returns the arctan of arg1/arg2 (<a href="#L2576" title="utils/adt/float.c:2576">radians</a>)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1836">&#x200c;</a><span class="linkable">datan2</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_FLOAT8(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Per the POSIX spec, return NaN if either input is NaN */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isnan(arg1) || isnan(arg2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(get_float8_nan());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * atan2 <a href="../mb/conversion_procs/utf8_and_iso8859/utf8_and_iso8859.c.html#L70" title="utils/mb/conversion_procs/utf8_and_iso8859/utf8_and_iso8859.c:70">maps</a> all inputs to <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> [-Pi, Pi], so the result<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * should always be finite, even if the inputs are infinite.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; result = atan2(arg1, arg2);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(isinf(result)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L79" title="utils/adt/float.c:79">float_overflow_error</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1862" title="utils/adt/float.c:1862">dcos</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - returns the cosine of arg1 (<a href="#L2576" title="utils/adt/float.c:2576">radians</a>)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1862">&#x200c;</a><span class="linkable">dcos</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Per the POSIX spec, return NaN if the input is NaN */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isnan(arg1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(get_float8_nan());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cos() is periodic and so theoretically can work for all finite inputs,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but some implementations may choose to throw error if the input is so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * large that there are no significant digits in the result.&nbsp; So we should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * check for errors.&nbsp; POSIX allows an error to be reported either via<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * errno or via fetestexcept(), but currently we only support checking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * errno.&nbsp; (fetestexcept() is rumored to report underflow unreasonably<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * early on some platforms, so it's not clear that believing it would be a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * net improvement anyway.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For infinite inputs, POSIX specifies that the trigonometric <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * should return a domain error; but we won't notice that unless the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * platform reports via errno, so also explicitly test for infinite<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inputs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; result = cos(arg1);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (errno != <span class="Constant">0</span> || isinf(arg1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;input is out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(isinf(result)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L79" title="utils/adt/float.c:79">float_overflow_error</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1903" title="utils/adt/float.c:1903">dcot</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - returns the cotangent of arg1 (<a href="#L2576" title="utils/adt/float.c:2576">radians</a>)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1903">&#x200c;</a><span class="linkable">dcot</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Per the POSIX spec, return NaN if the input is NaN */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isnan(arg1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(get_float8_nan());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Be sure to throw an error if the input is infinite --- see <a href="#L1862" title="utils/adt/float.c:1862">dcos</a>() */<br/></li>
<li></span>&nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; result = tan(arg1);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (errno != <span class="Constant">0</span> || isinf(arg1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;input is out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <span class="Constant">1.0</span> / result;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Not checking for overflow because cot(0) == Inf */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1931" title="utils/adt/float.c:1931">dsin</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - returns the sine of arg1 (<a href="#L2576" title="utils/adt/float.c:2576">radians</a>)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1931">&#x200c;</a><span class="linkable">dsin</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Per the POSIX spec, return NaN if the input is NaN */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isnan(arg1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(get_float8_nan());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Be sure to throw an error if the input is infinite --- see <a href="#L1862" title="utils/adt/float.c:1862">dcos</a>() */<br/></li>
<li></span>&nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; result = sin(arg1);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (errno != <span class="Constant">0</span> || isinf(arg1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;input is out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(isinf(result)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L79" title="utils/adt/float.c:79">float_overflow_error</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1958" title="utils/adt/float.c:1958">dtan</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - returns the tangent of arg1 (<a href="#L2576" title="utils/adt/float.c:2576">radians</a>)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1958">&#x200c;</a><span class="linkable">dtan</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Per the POSIX spec, return NaN if the input is NaN */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isnan(arg1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(get_float8_nan());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Be sure to throw an error if the input is infinite --- see <a href="#L1862" title="utils/adt/float.c:1862">dcos</a>() */<br/></li>
<li></span>&nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; result = tan(arg1);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (errno != <span class="Constant">0</span> || isinf(arg1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;input is out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Not checking for overflow because tan(pi/2) == Inf */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ========== DEGREE-BASED TRIGONOMETRIC FUNCTIONS ========== */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize the cached constants declared at the head of this file<br/></li>
<li></span><span class="Comment"> * (<a href="#L45" title="utils/adt/float.c:45">sin_30</a> etc).&nbsp; The fact that we need those at all, let alone need this<br/></li>
<li></span><span class="Comment"> * Rube-Goldberg-worthy method of initializing them, is because there are<br/></li>
<li></span><span class="Comment"> * compilers out there that will precompute expressions such as sin(constant)<br/></li>
<li></span><span class="Comment"> * using a sin() function different from what will be used at runtime.&nbsp; If we<br/></li>
<li></span><span class="Comment"> * want exact results, we must ensure that <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> of the scaling constants used<br/></li>
<li></span><span class="Comment"> * in the degree-based trig <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> are computed that way.&nbsp; To do so, we<br/></li>
<li></span><span class="Comment"> * compute them from the variables <a href="#L59" title="utils/adt/float.c:59">degree_c_thirty</a> etc, which are also really<br/></li>
<li></span><span class="Comment"> * constants, but the compiler cannot assume that.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Other hazards we are trying to forestall with this kluge include the<br/></li>
<li></span><span class="Comment"> * possibility that compilers will rearrange the expressions, or compute<br/></li>
<li></span><span class="Comment"> * some intermediate results in registers wider than a standard double.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In the places where we use these constants, the typical pattern is like<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; volatile float8 sin_x = sin(x * RADIANS_PER_DEGREE);<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; return (sin_x / <a href="#L45" title="utils/adt/float.c:45">sin_30</a>);<br/></li>
<li></span><span class="Comment"> * where we hope to get a value of exactly 1.0 from the division when x = 30.<br/></li>
<li></span><span class="Comment"> * The volatile temporary variable is needed on machines with wide float<br/></li>
<li></span><span class="Comment"> * registers, to ensure that the result of sin(x) is rounded to double width<br/></li>
<li></span><span class="Comment"> * the same as the value of <a href="#L45" title="utils/adt/float.c:45">sin_30</a> has been.&nbsp; Experimentation with gcc shows<br/></li>
<li></span><span class="Comment"> * that marking the temp variable volatile is necessary to make the store and<br/></li>
<li></span><span class="Comment"> * reload actually happen; hopefully the same trick works for other compilers.<br/></li>
<li></span><span class="Comment"> * (gcc's documentation suggests using the -ffloat-store compiler switch to<br/></li>
<li></span><span class="Comment"> * ensure this, but that is compiler-specific and it also pessimizes code in<br/></li>
<li></span><span class="Comment"> * many places where we don't care about this.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2012">&#x200c;</a></span><span class="linkable">init_degree_constants</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L45" title="utils/adt/float.c:45">sin_30</a> = sin(<a href="#L59" title="utils/adt/float.c:59">degree_c_thirty</a> * RADIANS_PER_DEGREE);<br/></li>
<li>&nbsp; &nbsp; <a href="#L46" title="utils/adt/float.c:46">one_minus_cos_60</a> = <span class="Constant">1.0</span> - cos(<a href="#L61" title="utils/adt/float.c:61">degree_c_sixty</a> * RADIANS_PER_DEGREE);<br/></li>
<li>&nbsp; &nbsp; <a href="#L47" title="utils/adt/float.c:47">asin_0_5</a> = asin(<a href="#L62" title="utils/adt/float.c:62">degree_c_one_half</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L48" title="utils/adt/float.c:48">acos_0_5</a> = acos(<a href="#L62" title="utils/adt/float.c:62">degree_c_one_half</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L49" title="utils/adt/float.c:49">atan_1_0</a> = atan(<a href="#L63" title="utils/adt/float.c:63">degree_c_one</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L50" title="utils/adt/float.c:50">tan_45</a> = <a href="#L2272" title="utils/adt/float.c:2272">sind_q1</a>(<a href="#L60" title="utils/adt/float.c:60">degree_c_forty_five</a>) / <a href="#L2292" title="utils/adt/float.c:2292">cosd_q1</a>(<a href="#L60" title="utils/adt/float.c:60">degree_c_forty_five</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L51" title="utils/adt/float.c:51">cot_45</a> = <a href="#L2292" title="utils/adt/float.c:2292">cosd_q1</a>(<a href="#L60" title="utils/adt/float.c:60">degree_c_forty_five</a>) / <a href="#L2272" title="utils/adt/float.c:2272">sind_q1</a>(<a href="#L60" title="utils/adt/float.c:60">degree_c_forty_five</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L44" title="utils/adt/float.c:44">degree_consts_set</a> = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L2024">&#x200c;</a><span class="PreProc">#define <span class="linkable">INIT_DEGREE_CONSTANTS</span>() \<br/></li>
<li></span><span class="Statement">do</span><span class="PreProc"> { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">if</span><span class="PreProc"> (!<a href="#L44" title="utils/adt/float.c:44">degree_consts_set</a>) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2012" title="utils/adt/float.c:2012">init_degree_constants</a>(); \<br/></li>
<li></span><span class="PreProc">} </span><span class="Statement">while</span><span class="PreProc">(</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2041" title="utils/adt/float.c:2041">asind_q1</a>&nbsp; &nbsp; &nbsp; &nbsp; - returns the inverse sine of x in <a href="#L2554" title="utils/adt/float.c:2554">degrees</a>, for x in<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> [0, 1].&nbsp; The result is an angle in the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; first quadrant --- [0, 90] <a href="#L2554" title="utils/adt/float.c:2554">degrees</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; For the 3 special case inputs (0, 0.5 and 1), this<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; function will return exact <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> (0, 30 and 90<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2554" title="utils/adt/float.c:2554">degrees</a> respectively).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">double<br/></li>
<li><a id="L2041">&#x200c;</a></span><span class="linkable">asind_q1</span>(<span class="Type">double</span> x)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Stitch together inverse sine and cosine <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for the ranges [0,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 0.5] and (0.5, 1].&nbsp; Each expression below is guaranteed to return<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exactly 30 for x=0.5, so the result is a continuous monotonic function<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * over the full <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (x &lt;= <span class="Constant">0.5</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">volatile</span> float8 asin_x = asin(x);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (asin_x / <a href="#L47" title="utils/adt/float.c:47">asin_0_5</a>) * <span class="Constant">30.0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">volatile</span> float8 acos_x = acos(x);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">90.0</span> - (acos_x / <a href="#L48" title="utils/adt/float.c:48">acos_0_5</a>) * <span class="Constant">60.0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2074" title="utils/adt/float.c:2074">acosd_q1</a>&nbsp; &nbsp; &nbsp; &nbsp; - returns the inverse cosine of x in <a href="#L2554" title="utils/adt/float.c:2554">degrees</a>, for x in<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> [0, 1].&nbsp; The result is an angle in the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; first quadrant --- [0, 90] <a href="#L2554" title="utils/adt/float.c:2554">degrees</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; For the 3 special case inputs (0, 0.5 and 1), this<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; function will return exact <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> (0, 60 and 90<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2554" title="utils/adt/float.c:2554">degrees</a> respectively).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">double<br/></li>
<li><a id="L2074">&#x200c;</a></span><span class="linkable">acosd_q1</span>(<span class="Type">double</span> x)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Stitch together inverse sine and cosine <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for the ranges [0,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 0.5] and (0.5, 1].&nbsp; Each expression below is guaranteed to return<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exactly 60 for x=0.5, so the result is a continuous monotonic function<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * over the full <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (x &lt;= <span class="Constant">0.5</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">volatile</span> float8 asin_x = asin(x);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">90.0</span> - (asin_x / <a href="#L47" title="utils/adt/float.c:47">asin_0_5</a>) * <span class="Constant">30.0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">volatile</span> float8 acos_x = acos(x);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (acos_x / <a href="#L48" title="utils/adt/float.c:48">acos_0_5</a>) * <span class="Constant">60.0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2101" title="utils/adt/float.c:2101">dacosd</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - returns the arccos of arg1 (<a href="#L2554" title="utils/adt/float.c:2554">degrees</a>)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2101">&#x200c;</a><span class="linkable">dacosd</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Per the POSIX spec, return NaN if the input is NaN */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isnan(arg1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(get_float8_nan());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2024" title="utils/adt/float.c:2024">INIT_DEGREE_CONSTANTS</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The principal branch of the inverse cosine function <a href="../mb/conversion_procs/utf8_and_iso8859/utf8_and_iso8859.c.html#L70" title="utils/mb/conversion_procs/utf8_and_iso8859/utf8_and_iso8859.c:70">maps</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> [-1, 1] to <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> [0, 180], so we should reject <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inputs outside that <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> and the result will always be finite.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (arg1 &lt; -<span class="Constant">1.0</span> || arg1 &gt; <span class="Constant">1.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;input is out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (arg1 &gt;= <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L2074" title="utils/adt/float.c:2074">acosd_q1</a>(arg1);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">90.0</span> + <a href="#L2041" title="utils/adt/float.c:2041">asind_q1</a>(-arg1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(isinf(result)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L79" title="utils/adt/float.c:79">float_overflow_error</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2138" title="utils/adt/float.c:2138">dasind</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - returns the arcsin of arg1 (<a href="#L2554" title="utils/adt/float.c:2554">degrees</a>)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2138">&#x200c;</a><span class="linkable">dasind</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Per the POSIX spec, return NaN if the input is NaN */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isnan(arg1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(get_float8_nan());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2024" title="utils/adt/float.c:2024">INIT_DEGREE_CONSTANTS</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The principal branch of the inverse sine function <a href="../mb/conversion_procs/utf8_and_iso8859/utf8_and_iso8859.c.html#L70" title="utils/mb/conversion_procs/utf8_and_iso8859/utf8_and_iso8859.c:70">maps</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> [-1, 1] to <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> [-90, 90], so we should reject <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inputs outside that <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> and the result will always be finite.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (arg1 &lt; -<span class="Constant">1.0</span> || arg1 &gt; <span class="Constant">1.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;input is out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (arg1 &gt;= <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L2041" title="utils/adt/float.c:2041">asind_q1</a>(arg1);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = -<a href="#L2041" title="utils/adt/float.c:2041">asind_q1</a>(-arg1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(isinf(result)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L79" title="utils/adt/float.c:79">float_overflow_error</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2175" title="utils/adt/float.c:2175">datand</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - returns the arctan of arg1 (<a href="#L2554" title="utils/adt/float.c:2554">degrees</a>)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2175">&#x200c;</a><span class="linkable">datand</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">volatile</span> float8 atan_arg1;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Per the POSIX spec, return NaN if the input is NaN */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isnan(arg1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(get_float8_nan());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2024" title="utils/adt/float.c:2024">INIT_DEGREE_CONSTANTS</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The principal branch of the inverse tangent function <a href="../mb/conversion_procs/utf8_and_iso8859/utf8_and_iso8859.c.html#L70" title="utils/mb/conversion_procs/utf8_and_iso8859/utf8_and_iso8859.c:70">maps</a> all inputs to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> [-90, 90], so the result should always be finite,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * even if the input is infinite.&nbsp; Additionally, we take care to ensure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * than when arg1 is 1, the result is exactly 45.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; atan_arg1 = atan(arg1);<br/></li>
<li>&nbsp; &nbsp; result = (atan_arg1 / <a href="#L49" title="utils/adt/float.c:49">atan_1_0</a>) * <span class="Constant">45.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(isinf(result)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L79" title="utils/adt/float.c:79">float_overflow_error</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; atan2d&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - returns the arctan of arg1/arg2 (<a href="#L2554" title="utils/adt/float.c:2554">degrees</a>)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2207">&#x200c;</a><span class="linkable">datan2d</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_FLOAT8(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">volatile</span> float8 atan2_arg1_arg2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Per the POSIX spec, return NaN if either input is NaN */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isnan(arg1) || isnan(arg2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(get_float8_nan());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2024" title="utils/adt/float.c:2024">INIT_DEGREE_CONSTANTS</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * atan2d <a href="../mb/conversion_procs/utf8_and_iso8859/utf8_and_iso8859.c.html#L70" title="utils/mb/conversion_procs/utf8_and_iso8859/utf8_and_iso8859.c:70">maps</a> all inputs to <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> [-180, 180], so the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * result should always be finite, even if the inputs are infinite.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: this coding assumes that atan(1.0) is a suitable scaling constant<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to get an exact result from atan2().&nbsp; This might well fail on us at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * some point, requiring us to decide exactly what inputs we think we're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * going to guarantee an exact result for.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; atan2_arg1_arg2 = atan2(arg1, arg2);<br/></li>
<li>&nbsp; &nbsp; result = (atan2_arg1_arg2 / <a href="#L49" title="utils/adt/float.c:49">atan_1_0</a>) * <span class="Constant">45.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(isinf(result)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L79" title="utils/adt/float.c:79">float_overflow_error</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2245" title="utils/adt/float.c:2245">sind_0_to_30</a>&nbsp; &nbsp; - returns the sine of an angle that lies between 0 and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 30 <a href="#L2554" title="utils/adt/float.c:2554">degrees</a>.&nbsp; This will return exactly 0 when x is 0,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; and exactly 0.5 when x is 30 <a href="#L2554" title="utils/adt/float.c:2554">degrees</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">double<br/></li>
<li><a id="L2245">&#x200c;</a></span><span class="linkable">sind_0_to_30</span>(<span class="Type">double</span> x)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">volatile</span> float8 sin_x = sin(x * RADIANS_PER_DEGREE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (sin_x / <a href="#L45" title="utils/adt/float.c:45">sin_30</a>) / <span class="Constant">2.0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2259" title="utils/adt/float.c:2259">cosd_0_to_60</a>&nbsp; &nbsp; - returns the cosine of an angle that lies between 0<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; and 60 <a href="#L2554" title="utils/adt/float.c:2554">degrees</a>.&nbsp; This will return exactly 1 when x<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is 0, and exactly 0.5 when x is 60 <a href="#L2554" title="utils/adt/float.c:2554">degrees</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">double<br/></li>
<li><a id="L2259">&#x200c;</a></span><span class="linkable">cosd_0_to_60</span>(<span class="Type">double</span> x)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">volatile</span> float8 one_minus_cos_x = <span class="Constant">1.0</span> - cos(x * RADIANS_PER_DEGREE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1.0</span> - (one_minus_cos_x / <a href="#L46" title="utils/adt/float.c:46">one_minus_cos_60</a>) / <span class="Constant">2.0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2272" title="utils/adt/float.c:2272">sind_q1</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - returns the sine of an angle in the first quadrant<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (0 to 90 <a href="#L2554" title="utils/adt/float.c:2554">degrees</a>).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">double<br/></li>
<li><a id="L2272">&#x200c;</a></span><span class="linkable">sind_q1</span>(<span class="Type">double</span> x)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Stitch together the sine and cosine <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for the ranges [0, 30]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and (30, 90].&nbsp; These guarantee to return exact answers at their<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * endpoints, so the overall result is a continuous monotonic function<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that gives exact results when x = 0, 30 and 90 <a href="#L2554" title="utils/adt/float.c:2554">degrees</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (x &lt;= <span class="Constant">30.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2245" title="utils/adt/float.c:2245">sind_0_to_30</a>(x);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2259" title="utils/adt/float.c:2259">cosd_0_to_60</a>(<span class="Constant">90.0</span> - x);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2292" title="utils/adt/float.c:2292">cosd_q1</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - returns the cosine of an angle in the first quadrant<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (0 to 90 <a href="#L2554" title="utils/adt/float.c:2554">degrees</a>).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">double<br/></li>
<li><a id="L2292">&#x200c;</a></span><span class="linkable">cosd_q1</span>(<span class="Type">double</span> x)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Stitch together the sine and cosine <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for the ranges [0, 60]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and (60, 90].&nbsp; These guarantee to return exact answers at their<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * endpoints, so the overall result is a continuous monotonic function<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that gives exact results when x = 0, 60 and 90 <a href="#L2554" title="utils/adt/float.c:2554">degrees</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (x &lt;= <span class="Constant">60.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2259" title="utils/adt/float.c:2259">cosd_0_to_60</a>(x);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2245" title="utils/adt/float.c:2245">sind_0_to_30</a>(<span class="Constant">90.0</span> - x);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2311" title="utils/adt/float.c:2311">dcosd</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - returns the cosine of arg1 (<a href="#L2554" title="utils/adt/float.c:2554">degrees</a>)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2311">&#x200c;</a><span class="linkable">dcosd</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sign = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Per the POSIX spec, return NaN if the input is NaN and throw an error<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if the input is infinite.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isnan(arg1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(get_float8_nan());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isinf(arg1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;input is out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2024" title="utils/adt/float.c:2024">INIT_DEGREE_CONSTANTS</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reduce the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of the input to [0,90] <a href="#L2554" title="utils/adt/float.c:2554">degrees</a> */<br/></li>
<li></span>&nbsp; &nbsp; arg1 = fmod(arg1, <span class="Constant">360.0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (arg1 &lt; <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* cosd(-x) = cosd(x) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; arg1 = -arg1;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (arg1 &gt; <span class="Constant">180.0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* cosd(360-x) = cosd(x) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; arg1 = <span class="Constant">360.0</span> - arg1;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (arg1 &gt; <span class="Constant">90.0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* cosd(180-x) = -cosd(x) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; arg1 = <span class="Constant">180.0</span> - arg1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sign = -sign;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = sign * <a href="#L2292" title="utils/adt/float.c:2292">cosd_q1</a>(arg1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(isinf(result)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L79" title="utils/adt/float.c:79">float_overflow_error</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2366" title="utils/adt/float.c:2366">dcotd</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - returns the cotangent of arg1 (<a href="#L2554" title="utils/adt/float.c:2554">degrees</a>)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2366">&#x200c;</a><span class="linkable">dcotd</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">volatile</span> float8 cot_arg1;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sign = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Per the POSIX spec, return NaN if the input is NaN and throw an error<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if the input is infinite.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isnan(arg1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(get_float8_nan());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isinf(arg1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;input is out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2024" title="utils/adt/float.c:2024">INIT_DEGREE_CONSTANTS</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reduce the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of the input to [0,90] <a href="#L2554" title="utils/adt/float.c:2554">degrees</a> */<br/></li>
<li></span>&nbsp; &nbsp; arg1 = fmod(arg1, <span class="Constant">360.0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (arg1 &lt; <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* cotd(-x) = -cotd(x) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; arg1 = -arg1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sign = -sign;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (arg1 &gt; <span class="Constant">180.0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* cotd(360-x) = -cotd(x) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; arg1 = <span class="Constant">360.0</span> - arg1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sign = -sign;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (arg1 &gt; <span class="Constant">90.0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* cotd(180-x) = -cotd(x) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; arg1 = <span class="Constant">180.0</span> - arg1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sign = -sign;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cot_arg1 = <a href="#L2292" title="utils/adt/float.c:2292">cosd_q1</a>(arg1) / <a href="#L2272" title="utils/adt/float.c:2272">sind_q1</a>(arg1);<br/></li>
<li>&nbsp; &nbsp; result = sign * (cot_arg1 / <a href="#L51" title="utils/adt/float.c:51">cot_45</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * On some machines we get cotd(270) = minus zero, but this isn't always<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * true.&nbsp; For portability, and because the user constituency for this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * function probably doesn't want minus zero, force it to plain zero.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (result == <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">0.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Not checking for overflow because cotd(0) == Inf */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2432" title="utils/adt/float.c:2432">dsind</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - returns the sine of arg1 (<a href="#L2554" title="utils/adt/float.c:2554">degrees</a>)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2432">&#x200c;</a><span class="linkable">dsind</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sign = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Per the POSIX spec, return NaN if the input is NaN and throw an error<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if the input is infinite.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isnan(arg1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(get_float8_nan());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isinf(arg1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;input is out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2024" title="utils/adt/float.c:2024">INIT_DEGREE_CONSTANTS</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reduce the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of the input to [0,90] <a href="#L2554" title="utils/adt/float.c:2554">degrees</a> */<br/></li>
<li></span>&nbsp; &nbsp; arg1 = fmod(arg1, <span class="Constant">360.0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (arg1 &lt; <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* sind(-x) = -sind(x) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; arg1 = -arg1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sign = -sign;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (arg1 &gt; <span class="Constant">180.0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* sind(360-x) = -sind(x) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; arg1 = <span class="Constant">360.0</span> - arg1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sign = -sign;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (arg1 &gt; <span class="Constant">90.0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* sind(180-x) = sind(x) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; arg1 = <span class="Constant">180.0</span> - arg1;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = sign * <a href="#L2272" title="utils/adt/float.c:2272">sind_q1</a>(arg1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(isinf(result)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L79" title="utils/adt/float.c:79">float_overflow_error</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2488" title="utils/adt/float.c:2488">dtand</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - returns the tangent of arg1 (<a href="#L2554" title="utils/adt/float.c:2554">degrees</a>)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2488">&#x200c;</a><span class="linkable">dtand</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">volatile</span> float8 tan_arg1;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sign = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Per the POSIX spec, return NaN if the input is NaN and throw an error<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if the input is infinite.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isnan(arg1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(get_float8_nan());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isinf(arg1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;input is out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2024" title="utils/adt/float.c:2024">INIT_DEGREE_CONSTANTS</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reduce the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of the input to [0,90] <a href="#L2554" title="utils/adt/float.c:2554">degrees</a> */<br/></li>
<li></span>&nbsp; &nbsp; arg1 = fmod(arg1, <span class="Constant">360.0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (arg1 &lt; <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* tand(-x) = -tand(x) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; arg1 = -arg1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sign = -sign;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (arg1 &gt; <span class="Constant">180.0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* tand(360-x) = -tand(x) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; arg1 = <span class="Constant">360.0</span> - arg1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sign = -sign;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (arg1 &gt; <span class="Constant">90.0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* tand(180-x) = -tand(x) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; arg1 = <span class="Constant">180.0</span> - arg1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sign = -sign;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tan_arg1 = <a href="#L2272" title="utils/adt/float.c:2272">sind_q1</a>(arg1) / <a href="#L2292" title="utils/adt/float.c:2292">cosd_q1</a>(arg1);<br/></li>
<li>&nbsp; &nbsp; result = sign * (tan_arg1 / <a href="#L50" title="utils/adt/float.c:50">tan_45</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * On some machines we get tand(180) = minus zero, but this isn't always<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * true.&nbsp; For portability, and because the user constituency for this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * function probably doesn't want minus zero, force it to plain zero.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (result == <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">0.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Not checking for overflow because tand(90) == Inf */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2554" title="utils/adt/float.c:2554">degrees</a>&nbsp; &nbsp; &nbsp; &nbsp; - returns <a href="#L2554" title="utils/adt/float.c:2554">degrees</a> converted from <a href="#L2576" title="utils/adt/float.c:2576">radians</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2554">&#x200c;</a><span class="linkable">degrees</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(float8_div(arg1, RADIANS_PER_DEGREE));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2566" title="utils/adt/float.c:2566">dpi</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - returns the constant PI<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2566">&#x200c;</a><span class="linkable">dpi</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(<span class="Constant">M_PI</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2576" title="utils/adt/float.c:2576">radians</a>&nbsp; &nbsp; &nbsp; &nbsp; - returns <a href="#L2576" title="utils/adt/float.c:2576">radians</a> converted from <a href="#L2554" title="utils/adt/float.c:2554">degrees</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2576">&#x200c;</a><span class="linkable">radians</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(float8_mul(arg1, RADIANS_PER_DEGREE));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ========== HYPERBOLIC FUNCTIONS ========== */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2591" title="utils/adt/float.c:2591">dsinh</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - returns the hyperbolic sine of arg1<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2591">&#x200c;</a><span class="linkable">dsinh</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; result = sinh(arg1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if an ERANGE error occurs, it means there is an overflow.&nbsp; For sinh,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the result should be either -infinity or infinity, depending on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sign of arg1.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">ERANGE</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (arg1 &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = -get_float8_infinity();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = get_float8_infinity();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2620" title="utils/adt/float.c:2620">dcosh</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - returns the hyperbolic cosine of arg1<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2620">&#x200c;</a><span class="linkable">dcosh</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; result = cosh(arg1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if an ERANGE error occurs, it means there is an overflow.&nbsp; As cosh is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * always positive, it always means the result is positive infinity.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">ERANGE</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = get_float8_infinity();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(result == <span class="Constant">0.0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L87" title="utils/adt/float.c:87">float_underflow_error</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2645" title="utils/adt/float.c:2645">dtanh</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - returns the hyperbolic tangent of arg1<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2645">&#x200c;</a><span class="linkable">dtanh</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For tanh, we don't need an errno check because it never overflows.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; result = tanh(arg1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(isinf(result)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L79" title="utils/adt/float.c:79">float_overflow_error</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2665" title="utils/adt/float.c:2665">dasinh</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - returns the inverse hyperbolic sine of arg1<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2665">&#x200c;</a><span class="linkable">dasinh</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For asinh, we don't need an errno check because it never overflows.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; result = asinh(arg1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2682" title="utils/adt/float.c:2682">dacosh</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - returns the inverse hyperbolic cosine of arg1<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2682">&#x200c;</a><span class="linkable">dacosh</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * acosh is only defined for inputs &gt;= 1.0.&nbsp; By checking this ourselves,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we need not worry about checking for an EDOM error, which is a good<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * thing because some implementations will report that for NaN. Otherwise,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * no error is possible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (arg1 &lt; <span class="Constant">1.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;input is out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = acosh(arg1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2707" title="utils/adt/float.c:2707">datanh</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - returns the inverse hyperbolic tangent of arg1<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2707">&#x200c;</a><span class="linkable">datanh</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * atanh is only defined for inputs between -1 and 1.&nbsp; By checking this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ourselves, we need not worry about checking for an EDOM error, which is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a good thing because some implementations will report that for NaN.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (arg1 &lt; -<span class="Constant">1.0</span> || arg1 &gt; <span class="Constant">1.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;input is out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also handle the infinity cases ourselves; this is helpful because old<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * glibc versions may produce the wrong errno for this.&nbsp; All other inputs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cannot produce an error.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (arg1 == -<span class="Constant">1.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = -get_float8_infinity();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (arg1 == <span class="Constant">1.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = get_float8_infinity();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = atanh(arg1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ========== ERROR FUNCTIONS ========== */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2745" title="utils/adt/float.c:2745">derf</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - returns the error function: erf(arg1)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2745">&#x200c;</a><span class="linkable">derf</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For erf, we don't need an errno check because it never overflows.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; result = erf(arg1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(isinf(result)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L79" title="utils/adt/float.c:79">float_overflow_error</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2765" title="utils/adt/float.c:2765">derfc</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - returns the complementary error function: 1 - erf(arg1)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2765">&#x200c;</a><span class="linkable">derfc</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For erfc, we don't need an errno check because it never overflows.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; result = erfc(arg1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(isinf(result)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L79" title="utils/adt/float.c:79">float_overflow_error</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; =========================<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; FLOAT AGGREGATE OPERATORS<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; =========================<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2950" title="utils/adt/float.c:2950">float8_accum</a>&nbsp; &nbsp; &nbsp; &nbsp; - accumulate for AVG(), variance aggregates, etc.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3033" title="utils/adt/float.c:3033">float4_accum</a>&nbsp; &nbsp; &nbsp; &nbsp; - same, but input data is float4<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3118" title="utils/adt/float.c:3118">float8_avg</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - produce final result for float AVG()<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3160" title="utils/adt/float.c:3160">float8_var_samp</a>&nbsp; &nbsp; &nbsp; &nbsp; - produce final result for float VAR_SAMP()<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3138" title="utils/adt/float.c:3138">float8_var_pop</a>&nbsp; &nbsp; &nbsp; &nbsp; - produce final result for float VAR_POP()<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3204" title="utils/adt/float.c:3204">float8_stddev_samp</a>&nbsp; &nbsp; - produce final result for float STDDEV_SAMP()<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3182" title="utils/adt/float.c:3182">float8_stddev_pop</a>&nbsp; &nbsp; - produce final result for float STDDEV_POP()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The naive schoolbook implementation of these aggregates works by<br/></li>
<li></span><span class="Comment"> * accumulating sum(X) and sum(X^2).&nbsp; However, this approach suffers from<br/></li>
<li></span><span class="Comment"> * large rounding errors in the final computation of quantities like the<br/></li>
<li></span><span class="Comment"> * population variance (N*sum(X^2) - sum(X)^2) / N^2, since each of the<br/></li>
<li></span><span class="Comment"> * intermediate terms is potentially very large, while the difference is often<br/></li>
<li></span><span class="Comment"> * quite small.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Instead we use the Youngs-Cramer algorithm [1] which works by accumulating<br/></li>
<li></span><span class="Comment"> * Sx=sum(X) and Sxx=sum((X-Sx/N)^2), using a numerically stable algorithm to<br/></li>
<li></span><span class="Comment"> * incrementally update those quantities.&nbsp; The final computations of each of<br/></li>
<li></span><span class="Comment"> * the aggregate <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> is then trivial and gives more accurate results (for<br/></li>
<li></span><span class="Comment"> * example, the population variance is just Sxx/N).&nbsp; This algorithm is also<br/></li>
<li></span><span class="Comment"> * fairly easy to generalize to allow parallel execution without loss of<br/></li>
<li></span><span class="Comment"> * precision (see, for example, [2]).&nbsp; For more details, and a comparison of<br/></li>
<li></span><span class="Comment"> * this with other algorithms, see [3].<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The transition datatype for all these aggregates is a 3-<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> array<br/></li>
<li></span><span class="Comment"> * of float8, holding the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> N, Sx, Sxx in that order.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that we represent N as a float to avoid having to build a special<br/></li>
<li></span><span class="Comment"> * datatype.&nbsp; Given a reasonable floating-point implementation, there should<br/></li>
<li></span><span class="Comment"> * be no accuracy loss unless N exceeds 2 ^ 52 or so (by which time the<br/></li>
<li></span><span class="Comment"> * user will have doubtless lost interest anyway...)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * [1] Some Results Relevant to Choice of Sum and Sum-of-Product Algorithms,<br/></li>
<li></span><span class="Comment"> * E. A. Youngs and E. M. Cramer, Technometrics Vol 13, No 3, August 1971.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * [2] Updating Formulae and a Pairwise Algorithm for Computing Sample<br/></li>
<li></span><span class="Comment"> * Variances, T. F. Chan, G. H. Golub &amp; R. J. LeVeque, COMPSTAT 1982.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * [3] Numerically Stable Parallel Computation of (Co-)Variance, Erich<br/></li>
<li></span><span class="Comment"> * Schubert and Michael Gertz, Proceedings of the 30th International<br/></li>
<li></span><span class="Comment"> * Conference on Scientific and Statistical Database Management, 2018.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> float8 *<br/></li>
<li><a id="L2832">&#x200c;</a><span class="linkable">check_float8_array</span>(ArrayType *transarray, <span class="Type">const</span> <span class="Type">char</span> *caller, <span class="Type">int</span> n)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We expect the input to be an N-<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> float array; verify that. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't need to use <a href="arrayfuncs.c.html#L3612" title="utils/adt/arrayfuncs.c:3612">deconstruct_array</a>() since the array data is just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * going to look like a C array of N float8 <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ARR_NDIM(transarray) != <span class="Constant">1</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ARR_DIMS(transarray)[<span class="Constant">0</span>] != n ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ARR_HASNULL(transarray) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ARR_ELEMTYPE(transarray) != FLOAT8OID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">: expected </span><span class="Special">%d</span><span class="Constant">-<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> float8 array&quot;</span>, caller, n);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (float8 *) ARR_DATA_PTR(transarray);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2856" title="utils/adt/float.c:2856">float8_combine</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * An aggregate <a href="../../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> function used to <a href="../../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> two 3 fields<br/></li>
<li></span><span class="Comment"> * aggregate transition data into a single transition data.<br/></li>
<li></span><span class="Comment"> * This function is used only in two stage aggregation and<br/></li>
<li></span><span class="Comment"> * shouldn't be called outside aggregate context.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2856">&#x200c;</a><span class="linkable">float8_combine</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *transarray1 = PG_GETARG_ARRAYTYPE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *transarray2 = PG_GETARG_ARRAYTYPE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp;&nbsp; *transvalues1;<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp;&nbsp; *transvalues2;<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; N1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sx1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sxx1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; N2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sx2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sxx2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; N,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sxx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; transvalues1 = <a href="#L2832" title="utils/adt/float.c:2832">check_float8_array</a>(transarray1, <span class="Constant">&quot;<a href="#L2856" title="utils/adt/float.c:2856">float8_combine</a>&quot;</span>, <span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; transvalues2 = <a href="#L2832" title="utils/adt/float.c:2832">check_float8_array</a>(transarray2, <span class="Constant">&quot;<a href="#L2856" title="utils/adt/float.c:2856">float8_combine</a>&quot;</span>, <span class="Constant">3</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; N1 = transvalues1[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; Sx1 = transvalues1[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; Sxx1 = transvalues1[<span class="Constant">2</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; N2 = transvalues2[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; Sx2 = transvalues2[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; Sxx2 = transvalues2[<span class="Constant">2</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*--------------------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The transition <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> <a href="../../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> using a generalization of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Youngs-Cramer algorithm as follows:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; N = N1 + N2<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; Sx = Sx1 + Sx2<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; Sxx = Sxx1 + Sxx2 + N1 * N2 * (Sx1/N1 - Sx2/N2)^2 / N;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's worth handling the special cases N1 = 0 and N2 = 0 separately<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * since those cases are trivial, and we then don't need to worry about<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * division-by-zero errors in the general case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *--------------------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (N1 == <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; N = N2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Sx = Sx2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Sxx = Sxx2;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (N2 == <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; N = N1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Sx = Sx1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Sxx = Sxx1;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; N = N1 + N2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Sx = float8_pl(Sx1, Sx2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tmp = Sx1 / N1 - Sx2 / N2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Sxx = Sxx1 + Sxx2 + N1 * N2 * tmp * tmp / N;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlikely(isinf(Sxx)) &amp;&amp; !isinf(Sxx1) &amp;&amp; !isinf(Sxx2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L79" title="utils/adt/float.c:79">float_overflow_error</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're invoked as an aggregate, we can cheat and modify our first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parameter in-place to reduce <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a> overhead. Otherwise we construct a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * new array with the updated transition data and return it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../executor/nodeAgg.c.html#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>(fcinfo, <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; transvalues1[<span class="Constant">0</span>] = N;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; transvalues1[<span class="Constant">1</span>] = Sx;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; transvalues1[<span class="Constant">2</span>] = Sxx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_ARRAYTYPE_P(transarray1);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; transdatums[<span class="Constant">3</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ArrayType&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; transdatums[<span class="Constant">0</span>] = Float8GetDatumFast(N);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; transdatums[<span class="Constant">1</span>] = Float8GetDatumFast(Sx);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; transdatums[<span class="Constant">2</span>] = Float8GetDatumFast(Sxx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="arrayfuncs.c.html#L3354" title="utils/adt/arrayfuncs.c:3354">construct_array</a>(transdatums, <span class="Constant">3</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; FLOAT8OID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(float8), FLOAT8PASSBYVAL, TYPALIGN_DOUBLE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_ARRAYTYPE_P(result);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2950">&#x200c;</a><span class="linkable">float8_accum</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *transarray = PG_GETARG_ARRAYTYPE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> = PG_GETARG_FLOAT8(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp;&nbsp; *transvalues;<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; N,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sxx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; transvalues = <a href="#L2832" title="utils/adt/float.c:2832">check_float8_array</a>(transarray, <span class="Constant">&quot;<a href="#L2950" title="utils/adt/float.c:2950">float8_accum</a>&quot;</span>, <span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; N = transvalues[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; Sx = transvalues[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; Sxx = transvalues[<span class="Constant">2</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Use the Youngs-Cramer algorithm to incorporate the new value into the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transition <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; N += <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; Sx += <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (transvalues[<span class="Constant">0</span>] &gt; <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tmp = <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> * N - Sx;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Sxx += tmp * tmp / (N * transvalues[<span class="Constant">0</span>]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Overflow check.&nbsp; We only report an overflow error when finite<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * inputs lead to infinite results.&nbsp; Note also that Sxx should be NaN<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the inputs are infinite, so we intentionally prevent Sxx<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * from becoming infinite.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isinf(Sx) || isinf(Sxx))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!isinf(transvalues[<span class="Constant">1</span>]) &amp;&amp; !isinf(<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L79" title="utils/adt/float.c:79">float_overflow_error</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sxx = get_float8_nan();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * At the first input, we normally can leave Sxx as 0.&nbsp; However, if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the first input is Inf or NaN, we'd better force Sxx to NaN;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * otherwise we will falsely report variance zero when there are no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * more inputs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnan(<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>) || isinf(<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sxx = get_float8_nan();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're invoked as an aggregate, we can cheat and modify our first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parameter in-place to reduce <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a> overhead. Otherwise we construct a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * new array with the updated transition data and return it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../executor/nodeAgg.c.html#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>(fcinfo, <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; transvalues[<span class="Constant">0</span>] = N;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; transvalues[<span class="Constant">1</span>] = Sx;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; transvalues[<span class="Constant">2</span>] = Sxx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_ARRAYTYPE_P(transarray);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; transdatums[<span class="Constant">3</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ArrayType&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; transdatums[<span class="Constant">0</span>] = Float8GetDatumFast(N);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; transdatums[<span class="Constant">1</span>] = Float8GetDatumFast(Sx);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; transdatums[<span class="Constant">2</span>] = Float8GetDatumFast(Sxx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="arrayfuncs.c.html#L3354" title="utils/adt/arrayfuncs.c:3354">construct_array</a>(transdatums, <span class="Constant">3</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; FLOAT8OID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(float8), FLOAT8PASSBYVAL, TYPALIGN_DOUBLE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_ARRAYTYPE_P(result);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3033">&#x200c;</a><span class="linkable">float4_accum</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *transarray = PG_GETARG_ARRAYTYPE_P(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* do computations as float8 */<br/></li>
<li></span>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> = PG_GETARG_FLOAT4(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp;&nbsp; *transvalues;<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; N,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sxx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; transvalues = <a href="#L2832" title="utils/adt/float.c:2832">check_float8_array</a>(transarray, <span class="Constant">&quot;<a href="#L3033" title="utils/adt/float.c:3033">float4_accum</a>&quot;</span>, <span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; N = transvalues[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; Sx = transvalues[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; Sxx = transvalues[<span class="Constant">2</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Use the Youngs-Cramer algorithm to incorporate the new value into the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transition <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; N += <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; Sx += <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (transvalues[<span class="Constant">0</span>] &gt; <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tmp = <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> * N - Sx;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Sxx += tmp * tmp / (N * transvalues[<span class="Constant">0</span>]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Overflow check.&nbsp; We only report an overflow error when finite<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * inputs lead to infinite results.&nbsp; Note also that Sxx should be NaN<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the inputs are infinite, so we intentionally prevent Sxx<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * from becoming infinite.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isinf(Sx) || isinf(Sxx))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!isinf(transvalues[<span class="Constant">1</span>]) &amp;&amp; !isinf(<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L79" title="utils/adt/float.c:79">float_overflow_error</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sxx = get_float8_nan();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * At the first input, we normally can leave Sxx as 0.&nbsp; However, if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the first input is Inf or NaN, we'd better force Sxx to NaN;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * otherwise we will falsely report variance zero when there are no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * more inputs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnan(<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>) || isinf(<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sxx = get_float8_nan();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're invoked as an aggregate, we can cheat and modify our first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parameter in-place to reduce <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a> overhead. Otherwise we construct a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * new array with the updated transition data and return it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../executor/nodeAgg.c.html#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>(fcinfo, <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; transvalues[<span class="Constant">0</span>] = N;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; transvalues[<span class="Constant">1</span>] = Sx;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; transvalues[<span class="Constant">2</span>] = Sxx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_ARRAYTYPE_P(transarray);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; transdatums[<span class="Constant">3</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ArrayType&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; transdatums[<span class="Constant">0</span>] = Float8GetDatumFast(N);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; transdatums[<span class="Constant">1</span>] = Float8GetDatumFast(Sx);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; transdatums[<span class="Constant">2</span>] = Float8GetDatumFast(Sxx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="arrayfuncs.c.html#L3354" title="utils/adt/arrayfuncs.c:3354">construct_array</a>(transdatums, <span class="Constant">3</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; FLOAT8OID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(float8), FLOAT8PASSBYVAL, TYPALIGN_DOUBLE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_ARRAYTYPE_P(result);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3118">&#x200c;</a><span class="linkable">float8_avg</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *transarray = PG_GETARG_ARRAYTYPE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp;&nbsp; *transvalues;<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; N,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; transvalues = <a href="#L2832" title="utils/adt/float.c:2832">check_float8_array</a>(transarray, <span class="Constant">&quot;<a href="#L3118" title="utils/adt/float.c:3118">float8_avg</a>&quot;</span>, <span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; N = transvalues[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; Sx = transvalues[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ignore Sxx */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* SQL defines AVG of no <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to be NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (N == <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(Sx / N);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3138">&#x200c;</a><span class="linkable">float8_var_pop</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *transarray = PG_GETARG_ARRAYTYPE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp;&nbsp; *transvalues;<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; N,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sxx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; transvalues = <a href="#L2832" title="utils/adt/float.c:2832">check_float8_array</a>(transarray, <span class="Constant">&quot;<a href="#L3138" title="utils/adt/float.c:3138">float8_var_pop</a>&quot;</span>, <span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; N = transvalues[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ignore Sx */<br/></li>
<li></span>&nbsp; &nbsp; Sxx = transvalues[<span class="Constant">2</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Population variance is undefined when N is 0, so return NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (N == <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Note that Sxx is guaranteed to be non-negative */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(Sxx / N);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3160">&#x200c;</a><span class="linkable">float8_var_samp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *transarray = PG_GETARG_ARRAYTYPE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp;&nbsp; *transvalues;<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; N,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sxx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; transvalues = <a href="#L2832" title="utils/adt/float.c:2832">check_float8_array</a>(transarray, <span class="Constant">&quot;<a href="#L3160" title="utils/adt/float.c:3160">float8_var_samp</a>&quot;</span>, <span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; N = transvalues[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ignore Sx */<br/></li>
<li></span>&nbsp; &nbsp; Sxx = transvalues[<span class="Constant">2</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Sample variance is undefined when N is 0 or 1, so return NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (N &lt;= <span class="Constant">1.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Note that Sxx is guaranteed to be non-negative */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(Sxx / (N - <span class="Constant">1.0</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3182">&#x200c;</a><span class="linkable">float8_stddev_pop</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *transarray = PG_GETARG_ARRAYTYPE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp;&nbsp; *transvalues;<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; N,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sxx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; transvalues = <a href="#L2832" title="utils/adt/float.c:2832">check_float8_array</a>(transarray, <span class="Constant">&quot;<a href="#L3182" title="utils/adt/float.c:3182">float8_stddev_pop</a>&quot;</span>, <span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; N = transvalues[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ignore Sx */<br/></li>
<li></span>&nbsp; &nbsp; Sxx = transvalues[<span class="Constant">2</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Population stddev is undefined when N is 0, so return NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (N == <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Note that Sxx is guaranteed to be non-negative */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(sqrt(Sxx / N));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3204">&#x200c;</a><span class="linkable">float8_stddev_samp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *transarray = PG_GETARG_ARRAYTYPE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp;&nbsp; *transvalues;<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; N,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sxx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; transvalues = <a href="#L2832" title="utils/adt/float.c:2832">check_float8_array</a>(transarray, <span class="Constant">&quot;<a href="#L3204" title="utils/adt/float.c:3204">float8_stddev_samp</a>&quot;</span>, <span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; N = transvalues[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ignore Sx */<br/></li>
<li></span>&nbsp; &nbsp; Sxx = transvalues[<span class="Constant">2</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Sample stddev is undefined when N is 0 or 1, so return NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (N &lt;= <span class="Constant">1.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Note that Sxx is guaranteed to be non-negative */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(sqrt(Sxx / (N - <span class="Constant">1.0</span>)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; =========================<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; SQL2003 BINARY AGGREGATES<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; =========================<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As with the preceding aggregates, we use the Youngs-Cramer algorithm to<br/></li>
<li></span><span class="Comment"> * reduce rounding errors in the aggregate final <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The transition datatype for all these aggregates is a 6-<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> array of<br/></li>
<li></span><span class="Comment"> * float8, holding the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> N, Sx=sum(X), Sxx=sum((X-Sx/N)^2), Sy=sum(Y),<br/></li>
<li></span><span class="Comment"> * Syy=sum((Y-Sy/N)^2), Sxy=sum((X-Sx/N)*(Y-Sy/N)) in that order.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that Y is the first argument to all these aggregates!<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It might seem attractive to <a href="../../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> this by having multiple accumulator<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> that only calculate the sums actually needed.&nbsp; But on most<br/></li>
<li></span><span class="Comment"> * modern machines, a couple of extra floating-point multiplies will be<br/></li>
<li></span><span class="Comment"> * insignificant compared to the other per-tuple overhead, so I've chosen<br/></li>
<li></span><span class="Comment"> * to minimize code space instead.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L3247">&#x200c;</a><span class="linkable">float8_regr_accum</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *transarray = PG_GETARG_ARRAYTYPE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; newvalY = PG_GETARG_FLOAT8(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; newvalX = PG_GETARG_FLOAT8(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp;&nbsp; *transvalues;<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; N,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sxx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Syy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sxy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmpX,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmpY,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scale;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; transvalues = <a href="#L2832" title="utils/adt/float.c:2832">check_float8_array</a>(transarray, <span class="Constant">&quot;<a href="#L3247" title="utils/adt/float.c:3247">float8_regr_accum</a>&quot;</span>, <span class="Constant">6</span>);<br/></li>
<li>&nbsp; &nbsp; N = transvalues[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; Sx = transvalues[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; Sxx = transvalues[<span class="Constant">2</span>];<br/></li>
<li>&nbsp; &nbsp; Sy = transvalues[<span class="Constant">3</span>];<br/></li>
<li>&nbsp; &nbsp; Syy = transvalues[<span class="Constant">4</span>];<br/></li>
<li>&nbsp; &nbsp; Sxy = transvalues[<span class="Constant">5</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Use the Youngs-Cramer algorithm to incorporate the new <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> into the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transition <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; N += <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; Sx += newvalX;<br/></li>
<li>&nbsp; &nbsp; Sy += newvalY;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (transvalues[<span class="Constant">0</span>] &gt; <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tmpX = newvalX * N - Sx;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tmpY = newvalY * N - Sy;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scale = <span class="Constant">1.0</span> / (N * transvalues[<span class="Constant">0</span>]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Sxx += tmpX * tmpX * scale;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Syy += tmpY * tmpY * scale;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Sxy += tmpX * tmpY * scale;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Overflow check.&nbsp; We only report an overflow error when finite<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * inputs lead to infinite results.&nbsp; Note also that Sxx, Syy and Sxy<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * should be NaN if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the relevant inputs are infinite, so we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * intentionally prevent them from becoming infinite.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isinf(Sx) || isinf(Sxx) || isinf(Sy) || isinf(Syy) || isinf(Sxy))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (((isinf(Sx) || isinf(Sxx)) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !isinf(transvalues[<span class="Constant">1</span>]) &amp;&amp; !isinf(newvalX)) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((isinf(Sy) || isinf(Syy)) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !isinf(transvalues[<span class="Constant">3</span>]) &amp;&amp; !isinf(newvalY)) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (isinf(Sxy) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !isinf(transvalues[<span class="Constant">1</span>]) &amp;&amp; !isinf(newvalX) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !isinf(transvalues[<span class="Constant">3</span>]) &amp;&amp; !isinf(newvalY)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L79" title="utils/adt/float.c:79">float_overflow_error</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isinf(Sxx))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sxx = get_float8_nan();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isinf(Syy))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Syy = get_float8_nan();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isinf(Sxy))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sxy = get_float8_nan();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * At the first input, we normally can leave Sxx et al as 0.&nbsp; However,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if the first input is Inf or NaN, we'd better force the dependent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sums to NaN; otherwise we will falsely report variance zero when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there are no more inputs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnan(newvalX) || isinf(newvalX))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sxx = Sxy = get_float8_nan();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnan(newvalY) || isinf(newvalY))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Syy = Sxy = get_float8_nan();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're invoked as an aggregate, we can cheat and modify our first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parameter in-place to reduce <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a> overhead. Otherwise we construct a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * new array with the updated transition data and return it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../executor/nodeAgg.c.html#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>(fcinfo, <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; transvalues[<span class="Constant">0</span>] = N;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; transvalues[<span class="Constant">1</span>] = Sx;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; transvalues[<span class="Constant">2</span>] = Sxx;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; transvalues[<span class="Constant">3</span>] = Sy;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; transvalues[<span class="Constant">4</span>] = Syy;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; transvalues[<span class="Constant">5</span>] = Sxy;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_ARRAYTYPE_P(transarray);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; transdatums[<span class="Constant">6</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ArrayType&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; transdatums[<span class="Constant">0</span>] = Float8GetDatumFast(N);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; transdatums[<span class="Constant">1</span>] = Float8GetDatumFast(Sx);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; transdatums[<span class="Constant">2</span>] = Float8GetDatumFast(Sxx);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; transdatums[<span class="Constant">3</span>] = Float8GetDatumFast(Sy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; transdatums[<span class="Constant">4</span>] = Float8GetDatumFast(Syy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; transdatums[<span class="Constant">5</span>] = Float8GetDatumFast(Sxy);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="arrayfuncs.c.html#L3354" title="utils/adt/arrayfuncs.c:3354">construct_array</a>(transdatums, <span class="Constant">6</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; FLOAT8OID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(float8), FLOAT8PASSBYVAL, TYPALIGN_DOUBLE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_ARRAYTYPE_P(result);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3371" title="utils/adt/float.c:3371">float8_regr_combine</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * An aggregate <a href="../../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> function used to <a href="../../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> two 6 fields<br/></li>
<li></span><span class="Comment"> * aggregate transition data into a single transition data.<br/></li>
<li></span><span class="Comment"> * This function is used only in two stage aggregation and<br/></li>
<li></span><span class="Comment"> * shouldn't be called outside aggregate context.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3371">&#x200c;</a><span class="linkable">float8_regr_combine</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *transarray1 = PG_GETARG_ARRAYTYPE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *transarray2 = PG_GETARG_ARRAYTYPE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp;&nbsp; *transvalues1;<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp;&nbsp; *transvalues2;<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; N1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sx1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sxx1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sy1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Syy1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sxy1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; N2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sx2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sxx2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sy2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Syy2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sxy2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; N,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sxx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Syy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sxy;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; transvalues1 = <a href="#L2832" title="utils/adt/float.c:2832">check_float8_array</a>(transarray1, <span class="Constant">&quot;<a href="#L3371" title="utils/adt/float.c:3371">float8_regr_combine</a>&quot;</span>, <span class="Constant">6</span>);<br/></li>
<li>&nbsp; &nbsp; transvalues2 = <a href="#L2832" title="utils/adt/float.c:2832">check_float8_array</a>(transarray2, <span class="Constant">&quot;<a href="#L3371" title="utils/adt/float.c:3371">float8_regr_combine</a>&quot;</span>, <span class="Constant">6</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; N1 = transvalues1[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; Sx1 = transvalues1[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; Sxx1 = transvalues1[<span class="Constant">2</span>];<br/></li>
<li>&nbsp; &nbsp; Sy1 = transvalues1[<span class="Constant">3</span>];<br/></li>
<li>&nbsp; &nbsp; Syy1 = transvalues1[<span class="Constant">4</span>];<br/></li>
<li>&nbsp; &nbsp; Sxy1 = transvalues1[<span class="Constant">5</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; N2 = transvalues2[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; Sx2 = transvalues2[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; Sxx2 = transvalues2[<span class="Constant">2</span>];<br/></li>
<li>&nbsp; &nbsp; Sy2 = transvalues2[<span class="Constant">3</span>];<br/></li>
<li>&nbsp; &nbsp; Syy2 = transvalues2[<span class="Constant">4</span>];<br/></li>
<li>&nbsp; &nbsp; Sxy2 = transvalues2[<span class="Constant">5</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*--------------------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The transition <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> <a href="../../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> using a generalization of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Youngs-Cramer algorithm as follows:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; N = N1 + N2<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; Sx = Sx1 + Sx2<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; Sxx = Sxx1 + Sxx2 + N1 * N2 * (Sx1/N1 - Sx2/N2)^2 / N<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; Sy = Sy1 + Sy2<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; Syy = Syy1 + Syy2 + N1 * N2 * (Sy1/N1 - Sy2/N2)^2 / N<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; Sxy = Sxy1 + Sxy2 + N1 * N2 * (Sx1/N1 - Sx2/N2) * (Sy1/N1 - Sy2/N2) / N<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's worth handling the special cases N1 = 0 and N2 = 0 separately<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * since those cases are trivial, and we then don't need to worry about<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * division-by-zero errors in the general case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *--------------------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (N1 == <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; N = N2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Sx = Sx2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Sxx = Sxx2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Sy = Sy2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Syy = Syy2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Sxy = Sxy2;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (N2 == <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; N = N1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Sx = Sx1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Sxx = Sxx1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Sy = Sy1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Syy = Syy1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Sxy = Sxy1;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; N = N1 + N2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Sx = float8_pl(Sx1, Sx2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tmp1 = Sx1 / N1 - Sx2 / N2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Sxx = Sxx1 + Sxx2 + N1 * N2 * tmp1 * tmp1 / N;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlikely(isinf(Sxx)) &amp;&amp; !isinf(Sxx1) &amp;&amp; !isinf(Sxx2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L79" title="utils/adt/float.c:79">float_overflow_error</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Sy = float8_pl(Sy1, Sy2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tmp2 = Sy1 / N1 - Sy2 / N2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Syy = Syy1 + Syy2 + N1 * N2 * tmp2 * tmp2 / N;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlikely(isinf(Syy)) &amp;&amp; !isinf(Syy1) &amp;&amp; !isinf(Syy2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L79" title="utils/adt/float.c:79">float_overflow_error</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Sxy = Sxy1 + Sxy2 + N1 * N2 * tmp1 * tmp2 / N;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlikely(isinf(Sxy)) &amp;&amp; !isinf(Sxy1) &amp;&amp; !isinf(Sxy2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L79" title="utils/adt/float.c:79">float_overflow_error</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're invoked as an aggregate, we can cheat and modify our first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parameter in-place to reduce <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a> overhead. Otherwise we construct a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * new array with the updated transition data and return it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../executor/nodeAgg.c.html#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>(fcinfo, <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; transvalues1[<span class="Constant">0</span>] = N;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; transvalues1[<span class="Constant">1</span>] = Sx;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; transvalues1[<span class="Constant">2</span>] = Sxx;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; transvalues1[<span class="Constant">3</span>] = Sy;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; transvalues1[<span class="Constant">4</span>] = Syy;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; transvalues1[<span class="Constant">5</span>] = Sxy;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_ARRAYTYPE_P(transarray1);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; transdatums[<span class="Constant">6</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ArrayType&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; transdatums[<span class="Constant">0</span>] = Float8GetDatumFast(N);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; transdatums[<span class="Constant">1</span>] = Float8GetDatumFast(Sx);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; transdatums[<span class="Constant">2</span>] = Float8GetDatumFast(Sxx);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; transdatums[<span class="Constant">3</span>] = Float8GetDatumFast(Sy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; transdatums[<span class="Constant">4</span>] = Float8GetDatumFast(Syy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; transdatums[<span class="Constant">5</span>] = Float8GetDatumFast(Sxy);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="arrayfuncs.c.html#L3354" title="utils/adt/arrayfuncs.c:3354">construct_array</a>(transdatums, <span class="Constant">6</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; FLOAT8OID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(float8), FLOAT8PASSBYVAL, TYPALIGN_DOUBLE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_ARRAYTYPE_P(result);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3505">&#x200c;</a><span class="linkable">float8_regr_sxx</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *transarray = PG_GETARG_ARRAYTYPE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp;&nbsp; *transvalues;<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; N,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sxx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; transvalues = <a href="#L2832" title="utils/adt/float.c:2832">check_float8_array</a>(transarray, <span class="Constant">&quot;<a href="#L3505" title="utils/adt/float.c:3505">float8_regr_sxx</a>&quot;</span>, <span class="Constant">6</span>);<br/></li>
<li>&nbsp; &nbsp; N = transvalues[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; Sxx = transvalues[<span class="Constant">2</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if N is 0 we should return NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (N &lt; <span class="Constant">1.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Note that Sxx is guaranteed to be non-negative */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(Sxx);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3526">&#x200c;</a><span class="linkable">float8_regr_syy</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *transarray = PG_GETARG_ARRAYTYPE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp;&nbsp; *transvalues;<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; N,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Syy;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; transvalues = <a href="#L2832" title="utils/adt/float.c:2832">check_float8_array</a>(transarray, <span class="Constant">&quot;<a href="#L3526" title="utils/adt/float.c:3526">float8_regr_syy</a>&quot;</span>, <span class="Constant">6</span>);<br/></li>
<li>&nbsp; &nbsp; N = transvalues[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; Syy = transvalues[<span class="Constant">4</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if N is 0 we should return NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (N &lt; <span class="Constant">1.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Note that Syy is guaranteed to be non-negative */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(Syy);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3547">&#x200c;</a><span class="linkable">float8_regr_sxy</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *transarray = PG_GETARG_ARRAYTYPE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp;&nbsp; *transvalues;<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; N,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sxy;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; transvalues = <a href="#L2832" title="utils/adt/float.c:2832">check_float8_array</a>(transarray, <span class="Constant">&quot;<a href="#L3547" title="utils/adt/float.c:3547">float8_regr_sxy</a>&quot;</span>, <span class="Constant">6</span>);<br/></li>
<li>&nbsp; &nbsp; N = transvalues[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; Sxy = transvalues[<span class="Constant">5</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if N is 0 we should return NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (N &lt; <span class="Constant">1.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* A negative result is valid here */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(Sxy);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3568">&#x200c;</a><span class="linkable">float8_regr_avgx</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *transarray = PG_GETARG_ARRAYTYPE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp;&nbsp; *transvalues;<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; N,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; transvalues = <a href="#L2832" title="utils/adt/float.c:2832">check_float8_array</a>(transarray, <span class="Constant">&quot;<a href="#L3568" title="utils/adt/float.c:3568">float8_regr_avgx</a>&quot;</span>, <span class="Constant">6</span>);<br/></li>
<li>&nbsp; &nbsp; N = transvalues[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; Sx = transvalues[<span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if N is 0 we should return NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (N &lt; <span class="Constant">1.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(Sx / N);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3587">&#x200c;</a><span class="linkable">float8_regr_avgy</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *transarray = PG_GETARG_ARRAYTYPE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp;&nbsp; *transvalues;<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; N,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sy;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; transvalues = <a href="#L2832" title="utils/adt/float.c:2832">check_float8_array</a>(transarray, <span class="Constant">&quot;<a href="#L3587" title="utils/adt/float.c:3587">float8_regr_avgy</a>&quot;</span>, <span class="Constant">6</span>);<br/></li>
<li>&nbsp; &nbsp; N = transvalues[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; Sy = transvalues[<span class="Constant">3</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if N is 0 we should return NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (N &lt; <span class="Constant">1.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(Sy / N);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3606">&#x200c;</a><span class="linkable">float8_covar_pop</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *transarray = PG_GETARG_ARRAYTYPE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp;&nbsp; *transvalues;<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; N,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sxy;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; transvalues = <a href="#L2832" title="utils/adt/float.c:2832">check_float8_array</a>(transarray, <span class="Constant">&quot;<a href="#L3606" title="utils/adt/float.c:3606">float8_covar_pop</a>&quot;</span>, <span class="Constant">6</span>);<br/></li>
<li>&nbsp; &nbsp; N = transvalues[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; Sxy = transvalues[<span class="Constant">5</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if N is 0 we should return NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (N &lt; <span class="Constant">1.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(Sxy / N);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3625">&#x200c;</a><span class="linkable">float8_covar_samp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *transarray = PG_GETARG_ARRAYTYPE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp;&nbsp; *transvalues;<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; N,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sxy;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; transvalues = <a href="#L2832" title="utils/adt/float.c:2832">check_float8_array</a>(transarray, <span class="Constant">&quot;<a href="#L3625" title="utils/adt/float.c:3625">float8_covar_samp</a>&quot;</span>, <span class="Constant">6</span>);<br/></li>
<li>&nbsp; &nbsp; N = transvalues[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; Sxy = transvalues[<span class="Constant">5</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if N is &lt;= 1 we should return NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (N &lt; <span class="Constant">2.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(Sxy / (N - <span class="Constant">1.0</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3644">&#x200c;</a><span class="linkable">float8_corr</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *transarray = PG_GETARG_ARRAYTYPE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp;&nbsp; *transvalues;<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; N,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sxx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Syy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sxy;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; transvalues = <a href="#L2832" title="utils/adt/float.c:2832">check_float8_array</a>(transarray, <span class="Constant">&quot;<a href="#L3644" title="utils/adt/float.c:3644">float8_corr</a>&quot;</span>, <span class="Constant">6</span>);<br/></li>
<li>&nbsp; &nbsp; N = transvalues[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; Sxx = transvalues[<span class="Constant">2</span>];<br/></li>
<li>&nbsp; &nbsp; Syy = transvalues[<span class="Constant">4</span>];<br/></li>
<li>&nbsp; &nbsp; Sxy = transvalues[<span class="Constant">5</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if N is 0 we should return NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (N &lt; <span class="Constant">1.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Note that Sxx and Syy are guaranteed to be non-negative */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* per spec, return NULL for horizontal and vertical lines */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (Sxx == <span class="Constant">0</span> || Syy == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(Sxy / sqrt(Sxx * Syy));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3673">&#x200c;</a><span class="linkable">float8_regr_r2</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *transarray = PG_GETARG_ARRAYTYPE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp;&nbsp; *transvalues;<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; N,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sxx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Syy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sxy;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; transvalues = <a href="#L2832" title="utils/adt/float.c:2832">check_float8_array</a>(transarray, <span class="Constant">&quot;<a href="#L3673" title="utils/adt/float.c:3673">float8_regr_r2</a>&quot;</span>, <span class="Constant">6</span>);<br/></li>
<li>&nbsp; &nbsp; N = transvalues[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; Sxx = transvalues[<span class="Constant">2</span>];<br/></li>
<li>&nbsp; &nbsp; Syy = transvalues[<span class="Constant">4</span>];<br/></li>
<li>&nbsp; &nbsp; Sxy = transvalues[<span class="Constant">5</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if N is 0 we should return NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (N &lt; <span class="Constant">1.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Note that Sxx and Syy are guaranteed to be non-negative */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* per spec, return NULL for a vertical line */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (Sxx == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* per spec, return 1.0 for a horizontal line */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (Syy == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(<span class="Constant">1.0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8((Sxy * Sxy) / (Sxx * Syy));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3706">&#x200c;</a><span class="linkable">float8_regr_slope</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *transarray = PG_GETARG_ARRAYTYPE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp;&nbsp; *transvalues;<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; N,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sxx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sxy;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; transvalues = <a href="#L2832" title="utils/adt/float.c:2832">check_float8_array</a>(transarray, <span class="Constant">&quot;<a href="#L3706" title="utils/adt/float.c:3706">float8_regr_slope</a>&quot;</span>, <span class="Constant">6</span>);<br/></li>
<li>&nbsp; &nbsp; N = transvalues[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; Sxx = transvalues[<span class="Constant">2</span>];<br/></li>
<li>&nbsp; &nbsp; Sxy = transvalues[<span class="Constant">5</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if N is 0 we should return NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (N &lt; <span class="Constant">1.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Note that Sxx is guaranteed to be non-negative */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* per spec, return NULL for a vertical line */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (Sxx == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(Sxy / Sxx);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3733">&#x200c;</a><span class="linkable">float8_regr_intercept</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *transarray = PG_GETARG_ARRAYTYPE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp;&nbsp; *transvalues;<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; N,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sxx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sxy;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; transvalues = <a href="#L2832" title="utils/adt/float.c:2832">check_float8_array</a>(transarray, <span class="Constant">&quot;<a href="#L3733" title="utils/adt/float.c:3733">float8_regr_intercept</a>&quot;</span>, <span class="Constant">6</span>);<br/></li>
<li>&nbsp; &nbsp; N = transvalues[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; Sx = transvalues[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; Sxx = transvalues[<span class="Constant">2</span>];<br/></li>
<li>&nbsp; &nbsp; Sy = transvalues[<span class="Constant">3</span>];<br/></li>
<li>&nbsp; &nbsp; Sxy = transvalues[<span class="Constant">5</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if N is 0 we should return NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (N &lt; <span class="Constant">1.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Note that Sxx is guaranteed to be non-negative */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* per spec, return NULL for a vertical line */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (Sxx == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8((Sy - Sx * Sxy / Sxx) / N);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; ====================================<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; MIXED-PRECISION ARITHMETIC OPERATORS<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; ====================================<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3777" title="utils/adt/float.c:3777">float48pl</a>&nbsp; &nbsp; &nbsp; &nbsp; - returns arg1 + arg2<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3786" title="utils/adt/float.c:3786">float48mi</a>&nbsp; &nbsp; &nbsp; &nbsp; - returns arg1 - arg2<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3795" title="utils/adt/float.c:3795">float48mul</a>&nbsp; &nbsp; &nbsp; &nbsp; - returns arg1 * arg2<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3804" title="utils/adt/float.c:3804">float48div</a>&nbsp; &nbsp; &nbsp; &nbsp; - returns arg1 / arg2<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3777">&#x200c;</a><span class="linkable">float48pl</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT4(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_FLOAT8(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(float8_pl((float8) arg1, arg2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3786">&#x200c;</a><span class="linkable">float48mi</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT4(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_FLOAT8(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(float8_mi((float8) arg1, arg2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3795">&#x200c;</a><span class="linkable">float48mul</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT4(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_FLOAT8(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(float8_mul((float8) arg1, arg2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3804">&#x200c;</a><span class="linkable">float48div</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT4(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_FLOAT8(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(float8_div((float8) arg1, arg2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3819" title="utils/adt/float.c:3819">float84pl</a>&nbsp; &nbsp; &nbsp; &nbsp; - returns arg1 + arg2<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3828" title="utils/adt/float.c:3828">float84mi</a>&nbsp; &nbsp; &nbsp; &nbsp; - returns arg1 - arg2<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3837" title="utils/adt/float.c:3837">float84mul</a>&nbsp; &nbsp; &nbsp; &nbsp; - returns arg1 * arg2<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3846" title="utils/adt/float.c:3846">float84div</a>&nbsp; &nbsp; &nbsp; &nbsp; - returns arg1 / arg2<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3819">&#x200c;</a><span class="linkable">float84pl</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_FLOAT4(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(float8_pl(arg1, (float8) arg2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3828">&#x200c;</a><span class="linkable">float84mi</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_FLOAT4(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(float8_mi(arg1, (float8) arg2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3837">&#x200c;</a><span class="linkable">float84mul</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_FLOAT4(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(float8_mul(arg1, (float8) arg2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3846">&#x200c;</a><span class="linkable">float84div</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_FLOAT4(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(float8_div(arg1, (float8) arg2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; ====================<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; COMPARISON OPERATORS<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; ====================<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; float48{eq,ne,lt,le,gt,ge}&nbsp; &nbsp; &nbsp; &nbsp; - float4/float8 comparison operations<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3864">&#x200c;</a><span class="linkable">float48eq</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT4(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_FLOAT8(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(float8_eq((float8) arg1, arg2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3873">&#x200c;</a><span class="linkable">float48ne</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT4(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_FLOAT8(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(float8_ne((float8) arg1, arg2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3882">&#x200c;</a><span class="linkable">float48lt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT4(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_FLOAT8(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(float8_lt((float8) arg1, arg2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3891">&#x200c;</a><span class="linkable">float48le</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT4(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_FLOAT8(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(float8_le((float8) arg1, arg2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3900">&#x200c;</a><span class="linkable">float48gt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT4(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_FLOAT8(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(float8_gt((float8) arg1, arg2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3909">&#x200c;</a><span class="linkable">float48ge</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT4(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_FLOAT8(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(float8_ge((float8) arg1, arg2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; float84{eq,ne,lt,le,gt,ge}&nbsp; &nbsp; &nbsp; &nbsp; - float8/float4 comparison operations<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3921">&#x200c;</a><span class="linkable">float84eq</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_FLOAT4(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(float8_eq(arg1, (float8) arg2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3930">&#x200c;</a><span class="linkable">float84ne</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_FLOAT4(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(float8_ne(arg1, (float8) arg2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3939">&#x200c;</a><span class="linkable">float84lt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_FLOAT4(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(float8_lt(arg1, (float8) arg2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3948">&#x200c;</a><span class="linkable">float84le</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_FLOAT4(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(float8_le(arg1, (float8) arg2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3957">&#x200c;</a><span class="linkable">float84gt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_FLOAT4(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(float8_gt(arg1, (float8) arg2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3966">&#x200c;</a><span class="linkable">float84ge</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_FLOAT4(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(float8_ge(arg1, (float8) arg2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Implements the float8 version of the width_bucket() function<br/></li>
<li></span><span class="Comment"> * defined by SQL2003. See also <a href="numeric.c.html#L1829" title="utils/adt/numeric.c:1829">width_bucket_numeric</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'bound1' and 'bound2' are the <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> and <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bounds of the<br/></li>
<li></span><span class="Comment"> * histogram's <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, respectively. 'count' is the number of buckets<br/></li>
<li></span><span class="Comment"> * in the histogram. width_bucket() returns an integer indicating the<br/></li>
<li></span><span class="Comment"> * bucket number that 'operand' belongs to in an equiwidth histogram<br/></li>
<li></span><span class="Comment"> * with the specified characteristics. An operand smaller than the<br/></li>
<li></span><span class="Comment"> * <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound is assigned to bucket 0. An operand greater than the<br/></li>
<li></span><span class="Comment"> * <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound is assigned to an additional bucket (with number<br/></li>
<li></span><span class="Comment"> * count+1). We don't allow &quot;NaN&quot; for <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the float8 inputs, and we<br/></li>
<li></span><span class="Comment"> * don't allow either of the histogram bounds to be +/- infinity.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3989">&#x200c;</a><span class="linkable">width_bucket_float8</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; operand = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; bound1 = PG_GETARG_FLOAT8(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; bound2 = PG_GETARG_FLOAT8(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; count = PG_GETARG_INT32(<span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (count &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_ARGUMENT_FOR_WIDTH_BUCKET_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;count must be greater than zero&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isnan(operand) || isnan(bound1) || isnan(bound2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_ARGUMENT_FOR_WIDTH_BUCKET_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;operand, <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound, and <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound cannot be NaN&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Note that we allow &quot;operand&quot; to be infinite */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isinf(bound1) || isinf(bound2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_ARGUMENT_FOR_WIDTH_BUCKET_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> and <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bounds must be finite&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (bound1 &lt; bound2)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (operand &lt; bound1)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (operand &gt;= bound2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pg_add_s32_overflow(count, <span class="Constant">1</span>, &amp;result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;integer out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!isinf(bound2 - bound1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The quotient is surely in [0,1], so this can't overflow */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = count * ((operand - bound1) / (bound2 - bound1));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We get here if bound2 - bound1 overflows DBL_MAX.&nbsp; Since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * both bounds are finite, their difference can't exceed twice<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * DBL_MAX; so we can perform the computation without overflow<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * by dividing all the inputs by 2.&nbsp; That should be exact too,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * except in the case where a very small operand underflows to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * zero, which would have negligible impact on the result<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * given such large bounds.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = count * ((operand / <span class="Constant">2</span> - bound1 / <span class="Constant">2</span>) / (bound2 / <span class="Constant">2</span> - bound1 / <span class="Constant">2</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The quotient could round to 1.0, which would be a lie */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result &gt;= count)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = count - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Having done that, we can add 1 without fear of overflow */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (bound1 &gt; bound2)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (operand &gt; bound1)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (operand &lt;= bound2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pg_add_s32_overflow(count, <span class="Constant">1</span>, &amp;result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;integer out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!isinf(bound1 - bound2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = count * ((bound1 - operand) / (bound1 - bound2));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = count * ((bound1 / <span class="Constant">2</span> - operand / <span class="Constant">2</span>) / (bound1 / <span class="Constant">2</span> - bound2 / <span class="Constant">2</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result &gt;= count)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = count - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_ARGUMENT_FOR_WIDTH_BUCKET_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound cannot <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep the compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(result);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
