<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/adt/like_support.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/adt/like_support.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L70">Pattern_Prefix_Status</a></li>
<li><a href="#L65">Pattern_Type</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L1523">byte_increment</a></li>
<li><a href="#L921">iclikejoinsel</a></li>
<li><a href="#L830">iclikesel</a></li>
<li><a href="#L957">icnlikejoinsel</a></li>
<li><a href="#L866">icnlikesel</a></li>
<li><a href="#L894">icregexeqjoinsel</a></li>
<li><a href="#L802">icregexeqsel</a></li>
<li><a href="#L939">icregexnejoinsel</a></li>
<li><a href="#L848">icregexnesel</a></li>
<li><a href="#L992">like_fixed_prefix</a></li>
<li><a href="#L156">like_regex_support</a></li>
<li><a href="#L1323">like_selectivity</a></li>
<li><a href="#L903">likejoinsel</a></li>
<li><a href="#L811">likesel</a></li>
<li><a href="#L1573">make_greater_string</a></li>
<li><a href="#L241">match_pattern_prefix</a></li>
<li><a href="#L948">nlikejoinsel</a></li>
<li><a href="#L857">nlikesel</a></li>
<li><a href="#L1501">pattern_char_isalpha</a></li>
<li><a href="#L1167">pattern_fixed_prefix</a></li>
<li><a href="#L875">patternjoinsel</a></li>
<li><a href="#L760">patternsel</a></li>
<li><a href="#L486">patternsel_common</a></li>
<li><a href="#L1232">prefix_selectivity</a></li>
<li><a href="#L912">prefixjoinsel</a></li>
<li><a href="#L820">prefixsel</a></li>
<li><a href="#L1099">regex_fixed_prefix</a></li>
<li><a href="#L1455">regex_selectivity</a></li>
<li><a href="#L1360">regex_selectivity_sub</a></li>
<li><a href="#L885">regexeqjoinsel</a></li>
<li><a href="#L793">regexeqsel</a></li>
<li><a href="#L930">regexnejoinsel</a></li>
<li><a href="#L839">regexnesel</a></li>
<li><a href="#L1787">string_to_bytea_const</a></li>
<li><a href="#L1744">string_to_const</a></li>
<li><a href="#L1724">string_to_datum</a></li>
<li><a href="#L147">text_starts_with_support</a></li>
<li><a href="#L123">texticlike_support</a></li>
<li><a href="#L139">texticregexeq_support</a></li>
<li><a href="#L115">textlike_support</a></li>
<li><a href="#L131">textregexeq_support</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L1318">ANY_CHAR_SEL</a></li>
<li><a href="#L1317">CHAR_RANGE_SEL</a></li>
<li><a href="#L1316">FIXED_CHAR_SEL</a></li>
<li><a href="#L1319">FULL_WILDCARD_SEL</a></li>
<li><a href="#L1320">PARTIAL_WILDCARD_SEL</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * like_support.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Planner support <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for LIKE, regex, and related operators.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * These routines handle special optimization of operators that can be<br/></li>
<li></span><span class="Comment"> * used with index scans even though they are not known to the executor's<br/></li>
<li></span><span class="Comment"> * indexscan machinery.&nbsp; The key idea is that these operators allow us<br/></li>
<li></span><span class="Comment"> * to derive approximate indexscan qual clauses, such that <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> tuples<br/></li>
<li></span><span class="Comment"> * that pass the operator clause itself must also satisfy the simpler<br/></li>
<li></span><span class="Comment"> * indexscan condition(s).&nbsp; Then we can use the indexscan machinery<br/></li>
<li></span><span class="Comment"> * to avoid scanning as much of the table as we'd otherwise have to,<br/></li>
<li></span><span class="Comment"> * while applying the original operator as a qpqual condition to ensure<br/></li>
<li></span><span class="Comment"> * we deliver only the tuples we want.&nbsp; (In essence, we're using a regular<br/></li>
<li></span><span class="Comment"> * index as if it were a lossy index.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * An example of what we're doing is<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; textfield LIKE 'abc%def'<br/></li>
<li></span><span class="Comment"> * from which we can generate the indexscanable conditions<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; textfield &gt;= 'abc' AND textfield &lt; 'abd'<br/></li>
<li></span><span class="Comment"> * which allow efficient scanning of an index on textfield.<br/></li>
<li></span><span class="Comment"> * (In reality, character set and collation issues make the transformation<br/></li>
<li></span><span class="Comment"> * from LIKE to indexscan limits rather harder than one might think ...<br/></li>
<li></span><span class="Comment"> * but that's the basic idea.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/adt/like_support.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;math.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_collation.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_operator.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_opfamily.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_statistic.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;mb/pg_wchar.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/makefuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/nodeFuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/supportnodes.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/datum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/pg_locale.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/selfuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/varlena.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Type">typedef</span> <span class="Type">enum<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; Pattern_Type_Like,<br/></li>
<li>&nbsp; &nbsp; Pattern_Type_Like_IC,<br/></li>
<li>&nbsp; &nbsp; Pattern_Type_Regex,<br/></li>
<li>&nbsp; &nbsp; Pattern_Type_Regex_IC,<br/></li>
<li>&nbsp; &nbsp; Pattern_Type_Prefix,<br/></li>
<li><a id="L65">&#x200c;</a>} <span class="linkable">Pattern_Type</span>;<br/></li>
<li><br/></li>
<li><span class="Type">typedef</span> <span class="Type">enum<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; Pattern_Prefix_None, Pattern_Prefix_Partial, Pattern_Prefix_Exact,<br/></li>
<li><a id="L70">&#x200c;</a>} <span class="linkable">Pattern_Prefix_Status</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> Node *<a href="#L156" title="utils/adt/like_support.c:156">like_regex_support</a>(Node *rawreq, <a href="#L65" title="utils/adt/like_support.c:65">Pattern_Type</a> ptype);<br/></li>
<li><span class="Type">static</span> List *<a href="#L241" title="utils/adt/like_support.c:241">match_pattern_prefix</a>(Node *leftop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node *rightop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L65" title="utils/adt/like_support.c:65">Pattern_Type</a> ptype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid expr_coll,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid opfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid indexcollation);<br/></li>
<li><span class="Type">static</span> <span class="Type">double</span> <a href="#L486" title="utils/adt/like_support.c:486">patternsel_common</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid <a href="../../parser/parse_oper.c.html#L238" title="parser/parse_oper.c:238">oprid</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid opfuncid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *args,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> varRelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L65" title="utils/adt/like_support.c:65">Pattern_Type</a> ptype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> negate);<br/></li>
<li><span class="Type">static</span> <a href="#L70" title="utils/adt/like_support.c:70">Pattern_Prefix_Status</a> <a href="#L1167" title="utils/adt/like_support.c:1167">pattern_fixed_prefix</a>(Const *patt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L65" title="utils/adt/like_support.c:65">Pattern_Type</a> ptype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Const **prefix,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Selectivity *rest_selec);<br/></li>
<li><span class="Type">static</span> Selectivity <a href="#L1232" title="utils/adt/like_support.c:1232">prefix_selectivity</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VariableStatData *vardata,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid eqopr, Oid ltopr, Oid geopr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Const *prefixcon);<br/></li>
<li><span class="Type">static</span> Selectivity <a href="#L1323" title="utils/adt/like_support.c:1323">like_selectivity</a>(<span class="Type">const</span> <span class="Type">char</span> *patt, <span class="Type">int</span> pattlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> case_insensitive);<br/></li>
<li><span class="Type">static</span> Selectivity <a href="#L1455" title="utils/adt/like_support.c:1455">regex_selectivity</a>(<span class="Type">const</span> <span class="Type">char</span> *patt, <span class="Type">int</span> pattlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> case_insensitive,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> fixed_prefix_len);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1501" title="utils/adt/like_support.c:1501">pattern_char_isalpha</a>(<span class="Type">char</span> c, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_multibyte,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pg_locale_t locale, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> locale_is_c);<br/></li>
<li><span class="Type">static</span> Const *<a href="#L1573" title="utils/adt/like_support.c:1573">make_greater_string</a>(<span class="Type">const</span> Const *str_const, FmgrInfo *ltproc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid collation);<br/></li>
<li><span class="Type">static</span> Datum <a href="#L1724" title="utils/adt/like_support.c:1724">string_to_datum</a>(<span class="Type">const</span> <span class="Type">char</span> *str, Oid datatype);<br/></li>
<li><span class="Type">static</span> Const *<a href="#L1744" title="utils/adt/like_support.c:1744">string_to_const</a>(<span class="Type">const</span> <span class="Type">char</span> *str, Oid datatype);<br/></li>
<li><span class="Type">static</span> Const *<a href="#L1787" title="utils/adt/like_support.c:1787">string_to_bytea_const</a>(<span class="Type">const</span> <span class="Type">char</span> *str, <span class="Type">size_t</span> str_len);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Planner support <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for LIKE, regex, and related operators<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L115">&#x200c;</a><span class="linkable">textlike_support</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *rawreq = (Node *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(<a href="#L156" title="utils/adt/like_support.c:156">like_regex_support</a>(rawreq, Pattern_Type_Like));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L123">&#x200c;</a><span class="linkable">texticlike_support</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *rawreq = (Node *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(<a href="#L156" title="utils/adt/like_support.c:156">like_regex_support</a>(rawreq, Pattern_Type_Like_IC));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L131">&#x200c;</a><span class="linkable">textregexeq_support</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *rawreq = (Node *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(<a href="#L156" title="utils/adt/like_support.c:156">like_regex_support</a>(rawreq, Pattern_Type_Regex));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L139">&#x200c;</a><span class="linkable">texticregexeq_support</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *rawreq = (Node *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(<a href="#L156" title="utils/adt/like_support.c:156">like_regex_support</a>(rawreq, Pattern_Type_Regex_IC));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L147">&#x200c;</a><span class="linkable">text_starts_with_support</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *rawreq = (Node *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(<a href="#L156" title="utils/adt/like_support.c:156">like_regex_support</a>(rawreq, Pattern_Type_Prefix));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Common code for the above */<br/></li>
<li></span><span class="Type">static</span> Node *<br/></li>
<li><a id="L156">&#x200c;</a><span class="linkable">like_regex_support</span>(Node *rawreq, <a href="#L65" title="utils/adt/like_support.c:65">Pattern_Type</a> ptype)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *ret = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(rawreq, SupportRequestSelectivity))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make a selectivity estimate for a function call, just as we'd do if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the call was via the corresponding operator.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; SupportRequestSelectivity *req = (SupportRequestSelectivity *) rawreq;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Selectivity s1;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (req-&gt;is_join)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For the moment we just punt.&nbsp; If <a href="#L875" title="utils/adt/like_support.c:875">patternjoinsel</a> is ever<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * improved to do better, this should be made to call it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s1 = DEFAULT_MATCH_SEL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Share code with operator restriction selectivity <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s1 = <a href="#L486" title="utils/adt/like_support.c:486">patternsel_common</a>(req-&gt;root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; req-&gt;funcid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; req-&gt;args,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; req-&gt;varRelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; req-&gt;inputcollid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ptype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; req-&gt;selectivity = s1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ret = (Node *) req;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(rawreq, SupportRequestIndexCondition))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Try to convert operator/function call to index conditions */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; SupportRequestIndexCondition *req = (SupportRequestIndexCondition *) rawreq;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Currently we have no &quot;reverse&quot; match operators with the pattern on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the left, so we only need consider cases with the indexkey on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * left.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (req-&gt;indexarg != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (is_opclause(req-&gt;node))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OpExpr&nbsp; &nbsp; &nbsp;&nbsp; *clause = (OpExpr *) req-&gt;node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(list_length(clause-&gt;args) == <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret = (Node *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L241" title="utils/adt/like_support.c:241">match_pattern_prefix</a>((Node *) linitial(clause-&gt;args),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Node *) lsecond(clause-&gt;args),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ptype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; clause-&gt;inputcollid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; req-&gt;opfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; req-&gt;indexcollation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (is_funcclause(req-&gt;node))&nbsp; &nbsp; <span class="Comment">/* be paranoid */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FuncExpr&nbsp;&nbsp; *clause = (FuncExpr *) req-&gt;node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(list_length(clause-&gt;args) == <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret = (Node *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L241" title="utils/adt/like_support.c:241">match_pattern_prefix</a>((Node *) linitial(clause-&gt;args),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Node *) lsecond(clause-&gt;args),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ptype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; clause-&gt;inputcollid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; req-&gt;opfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; req-&gt;indexcollation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ret;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L241" title="utils/adt/like_support.c:241">match_pattern_prefix</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Try to generate an indexqual for a LIKE or regex operator.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L241">&#x200c;</a><span class="linkable">match_pattern_prefix</span>(Node *leftop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Node *rightop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L65" title="utils/adt/like_support.c:65">Pattern_Type</a> ptype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid expr_coll,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid opfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid indexcollation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; Const&nbsp; &nbsp; &nbsp;&nbsp; *patt;<br/></li>
<li>&nbsp; &nbsp; Const&nbsp; &nbsp; &nbsp;&nbsp; *prefix;<br/></li>
<li>&nbsp; &nbsp; <a href="#L70" title="utils/adt/like_support.c:70">Pattern_Prefix_Status</a> pstatus;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ldatatype;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rdatatype;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eqopr;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ltopr;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; geopr;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; preopr = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; collation_aware;<br/></li>
<li>&nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *expr;<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; ltproc;<br/></li>
<li>&nbsp; &nbsp; Const&nbsp; &nbsp; &nbsp;&nbsp; *greaterstr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Can't do anything with a non-constant or NULL pattern argument.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that since we restrict ourselves to cases with a hard constant on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the RHS, it's a-fortiori a pseudoconstant, and we don't need to worry<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * about verifying that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!IsA(rightop, Const) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ((Const *) rightop)-&gt;constisnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;<br/></li>
<li>&nbsp; &nbsp; patt = (Const *) rightop;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Not supported if the expression collation is nondeterministic.&nbsp; The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * optimized equality or prefix tests use bytewise comparisons, which is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not consistent with nondeterministic collations.&nbsp; The actual<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pattern-matching implementation <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> will later error out that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pattern-matching is not supported with nondeterministic collations. (We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * could also error out here, but by doing it later we get more precise<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * error messages.)&nbsp; (It should be possible to support at least<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Pattern_Prefix_Exact, but no point as long as the actual<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pattern-matching implementations don't support it.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * expr_coll is not set for a non-collation-aware data type such as bytea.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (expr_coll &amp;&amp; !<a href="../cache/lsyscache.c.html#L1054" title="utils/cache/lsyscache.c:1054">get_collation_isdeterministic</a>(expr_coll))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Try to extract a fixed prefix from the pattern.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pstatus = <a href="#L1167" title="utils/adt/like_support.c:1167">pattern_fixed_prefix</a>(patt, ptype, expr_coll,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;prefix, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fail if no fixed prefix */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pstatus == Pattern_Prefix_None)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Identify the operators we want to use, based on the type of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * left-hand argument.&nbsp; Usually these are just the type's regular<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * comparison operators, but if we are considering one of the semi-legacy<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &quot;pattern&quot; opclasses, use the &quot;pattern&quot; operators instead.&nbsp; Those are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not collation-sensitive but always use C collation, as we want.&nbsp; The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * selected operators also determine the needed type of the prefix<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * constant.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ldatatype = <a href="../../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>(leftop);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (ldatatype)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TEXTOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (opfamily == TEXT_PATTERN_BTREE_FAM_OID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eqopr = TextEqualOperator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ltopr = TextPatternLessOperator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; geopr = TextPatternGreaterEqualOperator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collation_aware = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (opfamily == TEXT_SPGIST_FAM_OID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eqopr = TextEqualOperator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ltopr = TextPatternLessOperator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; geopr = TextPatternGreaterEqualOperator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This opfamily has direct support for prefixing */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; preopr = TextPrefixOperator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collation_aware = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eqopr = TextEqualOperator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ltopr = TextLessOperator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; geopr = TextGreaterEqualOperator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collation_aware = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rdatatype = TEXTOID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> NAMEOID:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that here, we need the RHS type to be text, so that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * comparison value isn't improperly truncated to NAMEDATALEN.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eqopr = NameEqualTextOperator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ltopr = NameLessTextOperator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; geopr = NameGreaterEqualTextOperator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collation_aware = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rdatatype = TEXTOID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BPCHAROID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (opfamily == BPCHAR_PATTERN_BTREE_FAM_OID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eqopr = BpcharEqualOperator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ltopr = BpcharPatternLessOperator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; geopr = BpcharPatternGreaterEqualOperator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collation_aware = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eqopr = BpcharEqualOperator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ltopr = BpcharLessOperator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; geopr = BpcharGreaterEqualOperator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collation_aware = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rdatatype = BPCHAROID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BYTEAOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eqopr = ByteaEqualOperator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ltopr = ByteaLessOperator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; geopr = ByteaGreaterEqualOperator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collation_aware = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rdatatype = BYTEAOID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Can't get here unless we're attached to the wrong operator */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If necessary, coerce the prefix constant to the right type.&nbsp; The given<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * prefix constant is either text or bytea type, therefore the only case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * where we need to do anything is when converting text to <a href="varchar.c.html#L271" title="utils/adt/varchar.c:271">bpchar</a>.&nbsp; Those<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * two types are binary-compatible, so relabeling the Const node is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sufficient.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (prefix-&gt;consttype != rdatatype)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(prefix-&gt;consttype == TEXTOID &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rdatatype == BPCHAROID);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prefix-&gt;consttype = rdatatype;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we found an exact-match pattern, generate an &quot;=&quot; indexqual.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Here and below, check to see whether the desired operator is actually<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * supported by the index opclass, and fail quietly if not.&nbsp; This allows<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * us to not be concerned with specific opclasses (except for the legacy<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &quot;pattern&quot; cases); <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> index that correctly implements the operators<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will work.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pstatus == Pattern_Prefix_Exact)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../cache/lsyscache.c.html#L66" title="utils/cache/lsyscache.c:66">op_in_opfamily</a>(eqopr, opfamily))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; expr = <a href="../../nodes/makefuncs.c.html#L628" title="nodes/makefuncs.c:628">make_opclause</a>(eqopr, BOOLOID, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Expr *) leftop, (Expr *) prefix,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid, indexcollation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = list_make1(expr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Otherwise, we have a nonempty required prefix of the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.&nbsp; Some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * opclasses support prefix checks directly, otherwise we'll try to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * generate a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> constraint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(preopr) &amp;&amp; <a href="../cache/lsyscache.c.html#L66" title="utils/cache/lsyscache.c:66">op_in_opfamily</a>(preopr, opfamily))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; expr = <a href="../../nodes/makefuncs.c.html#L628" title="nodes/makefuncs.c:628">make_opclause</a>(preopr, BOOLOID, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Expr *) leftop, (Expr *) prefix,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid, indexcollation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = list_make1(expr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since we need a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> constraint, it's only going to work reliably if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the index is collation-insensitive or has &quot;C&quot; collation.&nbsp; Note that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * here we are looking at the index's collation, not the expression's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * collation -- this test is *not* dependent on the LIKE/regex operator's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * collation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (collation_aware &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="pg_locale.c.html#L1317" title="utils/adt/pg_locale.c:1317">lc_collate_is_c</a>(indexcollation))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can always say &quot;x &gt;= prefix&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../cache/lsyscache.c.html#L66" title="utils/cache/lsyscache.c:66">op_in_opfamily</a>(geopr, opfamily))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;<br/></li>
<li>&nbsp; &nbsp; expr = <a href="../../nodes/makefuncs.c.html#L628" title="nodes/makefuncs.c:628">make_opclause</a>(geopr, BOOLOID, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Expr *) leftop, (Expr *) prefix,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid, indexcollation);<br/></li>
<li>&nbsp; &nbsp; result = list_make1(expr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*-------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we can create a string larger than the prefix, we can say<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &quot;x &lt; greaterstr&quot;.&nbsp; NB: we rely on <a href="#L1573" title="utils/adt/like_support.c:1573">make_greater_string</a>() to generate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a guaranteed-greater string, not just a probably-greater string.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In general this is only guaranteed in C locale, so we'd better be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * using a C-locale index collation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *-------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../cache/lsyscache.c.html#L66" title="utils/cache/lsyscache.c:66">op_in_opfamily</a>(ltopr, opfamily))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; <a href="../fmgr/fmgr.c.html#L127" title="utils/fmgr/fmgr.c:127">fmgr_info</a>(<a href="../cache/lsyscache.c.html#L1285" title="utils/cache/lsyscache.c:1285">get_opcode</a>(ltopr), &amp;ltproc);<br/></li>
<li>&nbsp; &nbsp; greaterstr = <a href="#L1573" title="utils/adt/like_support.c:1573">make_greater_string</a>(prefix, &amp;ltproc, indexcollation);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (greaterstr)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; expr = <a href="../../nodes/makefuncs.c.html#L628" title="nodes/makefuncs.c:628">make_opclause</a>(ltopr, BOOLOID, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Expr *) leftop, (Expr *) greaterstr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid, indexcollation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(result, expr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L486" title="utils/adt/like_support.c:486">patternsel_common</a> - generic code for pattern-match restriction selectivity.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To support using this from either the operator or function paths, caller<br/></li>
<li></span><span class="Comment"> * may pass either operator OID or underlying function OID; we look up the<br/></li>
<li></span><span class="Comment"> * latter from the former if needed.&nbsp; (We could just have <a href="#L760" title="utils/adt/like_support.c:760">patternsel</a>() call<br/></li>
<li></span><span class="Comment"> * <a href="../cache/lsyscache.c.html#L1285" title="utils/cache/lsyscache.c:1285">get_opcode</a>(), but the work would be wasted if we don't have a need to<br/></li>
<li></span><span class="Comment"> * <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> a fixed prefix to the pg_statistic data.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that <a href="../../parser/parse_oper.c.html#L238" title="parser/parse_oper.c:238">oprid</a> and/or opfuncid should be for the positive-match operator<br/></li>
<li></span><span class="Comment"> * even when negate is true.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">double<br/></li>
<li><a id="L486">&#x200c;</a></span><span class="linkable">patternsel_common</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid <a href="../../parser/parse_oper.c.html#L238" title="parser/parse_oper.c:238">oprid</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid opfuncid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *args,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> varRelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L65" title="utils/adt/like_support.c:65">Pattern_Type</a> ptype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> negate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; VariableStatData vardata;<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *other;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; varonleft;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; constval;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; consttype;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vartype;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rdatatype;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eqopr;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ltopr;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; geopr;<br/></li>
<li>&nbsp; &nbsp; <a href="#L70" title="utils/adt/like_support.c:70">Pattern_Prefix_Status</a> pstatus;<br/></li>
<li>&nbsp; &nbsp; Const&nbsp; &nbsp; &nbsp;&nbsp; *patt;<br/></li>
<li>&nbsp; &nbsp; Const&nbsp; &nbsp; &nbsp;&nbsp; *prefix = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; Selectivity rest_selec = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; nullfrac = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize result to the appropriate default estimate depending on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * whether it's a match or not-match operator.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (negate)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">1.0</span> - DEFAULT_MATCH_SEL;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = DEFAULT_MATCH_SEL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If expression is not variable op constant, then punt and return the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * default estimate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="selfuncs.c.html#L4883" title="utils/adt/selfuncs.c:4883">get_restriction_variable</a>(root, args, varRelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;vardata, &amp;other, &amp;varonleft))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!varonleft || !IsA(other, Const))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ReleaseVariableStats(vardata);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the constant is NULL, assume operator is strict and return zero, ie,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operator will never return TRUE.&nbsp; (It's zero even for a negator op.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (((Const *) other)-&gt;constisnull)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ReleaseVariableStats(vardata);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; constval = ((Const *) other)-&gt;constvalue;<br/></li>
<li>&nbsp; &nbsp; consttype = ((Const *) other)-&gt;consttype;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The right-hand const is type text or bytea for all supported operators.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We do not expect to see binary-compatible types here, since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * const-folding should have relabeled the const to exactly match the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operator's declared type.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (consttype != TEXTOID &amp;&amp; consttype != BYTEAOID)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ReleaseVariableStats(vardata);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Similarly, the exposed type of the left-hand side should be one of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * those we know.&nbsp; (Do not look at vardata.atttype, which might be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * something binary-compatible but different.)&nbsp; &nbsp; We can use it to identify<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the comparison operators and the required type of the comparison<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * constant, much as in <a href="#L241" title="utils/adt/like_support.c:241">match_pattern_prefix</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; vartype = vardata.vartype;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (vartype)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TEXTOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eqopr = TextEqualOperator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ltopr = TextLessOperator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; geopr = TextGreaterEqualOperator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rdatatype = TEXTOID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> NAMEOID:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that here, we need the RHS type to be text, so that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * comparison value isn't improperly truncated to NAMEDATALEN.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eqopr = NameEqualTextOperator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ltopr = NameLessTextOperator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; geopr = NameGreaterEqualTextOperator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rdatatype = TEXTOID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BPCHAROID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eqopr = BpcharEqualOperator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ltopr = BpcharLessOperator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; geopr = BpcharGreaterEqualOperator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rdatatype = BPCHAROID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BYTEAOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eqopr = ByteaEqualOperator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ltopr = ByteaLessOperator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; geopr = ByteaGreaterEqualOperator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rdatatype = BYTEAOID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Can't get here unless we're attached to the wrong operator */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReleaseVariableStats(vardata);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Grab the nullfrac for use below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(vardata.statsTuple))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_statistic stats;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stats = (Form_pg_statistic) GETSTRUCT(vardata.statsTuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nullfrac = stats-&gt;stanullfrac;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Pull out <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> fixed prefix implied by the pattern, and estimate the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fractional selectivity of the remainder of the pattern.&nbsp; Unlike many<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * other selectivity estimators, we use the pattern operator's actual<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * collation for this step.&nbsp; This is not because we expect the collation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to make a big difference in the selectivity estimate (it seldom would),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but because we want to be sure we cache compiled regexps under the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * right cache key, so that they can be re-used at runtime.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; patt = (Const *) other;<br/></li>
<li>&nbsp; &nbsp; pstatus = <a href="#L1167" title="utils/adt/like_support.c:1167">pattern_fixed_prefix</a>(patt, ptype, collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;prefix, &amp;rest_selec);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If necessary, coerce the prefix constant to the right type.&nbsp; The only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * case where we need to do anything is when converting text to <a href="varchar.c.html#L271" title="utils/adt/varchar.c:271">bpchar</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Those two types are binary-compatible, so relabeling the Const node is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sufficient.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (prefix &amp;&amp; prefix-&gt;consttype != rdatatype)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(prefix-&gt;consttype == TEXTOID &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rdatatype == BPCHAROID);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prefix-&gt;consttype = rdatatype;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pstatus == Pattern_Prefix_Exact)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Pattern specifies an exact match, so estimate as for '='<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="selfuncs.c.html#L295" title="utils/adt/selfuncs.c:295">var_eq_const</a>(&amp;vardata, eqopr, collation, prefix-&gt;constvalue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>, <span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Not exact-match pattern.&nbsp; If we have a sufficiently large<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * histogram, estimate selectivity for the histogram part of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * population by counting matches in the histogram.&nbsp; If not, estimate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * selectivity of the fixed prefix and remainder of pattern<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * separately, then <a href="../../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> the two to get an estimate of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * selectivity for the part of the column population represented by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the histogram.&nbsp; (For small histograms, we <a href="../../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> these<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * approaches.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We then add up data for <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> most-common-<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>; these are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not in the histogram population, and we can get exact answers for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * them by applying the pattern operator, so there's no reason to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * approximate.&nbsp; (If the MCVs cover a significant part of the total<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * population, this gives us a big leg up in accuracy.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Selectivity selec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hist_size;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; opproc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; mcv_selec,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sumcommon;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Try to use the histogram entries to get selectivity */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(opfuncid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opfuncid = <a href="../cache/lsyscache.c.html#L1285" title="utils/cache/lsyscache.c:1285">get_opcode</a>(<a href="../../parser/parse_oper.c.html#L238" title="parser/parse_oper.c:238">oprid</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../fmgr/fmgr.c.html#L127" title="utils/fmgr/fmgr.c:127">fmgr_info</a>(opfuncid, &amp;opproc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; selec = <a href="selfuncs.c.html#L823" title="utils/adt/selfuncs.c:823">histogram_selectivity</a>(&amp;vardata, &amp;opproc, collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constval, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">10</span>, <span class="Constant">1</span>, &amp;hist_size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If not at least 100 entries, use the heuristic method */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hist_size &lt; <span class="Constant">100</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Selectivity heursel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Selectivity <a href="#L820" title="utils/adt/like_support.c:820">prefixsel</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pstatus == Pattern_Prefix_Partial)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L820" title="utils/adt/like_support.c:820">prefixsel</a> = <a href="#L1232" title="utils/adt/like_support.c:1232">prefix_selectivity</a>(root, &amp;vardata,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; eqopr, ltopr, geopr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; prefix);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L820" title="utils/adt/like_support.c:820">prefixsel</a> = <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; heursel = <a href="#L820" title="utils/adt/like_support.c:820">prefixsel</a> * rest_selec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (selec &lt; <span class="Constant">0</span>)&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fewer than 10 histogram entries? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = heursel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For histogram sizes from 10 to 100, we <a href="../../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * histogram and heuristic selectivities, putting increasingly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * more trust in the histogram for larger sizes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; hist_weight = hist_size / <span class="Constant">100.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = selec * hist_weight + heursel * (<span class="Constant">1.0</span> - hist_weight);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* In <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case, don't believe extremely small or large estimates. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (selec &lt; <span class="Constant">0.0001</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = <span class="Constant">0.0001</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (selec &gt; <span class="Constant">0.9999</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = <span class="Constant">0.9999</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we have most-common-<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> info, add up the fractions of the MCV<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entries that satisfy MCV OP PATTERN.&nbsp; These fractions contribute<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * directly to the result selectivity.&nbsp; Also add up the total fraction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * represented by MCV entries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; mcv_selec = <a href="selfuncs.c.html#L732" title="utils/adt/selfuncs.c:732">mcv_selectivity</a>(&amp;vardata, &amp;opproc, collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constval, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;sumcommon);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> the results from the MCV and histogram calculations,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * realizing that the histogram covers only the non-null <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * are not listed in MCV.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; selec *= <span class="Constant">1.0</span> - nullfrac - sumcommon;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; selec += mcv_selec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = selec;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> adjust if we wanted not-match rather than match */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (negate)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">1.0</span> - result - nullfrac;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* result should be in <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, but make sure... */<br/></li>
<li></span>&nbsp; &nbsp; CLAMP_PROBABILITY(result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (prefix)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(DatumGetPointer(prefix-&gt;constvalue));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(prefix);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ReleaseVariableStats(vardata);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Fix impedance mismatch between SQL-callable <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> and <a href="#L486" title="utils/adt/like_support.c:486">patternsel_common</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">double<br/></li>
<li><a id="L760">&#x200c;</a></span><span class="linkable">patternsel</span>(PG_FUNCTION_ARGS, <a href="#L65" title="utils/adt/like_support.c:65">Pattern_Type</a> ptype, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> negate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; operator = PG_GETARG_OID(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *args = (List *) PG_GETARG_POINTER(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; varRelid = PG_GETARG_INT32(<span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collation = PG_GET_COLLATION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this is for a NOT LIKE or similar operator, get the corresponding<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * positive-match operator and work with that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (negate)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; operator = <a href="../cache/lsyscache.c.html#L1533" title="utils/cache/lsyscache.c:1533">get_negator</a>(operator);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(operator))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L760" title="utils/adt/like_support.c:760">patternsel</a> called for operator without a negator&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L486" title="utils/adt/like_support.c:486">patternsel_common</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; operator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; args,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; varRelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ptype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; negate);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L793" title="utils/adt/like_support.c:793">regexeqsel</a>&nbsp; &nbsp; &nbsp; &nbsp; - Selectivity of regular-expression pattern match.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L793">&#x200c;</a><span class="linkable">regexeqsel</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(<a href="#L760" title="utils/adt/like_support.c:760">patternsel</a>(fcinfo, Pattern_Type_Regex, <span class="Constant">false</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L802" title="utils/adt/like_support.c:802">icregexeqsel</a>&nbsp; &nbsp; - Selectivity of case-insensitive regex match.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L802">&#x200c;</a><span class="linkable">icregexeqsel</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(<a href="#L760" title="utils/adt/like_support.c:760">patternsel</a>(fcinfo, Pattern_Type_Regex_IC, <span class="Constant">false</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L811" title="utils/adt/like_support.c:811">likesel</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - Selectivity of LIKE pattern match.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L811">&#x200c;</a><span class="linkable">likesel</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(<a href="#L760" title="utils/adt/like_support.c:760">patternsel</a>(fcinfo, Pattern_Type_Like, <span class="Constant">false</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L820" title="utils/adt/like_support.c:820">prefixsel</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - selectivity of prefix operator<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L820">&#x200c;</a><span class="linkable">prefixsel</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(<a href="#L760" title="utils/adt/like_support.c:760">patternsel</a>(fcinfo, Pattern_Type_Prefix, <span class="Constant">false</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L830" title="utils/adt/like_support.c:830">iclikesel</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - Selectivity of ILIKE pattern match.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L830">&#x200c;</a><span class="linkable">iclikesel</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(<a href="#L760" title="utils/adt/like_support.c:760">patternsel</a>(fcinfo, Pattern_Type_Like_IC, <span class="Constant">false</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L839" title="utils/adt/like_support.c:839">regexnesel</a>&nbsp; &nbsp; &nbsp; &nbsp; - Selectivity of regular-expression pattern non-match.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L839">&#x200c;</a><span class="linkable">regexnesel</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(<a href="#L760" title="utils/adt/like_support.c:760">patternsel</a>(fcinfo, Pattern_Type_Regex, <span class="Constant">true</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L848" title="utils/adt/like_support.c:848">icregexnesel</a>&nbsp; &nbsp; - Selectivity of case-insensitive regex non-match.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L848">&#x200c;</a><span class="linkable">icregexnesel</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(<a href="#L760" title="utils/adt/like_support.c:760">patternsel</a>(fcinfo, Pattern_Type_Regex_IC, <span class="Constant">true</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L857" title="utils/adt/like_support.c:857">nlikesel</a>&nbsp; &nbsp; &nbsp; &nbsp; - Selectivity of LIKE pattern non-match.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L857">&#x200c;</a><span class="linkable">nlikesel</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(<a href="#L760" title="utils/adt/like_support.c:760">patternsel</a>(fcinfo, Pattern_Type_Like, <span class="Constant">true</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L866" title="utils/adt/like_support.c:866">icnlikesel</a>&nbsp; &nbsp; &nbsp; &nbsp; - Selectivity of ILIKE pattern non-match.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L866">&#x200c;</a><span class="linkable">icnlikesel</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(<a href="#L760" title="utils/adt/like_support.c:760">patternsel</a>(fcinfo, Pattern_Type_Like_IC, <span class="Constant">true</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L875" title="utils/adt/like_support.c:875">patternjoinsel</a>&nbsp; &nbsp; &nbsp; &nbsp; - Generic code for pattern-match join selectivity.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">double<br/></li>
<li><a id="L875">&#x200c;</a></span><span class="linkable">patternjoinsel</span>(PG_FUNCTION_ARGS, <a href="#L65" title="utils/adt/like_support.c:65">Pattern_Type</a> ptype, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> negate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* For the moment we just punt. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> negate ? (<span class="Constant">1.0</span> - DEFAULT_MATCH_SEL) : DEFAULT_MATCH_SEL;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L885" title="utils/adt/like_support.c:885">regexeqjoinsel</a>&nbsp; &nbsp; - Join selectivity of regular-expression pattern match.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L885">&#x200c;</a><span class="linkable">regexeqjoinsel</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(<a href="#L875" title="utils/adt/like_support.c:875">patternjoinsel</a>(fcinfo, Pattern_Type_Regex, <span class="Constant">false</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L894" title="utils/adt/like_support.c:894">icregexeqjoinsel</a>&nbsp; &nbsp; - Join selectivity of case-insensitive regex match.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L894">&#x200c;</a><span class="linkable">icregexeqjoinsel</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(<a href="#L875" title="utils/adt/like_support.c:875">patternjoinsel</a>(fcinfo, Pattern_Type_Regex_IC, <span class="Constant">false</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L903" title="utils/adt/like_support.c:903">likejoinsel</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - Join selectivity of LIKE pattern match.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L903">&#x200c;</a><span class="linkable">likejoinsel</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(<a href="#L875" title="utils/adt/like_support.c:875">patternjoinsel</a>(fcinfo, Pattern_Type_Like, <span class="Constant">false</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L912" title="utils/adt/like_support.c:912">prefixjoinsel</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - Join selectivity of prefix operator<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L912">&#x200c;</a><span class="linkable">prefixjoinsel</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(<a href="#L875" title="utils/adt/like_support.c:875">patternjoinsel</a>(fcinfo, Pattern_Type_Prefix, <span class="Constant">false</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L921" title="utils/adt/like_support.c:921">iclikejoinsel</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - Join selectivity of ILIKE pattern match.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L921">&#x200c;</a><span class="linkable">iclikejoinsel</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(<a href="#L875" title="utils/adt/like_support.c:875">patternjoinsel</a>(fcinfo, Pattern_Type_Like_IC, <span class="Constant">false</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L930" title="utils/adt/like_support.c:930">regexnejoinsel</a>&nbsp; &nbsp; - Join selectivity of regex non-match.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L930">&#x200c;</a><span class="linkable">regexnejoinsel</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(<a href="#L875" title="utils/adt/like_support.c:875">patternjoinsel</a>(fcinfo, Pattern_Type_Regex, <span class="Constant">true</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L939" title="utils/adt/like_support.c:939">icregexnejoinsel</a>&nbsp; &nbsp; - Join selectivity of case-insensitive regex non-match.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L939">&#x200c;</a><span class="linkable">icregexnejoinsel</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(<a href="#L875" title="utils/adt/like_support.c:875">patternjoinsel</a>(fcinfo, Pattern_Type_Regex_IC, <span class="Constant">true</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L948" title="utils/adt/like_support.c:948">nlikejoinsel</a>&nbsp; &nbsp; &nbsp; &nbsp; - Join selectivity of LIKE pattern non-match.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L948">&#x200c;</a><span class="linkable">nlikejoinsel</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(<a href="#L875" title="utils/adt/like_support.c:875">patternjoinsel</a>(fcinfo, Pattern_Type_Like, <span class="Constant">true</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L957" title="utils/adt/like_support.c:957">icnlikejoinsel</a>&nbsp; &nbsp; &nbsp; &nbsp; - Join selectivity of ILIKE pattern non-match.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L957">&#x200c;</a><span class="linkable">icnlikejoinsel</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(<a href="#L875" title="utils/adt/like_support.c:875">patternjoinsel</a>(fcinfo, Pattern_Type_Like_IC, <span class="Constant">true</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Pattern analysis <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * These routines support analysis of LIKE and regular-expression patterns<br/></li>
<li></span><span class="Comment"> * by the <a href="../../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a>/optimizer.&nbsp; It's important that they agree with the<br/></li>
<li></span><span class="Comment"> * regular-expression code in backend/regex/ and the LIKE code in<br/></li>
<li></span><span class="Comment"> * backend/utils/adt/like.c.&nbsp; Also, the computation of the fixed prefix<br/></li>
<li></span><span class="Comment"> * must be conservative: if we report a string longer than the true fixed<br/></li>
<li></span><span class="Comment"> * prefix, the query may produce actually wrong answers, rather than just<br/></li>
<li></span><span class="Comment"> * getting a bad selectivity estimate!<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Extract the fixed prefix, if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, for a pattern.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * *prefix is set to a <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d prefix string (in the form of a Const node),<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; or to NULL if no fixed prefix exists for the pattern.<br/></li>
<li></span><span class="Comment"> * If rest_selec is not NULL, *rest_selec is set to an estimate of the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; selectivity of the remainder of the pattern (without <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> fixed prefix).<br/></li>
<li></span><span class="Comment"> * The prefix Const has the same type (TEXT or BYTEA) as the input pattern.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The return value distinguishes no fixed prefix, a partial prefix,<br/></li>
<li></span><span class="Comment"> * or an exact-match-only pattern.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <a href="#L70" title="utils/adt/like_support.c:70">Pattern_Prefix_Status</a><br/></li>
<li><a id="L992">&#x200c;</a><span class="linkable">like_fixed_prefix</span>(Const *patt_const, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> case_insensitive, Oid collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Const **prefix_const, Selectivity *rest_selec)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *match;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *patt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pattlen;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typeid = patt_const-&gt;consttype;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; match_pos;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_multibyte = (<a href="../mb/mbutils.c.html#L1546" title="utils/mb/mbutils.c:1546">pg_database_encoding_max_length</a>() &gt; <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; pg_locale_t locale = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; locale_is_c = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* the right-hand const is type text or bytea */<br/></li>
<li></span>&nbsp; &nbsp; Assert(typeid == BYTEAOID || typeid == TEXTOID);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (case_insensitive)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typeid == BYTEAOID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;case insensitive matching not supported on type bytea&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(collation))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This typically means that the parser could not resolve a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * conflict of implicit collations, so report it that way.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INDETERMINATE_COLLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not determine which collation to use for ILIKE&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Use the COLLATE clause to set the collation explicitly.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If case-insensitive, we need locale info */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="pg_locale.c.html#L1384" title="utils/adt/pg_locale.c:1384">lc_ctype_is_c</a>(collation))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locale_is_c = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locale = <a href="pg_locale.c.html#L1551" title="utils/adt/pg_locale.c:1551">pg_newlocale_from_collation</a>(collation);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (typeid != BYTEAOID)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; patt = TextDatumGetCString(patt_const-&gt;constvalue);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pattlen = strlen(patt);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *bstr = DatumGetByteaPP(patt_const-&gt;constvalue);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pattlen = VARSIZE_ANY_EXHDR(bstr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; patt = (<span class="Type">char</span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(pattlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(patt, VARDATA_ANY(bstr), pattlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert((Pointer) bstr == DatumGetPointer(patt_const-&gt;constvalue));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; match = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(pattlen + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; match_pos = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (pos = <span class="Constant">0</span>; pos &lt; pattlen; pos++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* % and <a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a> are wildcard characters in LIKE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (patt[pos] == <span class="Constant">'%'</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; patt[pos] == <span class="Constant">'<a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Backslash escapes the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> character */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (patt[pos] == <span class="Special">'\\'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pos++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pos &gt;= pattlen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Stop if case-varying character (it's sort of a wildcard) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (case_insensitive &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1501" title="utils/adt/like_support.c:1501">pattern_char_isalpha</a>(patt[pos], is_multibyte, locale, locale_is_c))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; match[match_pos++] = patt[pos];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; match[match_pos] = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (typeid != BYTEAOID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *prefix_const = <a href="#L1744" title="utils/adt/like_support.c:1744">string_to_const</a>(match, typeid);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *prefix_const = <a href="#L1787" title="utils/adt/like_support.c:1787">string_to_bytea_const</a>(match, match_pos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rest_selec != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *rest_selec = <a href="#L1323" title="utils/adt/like_support.c:1323">like_selectivity</a>(&amp;patt[pos], pattlen - pos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; case_insensitive);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(patt);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(match);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* in LIKE, an empty pattern is an exact match! */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pos == pattlen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> Pattern_Prefix_Exact;&nbsp; &nbsp; <span class="Comment">/* reached end of pattern, so exact */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (match_pos &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> Pattern_Prefix_Partial;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> Pattern_Prefix_None;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <a href="#L70" title="utils/adt/like_support.c:70">Pattern_Prefix_Status</a><br/></li>
<li><a id="L1099">&#x200c;</a><span class="linkable">regex_fixed_prefix</span>(Const *patt_const, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> case_insensitive, Oid collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Const **prefix_const, Selectivity *rest_selec)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typeid = patt_const-&gt;consttype;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *prefix;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; exact;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Should be unnecessary, there are no bytea regex operators defined. As<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * such, it should be noted that the rest of this function has *not* been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * made safe for binary (possibly NULL containing) strings.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (typeid == BYTEAOID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;regular-expression matching not supported on type bytea&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Use the regexp machinery to extract the prefix, if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; prefix = <a href="regexp.c.html#L1953" title="utils/adt/regexp.c:1953">regexp_fixed_prefix</a>(DatumGetTextPP(patt_const-&gt;constvalue),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; case_insensitive, collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;exact);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (prefix == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *prefix_const = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rest_selec != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *patt = TextDatumGetCString(patt_const-&gt;constvalue);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *rest_selec = <a href="#L1455" title="utils/adt/like_support.c:1455">regex_selectivity</a>(patt, strlen(patt),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case_insensitive,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(patt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> Pattern_Prefix_None;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *prefix_const = <a href="#L1744" title="utils/adt/like_support.c:1744">string_to_const</a>(prefix, typeid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rest_selec != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (exact)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Exact match, so there's no additional selectivity */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *rest_selec = <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *patt = TextDatumGetCString(patt_const-&gt;constvalue);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *rest_selec = <a href="#L1455" title="utils/adt/like_support.c:1455">regex_selectivity</a>(patt, strlen(patt),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case_insensitive,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strlen(prefix));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(patt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(prefix);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (exact)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> Pattern_Prefix_Exact;&nbsp; &nbsp; <span class="Comment">/* pattern specifies exact match */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> Pattern_Prefix_Partial;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <a href="#L70" title="utils/adt/like_support.c:70">Pattern_Prefix_Status</a><br/></li>
<li><a id="L1167">&#x200c;</a><span class="linkable">pattern_fixed_prefix</span>(Const *patt, <a href="#L65" title="utils/adt/like_support.c:65">Pattern_Type</a> ptype, Oid collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Const **prefix, Selectivity *rest_selec)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L70" title="utils/adt/like_support.c:70">Pattern_Prefix_Status</a> result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (ptype)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> Pattern_Type_Like:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L992" title="utils/adt/like_support.c:992">like_fixed_prefix</a>(patt, <span class="Constant">false</span>, collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; prefix, rest_selec);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> Pattern_Type_Like_IC:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L992" title="utils/adt/like_support.c:992">like_fixed_prefix</a>(patt, <span class="Constant">true</span>, collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; prefix, rest_selec);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> Pattern_Type_Regex:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L1099" title="utils/adt/like_support.c:1099">regex_fixed_prefix</a>(patt, <span class="Constant">false</span>, collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prefix, rest_selec);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> Pattern_Type_Regex_IC:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L1099" title="utils/adt/like_support.c:1099">regex_fixed_prefix</a>(patt, <span class="Constant">true</span>, collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prefix, rest_selec);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> Pattern_Type_Prefix:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Prefix type work is trivial.&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = Pattern_Prefix_Partial;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *prefix = <a href="../../nodes/makefuncs.c.html#L301" title="nodes/makefuncs.c:301">makeConst</a>(patt-&gt;consttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; patt-&gt;consttypmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; patt-&gt;constcollid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; patt-&gt;constlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="datum.c.html#L132" title="utils/adt/datum.c:132">datumCopy</a>(patt-&gt;constvalue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; patt-&gt;constbyval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; patt-&gt;constlen),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; patt-&gt;constisnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; patt-&gt;constbyval);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rest_selec != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *rest_selec = <span class="Constant">1.0</span>;&nbsp; &nbsp; <span class="Comment">/* all */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized ptype: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, (<span class="Type">int</span>) ptype);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = Pattern_Prefix_None;&nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Estimate the selectivity of a fixed prefix for a pattern match.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A fixed prefix &quot;foo&quot; is estimated as the selectivity of the expression<br/></li>
<li></span><span class="Comment"> * &quot;variable &gt;= 'foo' AND variable &lt; 'fop'&quot;.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The selectivity estimate is with respect to the portion of the column<br/></li>
<li></span><span class="Comment"> * population represented by the histogram --- the caller must fold this<br/></li>
<li></span><span class="Comment"> * together with info about MCVs and NULLs.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We use the given comparison operators and collation to do the estimation.<br/></li>
<li></span><span class="Comment"> * The given variable and Const must be of the associated datatype(s).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment"> Note: we make use of the <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound to estimate operator selectivity<br/></li>
<li></span><span class="Comment"> * even if the locale is such that we cannot rely on the <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-bound string.<br/></li>
<li></span><span class="Comment"> * The selectivity only needs to be approximately right anyway, so it seems<br/></li>
<li></span><span class="Comment"> * more useful to use the <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-bound code than not.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Selectivity<br/></li>
<li><a id="L1232">&#x200c;</a><span class="linkable">prefix_selectivity</span>(PlannerInfo *root, VariableStatData *vardata,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid eqopr, Oid ltopr, Oid geopr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Const *prefixcon)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Selectivity <a href="#L820" title="utils/adt/like_support.c:820">prefixsel</a>;<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; opproc;<br/></li>
<li>&nbsp; &nbsp; Const&nbsp; &nbsp; &nbsp;&nbsp; *greaterstrcon;<br/></li>
<li>&nbsp; &nbsp; Selectivity eq_sel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Estimate the selectivity of &quot;x &gt;= prefix&quot; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../fmgr/fmgr.c.html#L127" title="utils/fmgr/fmgr.c:127">fmgr_info</a>(<a href="../cache/lsyscache.c.html#L1285" title="utils/cache/lsyscache.c:1285">get_opcode</a>(geopr), &amp;opproc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L820" title="utils/adt/like_support.c:820">prefixsel</a> = <a href="selfuncs.c.html#L1041" title="utils/adt/selfuncs.c:1041">ineq_histogram_selectivity</a>(root, vardata,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; geopr, &amp;opproc, <span class="Constant">true</span>, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; prefixcon-&gt;constvalue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; prefixcon-&gt;consttype);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L820" title="utils/adt/like_support.c:820">prefixsel</a> &lt; <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No histogram is present ... return a suitable default estimate */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DEFAULT_MATCH_SEL;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we can create a string larger than the prefix, say &quot;x &lt; greaterstr&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../fmgr/fmgr.c.html#L127" title="utils/fmgr/fmgr.c:127">fmgr_info</a>(<a href="../cache/lsyscache.c.html#L1285" title="utils/cache/lsyscache.c:1285">get_opcode</a>(ltopr), &amp;opproc);<br/></li>
<li>&nbsp; &nbsp; greaterstrcon = <a href="#L1573" title="utils/adt/like_support.c:1573">make_greater_string</a>(prefixcon, &amp;opproc, collation);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (greaterstrcon)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Selectivity topsel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; topsel = <a href="selfuncs.c.html#L1041" title="utils/adt/selfuncs.c:1041">ineq_histogram_selectivity</a>(root, vardata,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ltopr, &amp;opproc, <span class="Constant">false</span>, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; greaterstrcon-&gt;constvalue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; greaterstrcon-&gt;consttype);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="selfuncs.c.html#L1041" title="utils/adt/selfuncs.c:1041">ineq_histogram_selectivity</a> worked <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>, it shouldn't fail <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(topsel &gt;= <span class="Constant">0.0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Merge the two selectivities in the same way as for a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> query<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (see <a href="../../optimizer/path/clausesel.c.html#L100" title="optimizer/path/clausesel.c:100">clauselist_selectivity</a>()).&nbsp; Note that we don't need to worry<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * about double-exclusion of nulls, since <a href="selfuncs.c.html#L1041" title="utils/adt/selfuncs.c:1041">ineq_histogram_selectivity</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * doesn't count those anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L820" title="utils/adt/like_support.c:820">prefixsel</a> = topsel + <a href="#L820" title="utils/adt/like_support.c:820">prefixsel</a> - <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the prefix is long then the two bounding <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> might be too close<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * together for the histogram to distinguish them usefully, resulting in a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * zero estimate (plus or minus roundoff error). To avoid returning a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ridiculously small estimate, compute the estimated selectivity for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &quot;variable = 'foo'&quot;, and clamp to that. (Obviously, the resultant<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * estimate should be at least that.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We apply this even if we couldn't make a greater string.&nbsp; That case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * suggests that the prefix is near the maximum possible, and thus<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * probably off the end of the histogram, and thus we probably got a very<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * small estimate from the &gt;= condition; so we still need to clamp.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; eq_sel = <a href="selfuncs.c.html#L295" title="utils/adt/selfuncs.c:295">var_eq_const</a>(vardata, eqopr, collation, prefixcon-&gt;constvalue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>, <span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L820" title="utils/adt/like_support.c:820">prefixsel</a> = Max(<a href="#L820" title="utils/adt/like_support.c:820">prefixsel</a>, eq_sel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L820" title="utils/adt/like_support.c:820">prefixsel</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Estimate the selectivity of a pattern of the specified type.<br/></li>
<li></span><span class="Comment"> * Note that <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> fixed prefix of the pattern will have been removed already,<br/></li>
<li></span><span class="Comment"> * so actually we may be looking at just a fragment of the pattern.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, we use a very simplistic approach: fixed characters reduce the<br/></li>
<li></span><span class="Comment"> * selectivity a good deal, character ranges reduce it a little,<br/></li>
<li></span><span class="Comment"> * wildcards (such as % for LIKE or .* for regex) increase it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><a id="L1316">&#x200c;</a><span class="PreProc">#define <span class="linkable">FIXED_CHAR_SEL</span>&nbsp; &nbsp; </span><span class="Constant">0.20</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* about 1/5 */<br/></li>
<li><a id="L1317">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">CHAR_RANGE_SEL</span>&nbsp; &nbsp; </span><span class="Constant">0.25<br/></li>
<li><a id="L1318">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ANY_CHAR_SEL</span>&nbsp; &nbsp; </span><span class="Constant">0.9</span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* not 1, since it won't match end-of-string */<br/></li>
<li><a id="L1319">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">FULL_WILDCARD_SEL</span> </span><span class="Constant">5.0<br/></li>
<li><a id="L1320">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PARTIAL_WILDCARD_SEL</span> </span><span class="Constant">2.0<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> Selectivity<br/></li>
<li><a id="L1323">&#x200c;</a><span class="linkable">like_selectivity</span>(<span class="Type">const</span> <span class="Type">char</span> *patt, <span class="Type">int</span> pattlen, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> case_insensitive)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Selectivity sel = <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Skip <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> leading wildcard; it's already factored into initial sel */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (pos = <span class="Constant">0</span>; pos &lt; pattlen; pos++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (patt[pos] != <span class="Constant">'%'</span> &amp;&amp; patt[pos] != <span class="Constant">'<a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (; pos &lt; pattlen; pos++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* % and <a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a> are wildcard characters in LIKE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (patt[pos] == <span class="Constant">'%'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sel *= <a href="#L1319" title="utils/adt/like_support.c:1319">FULL_WILDCARD_SEL</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (patt[pos] == <span class="Constant">'<a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sel *= <a href="#L1318" title="utils/adt/like_support.c:1318">ANY_CHAR_SEL</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (patt[pos] == <span class="Special">'\\'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Backslash quotes the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> character */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pos++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pos &gt;= pattlen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sel *= <a href="#L1316" title="utils/adt/like_support.c:1316">FIXED_CHAR_SEL</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sel *= <a href="#L1316" title="utils/adt/like_support.c:1316">FIXED_CHAR_SEL</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Could get sel &gt; 1 if multiple wildcards */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (sel &gt; <span class="Constant">1.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sel = <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> sel;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> Selectivity<br/></li>
<li><a id="L1360">&#x200c;</a><span class="linkable">regex_selectivity_sub</span>(<span class="Type">const</span> <span class="Type">char</span> *patt, <span class="Type">int</span> pattlen, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> case_insensitive)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Selectivity sel = <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paren_depth = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paren_pos = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* dummy init to keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* since this function recurses, it could be driven to stack overflow */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (pos = <span class="Constant">0</span>; pos &lt; pattlen; pos++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (patt[pos] == <span class="Constant">'('</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (paren_depth == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paren_pos = pos;&nbsp; &nbsp; <span class="Comment">/* remember start of parenthesized item */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paren_depth++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (patt[pos] == <span class="Constant">')'</span> &amp;&amp; paren_depth &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paren_depth--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (paren_depth == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sel *= <a href="#L1360" title="utils/adt/like_support.c:1360">regex_selectivity_sub</a>(patt + (paren_pos + <span class="Constant">1</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pos - (paren_pos + <span class="Constant">1</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; case_insensitive);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (patt[pos] == <span class="Constant">'|'</span> &amp;&amp; paren_depth == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If unquoted | is present at paren level 0 in pattern, we have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * multiple alternatives; sum their probabilities.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sel += <a href="#L1360" title="utils/adt/like_support.c:1360">regex_selectivity_sub</a>(patt + (pos + <span class="Constant">1</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pattlen - (pos + <span class="Constant">1</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; case_insensitive);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* rest of pattern is <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> processed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (patt[pos] == <span class="Constant">'['</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; negclass = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (patt[++pos] == <span class="Constant">'^'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; negclass = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pos++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (patt[pos] == <span class="Constant">']'</span>)&nbsp; &nbsp; <span class="Comment">/* ']' at start of class is not special */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pos++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (pos &lt; pattlen &amp;&amp; patt[pos] != <span class="Constant">']'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pos++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (paren_depth == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sel *= (negclass ? (<span class="Constant">1.0</span> - <a href="#L1317" title="utils/adt/like_support.c:1317">CHAR_RANGE_SEL</a>) : <a href="#L1317" title="utils/adt/like_support.c:1317">CHAR_RANGE_SEL</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (patt[pos] == <span class="Constant">'.'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (paren_depth == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sel *= <a href="#L1318" title="utils/adt/like_support.c:1318">ANY_CHAR_SEL</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (patt[pos] == <span class="Constant">'*'</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; patt[pos] == <span class="Constant">'?'</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; patt[pos] == <span class="Constant">'+'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ought to be smarter about quantifiers... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (paren_depth == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sel *= <a href="#L1320" title="utils/adt/like_support.c:1320">PARTIAL_WILDCARD_SEL</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (patt[pos] == <span class="Constant">'{'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (pos &lt; pattlen &amp;&amp; patt[pos] != <span class="Constant">'}'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pos++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (paren_depth == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sel *= <a href="#L1320" title="utils/adt/like_support.c:1320">PARTIAL_WILDCARD_SEL</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (patt[pos] == <span class="Special">'\\'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* backslash quotes the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> character */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pos++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pos &gt;= pattlen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (paren_depth == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sel *= <a href="#L1316" title="utils/adt/like_support.c:1316">FIXED_CHAR_SEL</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (paren_depth == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sel *= <a href="#L1316" title="utils/adt/like_support.c:1316">FIXED_CHAR_SEL</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Could get sel &gt; 1 if multiple wildcards */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (sel &gt; <span class="Constant">1.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sel = <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> sel;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> Selectivity<br/></li>
<li><a id="L1455">&#x200c;</a><span class="linkable">regex_selectivity</span>(<span class="Type">const</span> <span class="Type">char</span> *patt, <span class="Type">int</span> pattlen, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> case_insensitive,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> fixed_prefix_len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Selectivity sel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If patt doesn't end with $, consider it to have a trailing wildcard */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pattlen &gt; <span class="Constant">0</span> &amp;&amp; patt[pattlen - <span class="Constant">1</span>] == <span class="Constant">'$'</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (pattlen == <span class="Constant">1</span> || patt[pattlen - <span class="Constant">2</span>] != <span class="Special">'\\'</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* has trailing $ */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sel = <a href="#L1360" title="utils/adt/like_support.c:1360">regex_selectivity_sub</a>(patt, pattlen - <span class="Constant">1</span>, case_insensitive);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no trailing $ */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sel = <a href="#L1360" title="utils/adt/like_support.c:1360">regex_selectivity_sub</a>(patt, pattlen, case_insensitive);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sel *= <a href="#L1319" title="utils/adt/like_support.c:1319">FULL_WILDCARD_SEL</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there's a fixed prefix, discount its selectivity.&nbsp; We have to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * careful here since a very long prefix could result in pow's result<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * underflowing to zero (in which case &quot;sel&quot; probably has as well).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fixed_prefix_len &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L820" title="utils/adt/like_support.c:820">prefixsel</a> = pow(<a href="#L1316" title="utils/adt/like_support.c:1316">FIXED_CHAR_SEL</a>, fixed_prefix_len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L820" title="utils/adt/like_support.c:820">prefixsel</a> &gt; <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sel /= <a href="#L820" title="utils/adt/like_support.c:820">prefixsel</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure result stays in <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; CLAMP_PROBABILITY(sel);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> sel;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check whether char is a letter (and, hence, subject to case-folding)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In multibyte character sets or with ICU, we can't use isalpha, and it does<br/></li>
<li></span><span class="Comment"> * not seem worth trying to convert to wchar_t to use iswalpha or u_isalpha.<br/></li>
<li></span><span class="Comment"> * Instead, just assume <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> non-ASCII char is potentially case-varying, and<br/></li>
<li></span><span class="Comment"> * hard-wire knowledge of which ASCII chars are letters.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1501">&#x200c;</a></span><span class="linkable">pattern_char_isalpha</span>(<span class="Type">char</span> c, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_multibyte,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pg_locale_t locale, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> locale_is_c)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (locale_is_c)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (c &gt;= <span class="Constant">'A'</span> &amp;&amp; c &lt;= <span class="Constant">'Z'</span>) || (c &gt;= <span class="Constant">'a'</span> &amp;&amp; c &lt;= <span class="Constant">'z'</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (is_multibyte &amp;&amp; IS_HIGHBIT_SET(c))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (locale &amp;&amp; locale-&gt;<a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a> == COLLPROVIDER_ICU)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> IS_HIGHBIT_SET(c) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (c &gt;= <span class="Constant">'A'</span> &amp;&amp; c &lt;= <span class="Constant">'Z'</span>) || (c &gt;= <span class="Constant">'a'</span> &amp;&amp; c &lt;= <span class="Constant">'z'</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (locale &amp;&amp; locale-&gt;<a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a> == COLLPROVIDER_LIBC)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> isalpha_l((<span class="Type">unsigned</span> <span class="Type">char</span>) c, locale-&gt;info.lt);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> isalpha((<span class="Type">unsigned</span> <span class="Type">char</span>) c);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * For bytea, the increment function need only increment the current byte<br/></li>
<li></span><span class="Comment"> * (there are no multibyte characters to worry about).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1523">&#x200c;</a></span><span class="linkable">byte_increment</span>(<span class="Type">unsigned</span> <span class="Type">char</span> *ptr, <span class="Type">int</span> len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*ptr &gt;= <span class="Constant">255</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; (*ptr)++;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Try to generate a string greater than the given string or <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * string it is a prefix of.&nbsp; If successful, return a <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d string<br/></li>
<li></span><span class="Comment"> * in the form of a Const node; else return NULL.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller must provide the appropriate &quot;less than&quot; comparison function<br/></li>
<li></span><span class="Comment"> * for testing the strings, along with the collation to use.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The key requirement here is that given a prefix string, say &quot;foo&quot;,<br/></li>
<li></span><span class="Comment"> * we must be able to generate another string &quot;fop&quot; that is greater than<br/></li>
<li></span><span class="Comment"> * all strings &quot;foobar&quot; starting with &quot;foo&quot;.&nbsp; We can test that we have<br/></li>
<li></span><span class="Comment"> * generated a string greater than the prefix string, but in non-C collations<br/></li>
<li></span><span class="Comment"> * that is not a bulletproof guarantee that an extension of the string might<br/></li>
<li></span><span class="Comment"> * not sort after it; an example is that &quot;foo &quot; is less than &quot;foo!&quot;, but it<br/></li>
<li></span><span class="Comment"> * is not clear that a &quot;dictionary&quot; sort ordering will consider &quot;foo!&quot; less<br/></li>
<li></span><span class="Comment"> * than &quot;foo bar&quot;.&nbsp; CAUTION: Therefore, this function should be used only for<br/></li>
<li></span><span class="Comment"> * estimation purposes when working in a non-C collation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To try to catch most cases where an extended string might otherwise sort<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the result value, we determine which of the strings &quot;Z&quot;, &quot;z&quot;, &quot;y&quot;,<br/></li>
<li></span><span class="Comment"> * and &quot;9&quot; is seen as largest by the collation, and append that to the given<br/></li>
<li></span><span class="Comment"> * prefix <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> trying to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a string that compares as larger.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To search for a greater string, we repeatedly &quot;increment&quot; the rightmost<br/></li>
<li></span><span class="Comment"> * character, using an encoding-specific character incrementer function.<br/></li>
<li></span><span class="Comment"> * When it's no longer possible to increment the last character, we truncate<br/></li>
<li></span><span class="Comment"> * off that character and start incrementing the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>-to-rightmost.<br/></li>
<li></span><span class="Comment"> * For example, if &quot;z&quot; were the last character in the sort order, then we<br/></li>
<li></span><span class="Comment"> * could produce &quot;foo&quot; as a string greater than &quot;fonz&quot;.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This could be rather slow in the worst case, but in most cases we<br/></li>
<li></span><span class="Comment"> * won't have to try more than one or two strings <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> succeeding.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that it's important for the character incrementer not to be too anal<br/></li>
<li></span><span class="Comment"> * about producing every possible character code, since in some cases the only<br/></li>
<li></span><span class="Comment"> * way to get a larger string is to increment a previous character position.<br/></li>
<li></span><span class="Comment"> * So we don't want to spend too much time trying every possible character<br/></li>
<li></span><span class="Comment"> * code at the last position.&nbsp; A good rule of thumb is to be sure that we<br/></li>
<li></span><span class="Comment"> * don't try more than 256*K <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for a K-byte character (and definitely<br/></li>
<li></span><span class="Comment"> * not 256^K, which is what an exhaustive search would approach).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Const *<br/></li>
<li><a id="L1573">&#x200c;</a><span class="linkable">make_greater_string</span>(<span class="Type">const</span> Const *str_const, FmgrInfo *ltproc, Oid collation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datatype = str_const-&gt;consttype;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *workstr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; cmpstr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *cmptxt = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; mbcharacter_incrementer charinc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get a modifiable copy of the prefix string in C-string format, and set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * up the string we will <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> to as a Datum.&nbsp; In C locale this can just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be the given prefix string, otherwise we need to add a suffix.&nbsp; Type<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * BYTEA sorts bytewise so it never needs a suffix either.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (datatype == BYTEAOID)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *bstr = DatumGetByteaPP(str_const-&gt;constvalue);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len = VARSIZE_ANY_EXHDR(bstr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; workstr = (<span class="Type">char</span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(workstr, VARDATA_ANY(bstr), len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert((Pointer) bstr == DatumGetPointer(str_const-&gt;constvalue));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cmpstr = str_const-&gt;constvalue;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (datatype == NAMEOID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; workstr = DatumGetCString(DirectFunctionCall1(<a href="name.c.html#L71" title="utils/adt/name.c:71">nameout</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str_const-&gt;constvalue));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; workstr = TextDatumGetCString(str_const-&gt;constvalue);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len = strlen(workstr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="pg_locale.c.html#L1317" title="utils/adt/pg_locale.c:1317">lc_collate_is_c</a>(collation) || len == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmpstr = str_const-&gt;constvalue;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If first time through, determine the suffix to use */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">static</span> <span class="Type">char</span> suffixchar = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">static</span> Oid&nbsp; &nbsp; suffixcollation = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!suffixchar || suffixcollation != collation)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *best;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best = <span class="Constant">&quot;Z&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="varlena.c.html#L1539" title="utils/adt/varlena.c:1539">varstr_cmp</a>(best, <span class="Constant">1</span>, <span class="Constant">&quot;z&quot;</span>, <span class="Constant">1</span>, collation) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best = <span class="Constant">&quot;z&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="varlena.c.html#L1539" title="utils/adt/varlena.c:1539">varstr_cmp</a>(best, <span class="Constant">1</span>, <span class="Constant">&quot;y&quot;</span>, <span class="Constant">1</span>, collation) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best = <span class="Constant">&quot;y&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="varlena.c.html#L1539" title="utils/adt/varlena.c:1539">varstr_cmp</a>(best, <span class="Constant">1</span>, <span class="Constant">&quot;9&quot;</span>, <span class="Constant">1</span>, collation) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best = <span class="Constant">&quot;9&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; suffixchar = *best;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; suffixcollation = collation;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* And build the string to <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> to */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (datatype == NAMEOID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmptxt = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(len + <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(cmptxt, workstr, len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmptxt[len] = suffixchar;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmptxt[len + <span class="Constant">1</span>] = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmpstr = PointerGetDatum(cmptxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmptxt = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(VARHDRSZ + len + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_VARSIZE(cmptxt, VARHDRSZ + len + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(VARDATA(cmptxt), workstr, len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *(VARDATA(cmptxt) + len) = suffixchar;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmpstr = PointerGetDatum(cmptxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Select appropriate character-incrementer function */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (datatype == BYTEAOID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; charinc = <a href="#L1523" title="utils/adt/like_support.c:1523">byte_increment</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; charinc = <a href="../mb/mbutils.c.html#L1523" title="utils/mb/mbutils.c:1523">pg_database_encoding_character_incrementer</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And search ... */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (len &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; charlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> *lastchar;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Identify the last character --- for bytea, just the last byte */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (datatype == BYTEAOID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; charlen = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; charlen = len - <a href="../mb/mbutils.c.html#L1083" title="utils/mb/mbutils.c:1083">pg_mbcliplen</a>(workstr, len, len - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lastchar = (<span class="Type">unsigned</span> <span class="Type">char</span> *) (workstr + len - charlen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Try to generate a larger string by incrementing the last character<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (for BYTEA, we treat each byte as a character).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: the incrementer function is expected to return true if it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * generated a valid-per-the-encoding new character, otherwise false.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The contents of the character on false return are unspecified.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (charinc(lastchar, charlen))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Const&nbsp; &nbsp; &nbsp;&nbsp; *workstr_const;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (datatype == BYTEAOID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; workstr_const = <a href="#L1787" title="utils/adt/like_support.c:1787">string_to_bytea_const</a>(workstr, len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; workstr_const = <a href="#L1744" title="utils/adt/like_support.c:1744">string_to_const</a>(workstr, datatype);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (DatumGetBool(<a href="../fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(ltproc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cmpstr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; workstr_const-&gt;constvalue)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Successfully made a string larger than cmpstr */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cmptxt)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(cmptxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(workstr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> workstr_const;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No good, release unusable value and try again */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(DatumGetPointer(workstr_const-&gt;constvalue));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(workstr_const);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No luck here, so truncate off the last character and try to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * increment the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; len -= charlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; workstr[len] = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Failed... */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (cmptxt)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(cmptxt);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(workstr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Generate a Datum of the appropriate type from a C string.<br/></li>
<li></span><span class="Comment"> * Note that all of the supported types are pass-by-ref, so the<br/></li>
<li></span><span class="Comment"> * returned value should be <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>'d if no longer needed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Datum<br/></li>
<li><a id="L1724">&#x200c;</a><span class="linkable">string_to_datum</span>(<span class="Type">const</span> <span class="Type">char</span> *str, Oid datatype)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(str != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We cheat a little by assuming that CStringGetTextDatum() will do for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="varchar.c.html#L271" title="utils/adt/varchar.c:271">bpchar</a> and <a href="varchar.c.html#L609" title="utils/adt/varchar.c:609">varchar</a> constants too...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (datatype == NAMEOID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DirectFunctionCall1(<a href="name.c.html#L48" title="utils/adt/name.c:48">namein</a>, CStringGetDatum(str));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (datatype == BYTEAOID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DirectFunctionCall1(<a href="varlena.c.html#L290" title="utils/adt/varlena.c:290">byteain</a>, CStringGetDatum(str));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> CStringGetTextDatum(str);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Generate a Const node of the appropriate type from a C string.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Const *<br/></li>
<li><a id="L1744">&#x200c;</a><span class="linkable">string_to_const</span>(<span class="Type">const</span> <span class="Type">char</span> *str, Oid datatype)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; conval = <a href="#L1724" title="utils/adt/like_support.c:1724">string_to_datum</a>(str, datatype);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collation;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constlen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We only need to support a few datatypes here, so hard-wire properties<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * instead of incurring the expense of catalog lookups.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (datatype)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TEXTOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> VARCHAROID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BPCHAROID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collation = DEFAULT_COLLATION_OID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constlen = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> NAMEOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collation = C_COLLATION_OID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constlen = NAMEDATALEN;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BYTEAOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collation = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constlen = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected datatype in <a href="#L1744" title="utils/adt/like_support.c:1744">string_to_const</a>: </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; datatype);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../nodes/makefuncs.c.html#L301" title="nodes/makefuncs.c:301">makeConst</a>(datatype, -<span class="Constant">1</span>, collation, constlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; conval, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Generate a Const node of bytea type from a binary C string and a length.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Const *<br/></li>
<li><a id="L1787">&#x200c;</a><span class="linkable">string_to_bytea_const</span>(<span class="Type">const</span> <span class="Type">char</span> *str, <span class="Type">size_t</span> str_len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *bstr = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(VARHDRSZ + str_len);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; conval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memcpy(VARDATA(bstr), str, str_len);<br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(bstr, VARHDRSZ + str_len);<br/></li>
<li>&nbsp; &nbsp; conval = PointerGetDatum(bstr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../nodes/makefuncs.c.html#L301" title="nodes/makefuncs.c:301">makeConst</a>(BYTEAOID, -<span class="Constant">1</span>, InvalidOid, -<span class="Constant">1</span>, conval, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
