<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/adt/varbit.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/adt/varbit.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L90">anybit_typmodin</a></li>
<li><a href="#L127">anybit_typmodout</a></li>
<li><a href="#L391">bit</a></li>
<li><a href="#L1243">bit_and</a></li>
<li><a href="#L1211">bit_bit_count</a></li>
<li><a href="#L977">bit_catenate</a></li>
<li><a href="#L818">bit_cmp</a></li>
<li><a href="#L147">bit_in</a></li>
<li><a href="#L1284">bit_or</a></li>
<li><a href="#L280">bit_out</a></li>
<li><a href="#L1176">bit_overlay</a></li>
<li><a href="#L331">bit_recv</a></li>
<li><a href="#L376">bit_send</a></li>
<li><a href="#L968">bitcat</a></li>
<li><a href="#L949">bitcmp</a></li>
<li><a href="#L841">biteq</a></li>
<li><a href="#L1531">bitfromint4</a></li>
<li><a href="#L1611">bitfromint8</a></li>
<li><a href="#L934">bitge</a></li>
<li><a href="#L1869">bitgetbit</a></li>
<li><a href="#L919">bitgt</a></li>
<li><a href="#L904">bitle</a></li>
<li><a href="#L1223">bitlength</a></li>
<li><a href="#L889">bitlt</a></li>
<li><a href="#L865">bitne</a></li>
<li><a href="#L1365">bitnot</a></li>
<li><a href="#L1231">bitoctetlength</a></li>
<li><a href="#L1153">bitoverlay</a></li>
<li><a href="#L1164">bitoverlay_no_len</a></li>
<li><a href="#L1698">bitposition</a></li>
<li><a href="#L1807">bitsetbit</a></li>
<li><a href="#L1392">bitshiftleft</a></li>
<li><a href="#L1459">bitshiftright</a></li>
<li><a href="#L1038">bitsubstr</a></li>
<li><a href="#L1047">bitsubstr_no_len</a></li>
<li><a href="#L1055">bitsubstring</a></li>
<li><a href="#L1586">bittoint4</a></li>
<li><a href="#L1666">bittoint8</a></li>
<li><a href="#L429">bittypmodin</a></li>
<li><a href="#L437">bittypmodout</a></li>
<li><a href="#L1324">bitxor</a></li>
<li><a href="#L742">varbit</a></li>
<li><a href="#L452">varbit_in</a></li>
<li><a href="#L587">varbit_out</a></li>
<li><a href="#L636">varbit_recv</a></li>
<li><a href="#L681">varbit_send</a></li>
<li><a href="#L702">varbit_support</a></li>
<li><a href="#L774">varbittypmodin</a></li>
<li><a href="#L782">varbittypmodout</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L44">HEXDIG</a></li>
<li><a href="#L69">VARBIT_CORRECTLY_PADDED</a></li>
<li><a href="#L77">VARBIT_CORRECTLY_PADDED</a></li>
<li><a href="#L47">VARBIT_PAD</a></li>
<li><a href="#L59">VARBIT_PAD_LAST</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L742" title="utils/adt/varbit.c:742">varbit</a>.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Functions for the SQL datatypes BIT() and BIT VARYING().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The data structure contains the following elements:<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; header&nbsp; -- length of the whole data structure (incl header)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in bytes (as with all varying length datatypes)<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; data section -- private data section for the bits data structures<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; <a href="#L1223" title="utils/adt/varbit.c:1223">bitlength</a> -- length of the <a href="#L391" title="utils/adt/varbit.c:391">bit</a> string in bits<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; bitdata&nbsp;&nbsp; -- <a href="#L391" title="utils/adt/varbit.c:391">bit</a> string, most significant byte first<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The length of the bitdata vector should always be exactly as many<br/></li>
<li></span><span class="Comment"> * bytes as are needed for the given <a href="#L1223" title="utils/adt/varbit.c:1223">bitlength</a>.&nbsp; If the <a href="#L1223" title="utils/adt/varbit.c:1223">bitlength</a> is<br/></li>
<li></span><span class="Comment"> * not a multiple of 8, the extra low-order padding bits of the last<br/></li>
<li></span><span class="Comment"> * byte must be zeroes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * attypmod is defined as the length of the <a href="#L391" title="utils/adt/varbit.c:391">bit</a> string in bits, or for<br/></li>
<li></span><span class="Comment"> * varying bits the maximum length.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Code originally contributed by Adriaan Joubert.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/adt/<a href="#L742" title="utils/adt/varbit.c:742">varbit</a>.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/int.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/pqformat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/nodeFuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/supportnodes.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;port/pg_bitutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/array.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgrprotos.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/<a href="#L742" title="utils/adt/varbit.c:742">varbit</a>.h&quot;<br/></li>
<li></span><br/></li>
<li><a id="L44">&#x200c;</a><span class="PreProc">#define <span class="linkable">HEXDIG</span>(z)&nbsp; &nbsp;&nbsp; ((z)&lt;</span><span class="Constant">10</span><span class="PreProc"> ? ((z)+</span><span class="Constant">'0'</span><span class="PreProc">) : ((z)-</span><span class="Constant">10</span><span class="PreProc">+</span><span class="Constant">'A'</span><span class="PreProc">))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Mask off <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> bits that should be zero in the last byte of a bitstring */<br/></li>
<li><a id="L47">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">VARBIT_PAD</span>(vb) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">do</span><span class="PreProc"> { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; pad_ = VARBITPAD(vb); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; Assert(pad_ &gt;= </span><span class="Constant">0</span><span class="PreProc"> &amp;&amp; pad_ &lt; BITS_PER_BYTE); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="PreProc"> (pad_ &gt; </span><span class="Constant">0</span><span class="PreProc">) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *(VARBITS(vb) + VARBITBYTES(vb) - </span><span class="Constant">1</span><span class="PreProc">) &amp;= BITMASK &lt;&lt; pad_; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; } </span><span class="Statement">while</span><span class="PreProc"> (</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Many <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> work byte-by-byte, so they have a pointer handy to the<br/></li>
<li></span><span class="Comment"> * last-plus-one byte, which saves a cycle or two.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L59">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">VARBIT_PAD_LAST</span>(vb, ptr) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">do</span><span class="PreProc"> { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; pad_ = VARBITPAD(vb); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; Assert(pad_ &gt;= </span><span class="Constant">0</span><span class="PreProc"> &amp;&amp; pad_ &lt; BITS_PER_BYTE); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="PreProc"> (pad_ &gt; </span><span class="Constant">0</span><span class="PreProc">) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *((ptr) - </span><span class="Constant">1</span><span class="PreProc">) &amp;= BITMASK &lt;&lt; pad_; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; } </span><span class="Statement">while</span><span class="PreProc"> (</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Assert proper padding of a bitstring */<br/></li>
<li></span><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li><a id="L69">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">VARBIT_CORRECTLY_PADDED</span>(vb) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">do</span><span class="PreProc"> { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; pad_ = VARBITPAD(vb); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; Assert(pad_ &gt;= </span><span class="Constant">0</span><span class="PreProc"> &amp;&amp; pad_ &lt; BITS_PER_BYTE); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; Assert(pad_ == </span><span class="Constant">0</span><span class="PreProc"> || \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (*(VARBITS(vb) + VARBITBYTES(vb) - </span><span class="Constant">1</span><span class="PreProc">) &amp; ~(BITMASK &lt;&lt; pad_)) == </span><span class="Constant">0</span><span class="PreProc">); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; } </span><span class="Statement">while</span><span class="PreProc"> (</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><span class="PreProc">#else<br/></li>
<li><a id="L77">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">VARBIT_CORRECTLY_PADDED</span>(vb) ((</span><span class="Type">void</span><span class="PreProc">) </span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> VarBit *<a href="#L977" title="utils/adt/varbit.c:977">bit_catenate</a>(VarBit *arg1, VarBit *arg2);<br/></li>
<li><span class="Type">static</span> VarBit *<a href="#L1055" title="utils/adt/varbit.c:1055">bitsubstring</a>(VarBit *arg, int32 s, int32 l,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> length_not_specified);<br/></li>
<li><span class="Type">static</span> VarBit *<a href="#L1176" title="utils/adt/varbit.c:1176">bit_overlay</a>(VarBit *t1, VarBit *t2, <span class="Type">int</span> sp, <span class="Type">int</span> sl);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * common code for <a href="#L429" title="utils/adt/varbit.c:429">bittypmodin</a> and <a href="#L774" title="utils/adt/varbit.c:774">varbittypmodin</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> int32<br/></li>
<li><a id="L90">&#x200c;</a><span class="linkable">anybit_typmodin</span>(ArrayType *ta, <span class="Type">const</span> <span class="Type">char</span> *typename)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; typmod;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp;&nbsp; *tl;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tl = <a href="arrayutils.c.html#L233" title="utils/adt/arrayutils.c:233">ArrayGetIntegerTypmods</a>(ta, &amp;n);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we're not too tense about good error message here because grammar<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * shouldn't allow wrong number of modifiers for BIT<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (n != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid type modifier&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*tl &lt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;length for type </span><span class="Special">%s</span><span class="Constant"> must be at least 1&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typename)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*tl &gt; (MaxAttrSize * BITS_PER_BYTE))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;length for type </span><span class="Special">%s</span><span class="Constant"> cannot exceed </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typename, MaxAttrSize * BITS_PER_BYTE)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typmod = *tl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> typmod;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * common code for <a href="#L437" title="utils/adt/varbit.c:437">bittypmodout</a> and <a href="#L782" title="utils/adt/varbit.c:782">varbittypmodout</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L127">&#x200c;</a><span class="linkable">anybit_typmodout</span>(int32 typmod)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *res = (<span class="Type">char</span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Constant">64</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (typmod &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(res, <span class="Constant">64</span>, <span class="Constant">&quot;(</span><span class="Special">%d</span><span class="Constant">)&quot;</span>, typmod);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *res = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L147" title="utils/adt/varbit.c:147">bit_in</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; converts a char string to the <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> representation of a bitstring.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; The length is determined by the number of bits required plus<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VARHDRSZ bytes or from atttypmod.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L147">&#x200c;</a><span class="linkable">bit_in</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *input_string = PG_GETARG_CSTRING(<span class="Constant">0</span>);<br/></li>
<li><span class="PreProc">#ifdef NOT_USED<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typelem = PG_GETARG_OID(<span class="Constant">1</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; atttypmod = PG_GETARG_INT32(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *escontext = fcinfo-&gt;context;<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *result;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The resulting <a href="#L391" title="utils/adt/varbit.c:391">bit</a> string&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *sp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* pointer into the character string&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; bits8&nbsp; &nbsp; &nbsp;&nbsp; *r;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* pointer into the result */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Length of the whole data structure */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitlen,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Number of bits in the <a href="#L391" title="utils/adt/varbit.c:391">bit</a> string&nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slen;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Length of the input string&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; bit_not_hex;&nbsp; &nbsp; <span class="Comment">/* false = hex string&nbsp; true = <a href="#L391" title="utils/adt/varbit.c:391">bit</a> string */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bc;<br/></li>
<li>&nbsp; &nbsp; bits8&nbsp; &nbsp; &nbsp; &nbsp; x = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check that the first character is a b or an x */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (input_string[<span class="Constant">0</span>] == <span class="Constant">'b'</span> || input_string[<span class="Constant">0</span>] == <span class="Constant">'B'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bit_not_hex = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sp = input_string + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (input_string[<span class="Constant">0</span>] == <span class="Constant">'x'</span> || input_string[<span class="Constant">0</span>] == <span class="Constant">'X'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bit_not_hex = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sp = input_string + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise it's binary.&nbsp; This allows things like cast('1001' as <a href="#L391" title="utils/adt/varbit.c:391">bit</a>)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to work transparently.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; bit_not_hex = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sp = input_string;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine <a href="#L1223" title="utils/adt/varbit.c:1223">bitlength</a> from input string.&nbsp; MaxAllocSize ensures a regular<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * input is small enough, but we must check hex input.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; slen = strlen(sp);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (bit_not_hex)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bitlen = slen;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (slen &gt; VARBITMAXLEN / <span class="Constant">4</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;<a href="#L391" title="utils/adt/varbit.c:391">bit</a> string length exceeds the maximum allowed (</span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VARBITMAXLEN)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bitlen = slen * <span class="Constant">4</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Sometimes atttypmod is not supplied. If it is supplied we need to make<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sure that the bitstring fits.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (atttypmod &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; atttypmod = bitlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (bitlen != atttypmod)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_STRING_DATA_LENGTH_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;<a href="#L391" title="utils/adt/varbit.c:391">bit</a> string length </span><span class="Special">%d</span><span class="Constant"> does not match type <a href="#L391" title="utils/adt/varbit.c:391">bit</a>(</span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitlen, atttypmod)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len = VARBITTOTALLEN(atttypmod);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set to 0 so that *r is always initialised and string is zero-padded */<br/></li>
<li></span>&nbsp; &nbsp; result = (VarBit *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(len);<br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(result, len);<br/></li>
<li>&nbsp; &nbsp; VARBITLEN(result) = atttypmod;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; r = VARBITS(result);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (bit_not_hex)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Parse the <a href="#L391" title="utils/adt/varbit.c:391">bit</a> representation of the string */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We know it fits, as bitlen was compared to atttypmod */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; x = HIGHBIT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (; *sp; sp++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*sp == <span class="Constant">'1'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *r |= x;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*sp != <span class="Constant">'0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">\&quot;%.*s\&quot;</span><span class="Constant"> is not a valid binary digit&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mb/mbutils.c.html#L1023" title="utils/mb/mbutils.c:1023">pg_mblen</a>(sp), sp)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x &gt;&gt;= <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (x == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x = HIGHBIT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Parse the hex representation of the string */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (bc = <span class="Constant">0</span>; *sp; sp++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*sp &gt;= <span class="Constant">'0'</span> &amp;&amp; *sp &lt;= <span class="Constant">'9'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x = (bits8) (*sp - <span class="Constant">'0'</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*sp &gt;= <span class="Constant">'A'</span> &amp;&amp; *sp &lt;= <span class="Constant">'F'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x = (bits8) (*sp - <span class="Constant">'A'</span>) + <span class="Constant">10</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*sp &gt;= <span class="Constant">'a'</span> &amp;&amp; *sp &lt;= <span class="Constant">'f'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x = (bits8) (*sp - <span class="Constant">'a'</span>) + <span class="Constant">10</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">\&quot;%.*s\&quot;</span><span class="Constant"> is not a valid hexadecimal digit&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mb/mbutils.c.html#L1023" title="utils/mb/mbutils.c:1023">pg_mblen</a>(sp), sp)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *r++ |= x;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bc = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *r = x &lt;&lt; <span class="Constant">4</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bc = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VARBIT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L280">&#x200c;</a><span class="linkable">bit_out</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#if 1<br/></li>
<li></span><span class="cCppInIf">&nbsp; &nbsp; </span><span class="Comment">/* same as <a href="#L742" title="utils/adt/varbit.c:742">varbit</a> output */<br/></li>
<li></span><span class="cCppInIf">&nbsp; &nbsp; </span><span class="Statement">return</span><span class="cCppInIf"> <a href="#L587" title="utils/adt/varbit.c:587">varbit_out</a>(fcinfo);<br/></li>
<li></span><span class="PreProc">#else<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; /*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is how one would <a href="../../nodes/print.c.html#L36" title="nodes/print.c:36">print</a> a hex string, in case someone wants to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * write a formatting function.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *s = PG_GETARG_VARBIT_P(0);<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; char&nbsp; &nbsp; &nbsp;&nbsp; *result,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *r;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; bits8&nbsp; &nbsp; &nbsp;&nbsp; *sp;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; int&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitlen;<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; /* Assertion to <a href="../../main/main.c.html#L320" title="main/main.c:320">help</a> catch <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="#L391" title="utils/adt/varbit.c:391">bit</a> <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> that don't pad correctly */<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="#L69" title="utils/adt/varbit.c:69">VARBIT_CORRECTLY_PADDED</a>(s);<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; bitlen = VARBITLEN(s);<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; len = (bitlen + 3) / 4;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; result = (char *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(len + 2);<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; sp = VARBITS(s);<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; r = result;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; *r++ = 'X';<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; /* we cheat by knowing that we store full bytes zero padded */<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; for (i = 0; i &lt; len; i += 2, sp++)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; {<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; *r++ = <a href="#L44" title="utils/adt/varbit.c:44">HEXDIG</a>((*sp) &gt;&gt; 4);<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; *r++ = <a href="#L44" title="utils/adt/varbit.c:44">HEXDIG</a>((*sp) &amp; 0xF);<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; }<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; /*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Go back one step if we printed a hex number that was not part of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bitstring anymore<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; if (i &gt; len)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; r--;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; *r = '\0';<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; PG_RETURN_CSTRING(result);<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L331" title="utils/adt/varbit.c:331">bit_recv</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts external binary format to <a href="#L391" title="utils/adt/varbit.c:391">bit</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L331">&#x200c;</a><span class="linkable">bit_recv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; buf = (StringInfo) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef NOT_USED<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typelem = PG_GETARG_OID(<span class="Constant">1</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; atttypmod = PG_GETARG_INT32(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitlen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; bitlen = <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(buf, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int32));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (bitlen &lt; <span class="Constant">0</span> || bitlen &gt; VARBITMAXLEN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_BINARY_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid length in external <a href="#L391" title="utils/adt/varbit.c:391">bit</a> string&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Sometimes atttypmod is not supplied. If it is supplied we need to make<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sure that the bitstring fits.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (atttypmod &gt; <span class="Constant">0</span> &amp;&amp; bitlen != atttypmod)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_STRING_DATA_LENGTH_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;<a href="#L391" title="utils/adt/varbit.c:391">bit</a> string length </span><span class="Special">%d</span><span class="Constant"> does not match type <a href="#L391" title="utils/adt/varbit.c:391">bit</a>(</span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitlen, atttypmod)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len = VARBITTOTALLEN(bitlen);<br/></li>
<li>&nbsp; &nbsp; result = (VarBit *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(len);<br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(result, len);<br/></li>
<li>&nbsp; &nbsp; VARBITLEN(result) = bitlen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L528" title="libpq/pqformat.c:528">pq_copymsgbytes</a>(buf, (<span class="Type">char</span> *) VARBITS(result), VARBITBYTES(result));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure last byte is correctly zero-padded */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L47" title="utils/adt/varbit.c:47">VARBIT_PAD</a>(result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VARBIT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L376" title="utils/adt/varbit.c:376">bit_send</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts <a href="#L391" title="utils/adt/varbit.c:391">bit</a> to binary format<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L376">&#x200c;</a><span class="linkable">bit_send</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Exactly the same as <a href="#L681" title="utils/adt/varbit.c:681">varbit_send</a>, so share code */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L681" title="utils/adt/varbit.c:681">varbit_send</a>(fcinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L391" title="utils/adt/varbit.c:391">bit</a>()<br/></li>
<li></span><span class="Comment"> * Converts a <a href="#L391" title="utils/adt/varbit.c:391">bit</a>() type to a specific <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> length.<br/></li>
<li></span><span class="Comment"> * len is the <a href="#L1223" title="utils/adt/varbit.c:1223">bitlength</a> specified in the column definition.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If doing implicit cast, raise error when source data is wrong length.<br/></li>
<li></span><span class="Comment"> * If doing explicit cast, silently truncate or zero-pad to specified length.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L391">&#x200c;</a><span class="linkable">bit</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *arg = PG_GETARG_VARBIT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; len = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isExplicit = PG_GETARG_BOOL(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rlen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No work if typmod is invalid or supplied data matches it already */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (len &lt;= <span class="Constant">0</span> || len &gt; VARBITMAXLEN || len == VARBITLEN(arg))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_VARBIT_P(arg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!isExplicit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_STRING_DATA_LENGTH_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;<a href="#L391" title="utils/adt/varbit.c:391">bit</a> string length </span><span class="Special">%d</span><span class="Constant"> does not match type <a href="#L391" title="utils/adt/varbit.c:391">bit</a>(</span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VARBITLEN(arg), len)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rlen = VARBITTOTALLEN(len);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set to 0 so that string is zero-padded */<br/></li>
<li></span>&nbsp; &nbsp; result = (VarBit *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(rlen);<br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(result, rlen);<br/></li>
<li>&nbsp; &nbsp; VARBITLEN(result) = len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memcpy(VARBITS(result), VARBITS(arg),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(VARBITBYTES(result), VARBITBYTES(arg)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make sure last byte is zero-padded if needed.&nbsp; This is useless but safe<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if source data was shorter than target length (we assume the last byte<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of the source data was itself correctly zero-padded).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L47" title="utils/adt/varbit.c:47">VARBIT_PAD</a>(result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VARBIT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L429">&#x200c;</a><span class="linkable">bittypmodin</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *ta = PG_GETARG_ARRAYTYPE_P(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(<a href="#L90" title="utils/adt/varbit.c:90">anybit_typmodin</a>(ta, <span class="Constant">&quot;<a href="#L391" title="utils/adt/varbit.c:391">bit</a>&quot;</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L437">&#x200c;</a><span class="linkable">bittypmodout</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; typmod = PG_GETARG_INT32(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CSTRING(<a href="#L127" title="utils/adt/varbit.c:127">anybit_typmodout</a>(typmod));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L452" title="utils/adt/varbit.c:452">varbit_in</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; converts a string to the <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> representation of a bitstring.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This is the same as <a href="#L147" title="utils/adt/varbit.c:147">bit_in</a> except that atttypmod is taken as<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; the maximum length, not the exact length to force the bitstring to.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L452">&#x200c;</a><span class="linkable">varbit_in</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *input_string = PG_GETARG_CSTRING(<span class="Constant">0</span>);<br/></li>
<li><span class="PreProc">#ifdef NOT_USED<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typelem = PG_GETARG_OID(<span class="Constant">1</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; atttypmod = PG_GETARG_INT32(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *escontext = fcinfo-&gt;context;<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *result;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The resulting <a href="#L391" title="utils/adt/varbit.c:391">bit</a> string&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *sp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* pointer into the character string&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; bits8&nbsp; &nbsp; &nbsp;&nbsp; *r;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* pointer into the result */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Length of the whole data structure */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitlen,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Number of bits in the <a href="#L391" title="utils/adt/varbit.c:391">bit</a> string&nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slen;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Length of the input string&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; bit_not_hex;&nbsp; &nbsp; <span class="Comment">/* false = hex string&nbsp; true = <a href="#L391" title="utils/adt/varbit.c:391">bit</a> string */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bc;<br/></li>
<li>&nbsp; &nbsp; bits8&nbsp; &nbsp; &nbsp; &nbsp; x = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check that the first character is a b or an x */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (input_string[<span class="Constant">0</span>] == <span class="Constant">'b'</span> || input_string[<span class="Constant">0</span>] == <span class="Constant">'B'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bit_not_hex = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sp = input_string + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (input_string[<span class="Constant">0</span>] == <span class="Constant">'x'</span> || input_string[<span class="Constant">0</span>] == <span class="Constant">'X'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bit_not_hex = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sp = input_string + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bit_not_hex = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sp = input_string;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine <a href="#L1223" title="utils/adt/varbit.c:1223">bitlength</a> from input string.&nbsp; MaxAllocSize ensures a regular<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * input is small enough, but we must check hex input.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; slen = strlen(sp);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (bit_not_hex)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bitlen = slen;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (slen &gt; VARBITMAXLEN / <span class="Constant">4</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;<a href="#L391" title="utils/adt/varbit.c:391">bit</a> string length exceeds the maximum allowed (</span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VARBITMAXLEN)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bitlen = slen * <span class="Constant">4</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Sometimes atttypmod is not supplied. If it is supplied we need to make<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sure that the bitstring fits.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (atttypmod &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; atttypmod = bitlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (bitlen &gt; atttypmod)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_STRING_DATA_RIGHT_TRUNCATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;<a href="#L391" title="utils/adt/varbit.c:391">bit</a> string too long for type <a href="#L391" title="utils/adt/varbit.c:391">bit</a> varying(</span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; atttypmod)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len = VARBITTOTALLEN(bitlen);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set to 0 so that *r is always initialised and string is zero-padded */<br/></li>
<li></span>&nbsp; &nbsp; result = (VarBit *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(len);<br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(result, len);<br/></li>
<li>&nbsp; &nbsp; VARBITLEN(result) = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(bitlen, atttypmod);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; r = VARBITS(result);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (bit_not_hex)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Parse the <a href="#L391" title="utils/adt/varbit.c:391">bit</a> representation of the string */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We know it fits, as bitlen was compared to atttypmod */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; x = HIGHBIT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (; *sp; sp++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*sp == <span class="Constant">'1'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *r |= x;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*sp != <span class="Constant">'0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">\&quot;%.*s\&quot;</span><span class="Constant"> is not a valid binary digit&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mb/mbutils.c.html#L1023" title="utils/mb/mbutils.c:1023">pg_mblen</a>(sp), sp)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x &gt;&gt;= <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (x == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x = HIGHBIT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Parse the hex representation of the string */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (bc = <span class="Constant">0</span>; *sp; sp++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*sp &gt;= <span class="Constant">'0'</span> &amp;&amp; *sp &lt;= <span class="Constant">'9'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x = (bits8) (*sp - <span class="Constant">'0'</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*sp &gt;= <span class="Constant">'A'</span> &amp;&amp; *sp &lt;= <span class="Constant">'F'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x = (bits8) (*sp - <span class="Constant">'A'</span>) + <span class="Constant">10</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*sp &gt;= <span class="Constant">'a'</span> &amp;&amp; *sp &lt;= <span class="Constant">'f'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x = (bits8) (*sp - <span class="Constant">'a'</span>) + <span class="Constant">10</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">\&quot;%.*s\&quot;</span><span class="Constant"> is not a valid hexadecimal digit&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mb/mbutils.c.html#L1023" title="utils/mb/mbutils.c:1023">pg_mblen</a>(sp), sp)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *r++ |= x;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bc = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *r = x &lt;&lt; <span class="Constant">4</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bc = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VARBIT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L587" title="utils/adt/varbit.c:587">varbit_out</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Prints the string as bits to preserve length accurately<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment"> <a href="#L636" title="utils/adt/varbit.c:636">varbit_recv</a>() and hex input to <a href="#L452" title="utils/adt/varbit.c:452">varbit_in</a>() can load a value that this<br/></li>
<li></span><span class="Comment"> * cannot emit.&nbsp; Consider using hex output for such <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L587">&#x200c;</a><span class="linkable">varbit_out</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *s = PG_GETARG_VARBIT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *r;<br/></li>
<li>&nbsp; &nbsp; bits8&nbsp; &nbsp; &nbsp;&nbsp; *sp;<br/></li>
<li>&nbsp; &nbsp; bits8&nbsp; &nbsp; &nbsp; &nbsp; x;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; k,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Assertion to <a href="../../main/main.c.html#L320" title="main/main.c:320">help</a> catch <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="#L391" title="utils/adt/varbit.c:391">bit</a> <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> that don't pad correctly */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L69" title="utils/adt/varbit.c:69">VARBIT_CORRECTLY_PADDED</a>(s);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len = VARBITLEN(s);<br/></li>
<li>&nbsp; &nbsp; result = (<span class="Type">char</span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(len + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; sp = VARBITS(s);<br/></li>
<li>&nbsp; &nbsp; r = result;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt;= len - BITS_PER_BYTE; i += BITS_PER_BYTE, sp++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../nodes/print.c.html#L36" title="nodes/print.c:36">print</a> full bytes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; x = *sp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (k = <span class="Constant">0</span>; k &lt; BITS_PER_BYTE; k++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *r++ = IS_HIGHBIT_SET(x) ? <span class="Constant">'1'</span> : <span class="Constant">'0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x &lt;&lt;= <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (i &lt; len)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../nodes/print.c.html#L36" title="nodes/print.c:36">print</a> the last partial byte */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; x = *sp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (k = i; k &lt; len; k++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *r++ = IS_HIGHBIT_SET(x) ? <span class="Constant">'1'</span> : <span class="Constant">'0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x &lt;&lt;= <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; *r = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CSTRING(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L636" title="utils/adt/varbit.c:636">varbit_recv</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts external binary format to <a href="#L742" title="utils/adt/varbit.c:742">varbit</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * External format is the bitlen as an int32, then the byte array.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L636">&#x200c;</a><span class="linkable">varbit_recv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; buf = (StringInfo) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef NOT_USED<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typelem = PG_GETARG_OID(<span class="Constant">1</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; atttypmod = PG_GETARG_INT32(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitlen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; bitlen = <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(buf, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int32));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (bitlen &lt; <span class="Constant">0</span> || bitlen &gt; VARBITMAXLEN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_BINARY_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid length in external <a href="#L391" title="utils/adt/varbit.c:391">bit</a> string&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Sometimes atttypmod is not supplied. If it is supplied we need to make<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sure that the bitstring fits.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (atttypmod &gt; <span class="Constant">0</span> &amp;&amp; bitlen &gt; atttypmod)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_STRING_DATA_RIGHT_TRUNCATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;<a href="#L391" title="utils/adt/varbit.c:391">bit</a> string too long for type <a href="#L391" title="utils/adt/varbit.c:391">bit</a> varying(</span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; atttypmod)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len = VARBITTOTALLEN(bitlen);<br/></li>
<li>&nbsp; &nbsp; result = (VarBit *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(len);<br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(result, len);<br/></li>
<li>&nbsp; &nbsp; VARBITLEN(result) = bitlen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L528" title="libpq/pqformat.c:528">pq_copymsgbytes</a>(buf, (<span class="Type">char</span> *) VARBITS(result), VARBITBYTES(result));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure last byte is correctly zero-padded */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L47" title="utils/adt/varbit.c:47">VARBIT_PAD</a>(result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VARBIT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L681" title="utils/adt/varbit.c:681">varbit_send</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts <a href="#L742" title="utils/adt/varbit.c:742">varbit</a> to binary format<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L681">&#x200c;</a><span class="linkable">varbit_send</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *s = PG_GETARG_VARBIT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L326" title="libpq/pqformat.c:326">pq_begintypsend</a>(&amp;buf);<br/></li>
<li>&nbsp; &nbsp; pq_sendint32(&amp;buf, VARBITLEN(s));<br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L126" title="libpq/pqformat.c:126">pq_sendbytes</a>(&amp;buf, VARBITS(s), VARBITBYTES(s));<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BYTEA_P(<a href="../../libpq/pqformat.c.html#L346" title="libpq/pqformat.c:346">pq_endtypsend</a>(&amp;buf));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L702" title="utils/adt/varbit.c:702">varbit_support</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Planner support function for the <a href="#L742" title="utils/adt/varbit.c:742">varbit</a>() length coercion function.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Currently, the only interesting thing we can do is flatten calls that set<br/></li>
<li></span><span class="Comment"> * the new maximum length &gt;= the previous maximum length.&nbsp; We can ignore the<br/></li>
<li></span><span class="Comment"> * isExplicit argument, since that only affects truncation cases.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L702">&#x200c;</a><span class="linkable">varbit_support</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *rawreq = (Node *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *ret = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(rawreq, SupportRequestSimplify))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SupportRequestSimplify *req = (SupportRequestSimplify *) rawreq;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FuncExpr&nbsp;&nbsp; *expr = req-&gt;fcall;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *typmod;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(list_length(expr-&gt;args) &gt;= <span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typmod = (Node *) lsecond(expr-&gt;args);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(typmod, Const) &amp;&amp; !((Const *) typmod)-&gt;constisnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *source = (Node *) linitial(expr-&gt;args);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; new_typmod = DatumGetInt32(((Const *) typmod)-&gt;constvalue);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; old_max = <a href="../../nodes/nodeFuncs.c.html#L298" title="nodes/nodeFuncs.c:298">exprTypmod</a>(source);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; new_max = new_typmod;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Note: <a href="#L742" title="utils/adt/varbit.c:742">varbit</a>() treats typmod 0 as invalid, so we do too */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (new_max &lt;= <span class="Constant">0</span> || (old_max &gt; <span class="Constant">0</span> &amp;&amp; old_max &lt;= new_max))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret = <a href="../../nodes/nodeFuncs.c.html#L684" title="nodes/nodeFuncs.c:684">relabel_to_typmod</a>(source, new_typmod);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(ret);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L742" title="utils/adt/varbit.c:742">varbit</a>()<br/></li>
<li></span><span class="Comment"> * Converts a <a href="#L742" title="utils/adt/varbit.c:742">varbit</a>() type to a specific <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> length.<br/></li>
<li></span><span class="Comment"> * len is the maximum <a href="#L1223" title="utils/adt/varbit.c:1223">bitlength</a> specified in the column definition.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If doing implicit cast, raise error when source data is too long.<br/></li>
<li></span><span class="Comment"> * If doing explicit cast, silently truncate to max length.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L742">&#x200c;</a><span class="linkable">varbit</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *arg = PG_GETARG_VARBIT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; len = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isExplicit = PG_GETARG_BOOL(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rlen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No work if typmod is invalid or supplied data matches it already */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (len &lt;= <span class="Constant">0</span> || len &gt;= VARBITLEN(arg))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_VARBIT_P(arg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!isExplicit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_STRING_DATA_RIGHT_TRUNCATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;<a href="#L391" title="utils/adt/varbit.c:391">bit</a> string too long for type <a href="#L391" title="utils/adt/varbit.c:391">bit</a> varying(</span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rlen = VARBITTOTALLEN(len);<br/></li>
<li>&nbsp; &nbsp; result = (VarBit *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(rlen);<br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(result, rlen);<br/></li>
<li>&nbsp; &nbsp; VARBITLEN(result) = len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memcpy(VARBITS(result), VARBITS(arg), VARBITBYTES(result));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure last byte is correctly zero-padded */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L47" title="utils/adt/varbit.c:47">VARBIT_PAD</a>(result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VARBIT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L774">&#x200c;</a><span class="linkable">varbittypmodin</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *ta = PG_GETARG_ARRAYTYPE_P(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(<a href="#L90" title="utils/adt/varbit.c:90">anybit_typmodin</a>(ta, <span class="Constant">&quot;<a href="#L742" title="utils/adt/varbit.c:742">varbit</a>&quot;</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L782">&#x200c;</a><span class="linkable">varbittypmodout</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; typmod = PG_GETARG_INT32(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CSTRING(<a href="#L127" title="utils/adt/varbit.c:127">anybit_typmodout</a>(typmod));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Comparison operators<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We only need one set of comparison operators for bitstrings, as the lengths<br/></li>
<li></span><span class="Comment"> * are stored in the same way for zero-padded and varying <a href="#L391" title="utils/adt/varbit.c:391">bit</a> strings.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that the standard is not unambiguous about the comparison between<br/></li>
<li></span><span class="Comment"> * zero-padded <a href="#L391" title="utils/adt/varbit.c:391">bit</a> strings and varying bitstrings. If the same value is written<br/></li>
<li></span><span class="Comment"> * into a zero padded bitstring as into a varying bitstring, but the zero<br/></li>
<li></span><span class="Comment"> * padded bitstring has greater length, it will be bigger.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Zeros from the beginning of a bitstring cannot simply be ignored, as they<br/></li>
<li></span><span class="Comment"> * may be part of a <a href="#L391" title="utils/adt/varbit.c:391">bit</a> string and may be significant.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: btree indexes need these routines not to leak memory; therefore,<br/></li>
<li></span><span class="Comment"> * be careful to free working copies of toasted datums.&nbsp; Most places don't<br/></li>
<li></span><span class="Comment"> * need to be so careful.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L818" title="utils/adt/varbit.c:818">bit_cmp</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Compares two bitstrings and returns &lt;0, 0, &gt;0 depending on whether the first<br/></li>
<li></span><span class="Comment"> * string is smaller, <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>, or bigger than the second. All bits are considered<br/></li>
<li></span><span class="Comment"> * and additional zero bits may make one string smaller/larger than the other,<br/></li>
<li></span><span class="Comment"> * even if their zero-padded <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> would be the same.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> int32<br/></li>
<li><a id="L818">&#x200c;</a><span class="linkable">bit_cmp</span>(VarBit *arg1, VarBit *arg2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitlen1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bytelen1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitlen2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bytelen2;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; bytelen1 = VARBITBYTES(arg1);<br/></li>
<li>&nbsp; &nbsp; bytelen2 = VARBITBYTES(arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = memcmp(VARBITS(arg1), VARBITS(arg2), <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(bytelen1, bytelen2));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bitlen1 = VARBITLEN(arg1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bitlen2 = VARBITLEN(arg2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bitlen1 != bitlen2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = (bitlen1 &lt; bitlen2) ? -<span class="Constant">1</span> : <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L841">&#x200c;</a><span class="linkable">biteq</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *arg1 = PG_GETARG_VARBIT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *arg2 = PG_GETARG_VARBIT_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitlen1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitlen2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; bitlen1 = VARBITLEN(arg1);<br/></li>
<li>&nbsp; &nbsp; bitlen2 = VARBITLEN(arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fast path for different-length inputs */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (bitlen1 != bitlen2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = (<a href="#L818" title="utils/adt/varbit.c:818">bit_cmp</a>(arg1, arg2) == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg2, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L865">&#x200c;</a><span class="linkable">bitne</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *arg1 = PG_GETARG_VARBIT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *arg2 = PG_GETARG_VARBIT_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitlen1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitlen2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; bitlen1 = VARBITLEN(arg1);<br/></li>
<li>&nbsp; &nbsp; bitlen2 = VARBITLEN(arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fast path for different-length inputs */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (bitlen1 != bitlen2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = (<a href="#L818" title="utils/adt/varbit.c:818">bit_cmp</a>(arg1, arg2) != <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg2, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L889">&#x200c;</a><span class="linkable">bitlt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *arg1 = PG_GETARG_VARBIT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *arg2 = PG_GETARG_VARBIT_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (<a href="#L818" title="utils/adt/varbit.c:818">bit_cmp</a>(arg1, arg2) &lt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg2, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L904">&#x200c;</a><span class="linkable">bitle</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *arg1 = PG_GETARG_VARBIT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *arg2 = PG_GETARG_VARBIT_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (<a href="#L818" title="utils/adt/varbit.c:818">bit_cmp</a>(arg1, arg2) &lt;= <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg2, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L919">&#x200c;</a><span class="linkable">bitgt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *arg1 = PG_GETARG_VARBIT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *arg2 = PG_GETARG_VARBIT_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (<a href="#L818" title="utils/adt/varbit.c:818">bit_cmp</a>(arg1, arg2) &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg2, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L934">&#x200c;</a><span class="linkable">bitge</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *arg1 = PG_GETARG_VARBIT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *arg2 = PG_GETARG_VARBIT_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (<a href="#L818" title="utils/adt/varbit.c:818">bit_cmp</a>(arg1, arg2) &gt;= <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg2, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L949">&#x200c;</a><span class="linkable">bitcmp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *arg1 = PG_GETARG_VARBIT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *arg2 = PG_GETARG_VARBIT_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L818" title="utils/adt/varbit.c:818">bit_cmp</a>(arg1, arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg2, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L968" title="utils/adt/varbit.c:968">bitcat</a><br/></li>
<li></span><span class="Comment"> * Concatenation of <a href="#L391" title="utils/adt/varbit.c:391">bit</a> strings<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L968">&#x200c;</a><span class="linkable">bitcat</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *arg1 = PG_GETARG_VARBIT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *arg2 = PG_GETARG_VARBIT_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VARBIT_P(<a href="#L977" title="utils/adt/varbit.c:977">bit_catenate</a>(arg1, arg2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> VarBit *<br/></li>
<li><a id="L977">&#x200c;</a><span class="linkable">bit_catenate</span>(VarBit *arg1, VarBit *arg2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitlen1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitlen2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bytelen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bit1pad,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bit2shift;<br/></li>
<li>&nbsp; &nbsp; bits8&nbsp; &nbsp; &nbsp;&nbsp; *pr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *pa;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; bitlen1 = VARBITLEN(arg1);<br/></li>
<li>&nbsp; &nbsp; bitlen2 = VARBITLEN(arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (bitlen1 &gt; VARBITMAXLEN - bitlen2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;<a href="#L391" title="utils/adt/varbit.c:391">bit</a> string length exceeds the maximum allowed (</span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VARBITMAXLEN)));<br/></li>
<li>&nbsp; &nbsp; bytelen = VARBITTOTALLEN(bitlen1 + bitlen2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (VarBit *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(bytelen);<br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(result, bytelen);<br/></li>
<li>&nbsp; &nbsp; VARBITLEN(result) = bitlen1 + bitlen2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Copy the first bitstring in */<br/></li>
<li></span>&nbsp; &nbsp; memcpy(VARBITS(result), VARBITS(arg1), VARBITBYTES(arg1));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Copy the second <a href="#L391" title="utils/adt/varbit.c:391">bit</a> string */<br/></li>
<li></span>&nbsp; &nbsp; bit1pad = VARBITPAD(arg1);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (bit1pad == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(VARBITS(result) + VARBITBYTES(arg1), VARBITS(arg2),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VARBITBYTES(arg2));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (bitlen2 &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We need to shift all the bits to fit */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; bit2shift = BITS_PER_BYTE - bit1pad;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pr = VARBITS(result) + VARBITBYTES(arg1) - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (pa = VARBITS(arg2); pa &lt; VARBITEND(arg2); pa++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *pr |= ((*pa &gt;&gt; bit2shift) &amp; BITMASK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pr++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pr &lt; VARBITEND(result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *pr = (*pa &lt;&lt; bit1pad) &amp; BITMASK;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The pad bits should be already zero at this point */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1038" title="utils/adt/varbit.c:1038">bitsubstr</a><br/></li>
<li></span><span class="Comment"> * retrieve a substring from the <a href="#L391" title="utils/adt/varbit.c:391">bit</a> string.<br/></li>
<li></span><span class="Comment"> * Note, s is 1-based.<br/></li>
<li></span><span class="Comment"> * SQL draft 6.10 9)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1038">&#x200c;</a><span class="linkable">bitsubstr</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VARBIT_P(<a href="#L1055" title="utils/adt/varbit.c:1055">bitsubstring</a>(PG_GETARG_VARBIT_P(<span class="Constant">0</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_GETARG_INT32(<span class="Constant">1</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_GETARG_INT32(<span class="Constant">2</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1047">&#x200c;</a><span class="linkable">bitsubstr_no_len</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VARBIT_P(<a href="#L1055" title="utils/adt/varbit.c:1055">bitsubstring</a>(PG_GETARG_VARBIT_P(<span class="Constant">0</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_GETARG_INT32(<span class="Constant">1</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -<span class="Constant">1</span>, <span class="Constant">true</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> VarBit *<br/></li>
<li><a id="L1055">&#x200c;</a><span class="linkable">bitsubstring</span>(VarBit *arg, int32 s, int32 l, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> length_not_specified)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rbitlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ishift,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; e,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; e1;<br/></li>
<li>&nbsp; &nbsp; bits8&nbsp; &nbsp; &nbsp;&nbsp; *r,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *ps;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; bitlen = VARBITLEN(arg);<br/></li>
<li>&nbsp; &nbsp; s1 = Max(s, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we do not have an <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound, use end of string */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (length_not_specified)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; e1 = bitlen + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (l &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* SQL99 says to throw an error for E &lt; S, i.e., negative length */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SUBSTRING_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;negative substring length not allowed&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; e1 = -<span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* silence stupider compilers */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (pg_add_s32_overflow(s, l, &amp;e))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * L could be large enough for S + L to overflow, in which case the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * substring must run to end of string.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; e1 = bitlen + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; e1 = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(e, bitlen + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (s1 &gt; bitlen || e1 &lt;= s1)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Need to return a zero-length bitstring */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; len = VARBITTOTALLEN(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = (VarBit *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SET_VARSIZE(result, len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; VARBITLEN(result) = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * OK, we've got a true substring starting at position s1-1 and ending<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * at position e1-1<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rbitlen = e1 - s1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len = VARBITTOTALLEN(rbitlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = (VarBit *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SET_VARSIZE(result, len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; VARBITLEN(result) = rbitlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len -= VARHDRSZ + VARBITHDRSZ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Are we copying from a byte boundary? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((s1 - <span class="Constant">1</span>) % BITS_PER_BYTE == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Yep, we are copying bytes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(VARBITS(result), VARBITS(arg) + (s1 - <span class="Constant">1</span>) / BITS_PER_BYTE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Figure out how much we need to shift the sequence by */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ishift = (s1 - <span class="Constant">1</span>) % BITS_PER_BYTE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r = VARBITS(result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ps = VARBITS(arg) + (s1 - <span class="Constant">1</span>) / BITS_PER_BYTE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; len; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *r = (*ps &lt;&lt; ishift) &amp; BITMASK;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((++ps) &lt; VARBITEND(arg))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *r |= *ps &gt;&gt; (BITS_PER_BYTE - ishift);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make sure last byte is correctly zero-padded */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L47" title="utils/adt/varbit.c:47">VARBIT_PAD</a>(result);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1153" title="utils/adt/varbit.c:1153">bitoverlay</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Replace specified substring of first string with second<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The SQL standard defines OVERLAY() in terms of substring and concatenation.<br/></li>
<li></span><span class="Comment"> * This code is a direct implementation of what the standard says.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1153">&#x200c;</a><span class="linkable">bitoverlay</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *t1 = PG_GETARG_VARBIT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *t2 = PG_GETARG_VARBIT_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sp = PG_GETARG_INT32(<span class="Constant">2</span>);&nbsp; &nbsp; <span class="Comment">/* substring start position */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sl = PG_GETARG_INT32(<span class="Constant">3</span>);&nbsp; &nbsp; <span class="Comment">/* substring length */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VARBIT_P(<a href="#L1176" title="utils/adt/varbit.c:1176">bit_overlay</a>(t1, t2, sp, sl));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1164">&#x200c;</a><span class="linkable">bitoverlay_no_len</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *t1 = PG_GETARG_VARBIT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *t2 = PG_GETARG_VARBIT_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sp = PG_GETARG_INT32(<span class="Constant">2</span>);&nbsp; &nbsp; <span class="Comment">/* substring start position */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sl = VARBITLEN(t2);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* defaults to length(t2) */<br/></li>
<li></span>&nbsp; &nbsp; PG_RETURN_VARBIT_P(<a href="#L1176" title="utils/adt/varbit.c:1176">bit_overlay</a>(t1, t2, sp, sl));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> VarBit *<br/></li>
<li><a id="L1176">&#x200c;</a><span class="linkable">bit_overlay</span>(VarBit *t1, VarBit *t2, <span class="Type">int</span> sp, <span class="Type">int</span> sl)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *s1;<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *s2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sp_pl_sl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check for possible integer-overflow cases.&nbsp; For negative sp, throw a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &quot;substring length&quot; error because that's what should be expected<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * according to the spec's definition of OVERLAY().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (sp &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SUBSTRING_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;negative substring length not allowed&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pg_add_s32_overflow(sp, sl, &amp;sp_pl_sl))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;integer out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; s1 = <a href="#L1055" title="utils/adt/varbit.c:1055">bitsubstring</a>(t1, <span class="Constant">1</span>, sp - <span class="Constant">1</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; s2 = <a href="#L1055" title="utils/adt/varbit.c:1055">bitsubstring</a>(t1, sp_pl_sl, -<span class="Constant">1</span>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; result = <a href="#L977" title="utils/adt/varbit.c:977">bit_catenate</a>(s1, t2);<br/></li>
<li>&nbsp; &nbsp; result = <a href="#L977" title="utils/adt/varbit.c:977">bit_catenate</a>(result, s2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * bit_count<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the number of bits set in a <a href="#L391" title="utils/adt/varbit.c:391">bit</a> string.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1211">&#x200c;</a><span class="linkable">bit_bit_count</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *arg = PG_GETARG_VARBIT_P(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT64(pg_popcount((<span class="Type">char</span> *) VARBITS(arg), VARBITBYTES(arg)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1223" title="utils/adt/varbit.c:1223">bitlength</a>, <a href="#L1231" title="utils/adt/varbit.c:1231">bitoctetlength</a><br/></li>
<li></span><span class="Comment"> * Return the length of a <a href="#L391" title="utils/adt/varbit.c:391">bit</a> string<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1223">&#x200c;</a><span class="linkable">bitlength</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *arg = PG_GETARG_VARBIT_P(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(VARBITLEN(arg));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1231">&#x200c;</a><span class="linkable">bitoctetlength</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *arg = PG_GETARG_VARBIT_P(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(VARBITBYTES(arg));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1243" title="utils/adt/varbit.c:1243">bit_and</a><br/></li>
<li></span><span class="Comment"> * perform a logical AND on two <a href="#L391" title="utils/adt/varbit.c:391">bit</a> strings.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1243">&#x200c;</a><span class="linkable">bit_and</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *arg1 = PG_GETARG_VARBIT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *arg2 = PG_GETARG_VARBIT_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitlen1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitlen2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; bits8&nbsp; &nbsp; &nbsp;&nbsp; *p1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *p2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *r;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; bitlen1 = VARBITLEN(arg1);<br/></li>
<li>&nbsp; &nbsp; bitlen2 = VARBITLEN(arg2);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (bitlen1 != bitlen2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_STRING_DATA_LENGTH_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot AND <a href="#L391" title="utils/adt/varbit.c:391">bit</a> strings of different sizes&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len = VARSIZE(arg1);<br/></li>
<li>&nbsp; &nbsp; result = (VarBit *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(len);<br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(result, len);<br/></li>
<li>&nbsp; &nbsp; VARBITLEN(result) = bitlen1;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; p1 = VARBITS(arg1);<br/></li>
<li>&nbsp; &nbsp; p2 = VARBITS(arg2);<br/></li>
<li>&nbsp; &nbsp; r = VARBITS(result);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; VARBITBYTES(arg1); i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *r++ = *p1++ &amp; *p2++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Padding is not needed as &amp; of 0 pads is 0 */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VARBIT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1284" title="utils/adt/varbit.c:1284">bit_or</a><br/></li>
<li></span><span class="Comment"> * perform a logical OR on two <a href="#L391" title="utils/adt/varbit.c:391">bit</a> strings.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1284">&#x200c;</a><span class="linkable">bit_or</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *arg1 = PG_GETARG_VARBIT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *arg2 = PG_GETARG_VARBIT_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitlen1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitlen2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; bits8&nbsp; &nbsp; &nbsp;&nbsp; *p1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *p2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *r;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; bitlen1 = VARBITLEN(arg1);<br/></li>
<li>&nbsp; &nbsp; bitlen2 = VARBITLEN(arg2);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (bitlen1 != bitlen2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_STRING_DATA_LENGTH_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot OR <a href="#L391" title="utils/adt/varbit.c:391">bit</a> strings of different sizes&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; len = VARSIZE(arg1);<br/></li>
<li>&nbsp; &nbsp; result = (VarBit *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(len);<br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(result, len);<br/></li>
<li>&nbsp; &nbsp; VARBITLEN(result) = bitlen1;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; p1 = VARBITS(arg1);<br/></li>
<li>&nbsp; &nbsp; p2 = VARBITS(arg2);<br/></li>
<li>&nbsp; &nbsp; r = VARBITS(result);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; VARBITBYTES(arg1); i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *r++ = *p1++ | *p2++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Padding is not needed as | of 0 pads is 0 */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VARBIT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1324" title="utils/adt/varbit.c:1324">bitxor</a><br/></li>
<li></span><span class="Comment"> * perform a logical XOR on two <a href="#L391" title="utils/adt/varbit.c:391">bit</a> strings.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1324">&#x200c;</a><span class="linkable">bitxor</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *arg1 = PG_GETARG_VARBIT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *arg2 = PG_GETARG_VARBIT_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitlen1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitlen2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; bits8&nbsp; &nbsp; &nbsp;&nbsp; *p1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *p2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *r;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; bitlen1 = VARBITLEN(arg1);<br/></li>
<li>&nbsp; &nbsp; bitlen2 = VARBITLEN(arg2);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (bitlen1 != bitlen2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_STRING_DATA_LENGTH_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot XOR <a href="#L391" title="utils/adt/varbit.c:391">bit</a> strings of different sizes&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len = VARSIZE(arg1);<br/></li>
<li>&nbsp; &nbsp; result = (VarBit *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(len);<br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(result, len);<br/></li>
<li>&nbsp; &nbsp; VARBITLEN(result) = bitlen1;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; p1 = VARBITS(arg1);<br/></li>
<li>&nbsp; &nbsp; p2 = VARBITS(arg2);<br/></li>
<li>&nbsp; &nbsp; r = VARBITS(result);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; VARBITBYTES(arg1); i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *r++ = *p1++ ^ *p2++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Padding is not needed as ^ of 0 pads is 0 */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VARBIT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1365" title="utils/adt/varbit.c:1365">bitnot</a><br/></li>
<li></span><span class="Comment"> * perform a logical NOT on a <a href="#L391" title="utils/adt/varbit.c:391">bit</a> string.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1365">&#x200c;</a><span class="linkable">bitnot</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *arg = PG_GETARG_VARBIT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; bits8&nbsp; &nbsp; &nbsp;&nbsp; *p,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *r;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (VarBit *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(VARSIZE(arg));<br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(result, VARSIZE(arg));<br/></li>
<li>&nbsp; &nbsp; VARBITLEN(result) = VARBITLEN(arg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; p = VARBITS(arg);<br/></li>
<li>&nbsp; &nbsp; r = VARBITS(result);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (; p &lt; VARBITEND(arg); p++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *r++ = ~*p;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Must zero-pad the result, because extra bits are surely 1's here */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L59" title="utils/adt/varbit.c:59">VARBIT_PAD_LAST</a>(result, r);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VARBIT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1392" title="utils/adt/varbit.c:1392">bitshiftleft</a><br/></li>
<li></span><span class="Comment"> * do a left shift (i.e. towards the beginning of the string)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1392">&#x200c;</a><span class="linkable">bitshiftleft</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *arg = PG_GETARG_VARBIT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; shft = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; byte_shift,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ishift,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; bits8&nbsp; &nbsp; &nbsp;&nbsp; *p,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *r;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Negative shift is a shift to the right */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (shft &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Prevent integer overflow in negation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (shft &lt; -VARBITMAXLEN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shft = -VARBITMAXLEN;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_DATUM(DirectFunctionCall2(<a href="#L1459" title="utils/adt/varbit.c:1459">bitshiftright</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VarBitPGetDatum(arg),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Int32GetDatum(-shft)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (VarBit *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(VARSIZE(arg));<br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(result, VARSIZE(arg));<br/></li>
<li>&nbsp; &nbsp; VARBITLEN(result) = VARBITLEN(arg);<br/></li>
<li>&nbsp; &nbsp; r = VARBITS(result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we shifted all the bits out, return an all-zero string */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (shft &gt;= VARBITLEN(arg))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemSet(r, <span class="Constant">0</span>, VARBITBYTES(arg));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_VARBIT_P(result);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; byte_shift = shft / BITS_PER_BYTE;<br/></li>
<li>&nbsp; &nbsp; ishift = shft % BITS_PER_BYTE;<br/></li>
<li>&nbsp; &nbsp; p = VARBITS(arg) + byte_shift;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ishift == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Special case: we can do a memcpy */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; len = VARBITBYTES(arg) - byte_shift;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(r, p, len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemSet(r + len, <span class="Constant">0</span>, byte_shift);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (; p &lt; VARBITEND(arg); r++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *r = *p &lt;&lt; ishift;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((++p) &lt; VARBITEND(arg))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *r |= *p &gt;&gt; (BITS_PER_BYTE - ishift);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (; r &lt; VARBITEND(result); r++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *r = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The pad bits should be already zero at this point */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VARBIT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1459" title="utils/adt/varbit.c:1459">bitshiftright</a><br/></li>
<li></span><span class="Comment"> * do a right shift (i.e. towards the end of the string)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1459">&#x200c;</a><span class="linkable">bitshiftright</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *arg = PG_GETARG_VARBIT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; shft = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; byte_shift,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ishift,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; bits8&nbsp; &nbsp; &nbsp;&nbsp; *p,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *r;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Negative shift is a shift to the left */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (shft &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Prevent integer overflow in negation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (shft &lt; -VARBITMAXLEN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shft = -VARBITMAXLEN;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_DATUM(DirectFunctionCall2(<a href="#L1392" title="utils/adt/varbit.c:1392">bitshiftleft</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VarBitPGetDatum(arg),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Int32GetDatum(-shft)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (VarBit *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(VARSIZE(arg));<br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(result, VARSIZE(arg));<br/></li>
<li>&nbsp; &nbsp; VARBITLEN(result) = VARBITLEN(arg);<br/></li>
<li>&nbsp; &nbsp; r = VARBITS(result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we shifted all the bits out, return an all-zero string */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (shft &gt;= VARBITLEN(arg))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemSet(r, <span class="Constant">0</span>, VARBITBYTES(arg));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_VARBIT_P(result);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; byte_shift = shft / BITS_PER_BYTE;<br/></li>
<li>&nbsp; &nbsp; ishift = shft % BITS_PER_BYTE;<br/></li>
<li>&nbsp; &nbsp; p = VARBITS(arg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set the first part of the result to 0 */<br/></li>
<li></span>&nbsp; &nbsp; MemSet(r, <span class="Constant">0</span>, byte_shift);<br/></li>
<li>&nbsp; &nbsp; r += byte_shift;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ishift == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Special case: we can do a memcpy */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; len = VARBITBYTES(arg) - byte_shift;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(r, p, len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; r += len;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (r &lt; VARBITEND(result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *r = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> first byte */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (; r &lt; VARBITEND(result); p++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *r |= *p &gt;&gt; ishift;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((++r) &lt; VARBITEND(result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *r = (*p &lt;&lt; (BITS_PER_BYTE - ishift)) &amp; BITMASK;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We may have shifted 1's into the pad bits, so fix that */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L59" title="utils/adt/varbit.c:59">VARBIT_PAD_LAST</a>(result, r);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VARBIT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This is not defined in <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> standard. We retain the natural ordering of<br/></li>
<li></span><span class="Comment"> * bits here, as it just seems more intuitive.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1531">&#x200c;</a><span class="linkable">bitfromint4</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; a = PG_GETARG_INT32(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; typmod = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; bits8&nbsp; &nbsp; &nbsp;&nbsp; *r;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; destbitsleft,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; srcbitsleft;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (typmod &lt;= <span class="Constant">0</span> || typmod &gt; VARBITMAXLEN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typmod = <span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* default <a href="#L391" title="utils/adt/varbit.c:391">bit</a> length */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; rlen = VARBITTOTALLEN(typmod);<br/></li>
<li>&nbsp; &nbsp; result = (VarBit *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(rlen);<br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(result, rlen);<br/></li>
<li>&nbsp; &nbsp; VARBITLEN(result) = typmod;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; r = VARBITS(result);<br/></li>
<li>&nbsp; &nbsp; destbitsleft = typmod;<br/></li>
<li>&nbsp; &nbsp; srcbitsleft = <span class="Constant">32</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* drop <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> input bits that don't fit */<br/></li>
<li></span>&nbsp; &nbsp; srcbitsleft = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(srcbitsleft, destbitsleft);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sign-fill <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> excess bytes in output */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (destbitsleft &gt;= srcbitsleft + <span class="Constant">8</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *r++ = (bits8) ((a &lt; <span class="Constant">0</span>) ? BITMASK : <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; destbitsleft -= <span class="Constant">8</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* store first fractional byte */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (destbitsleft &gt; srcbitsleft)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> val = (<span class="Type">unsigned</span> <span class="Type">int</span>) (a &gt;&gt; (destbitsleft - <span class="Constant">8</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Force sign-fill in case the compiler implements &gt;&gt; as zero-fill */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (a &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val |= ((<span class="Type">unsigned</span> <span class="Type">int</span>) -<span class="Constant">1</span>) &lt;&lt; (srcbitsleft + <span class="Constant">8</span> - destbitsleft);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *r++ = (bits8) (val &amp; BITMASK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; destbitsleft -= <span class="Constant">8</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now srcbitsleft and destbitsleft are the same, need not track both */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* store whole bytes */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (destbitsleft &gt;= <span class="Constant">8</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *r++ = (bits8) ((a &gt;&gt; (destbitsleft - <span class="Constant">8</span>)) &amp; BITMASK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; destbitsleft -= <span class="Constant">8</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* store last fractional byte */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (destbitsleft &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *r = (bits8) ((a &lt;&lt; (<span class="Constant">8</span> - destbitsleft)) &amp; BITMASK);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VARBIT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1586">&#x200c;</a><span class="linkable">bittoint4</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *arg = PG_GETARG_VARBIT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; bits8&nbsp; &nbsp; &nbsp;&nbsp; *r;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check that the <a href="#L391" title="utils/adt/varbit.c:391">bit</a> string is not too long */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (VARBITLEN(arg) &gt; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(result) * BITS_PER_BYTE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;integer out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (r = VARBITS(arg); r &lt; VARBITEND(arg); r++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result &lt;&lt;= BITS_PER_BYTE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result |= *r;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now shift the result to take account of the padding at the end */<br/></li>
<li></span>&nbsp; &nbsp; result &gt;&gt;= VARBITPAD(arg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1611">&#x200c;</a><span class="linkable">bitfromint8</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; a = PG_GETARG_INT64(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; typmod = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; bits8&nbsp; &nbsp; &nbsp;&nbsp; *r;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; destbitsleft,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; srcbitsleft;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (typmod &lt;= <span class="Constant">0</span> || typmod &gt; VARBITMAXLEN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typmod = <span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* default <a href="#L391" title="utils/adt/varbit.c:391">bit</a> length */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; rlen = VARBITTOTALLEN(typmod);<br/></li>
<li>&nbsp; &nbsp; result = (VarBit *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(rlen);<br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(result, rlen);<br/></li>
<li>&nbsp; &nbsp; VARBITLEN(result) = typmod;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; r = VARBITS(result);<br/></li>
<li>&nbsp; &nbsp; destbitsleft = typmod;<br/></li>
<li>&nbsp; &nbsp; srcbitsleft = <span class="Constant">64</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* drop <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> input bits that don't fit */<br/></li>
<li></span>&nbsp; &nbsp; srcbitsleft = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(srcbitsleft, destbitsleft);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sign-fill <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> excess bytes in output */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (destbitsleft &gt;= srcbitsleft + <span class="Constant">8</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *r++ = (bits8) ((a &lt; <span class="Constant">0</span>) ? BITMASK : <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; destbitsleft -= <span class="Constant">8</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* store first fractional byte */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (destbitsleft &gt; srcbitsleft)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> val = (<span class="Type">unsigned</span> <span class="Type">int</span>) (a &gt;&gt; (destbitsleft - <span class="Constant">8</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Force sign-fill in case the compiler implements &gt;&gt; as zero-fill */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (a &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val |= ((<span class="Type">unsigned</span> <span class="Type">int</span>) -<span class="Constant">1</span>) &lt;&lt; (srcbitsleft + <span class="Constant">8</span> - destbitsleft);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *r++ = (bits8) (val &amp; BITMASK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; destbitsleft -= <span class="Constant">8</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now srcbitsleft and destbitsleft are the same, need not track both */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* store whole bytes */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (destbitsleft &gt;= <span class="Constant">8</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *r++ = (bits8) ((a &gt;&gt; (destbitsleft - <span class="Constant">8</span>)) &amp; BITMASK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; destbitsleft -= <span class="Constant">8</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* store last fractional byte */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (destbitsleft &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *r = (bits8) ((a &lt;&lt; (<span class="Constant">8</span> - destbitsleft)) &amp; BITMASK);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VARBIT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1666">&#x200c;</a><span class="linkable">bittoint8</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *arg = PG_GETARG_VARBIT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; bits8&nbsp; &nbsp; &nbsp;&nbsp; *r;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check that the <a href="#L391" title="utils/adt/varbit.c:391">bit</a> string is not too long */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (VARBITLEN(arg) &gt; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(result) * BITS_PER_BYTE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;bigint out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (r = VARBITS(arg); r &lt; VARBITEND(arg); r++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result &lt;&lt;= BITS_PER_BYTE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result |= *r;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now shift the result to take account of the padding at the end */<br/></li>
<li></span>&nbsp; &nbsp; result &gt;&gt;= VARBITPAD(arg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT64(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Determines the position of S2 in the bitstring S1 (1-based string).<br/></li>
<li></span><span class="Comment"> * If S2 does not appear in S1 this function returns 0.<br/></li>
<li></span><span class="Comment"> * If S2 is of length 0 this function returns 1.<br/></li>
<li></span><span class="Comment"> * Compatible in usage with POSITION() <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for other data types.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1698">&#x200c;</a><span class="linkable">bitposition</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *str = PG_GETARG_VARBIT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *substr = PG_GETARG_VARBIT_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; substr_length,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str_length,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is;<br/></li>
<li>&nbsp; &nbsp; bits8&nbsp; &nbsp; &nbsp;&nbsp; *s,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* pointer into substring */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *p;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* pointer into str */<br/></li>
<li></span>&nbsp; &nbsp; bits8&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a>,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* shifted substring byte to <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mask1,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* mask for substring byte shifted right */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mask2,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* mask for substring byte shifted left */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end_mask,&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* pad mask for last substring byte */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str_mask;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* pad mask for last string byte */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_match;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get the substring length */<br/></li>
<li></span>&nbsp; &nbsp; substr_length = VARBITLEN(substr);<br/></li>
<li>&nbsp; &nbsp; str_length = VARBITLEN(str);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* String has zero length or substring longer than string, return 0 */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((str_length == <span class="Constant">0</span>) || (substr_length &gt; str_length))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_INT32(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* zero-length substring means return 1 */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (substr_length == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_INT32(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialise the padding masks */<br/></li>
<li></span>&nbsp; &nbsp; end_mask = BITMASK &lt;&lt; VARBITPAD(substr);<br/></li>
<li>&nbsp; &nbsp; str_mask = BITMASK &lt;&lt; VARBITPAD(str);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; VARBITBYTES(str) - VARBITBYTES(substr) + <span class="Constant">1</span>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (is = <span class="Constant">0</span>; is &lt; BITS_PER_BYTE; is++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is_match = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p = VARBITS(str) + i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mask1 = BITMASK &gt;&gt; is;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mask2 = ~mask1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (s = VARBITS(substr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; is_match &amp;&amp; s &lt; VARBITEND(substr); s++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = *s &gt;&gt; is;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s == VARBITEND(substr) - <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mask1 &amp;= end_mask &gt;&gt; is;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (p == VARBITEND(str) - <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check that there is enough of str left */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (mask1 &amp; ~str_mask)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is_match = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mask1 &amp;= str_mask;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is_match = ((<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> ^ *p) &amp; mask1) == <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!is_match)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Move on to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> byte */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (p == VARBITEND(str))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mask2 = end_mask &lt;&lt; (BITS_PER_BYTE - is);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is_match = mask2 == <span class="Constant">0</span>;<br/></li>
<li><span class="PreProc">#if 0<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG4, &quot;S. %d %d em=%2x sm=%2x r=%d&quot;,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; i, is, end_mask, mask2, is_match);<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = *s &lt;&lt; (BITS_PER_BYTE - is);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s == VARBITEND(substr) - <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mask2 &amp;= end_mask &lt;&lt; (BITS_PER_BYTE - is);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (p == VARBITEND(str) - <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (mask2 &amp; ~str_mask)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is_match = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mask2 &amp;= str_mask;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is_match = ((<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> ^ *p) &amp; mask2) == <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Have we found a match? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (is_match)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_INT32(i * BITS_PER_BYTE + is + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(<span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1807" title="utils/adt/varbit.c:1807">bitsetbit</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Given an instance of type '<a href="#L391" title="utils/adt/varbit.c:391">bit</a>' creates a new one with<br/></li>
<li></span><span class="Comment"> * the Nth <a href="#L391" title="utils/adt/varbit.c:391">bit</a> set to the given value.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The <a href="#L391" title="utils/adt/varbit.c:391">bit</a> location is specified left-to-right in a zero-based fashion<br/></li>
<li></span><span class="Comment"> * consistent with the other get_bit and set_bit <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, but<br/></li>
<li></span><span class="Comment"> * inconsistent with the standard substring, position, overlay <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1807">&#x200c;</a><span class="linkable">bitsetbit</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *arg1 = PG_GETARG_VARBIT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; n = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; newBit = PG_GETARG_INT32(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitlen;<br/></li>
<li>&nbsp; &nbsp; bits8&nbsp; &nbsp; &nbsp;&nbsp; *r,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *p;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; byteNo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitNo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; bitlen = VARBITLEN(arg1);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (n &lt; <span class="Constant">0</span> || n &gt;= bitlen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ARRAY_SUBSCRIPT_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;<a href="#L391" title="utils/adt/varbit.c:391">bit</a> index </span><span class="Special">%d</span><span class="Constant"> out of valid <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> (0..</span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n, bitlen - <span class="Constant">1</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sanity check!<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (newBit != <span class="Constant">0</span> &amp;&amp; newBit != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;new <a href="#L391" title="utils/adt/varbit.c:391">bit</a> must be 0 or 1&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len = VARSIZE(arg1);<br/></li>
<li>&nbsp; &nbsp; result = (VarBit *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(len);<br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(result, len);<br/></li>
<li>&nbsp; &nbsp; VARBITLEN(result) = bitlen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; p = VARBITS(arg1);<br/></li>
<li>&nbsp; &nbsp; r = VARBITS(result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memcpy(r, p, VARBITBYTES(arg1));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; byteNo = n / BITS_PER_BYTE;<br/></li>
<li>&nbsp; &nbsp; bitNo = BITS_PER_BYTE - <span class="Constant">1</span> - (n % BITS_PER_BYTE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update the byte.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (newBit == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; r[byteNo] &amp;= (~(<span class="Constant">1</span> &lt;&lt; bitNo));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; r[byteNo] |= (<span class="Constant">1</span> &lt;&lt; bitNo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VARBIT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1869" title="utils/adt/varbit.c:1869">bitgetbit</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * returns the value of the Nth <a href="#L391" title="utils/adt/varbit.c:391">bit</a> of a <a href="#L391" title="utils/adt/varbit.c:391">bit</a> array (0 or 1).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The <a href="#L391" title="utils/adt/varbit.c:391">bit</a> location is specified left-to-right in a zero-based fashion<br/></li>
<li></span><span class="Comment"> * consistent with the other get_bit and set_bit <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, but<br/></li>
<li></span><span class="Comment"> * inconsistent with the standard substring, position, overlay <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1869">&#x200c;</a><span class="linkable">bitgetbit</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; VarBit&nbsp; &nbsp; &nbsp;&nbsp; *arg1 = PG_GETARG_VARBIT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; n = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitlen;<br/></li>
<li>&nbsp; &nbsp; bits8&nbsp; &nbsp; &nbsp;&nbsp; *p;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; byteNo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitNo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; bitlen = VARBITLEN(arg1);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (n &lt; <span class="Constant">0</span> || n &gt;= bitlen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ARRAY_SUBSCRIPT_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;<a href="#L391" title="utils/adt/varbit.c:391">bit</a> index </span><span class="Special">%d</span><span class="Constant"> out of valid <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> (0..</span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n, bitlen - <span class="Constant">1</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; p = VARBITS(arg1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; byteNo = n / BITS_PER_BYTE;<br/></li>
<li>&nbsp; &nbsp; bitNo = BITS_PER_BYTE - <span class="Constant">1</span> - (n % BITS_PER_BYTE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (p[byteNo] &amp; (<span class="Constant">1</span> &lt;&lt; bitNo))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_INT32(<span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
