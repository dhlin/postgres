<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/adt/like_match.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/adt/like_match.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L80">MatchText</a></li>
<li><a href="#L249">do_like_escape</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L344">CHAREQ</a></li>
<li><a href="#L348">CopyAdvChar</a></li>
<li><a href="#L74">GETCHAR</a></li>
<li><a href="#L76">GETCHAR</a></li>
<li><a href="#L355">GETCHAR</a></li>
<li><a href="#L358">MATCH_LOWER</a></li>
<li><a href="#L349">MatchText</a></li>
<li><a href="#L347">NextChar</a></li>
<li><a href="#L352">do_like_escape</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * like_match.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; LIKE pattern matching <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> code.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This file is included by like.c four times, to provide matching code for<br/></li>
<li></span><span class="Comment"> * (1) single-byte encodings, (2) UTF8, (3) other multi-byte encodings,<br/></li>
<li></span><span class="Comment"> * and (4) case insensitive matches in single-byte encodings.<br/></li>
<li></span><span class="Comment"> * (UTF8 is a special case because we can use a much more efficient version<br/></li>
<li></span><span class="Comment"> * of <a href="like.c.html#L109" title="utils/adt/like.c:109">NextChar</a> than can be used for general multi-byte encodings.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Before the inclusion, we need to define the following macros:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="like.c.html#L109" title="utils/adt/like.c:109">NextChar</a><br/></li>
<li></span><span class="Comment"> * <a href="like.c.html#L118" title="utils/adt/like.c:118">MatchText</a> - to name of function wanted<br/></li>
<li></span><span class="Comment"> * <a href="like.c.html#L119" title="utils/adt/like.c:119">do_like_escape</a> - name of function if wanted - needs <a href="like.c.html#L108" title="utils/adt/like.c:108">CHAREQ</a> and <a href="like.c.html#L111" title="utils/adt/like.c:111">CopyAdvChar</a><br/></li>
<li></span><span class="Comment"> * <a href="like.c.html#L134" title="utils/adt/like.c:134">MATCH_LOWER</a> - define for case (4) to specify case folding for 1-byte chars<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; src/backend/utils/adt/like_match.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Originally written by Rich $alz, mirror!rs, Wed Nov 26 19:03:17 EST 1986.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Rich $alz is <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> &lt;rsalz@bbn.com&gt;.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Special thanks to Lars Mathiesen &lt;thorinn@diku.dk&gt; for the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="like.c.html#L32" title="utils/adt/like.c:32">LIKE_ABORT</a> code.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; This code was shamelessly stolen from the &quot;pql&quot; code by myself and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; slightly modified :)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; All references to the <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> &quot;star&quot; were replaced by &quot;percent&quot;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; All references to the <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> &quot;wild&quot; were replaced by &quot;like&quot;<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; All the nice shell RE matching stuff was replaced by just &quot;<a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>&quot; and &quot;%&quot;<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; As I don't have a copy of the SQL standard handy I wasn't sure whether<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; to leave in the '\' escape character handling.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Keith Parks. &lt;keith@mtcc.demon.co.uk&gt;<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; SQL lets you specify the escape character by saying<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; LIKE &lt;pattern&gt; ESCAPE &lt;escape character&gt;. We are a small operation<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; so we force you to use '\'. - ay 7/95<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Now we have the <a href="like.c.html#L428" title="utils/adt/like.c:428">like_escape</a>() function that converts patterns with<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> specified escape character (or <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> at all) to the <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; default escape character, which is still '\'. - tgl 9/2000<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The code is rewritten to avoid requiring null-terminated strings,<br/></li>
<li></span><span class="Comment"> * which in turn allows us to leave out some memcpy() operations.<br/></li>
<li></span><span class="Comment"> * This code should be faster and take less memory, but no promises...<br/></li>
<li></span><span class="Comment"> * - thomas 2000-08-06<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*--------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Match text and pattern, return <a href="like.c.html#L30" title="utils/adt/like.c:30">LIKE_TRUE</a>, <a href="like.c.html#L31" title="utils/adt/like.c:31">LIKE_FALSE</a>, or <a href="like.c.html#L32" title="utils/adt/like.c:32">LIKE_ABORT</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="like.c.html#L30" title="utils/adt/like.c:30">LIKE_TRUE</a>: they match<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="like.c.html#L31" title="utils/adt/like.c:31">LIKE_FALSE</a>: they don't match<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="like.c.html#L32" title="utils/adt/like.c:32">LIKE_ABORT</a>: not only don't they match, but the text is too short.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If <a href="like.c.html#L32" title="utils/adt/like.c:32">LIKE_ABORT</a> is returned, then no suffix of the text can match the<br/></li>
<li></span><span class="Comment"> * pattern either, so an <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-level % scan can stop scanning <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment"> *--------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef <a href="like.c.html#L134" title="utils/adt/like.c:134">MATCH_LOWER</a><br/></li>
<li><a id="L74">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">GETCHAR</span>(t) <a href="like.c.html#L134" title="utils/adt/like.c:134">MATCH_LOWER</a>(t)<br/></li>
<li></span><span class="PreProc">#else<br/></li>
<li><a id="L76">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">GETCHAR</span>(t) (t)<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L80">&#x200c;</a></span><span class="linkable">MatchText</span>(<span class="Type">const</span> <span class="Type">char</span> *t, <span class="Type">int</span> tlen, <span class="Type">const</span> <span class="Type">char</span> *p, <span class="Type">int</span> plen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_locale_t locale, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> locale_is_c)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fast path for match-everything pattern */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (plen == <span class="Constant">1</span> &amp;&amp; *p == <span class="Constant">'%'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="like.c.html#L30" title="utils/adt/like.c:30">LIKE_TRUE</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Since this function recurses, it could be driven to stack overflow */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In this loop, we advance by char when matching wildcards (and thus on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * recursive entry to this function we are properly char-synced). On other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * occasions it is safe to advance by byte, as the text and pattern will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be in lockstep. This allows us to perform all comparisons between the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * text and pattern on a byte by byte basis, even for multi-byte<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * encodings.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (tlen &gt; <span class="Constant">0</span> &amp;&amp; plen &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*p == <span class="Special">'\\'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Next pattern byte must match literally, whatever it is */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="like.c.html#L105" title="utils/adt/like.c:105">NextByte</a>(p, plen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ... and there had better be one, per SQL standard */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (plen &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_ESCAPE_SEQUENCE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;LIKE pattern must not end with escape character&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L74" title="utils/adt/like_match.c:74">GETCHAR</a>(*p) != <a href="#L74" title="utils/adt/like_match.c:74">GETCHAR</a>(*t))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="like.c.html#L31" title="utils/adt/like.c:31">LIKE_FALSE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*p == <span class="Constant">'%'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; firstpat;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * % processing is essentially a search for a text position at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * which the remainder of the text matches the remainder of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pattern, using a recursive call to check each potential match.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If there are wildcards immediately following the %, we can <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * over them first, using the idea that <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> sequence of N <a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>'s and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * one or more %'s is equivalent to N <a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>'s and one % (ie, it will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * match <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> sequence of at least N text characters).&nbsp; In this way<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we will always run the recursive search loop using a pattern<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fragment that begins with a literal character-to-match, thereby<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not recursing more than we have to.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="like.c.html#L105" title="utils/adt/like.c:105">NextByte</a>(p, plen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (plen &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*p == <span class="Constant">'%'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="like.c.html#L105" title="utils/adt/like.c:105">NextByte</a>(p, plen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*p == <span class="Constant">'<a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If not enough text left to match the pattern, ABORT */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tlen &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="like.c.html#L32" title="utils/adt/like.c:32">LIKE_ABORT</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="like.c.html#L109" title="utils/adt/like.c:109">NextChar</a>(t, tlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="like.c.html#L105" title="utils/adt/like.c:105">NextByte</a>(p, plen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reached a non-wildcard pattern char */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we're at end of pattern, match: we have a trailing % which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * matches <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> remaining text string.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (plen &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="like.c.html#L30" title="utils/adt/like.c:30">LIKE_TRUE</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise, scan for a text position at which we can match the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rest of the pattern.&nbsp; The first remaining pattern char is known<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to be a regular or escaped literal character, so we can <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the first pattern byte to each text byte to avoid recursing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * more than we have to.&nbsp; This fact also guarantees that we don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have to consider a match to the zero-length substring at the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * end of the text.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*p == <span class="Special">'\\'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (plen &lt; <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_ESCAPE_SEQUENCE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;LIKE pattern must not end with escape character&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; firstpat = <a href="#L74" title="utils/adt/like_match.c:74">GETCHAR</a>(p[<span class="Constant">1</span>]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; firstpat = <a href="#L74" title="utils/adt/like_match.c:74">GETCHAR</a>(*p);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (tlen &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L74" title="utils/adt/like_match.c:74">GETCHAR</a>(*t) == firstpat)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matched = <a href="like.c.html#L118" title="utils/adt/like.c:118">MatchText</a>(t, tlen, p, plen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locale, locale_is_c);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (matched != <a href="like.c.html#L31" title="utils/adt/like.c:31">LIKE_FALSE</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> matched; <span class="Comment">/* TRUE or ABORT */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="like.c.html#L109" title="utils/adt/like.c:109">NextChar</a>(t, tlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * End of text with no match, so no point in trying later places<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to start matching this pattern.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="like.c.html#L32" title="utils/adt/like.c:32">LIKE_ABORT</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*p == <span class="Constant">'<a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a> matches <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> single character, and we know there is one */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="like.c.html#L109" title="utils/adt/like.c:109">NextChar</a>(t, tlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="like.c.html#L105" title="utils/adt/like.c:105">NextByte</a>(p, plen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L74" title="utils/adt/like_match.c:74">GETCHAR</a>(*p) != <a href="#L74" title="utils/adt/like_match.c:74">GETCHAR</a>(*t))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* non-wildcard pattern char fails to match text char */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="like.c.html#L31" title="utils/adt/like.c:31">LIKE_FALSE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Pattern and text match, so advance.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It is safe to use <a href="like.c.html#L105" title="utils/adt/like.c:105">NextByte</a> instead of <a href="like.c.html#L109" title="utils/adt/like.c:109">NextChar</a> here, even for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * multi-byte character sets, because we are not following immediately<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * after a wildcard character. If we are in the middle of a multibyte<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * character, we must already have matched at least one byte of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * character from both text and pattern; so we cannot get out-of-sync<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * on character boundaries.&nbsp; And we know that no backend-legal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * encoding allows ASCII characters such as '%' to appear as non-first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * bytes of characters, so we won't mistakenly detect a new wildcard.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="like.c.html#L105" title="utils/adt/like.c:105">NextByte</a>(t, tlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="like.c.html#L105" title="utils/adt/like.c:105">NextByte</a>(p, plen);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tlen &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="like.c.html#L31" title="utils/adt/like.c:31">LIKE_FALSE</a>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* end of pattern, but not of text */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * End of text, but perhaps not of pattern.&nbsp; Match iff the remaining<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pattern can match a zero-length string, ie, it's zero or more %'s.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (plen &gt; <span class="Constant">0</span> &amp;&amp; *p == <span class="Constant">'%'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="like.c.html#L105" title="utils/adt/like.c:105">NextByte</a>(p, plen);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (plen &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="like.c.html#L30" title="utils/adt/like.c:30">LIKE_TRUE</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * End of text with no match, so no point in trying later places to start<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * matching this pattern.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="like.c.html#L32" title="utils/adt/like.c:32">LIKE_ABORT</a>;<br/></li>
<li>}&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="like.c.html#L118" title="utils/adt/like.c:118">MatchText</a>() */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="like.c.html#L428" title="utils/adt/like.c:428">like_escape</a>() --- given a pattern and an ESCAPE string,<br/></li>
<li></span><span class="Comment"> * convert the pattern to use Postgres' standard backslash escape convention.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#ifdef <a href="like.c.html#L119" title="utils/adt/like.c:119">do_like_escape</a><br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> text *<br/></li>
<li><a id="L249">&#x200c;</a><span class="linkable">do_like_escape</span>(text *pat, text *esc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *p,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *e,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *r;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; afterescape;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; p = VARDATA_ANY(pat);<br/></li>
<li>&nbsp; &nbsp; plen = VARSIZE_ANY_EXHDR(pat);<br/></li>
<li>&nbsp; &nbsp; e = VARDATA_ANY(esc);<br/></li>
<li>&nbsp; &nbsp; elen = VARSIZE_ANY_EXHDR(esc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Worst-case pattern growth is 2x --- unlikely, but it's hardly worth<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * trying to calculate the size more accurately than that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; result = (text *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(plen * <span class="Constant">2</span> + VARHDRSZ);<br/></li>
<li>&nbsp; &nbsp; r = VARDATA(result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (elen == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No escape character is wanted.&nbsp; Double <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> backslashes in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pattern to make them act like ordinary characters.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (plen &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*p == <span class="Special">'\\'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *r++ = <span class="Special">'\\'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="like.c.html#L111" title="utils/adt/like.c:111">CopyAdvChar</a>(r, p, plen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The specified escape must be only a single character.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="like.c.html#L109" title="utils/adt/like.c:109">NextChar</a>(e, elen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (elen != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_ESCAPE_SEQUENCE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid escape string&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Escape string must be empty or one character.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; e = VARDATA_ANY(esc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If specified escape is '\', just copy the pattern as-is.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*e == <span class="Special">'\\'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(result, pat, VARSIZE_ANY(pat));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise, convert occurrences of the specified escape character to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * '\', and double occurrences of '\' --- unless they immediately<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * follow an escape character!<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; afterescape = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (plen &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="like.c.html#L108" title="utils/adt/like.c:108">CHAREQ</a>(p, e) &amp;&amp; !afterescape)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *r++ = <span class="Special">'\\'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="like.c.html#L109" title="utils/adt/like.c:109">NextChar</a>(p, plen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; afterescape = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*p == <span class="Special">'\\'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *r++ = <span class="Special">'\\'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!afterescape)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *r++ = <span class="Special">'\\'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="like.c.html#L109" title="utils/adt/like.c:109">NextChar</a>(p, plen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; afterescape = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="like.c.html#L111" title="utils/adt/like.c:111">CopyAdvChar</a>(r, p, plen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; afterescape = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(result, r - ((<span class="Type">char</span> *) result));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="like.c.html#L119" title="utils/adt/like.c:119">do_like_escape</a> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef <a href="like.c.html#L108" title="utils/adt/like.c:108">CHAREQ</a><br/></li>
<li><a id="L344">&#x200c;</a></span><span class="PreProc">#undef <span class="linkable">CHAREQ</span><br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><a id="L347">&#x200c;</a><span class="PreProc">#undef <span class="linkable">NextChar</span><br/></li>
<li><a id="L348">&#x200c;</a></span><span class="PreProc">#undef <span class="linkable">CopyAdvChar</span><br/></li>
<li><a id="L349">&#x200c;</a></span><span class="PreProc">#undef <span class="linkable">MatchText</span><br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef <a href="like.c.html#L119" title="utils/adt/like.c:119">do_like_escape</a><br/></li>
<li><a id="L352">&#x200c;</a></span><span class="PreProc">#undef <span class="linkable">do_like_escape</span><br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><a id="L355">&#x200c;</a><span class="PreProc">#undef <span class="linkable">GETCHAR</span><br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef <a href="like.c.html#L134" title="utils/adt/like.c:134">MATCH_LOWER</a><br/></li>
<li><a id="L358">&#x200c;</a></span><span class="PreProc">#undef <span class="linkable">MATCH_LOWER</span><br/></li>
<li></span><br/></li>
<li><span class="PreProc">#endif<br/></li>
</ol></span></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
