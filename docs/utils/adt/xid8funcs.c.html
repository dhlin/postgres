<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/adt/xid8funcs.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/adt/xid8funcs.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L68">pg_snapshot</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L97">TransactionIdInRecentPast</a></li>
<li><a href="#L274">buf_add_txid</a></li>
<li><a href="#L285">buf_finalize</a></li>
<li><a href="#L259">buf_init</a></li>
<li><a href="#L190">cmp_fxid</a></li>
<li><a href="#L224">is_visible_fxid</a></li>
<li><a href="#L302">parse_snapshot</a></li>
<li><a href="#L407">pg_current_snapshot</a></li>
<li><a href="#L371">pg_current_xact_id</a></li>
<li><a href="#L389">pg_current_xact_id_if_assigned</a></li>
<li><a href="#L451">pg_snapshot_in</a></li>
<li><a href="#L467">pg_snapshot_out</a></li>
<li><a href="#L499">pg_snapshot_recv</a></li>
<li><a href="#L565">pg_snapshot_send</a></li>
<li><a href="#L626">pg_snapshot_xip</a></li>
<li><a href="#L613">pg_snapshot_xmax</a></li>
<li><a href="#L600">pg_snapshot_xmin</a></li>
<li><a href="#L586">pg_visible_in_snapshot</a></li>
<li><a href="#L671">pg_xact_status</a></li>
<li><a href="#L210">sort_snapshot</a></li>
<li><a href="#L164">widen_snapshot_xid</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L72">PG_SNAPSHOT_MAX_NXIP</a></li>
<li><a href="#L70">PG_SNAPSHOT_SIZE</a></li>
<li><a href="#L48">USE_BSEARCH_IF_NXIP_GREATER</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * xid8funcs.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Export <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> transaction IDs to user level.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that only top-level transaction IDs are exposed to user sessions.<br/></li>
<li></span><span class="Comment"> * This is important because xid8s frequently persist beyond the global<br/></li>
<li></span><span class="Comment"> * xmin horizon, or may even be shipped to other machines, so we cannot<br/></li>
<li></span><span class="Comment"> * rely on being able to correlate subtransaction IDs with their parents<br/></li>
<li></span><span class="Comment"> * via <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> such as <a href="../../access/transam/subtrans.c.html#L163" title="access/transam/subtrans.c:163">SubTransGetTopmostTransaction</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * These <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> are used to support the txid_XXX <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> and the newer<br/></li>
<li></span><span class="Comment"> * <a href="#L371" title="utils/adt/xid8funcs.c:371">pg_current_xact_id</a>, <a href="#L407" title="utils/adt/xid8funcs.c:407">pg_current_snapshot</a> and related fmgr <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, since<br/></li>
<li></span><span class="Comment"> * the only difference between them is whether they expose xid8 or int8 <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment"> * to users.&nbsp; The txid_XXX variants should eventually be dropped.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Copyright (c) 2003-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Author: Jan Wieck, Afilias USA INC.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; 64-<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> txids: Marko Kreen, Skype Technologies<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; src/backend/utils/adt/xid8funcs.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/transam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;funcapi.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lib/qunique.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/pqformat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/postmaster.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/lwlock.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/procarray.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/snapmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/xid8.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * If defined, use bsearch() function for searching for xid8s in snapshots<br/></li>
<li></span><span class="Comment"> * that have more than the specified number of <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L48">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">USE_BSEARCH_IF_NXIP_GREATER</span> </span><span class="Constant">30<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Snapshot containing FullTransactionIds.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 4-byte length hdr, should not be touched directly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Explicit embedding is ok as we want always correct alignment anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; __varsz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; nxip;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* number of fxids in xip array */<br/></li>
<li></span>&nbsp; &nbsp; FullTransactionId xmin;<br/></li>
<li>&nbsp; &nbsp; FullTransactionId xmax;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* in-progress fxids, xmin &lt;= xip[i] &lt; xmax: */<br/></li>
<li></span>&nbsp; &nbsp; FullTransactionId xip[FLEXIBLE_ARRAY_MEMBER];<br/></li>
<li><a id="L68">&#x200c;</a>} <span class="linkable">pg_snapshot</span>;<br/></li>
<li><br/></li>
<li><a id="L70">&#x200c;</a><span class="PreProc">#define <span class="linkable">PG_SNAPSHOT_SIZE</span>(nxip) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (offsetof(<a href="#L68" title="utils/adt/xid8funcs.c:68">pg_snapshot</a>, xip) + </span><span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(FullTransactionId) * (nxip))<br/></li>
<li><a id="L72">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PG_SNAPSHOT_MAX_NXIP</span> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((MaxAllocSize - offsetof(<a href="#L68" title="utils/adt/xid8funcs.c:68">pg_snapshot</a>, xip)) / </span><span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(FullTransactionId))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compile-time limits on the procarray (MAX_BACKENDS processes plus<br/></li>
<li></span><span class="Comment"> * MAX_BACKENDS prepared transactions) guarantee nxip won't be too large.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>StaticAssertDecl(MAX_BACKENDS * <span class="Constant">2</span> &lt;= <a href="#L72" title="utils/adt/xid8funcs.c:72">PG_SNAPSHOT_MAX_NXIP</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;possible overflow in <a href="#L407" title="utils/adt/xid8funcs.c:407">pg_current_snapshot</a>()&quot;</span>);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Helper to get a TransactionId from a 64-<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> xid with wraparound detection.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It is an ERROR if the xid is in the future.&nbsp; Otherwise, returns true if<br/></li>
<li></span><span class="Comment"> * the transaction is still new enough that we can determine whether it<br/></li>
<li></span><span class="Comment"> * committed and false otherwise.&nbsp; If *extracted_xid is not NULL, it is set<br/></li>
<li></span><span class="Comment"> * to the low 32 bits of the transaction ID (i.e. the actual XID, without the<br/></li>
<li></span><span class="Comment"> * epoch).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller must hold XactTruncationLock since it's dealing with arbitrary<br/></li>
<li></span><span class="Comment"> * XIDs, and must continue to hold it until it's done with <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> clog lookups<br/></li>
<li></span><span class="Comment"> * relating to those XIDs.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L97">&#x200c;</a></span><span class="linkable">TransactionIdInRecentPast</span>(FullTransactionId fxid, TransactionId *extracted_xid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TransactionId xid = XidFromFullTransactionId(fxid);<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; now_epoch;<br/></li>
<li>&nbsp; &nbsp; TransactionId now_epoch_next_xid;<br/></li>
<li>&nbsp; &nbsp; FullTransactionId now_fullxid;<br/></li>
<li>&nbsp; &nbsp; TransactionId oldest_xid;<br/></li>
<li>&nbsp; &nbsp; FullTransactionId oldest_fxid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; now_fullxid = <a href="../../access/transam/varsup.c.html#L288" title="access/transam/varsup.c:288">ReadNextFullTransactionId</a>();<br/></li>
<li>&nbsp; &nbsp; now_epoch_next_xid = XidFromFullTransactionId(now_fullxid);<br/></li>
<li>&nbsp; &nbsp; now_epoch = EpochFromFullTransactionId(now_fullxid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (extracted_xid != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *extracted_xid = xid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsValid(xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* For non-normal transaction IDs, we can ignore the epoch. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsNormal(xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If the transaction ID is in the future, throw an error. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!FullTransactionIdPrecedes(fxid, now_fullxid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;transaction ID </span><span class="Special">%llu</span><span class="Constant"> is in the future&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">long</span>) U64FromFullTransactionId(fxid))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../access/transam/varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;oldestClogXid is protected by XactTruncationLock, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we don't acquire that lock here.&nbsp; Instead, we require the caller to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * acquire it, because the caller is presumably going to look up the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * returned XID.&nbsp; If we took and released the lock within this function, a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * CLOG truncation could occur <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the caller finished with the XID.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../../storage/lmgr/lwlock.c.html#L1895" title="storage/lmgr/lwlock.c:1895">LWLockHeldByMe</a>(XactTruncationLock));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If fxid is not older than <a href="../../access/transam/varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;oldestClogXid, the relevant<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * CLOG entry is guaranteed to still exist.&nbsp; Convert<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../access/transam/varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;oldestClogXid into a FullTransactionId to <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with fxid.&nbsp; Determine the right epoch knowing that oldest_fxid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * shouldn't be more than 2^31 older than now_fullxid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; oldest_xid = <a href="../../access/transam/varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;oldestClogXid;<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../access/transam/transam.c.html#L299" title="access/transam/transam.c:299">TransactionIdPrecedesOrEquals</a>(oldest_xid, now_epoch_next_xid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (oldest_xid &lt;= now_epoch_next_xid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldest_fxid = FullTransactionIdFromEpochAndXid(now_epoch, oldest_xid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(now_epoch &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldest_fxid = FullTransactionIdFromEpochAndXid(now_epoch - <span class="Constant">1</span>, oldest_xid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> !FullTransactionIdPrecedes(fxid, oldest_fxid);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert a TransactionId obtained from a snapshot held by the caller to a<br/></li>
<li></span><span class="Comment"> * FullTransactionId.&nbsp; Use next_fxid as a reference FullTransactionId, so that<br/></li>
<li></span><span class="Comment"> * we can compute the high order bits.&nbsp; It must have been obtained by the<br/></li>
<li></span><span class="Comment"> * caller with <a href="../../access/transam/varsup.c.html#L288" title="access/transam/varsup.c:288">ReadNextFullTransactionId</a>() after the snapshot was created.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> FullTransactionId<br/></li>
<li><a id="L164">&#x200c;</a><span class="linkable">widen_snapshot_xid</span>(TransactionId xid, FullTransactionId next_fxid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TransactionId next_xid = XidFromFullTransactionId(next_fxid);<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; epoch = EpochFromFullTransactionId(next_fxid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Special transaction ID. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsNormal(xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> FullTransactionIdFromEpochAndXid(<span class="Constant">0</span>, xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The 64 <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> result must be &lt;= next_fxid, since next_fxid hadn't been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * issued yet when the snapshot was created.&nbsp; Every TransactionId in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * snapshot must therefore be from the same epoch as next_fxid, or the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * epoch <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>.&nbsp; We know this because next_fxid is never allow to get<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * more than one epoch ahead of the TransactionIds in <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> snapshot.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (xid &gt; next_xid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; epoch--;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> FullTransactionIdFromEpochAndXid(epoch, xid);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * txid comparator for qsort/bsearch<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L190">&#x200c;</a></span><span class="linkable">cmp_fxid</span>(<span class="Type">const</span> <span class="Type">void</span> *aa, <span class="Type">const</span> <span class="Type">void</span> *bb)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FullTransactionId a = *(<span class="Type">const</span> FullTransactionId *) aa;<br/></li>
<li>&nbsp; &nbsp; FullTransactionId b = *(<span class="Type">const</span> FullTransactionId *) bb;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (FullTransactionIdPrecedes(a, b))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (FullTransactionIdPrecedes(b, a))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Sort a snapshot's txids, so we can use bsearch() later.&nbsp; Also remove<br/></li>
<li></span><span class="Comment"> * <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> duplicates.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For consistency of on-disk representation, we always sort even if bsearch<br/></li>
<li></span><span class="Comment"> * will not be used.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L210">&#x200c;</a></span><span class="linkable">sort_snapshot</span>(<a href="#L68" title="utils/adt/xid8funcs.c:68">pg_snapshot</a> *snap)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (snap-&gt;nxip &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qsort(snap-&gt;xip, snap-&gt;nxip, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(FullTransactionId), <a href="#L190" title="utils/adt/xid8funcs.c:190">cmp_fxid</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snap-&gt;nxip = qunique(snap-&gt;xip, snap-&gt;nxip, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(FullTransactionId),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L190" title="utils/adt/xid8funcs.c:190">cmp_fxid</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * check fxid visibility.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L224">&#x200c;</a></span><span class="linkable">is_visible_fxid</span>(FullTransactionId value, <span class="Type">const</span> <a href="#L68" title="utils/adt/xid8funcs.c:68">pg_snapshot</a> *snap)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (FullTransactionIdPrecedes(value, snap-&gt;xmin))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!FullTransactionIdPrecedes(value, snap-&gt;xmax))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><span class="PreProc">#ifdef <a href="#L48" title="utils/adt/xid8funcs.c:48">USE_BSEARCH_IF_NXIP_GREATER</a><br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (snap-&gt;nxip &gt; <a href="#L48" title="utils/adt/xid8funcs.c:48">USE_BSEARCH_IF_NXIP_GREATER</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res = bsearch(&amp;value, snap-&gt;xip, snap-&gt;nxip, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(FullTransactionId),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L190" title="utils/adt/xid8funcs.c:190">cmp_fxid</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if found, transaction is still in progress */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (res) ? <span class="Constant">false</span> : <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; snap-&gt;nxip; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (FullTransactionIdEquals(value, snap-&gt;xip[i]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * helper <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> to use StringInfo for <a href="#L68" title="utils/adt/xid8funcs.c:68">pg_snapshot</a> creation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> StringInfo<br/></li>
<li><a id="L259">&#x200c;</a><span class="linkable">buf_init</span>(FullTransactionId xmin, FullTransactionId xmax)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L68" title="utils/adt/xid8funcs.c:68">pg_snapshot</a> snap;<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snap.xmin = xmin;<br/></li>
<li>&nbsp; &nbsp; snap.xmax = xmax;<br/></li>
<li>&nbsp; &nbsp; snap.nxip = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; buf = makeStringInfo();<br/></li>
<li>&nbsp; &nbsp; appendBinaryStringInfo(buf, &amp;snap, <a href="#L70" title="utils/adt/xid8funcs.c:70">PG_SNAPSHOT_SIZE</a>(<span class="Constant">0</span>));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> buf;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L274">&#x200c;</a></span><span class="linkable">buf_add_txid</span>(StringInfo buf, FullTransactionId fxid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L68" title="utils/adt/xid8funcs.c:68">pg_snapshot</a> *snap = (<a href="#L68" title="utils/adt/xid8funcs.c:68">pg_snapshot</a> *) buf-&gt;data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* do this <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> possible realloc */<br/></li>
<li></span>&nbsp; &nbsp; snap-&gt;nxip++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendBinaryStringInfo(buf, &amp;fxid, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(fxid));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <a href="#L68" title="utils/adt/xid8funcs.c:68">pg_snapshot</a> *<br/></li>
<li><a id="L285">&#x200c;</a><span class="linkable">buf_finalize</span>(StringInfo buf)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L68" title="utils/adt/xid8funcs.c:68">pg_snapshot</a> *snap = (<a href="#L68" title="utils/adt/xid8funcs.c:68">pg_snapshot</a> *) buf-&gt;data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(snap, buf-&gt;len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* buf is not needed anymore */<br/></li>
<li></span>&nbsp; &nbsp; buf-&gt;data = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> snap;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> snapshot from cstring<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L68" title="utils/adt/xid8funcs.c:68">pg_snapshot</a> *<br/></li>
<li><a id="L302">&#x200c;</a><span class="linkable">parse_snapshot</span>(<span class="Type">const</span> <span class="Type">char</span> *str, Node *escontext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FullTransactionId xmin;<br/></li>
<li>&nbsp; &nbsp; FullTransactionId xmax;<br/></li>
<li>&nbsp; &nbsp; FullTransactionId last_val = InvalidFullTransactionId;<br/></li>
<li>&nbsp; &nbsp; FullTransactionId val;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *str_start = str;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *endp;<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xmin = FullTransactionIdFromU64(strtou64(str, &amp;endp, <span class="Constant">10</span>));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*endp != <span class="Constant">':'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> bad_format;<br/></li>
<li>&nbsp; &nbsp; str = endp + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xmax = FullTransactionIdFromU64(strtou64(str, &amp;endp, <span class="Constant">10</span>));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*endp != <span class="Constant">':'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> bad_format;<br/></li>
<li>&nbsp; &nbsp; str = endp + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* it should look sane */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!FullTransactionIdIsValid(xmin) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !FullTransactionIdIsValid(xmax) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FullTransactionIdPrecedes(xmax, xmin))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> bad_format;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* allocate buffer */<br/></li>
<li></span>&nbsp; &nbsp; buf = <a href="#L259" title="utils/adt/xid8funcs.c:259">buf_init</a>(xmin, xmax);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* loop over <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (*str != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* read <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; val = FullTransactionIdFromU64(strtou64(str, &amp;endp, <span class="Constant">10</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; str = endp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* require the input to be in order */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (FullTransactionIdPrecedes(val, xmin) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FullTransactionIdFollowsOrEquals(val, xmax) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FullTransactionIdPrecedes(val, last_val))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> bad_format;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> duplicates */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!FullTransactionIdEquals(val, last_val))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L274" title="utils/adt/xid8funcs.c:274">buf_add_txid</a>(buf, val);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; last_val = val;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*str == <span class="Constant">','</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*str != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> bad_format;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L285" title="utils/adt/xid8funcs.c:285">buf_finalize</a>(buf);<br/></li>
<li><br/></li>
<li><span class="Statement">bad_format</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; ereturn(escontext, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid input syntax for type </span><span class="Special">%s</span><span class="Constant">: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;<a href="#L68" title="utils/adt/xid8funcs.c:68">pg_snapshot</a>&quot;</span>, str_start)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L371" title="utils/adt/xid8funcs.c:371">pg_current_xact_id</a>() returns xid8<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Return the current toplevel full transaction ID.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; If the current transaction does not have one, one is assigned.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L371">&#x200c;</a><span class="linkable">pg_current_xact_id</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Must prevent during recovery because if an xid is not assigned we try<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to assign one, which would fail. Programs already rely on this function<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to always return a valid current xid, so we should not change this to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * return NULL or similar invalid xid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../tcop/utility.c.html#L441" title="tcop/utility.c:441">PreventCommandDuringRecovery</a>(<span class="Constant">&quot;<a href="#L371" title="utils/adt/xid8funcs.c:371">pg_current_xact_id</a>()&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FULLTRANSACTIONID(<a href="../../access/transam/xact.c.html#L480" title="access/transam/xact.c:480">GetTopFullTransactionId</a>());<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Same as <a href="#L371" title="utils/adt/xid8funcs.c:371">pg_current_xact_id</a>() but doesn't assign a new xid if there<br/></li>
<li></span><span class="Comment"> * isn't one yet.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L389">&#x200c;</a><span class="linkable">pg_current_xact_id_if_assigned</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FullTransactionId topfxid = <a href="../../access/transam/xact.c.html#L496" title="access/transam/xact.c:496">GetTopFullTransactionIdIfAny</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!FullTransactionIdIsValid(topfxid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FULLTRANSACTIONID(topfxid);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L407" title="utils/adt/xid8funcs.c:407">pg_current_snapshot</a>() returns <a href="#L68" title="utils/adt/xid8funcs.c:68">pg_snapshot</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Return current snapshot<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that only top-transaction XIDs are included in the snapshot.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L407">&#x200c;</a><span class="linkable">pg_current_snapshot</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L68" title="utils/adt/xid8funcs.c:68">pg_snapshot</a> *snap;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; nxip,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; Snapshot&nbsp; &nbsp; cur;<br/></li>
<li>&nbsp; &nbsp; FullTransactionId next_fxid = <a href="../../access/transam/varsup.c.html#L288" title="access/transam/varsup.c:288">ReadNextFullTransactionId</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cur = <a href="../time/snapmgr.c.html#L770" title="utils/time/snapmgr.c:770">GetActiveSnapshot</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cur == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;no active snapshot set&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* allocate */<br/></li>
<li></span>&nbsp; &nbsp; nxip = cur-&gt;xcnt;<br/></li>
<li>&nbsp; &nbsp; snap = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<a href="#L70" title="utils/adt/xid8funcs.c:70">PG_SNAPSHOT_SIZE</a>(nxip));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fill */<br/></li>
<li></span>&nbsp; &nbsp; snap-&gt;xmin = <a href="#L164" title="utils/adt/xid8funcs.c:164">widen_snapshot_xid</a>(cur-&gt;xmin, next_fxid);<br/></li>
<li>&nbsp; &nbsp; snap-&gt;xmax = <a href="#L164" title="utils/adt/xid8funcs.c:164">widen_snapshot_xid</a>(cur-&gt;xmax, next_fxid);<br/></li>
<li>&nbsp; &nbsp; snap-&gt;nxip = nxip;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nxip; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snap-&gt;xip[i] = <a href="#L164" title="utils/adt/xid8funcs.c:164">widen_snapshot_xid</a>(cur-&gt;xip[i], next_fxid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We want them guaranteed to be in ascending order.&nbsp; This also removes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> duplicate xids.&nbsp; Normally, an XID can only be assigned to one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * backend, but when preparing a transaction for two-phase commit, there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is a transient state when both the original backend and the dummy<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * PGPROC entry reserved for the prepared transaction hold the same XID.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L210" title="utils/adt/xid8funcs.c:210">sort_snapshot</a>(snap);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set size after sorting, because it may have removed duplicate xips */<br/></li>
<li></span>&nbsp; &nbsp; SET_VARSIZE(snap, <a href="#L70" title="utils/adt/xid8funcs.c:70">PG_SNAPSHOT_SIZE</a>(snap-&gt;nxip));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(snap);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L451" title="utils/adt/xid8funcs.c:451">pg_snapshot_in</a>(cstring) returns <a href="#L68" title="utils/adt/xid8funcs.c:68">pg_snapshot</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; input function for type <a href="#L68" title="utils/adt/xid8funcs.c:68">pg_snapshot</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L451">&#x200c;</a><span class="linkable">pg_snapshot_in</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *str = PG_GETARG_CSTRING(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L68" title="utils/adt/xid8funcs.c:68">pg_snapshot</a> *snap;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snap = <a href="#L302" title="utils/adt/xid8funcs.c:302">parse_snapshot</a>(str, fcinfo-&gt;context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(snap);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L467" title="utils/adt/xid8funcs.c:467">pg_snapshot_out</a>(<a href="#L68" title="utils/adt/xid8funcs.c:68">pg_snapshot</a>) returns cstring<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; output function for type <a href="#L68" title="utils/adt/xid8funcs.c:68">pg_snapshot</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L467">&#x200c;</a><span class="linkable">pg_snapshot_out</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L68" title="utils/adt/xid8funcs.c:68">pg_snapshot</a> *snap = (<a href="#L68" title="utils/adt/xid8funcs.c:68">pg_snapshot</a> *) PG_GETARG_VARLENA_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; StringInfoData str;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;str);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfo(&amp;str, UINT64_FORMAT <span class="Constant">&quot;:&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; U64FromFullTransactionId(snap-&gt;xmin));<br/></li>
<li>&nbsp; &nbsp; appendStringInfo(&amp;str, UINT64_FORMAT <span class="Constant">&quot;:&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; U64FromFullTransactionId(snap-&gt;xmax));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; snap-&gt;nxip; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(&amp;str, <span class="Constant">','</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;str, UINT64_FORMAT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; U64FromFullTransactionId(snap-&gt;xip[i]));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CSTRING(str.data);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L499" title="utils/adt/xid8funcs.c:499">pg_snapshot_recv</a>(<a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a>) returns <a href="#L68" title="utils/adt/xid8funcs.c:68">pg_snapshot</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; binary input function for type <a href="#L68" title="utils/adt/xid8funcs.c:68">pg_snapshot</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; format: int4 nxip, int8 xmin, int8 xmax, int8 xip<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L499">&#x200c;</a><span class="linkable">pg_snapshot_recv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; buf = (StringInfo) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L68" title="utils/adt/xid8funcs.c:68">pg_snapshot</a> *snap;<br/></li>
<li>&nbsp; &nbsp; FullTransactionId last = InvalidFullTransactionId;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nxip;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; FullTransactionId xmin;<br/></li>
<li>&nbsp; &nbsp; FullTransactionId xmax;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* load and validate nxip */<br/></li>
<li></span>&nbsp; &nbsp; nxip = <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(buf, <span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nxip &lt; <span class="Constant">0</span> || nxip &gt; <a href="#L72" title="utils/adt/xid8funcs.c:72">PG_SNAPSHOT_MAX_NXIP</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> bad_format;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xmin = FullTransactionIdFromU64((uint64) <a href="../../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(buf));<br/></li>
<li>&nbsp; &nbsp; xmax = FullTransactionIdFromU64((uint64) <a href="../../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(buf));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!FullTransactionIdIsValid(xmin) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !FullTransactionIdIsValid(xmax) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FullTransactionIdPrecedes(xmax, xmin))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> bad_format;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snap = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<a href="#L70" title="utils/adt/xid8funcs.c:70">PG_SNAPSHOT_SIZE</a>(nxip));<br/></li>
<li>&nbsp; &nbsp; snap-&gt;xmin = xmin;<br/></li>
<li>&nbsp; &nbsp; snap-&gt;xmax = xmax;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nxip; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FullTransactionId cur =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FullTransactionIdFromU64((uint64) <a href="../../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(buf));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (FullTransactionIdPrecedes(cur, last) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FullTransactionIdPrecedes(cur, xmin) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FullTransactionIdPrecedes(xmax, cur))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> bad_format;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> duplicate xips */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (FullTransactionIdEquals(cur, last))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nxip--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snap-&gt;xip[i] = cur;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; last = cur;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; snap-&gt;nxip = nxip;<br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(snap, <a href="#L70" title="utils/adt/xid8funcs.c:70">PG_SNAPSHOT_SIZE</a>(nxip));<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(snap);<br/></li>
<li><br/></li>
<li><span class="Statement">bad_format</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_BINARY_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid external <a href="#L68" title="utils/adt/xid8funcs.c:68">pg_snapshot</a> data&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(<span class="Constant">NULL</span>);&nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L565" title="utils/adt/xid8funcs.c:565">pg_snapshot_send</a>(<a href="#L68" title="utils/adt/xid8funcs.c:68">pg_snapshot</a>) returns bytea<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; binary output function for type <a href="#L68" title="utils/adt/xid8funcs.c:68">pg_snapshot</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; format: int4 nxip, u64 xmin, u64 xmax, u64 xip...<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L565">&#x200c;</a><span class="linkable">pg_snapshot_send</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L68" title="utils/adt/xid8funcs.c:68">pg_snapshot</a> *snap = (<a href="#L68" title="utils/adt/xid8funcs.c:68">pg_snapshot</a> *) PG_GETARG_VARLENA_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L326" title="libpq/pqformat.c:326">pq_begintypsend</a>(&amp;buf);<br/></li>
<li>&nbsp; &nbsp; pq_sendint32(&amp;buf, snap-&gt;nxip);<br/></li>
<li>&nbsp; &nbsp; pq_sendint64(&amp;buf, (int64) U64FromFullTransactionId(snap-&gt;xmin));<br/></li>
<li>&nbsp; &nbsp; pq_sendint64(&amp;buf, (int64) U64FromFullTransactionId(snap-&gt;xmax));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; snap-&gt;nxip; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pq_sendint64(&amp;buf, (int64) U64FromFullTransactionId(snap-&gt;xip[i]));<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BYTEA_P(<a href="../../libpq/pqformat.c.html#L346" title="libpq/pqformat.c:346">pq_endtypsend</a>(&amp;buf));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L586" title="utils/adt/xid8funcs.c:586">pg_visible_in_snapshot</a>(xid8, <a href="#L68" title="utils/adt/xid8funcs.c:68">pg_snapshot</a>) returns <a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; is txid visible in snapshot ?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L586">&#x200c;</a><span class="linkable">pg_visible_in_snapshot</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FullTransactionId value = PG_GETARG_FULLTRANSACTIONID(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L68" title="utils/adt/xid8funcs.c:68">pg_snapshot</a> *snap = (<a href="#L68" title="utils/adt/xid8funcs.c:68">pg_snapshot</a> *) PG_GETARG_VARLENA_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L224" title="utils/adt/xid8funcs.c:224">is_visible_fxid</a>(value, snap));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L600" title="utils/adt/xid8funcs.c:600">pg_snapshot_xmin</a>(<a href="#L68" title="utils/adt/xid8funcs.c:68">pg_snapshot</a>) returns xid8<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; return snapshot's xmin<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L600">&#x200c;</a><span class="linkable">pg_snapshot_xmin</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L68" title="utils/adt/xid8funcs.c:68">pg_snapshot</a> *snap = (<a href="#L68" title="utils/adt/xid8funcs.c:68">pg_snapshot</a> *) PG_GETARG_VARLENA_P(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FULLTRANSACTIONID(snap-&gt;xmin);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L613" title="utils/adt/xid8funcs.c:613">pg_snapshot_xmax</a>(<a href="#L68" title="utils/adt/xid8funcs.c:68">pg_snapshot</a>) returns xid8<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; return snapshot's xmax<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L613">&#x200c;</a><span class="linkable">pg_snapshot_xmax</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L68" title="utils/adt/xid8funcs.c:68">pg_snapshot</a> *snap = (<a href="#L68" title="utils/adt/xid8funcs.c:68">pg_snapshot</a> *) PG_GETARG_VARLENA_P(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FULLTRANSACTIONID(snap-&gt;xmax);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L626" title="utils/adt/xid8funcs.c:626">pg_snapshot_xip</a>(<a href="#L68" title="utils/adt/xid8funcs.c:68">pg_snapshot</a>) returns setof xid8<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; return in-progress xid8s in snapshot.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L626">&#x200c;</a><span class="linkable">pg_snapshot_xip</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FuncCallContext *fctx;<br/></li>
<li>&nbsp; &nbsp; <a href="#L68" title="utils/adt/xid8funcs.c:68">pg_snapshot</a> *snap;<br/></li>
<li>&nbsp; &nbsp; FullTransactionId value;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* on first call <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> fctx and get copy of snapshot */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (SRF_IS_FIRSTCALL())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L68" title="utils/adt/xid8funcs.c:68">pg_snapshot</a> *arg = (<a href="#L68" title="utils/adt/xid8funcs.c:68">pg_snapshot</a> *) PG_GETARG_VARLENA_P(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fctx = SRF_FIRSTCALL_INIT();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* make a copy of user snapshot */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; snap = <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(fctx-&gt;multi_call_memory_ctx, VARSIZE(arg));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(snap, arg, VARSIZE(arg));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fctx-&gt;user_fctx = snap;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* return <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> one-by-one */<br/></li>
<li></span>&nbsp; &nbsp; fctx = SRF_PERCALL_SETUP();<br/></li>
<li>&nbsp; &nbsp; snap = fctx-&gt;user_fctx;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fctx-&gt;call_cntr &lt; snap-&gt;nxip)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; value = snap-&gt;xip[fctx-&gt;call_cntr];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SRF_RETURN_NEXT(fctx, FullTransactionIdGetDatum(value));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SRF_RETURN_DONE(fctx);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Report the status of a recent transaction ID, or null for wrapped,<br/></li>
<li></span><span class="Comment"> * truncated away or otherwise too old XIDs.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The passed epoch-qualified xid is treated as a normal xid, not a<br/></li>
<li></span><span class="Comment"> * multixact id.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If it points to a committed subxact the result is the subxact status even<br/></li>
<li></span><span class="Comment"> * though the parent xact may still be in progress or may have aborted.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L671">&#x200c;</a><span class="linkable">pg_xact_status</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *status;<br/></li>
<li>&nbsp; &nbsp; FullTransactionId fxid = PG_GETARG_FULLTRANSACTIONID(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TransactionId xid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We must protect against concurrent truncation of clog entries to avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * an I/O error on SLRU lookup.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(XactTruncationLock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../replication/walsender.c.html#L2541" title="replication/walsender.c:2541">TransactionIdInRecentPast</a>(fxid, &amp;xid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(TransactionIdIsValid(xid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Like when doing visibility checks on a row, check whether the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transaction is still in progress <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> looking into the CLOG.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise we would incorrectly return &quot;committed&quot; for a transaction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that is committing and has already updated the CLOG, but hasn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * removed its XID from the proc array yet. (See comment on that race<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * condition at the top of heapam_visibility.c)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/ipc/procarray.c.html#L1390" title="storage/ipc/procarray.c:1390">TransactionIdIsInProgress</a>(xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; status = <span class="Constant">&quot;in progress&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../../access/transam/transam.c.html#L126" title="access/transam/transam.c:126">TransactionIdDidCommit</a>(xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; status = <span class="Constant">&quot;committed&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* it must have aborted or crashed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; status = <span class="Constant">&quot;aborted&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; status = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(XactTruncationLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (status == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_TEXT_P(<a href="varlena.c.html#L184" title="utils/adt/varlena.c:184">cstring_to_text</a>(status));<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
