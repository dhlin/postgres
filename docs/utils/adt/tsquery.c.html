<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/adt/tsquery.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/adt/tsquery.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L29">tsearch_op_priority</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L978">INFIX</a></li>
<li><a href="#L633">OperatorElement</a></li>
<li><a href="#L637">OperatorElement</a></li>
<li><a href="#L78">TSQueryParserStateData</a></li>
<li><a href="#L45">ts_parserstate</a></li>
<li><a href="#L74">ts_tokenizer</a></li>
<li><a href="#L58">ts_tokentype</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L652">cleanOpStack</a></li>
<li><a href="#L788">findoprnd</a></li>
<li><a href="#L730">findoprnd_recurse</a></li>
<li><a href="#L114">get_modifiers</a></li>
<li><a href="#L514">gettoken_query_plain</a></li>
<li><a href="#L286">gettoken_query_standard</a></li>
<li><a href="#L398">gettoken_query_websearch</a></li>
<li><a href="#L995">infix</a></li>
<li><a href="#L676">makepol</a></li>
<li><a href="#L244">parse_or_operator</a></li>
<li><a href="#L165">parse_phrase_operator</a></li>
<li><a href="#L821">parse_tsquery</a></li>
<li><a href="#L640">pushOpStack</a></li>
<li><a href="#L535">pushOperator</a></li>
<li><a href="#L620">pushStop</a></li>
<li><a href="#L584">pushValue</a></li>
<li><a href="#L551">pushValue_internal</a></li>
<li><a href="#L946">pushval_asis</a></li>
<li><a href="#L956">tsqueryin</a></li>
<li><a href="#L1150">tsqueryout</a></li>
<li><a href="#L1230">tsqueryrecv</a></li>
<li><a href="#L1192">tsquerysend</a></li>
<li><a href="#L1366">tsquerytree</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L981">RESIZEBUF</a></li>
<li><a href="#L631">STACKDEPTH</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * tsquery.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; I/O <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for tsquery<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/adt/tsquery.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;libpq/pqformat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/miscnodes.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;tsearch/ts_locale.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;tsearch/ts_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;tsearch/ts_utils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/pg_crc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;varatt.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* FTS operator priorities, see ts_type.h */<br/></li>
<li><a id="L29">&#x200c;</a></span><span class="Type">const</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">tsearch_op_priority</span>[OP_COUNT] =<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Constant">4</span>,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OP_NOT */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Constant">2</span>,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OP_AND */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Constant">1</span>,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OP_OR */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Constant">3</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OP_PHRASE */<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * parser's states<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">enum<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; WAITOPERAND = <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; WAITOPERATOR = <span class="Constant">2</span>,<br/></li>
<li>&nbsp; &nbsp; WAITFIRSTOPERAND = <span class="Constant">3</span>,<br/></li>
<li><a id="L45">&#x200c;</a>} <span class="linkable">ts_parserstate</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * token types for parsing<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">enum<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; PT_END = <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; PT_ERR = <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; PT_VAL = <span class="Constant">2</span>,<br/></li>
<li>&nbsp; &nbsp; PT_OPR = <span class="Constant">3</span>,<br/></li>
<li>&nbsp; &nbsp; PT_OPEN = <span class="Constant">4</span>,<br/></li>
<li>&nbsp; &nbsp; PT_CLOSE = <span class="Constant">5</span>,<br/></li>
<li><a id="L58">&#x200c;</a>} <span class="linkable">ts_tokentype</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * get token from query string<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * All arguments except &quot;state&quot; are output arguments.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If return value is PT_OPR, then *operator is filled with an OP_* code<br/></li>
<li></span><span class="Comment"> * and *weight will contain a distance value in case of phrase operator.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If return value is PT_VAL, then *lenval, *strval, *weight, and *prefix<br/></li>
<li></span><span class="Comment"> * are filled.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If PT_ERR is returned then a soft error has occurred.&nbsp; If state-&gt;escontext<br/></li>
<li></span><span class="Comment"> * isn't already filled then this should be reported as a generic <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> error.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L74">&#x200c;</a></span><span class="Type">typedef</span> <a href="#L58" title="utils/adt/tsquery.c:58">ts_tokentype</a> (*<span class="linkable">ts_tokenizer</span>) (TSQueryParserState state, int8 *operator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> *lenval, <span class="Type">char</span> **strval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int16 *weight, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *prefix);<br/></li>
<li><br/></li>
<li><a id="L78">&#x200c;</a><span class="Type">struct</span> <span class="linkable">TSQueryParserStateData</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Tokenizer used for parsing tsquery */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L74" title="utils/adt/tsquery.c:74">ts_tokenizer</a> gettoken;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* State of tokenizer function */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *buffer;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* entire string we are scanning */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *buf;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* current scan point */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nesting count, incremented by (,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * decremented by ) */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L45" title="utils/adt/tsquery.c:45">ts_parserstate</a> state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* polish (prefix) notation in list, filled in by <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a>* <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *polstr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Strings from operands are collected in op. curop is a pointer to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * end of used space of op.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *op;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *curop;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lenop;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* allocated size of op */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sumlen;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* used size of op */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* state for value's parser */<br/></li>
<li></span>&nbsp; &nbsp; TSVectorParseState valstate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* context object for soft errors - must match valstate's escontext */<br/></li>
<li></span>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *escontext;<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * subroutine to <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> the modifiers (weight and prefix flag currently)<br/></li>
<li></span><span class="Comment"> * part, like ':AB*' of a query.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L114">&#x200c;</a><span class="linkable">get_modifiers</span>(<span class="Type">char</span> *buf, int16 *weight, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *prefix)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; *weight = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; *prefix = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!t_iseq(buf, <span class="Constant">':'</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; buf++;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (*buf &amp;&amp; <a href="../mb/mbutils.c.html#L1023" title="utils/mb/mbutils.c:1023">pg_mblen</a>(buf) == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (*buf)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'a'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'A'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *weight |= <span class="Constant">1</span> &lt;&lt; <span class="Constant">3</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'b'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'B'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *weight |= <span class="Constant">1</span> &lt;&lt; <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'c'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'C'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *weight |= <span class="Constant">1</span> &lt;&lt; <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'d'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'D'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *weight |= <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'*'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *prefix = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> buf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> buf;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Parse phrase operator. The operator<br/></li>
<li></span><span class="Comment"> * may take the following forms:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; a &lt;N&gt; b (distance is exactly N lexemes)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; a &lt;-&gt; b (default distance = 1)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The buffer should begin with '&lt;' char<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L165">&#x200c;</a></span><span class="linkable">parse_phrase_operator</span>(TSQueryParserState pstate, int16 *distance)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">enum<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PHRASE_OPEN = <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PHRASE_DIST,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PHRASE_CLOSE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PHRASE_FINISH<br/></li>
<li>&nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state = PHRASE_OPEN;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ptr = pstate-&gt;buf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *endptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; l = <span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* default distance */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (*ptr)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (state)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PHRASE_OPEN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (t_iseq(ptr, <span class="Constant">'&lt;'</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state = PHRASE_DIST;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PHRASE_DIST:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (t_iseq(ptr, <span class="Constant">'-'</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state = PHRASE_CLOSE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../tsearch/ts_locale.c.html#L35" title="tsearch/ts_locale.c:35">t_isdigit</a>(ptr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l = strtol(ptr, &amp;endptr, <span class="Constant">10</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ptr == endptr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (errno == <span class="Constant">ERANGE</span> || l &lt; <span class="Constant">0</span> || l &gt; MAXENTRYPOS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(pstate-&gt;escontext, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;distance in phrase operator must be an integer value between zero and </span><span class="Special">%d</span><span class="Constant"> inclusive&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MAXENTRYPOS)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state = PHRASE_CLOSE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr = endptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PHRASE_CLOSE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (t_iseq(ptr, <span class="Constant">'&gt;'</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state = PHRASE_FINISH;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PHRASE_FINISH:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *distance = (int16) l;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pstate-&gt;buf = ptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Parse OR operator used in <a href="../../tsearch/to_tsany.c.html#L718" title="tsearch/to_tsany.c:718">websearch_to_tsquery</a>(), returns true if we<br/></li>
<li></span><span class="Comment"> * believe that &quot;OR&quot; literal could be an operator OR<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L244">&#x200c;</a></span><span class="linkable">parse_or_operator</span>(TSQueryParserState pstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ptr = pstate-&gt;buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* it should begin with &quot;OR&quot; literal */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pg_strncasecmp(ptr, <span class="Constant">&quot;or&quot;</span>, <span class="Constant">2</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ptr += <span class="Constant">2</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it shouldn't be a part of <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> but somewhere later it should be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * some operand<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (*ptr == <span class="Special">'\0'</span>)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no operand */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* it shouldn't be a part of <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (t_iseq(ptr, <span class="Constant">'-'</span>) || t_iseq(ptr, <span class="Constant">'<a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>'</span>) || <a href="../../tsearch/ts_locale.c.html#L80" title="tsearch/ts_locale.c:80">t_isalnum</a>(ptr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr += <a href="../mb/mbutils.c.html#L1023" title="utils/mb/mbutils.c:1023">pg_mblen</a>(ptr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*ptr == <span class="Special">'\0'</span>)&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* got end of string without operand */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Suppose, we found an operand, but could be a not correct operand.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * So we still treat OR literal as operation with possibly incorrect<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * operand and will not search it as lexeme<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../tsearch/ts_locale.c.html#L50" title="tsearch/ts_locale.c:50">t_isspace</a>(ptr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pstate-&gt;buf += <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <a href="#L58" title="utils/adt/tsquery.c:58">ts_tokentype</a><br/></li>
<li><a id="L286">&#x200c;</a><span class="linkable">gettoken_query_standard</span>(TSQueryParserState state, int8 *operator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> *lenval, <span class="Type">char</span> **strval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int16 *weight, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *prefix)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; *weight = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; *prefix = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<span class="Constant">true</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (state-&gt;state)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WAITFIRSTOPERAND:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WAITOPERAND:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (t_iseq(state-&gt;buf, <span class="Constant">'!'</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;buf++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;state = WAITOPERAND;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *operator = OP_NOT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PT_OPR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (t_iseq(state-&gt;buf, <span class="Constant">'('</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;buf++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;state = WAITOPERAND;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;count++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PT_OPEN;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (t_iseq(state-&gt;buf, <span class="Constant">':'</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* generic syntax error message is fine */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PT_ERR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!<a href="../../tsearch/ts_locale.c.html#L50" title="tsearch/ts_locale.c:50">t_isspace</a>(state-&gt;buf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We rely on the tsvector parser to <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> the value for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * us<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="tsvector_parser.c.html#L81" title="utils/adt/tsvector_parser.c:81">reset_tsvector_parser</a>(state-&gt;valstate, state-&gt;buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="tsvector_parser.c.html#L176" title="utils/adt/tsvector_parser.c:176">gettoken_tsvector</a>(state-&gt;valstate, strval, lenval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">NULL</span>, &amp;state-&gt;buf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;buf = <a href="#L114" title="utils/adt/tsquery.c:114">get_modifiers</a>(state-&gt;buf, weight, prefix);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;state = WAITOPERATOR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PT_VAL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (SOFT_ERROR_OCCURRED(state-&gt;escontext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="tsvector_parser.c.html#L176" title="utils/adt/tsvector_parser.c:176">gettoken_tsvector</a> reported a soft error */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PT_ERR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (state-&gt;state == WAITFIRSTOPERAND)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PT_END;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(state-&gt;escontext, PT_ERR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;no operand in tsquery: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;buffer)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WAITOPERATOR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (t_iseq(state-&gt;buf, <span class="Constant">'&amp;'</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;buf++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;state = WAITOPERAND;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *operator = OP_AND;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PT_OPR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (t_iseq(state-&gt;buf, <span class="Constant">'|'</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;buf++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;state = WAITOPERAND;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *operator = OP_OR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PT_OPR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L165" title="utils/adt/tsquery.c:165">parse_phrase_operator</a>(state, weight))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* weight var is used as storage for distance */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;state = WAITOPERAND;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *operator = OP_PHRASE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PT_OPR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (SOFT_ERROR_OCCURRED(state-&gt;escontext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L165" title="utils/adt/tsquery.c:165">parse_phrase_operator</a> reported a soft error */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PT_ERR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (t_iseq(state-&gt;buf, <span class="Constant">')'</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;buf++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;count--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (state-&gt;count &lt; <span class="Constant">0</span>) ? PT_ERR : PT_CLOSE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*state-&gt;buf == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (state-&gt;count) ? PT_ERR : PT_END;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!<a href="../../tsearch/ts_locale.c.html#L50" title="tsearch/ts_locale.c:50">t_isspace</a>(state-&gt;buf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PT_ERR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;buf += <a href="../mb/mbutils.c.html#L1023" title="utils/mb/mbutils.c:1023">pg_mblen</a>(state-&gt;buf);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <a href="#L58" title="utils/adt/tsquery.c:58">ts_tokentype</a><br/></li>
<li><a id="L398">&#x200c;</a><span class="linkable">gettoken_query_websearch</span>(TSQueryParserState state, int8 *operator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> *lenval, <span class="Type">char</span> **strval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; int16 *weight, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *prefix)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; *weight = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; *prefix = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<span class="Constant">true</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (state-&gt;state)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WAITFIRSTOPERAND:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WAITOPERAND:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (t_iseq(state-&gt;buf, <span class="Constant">'-'</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;buf++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;state = WAITOPERAND;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *operator = OP_NOT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PT_OPR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (t_iseq(state-&gt;buf, <span class="Constant">'&quot;'</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Everything in quotes is processed as a single token */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> opening quote */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;buf++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *strval = state-&gt;buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* iterate to the closing quote or end of the string */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (*state-&gt;buf != <span class="Special">'\0'</span> &amp;&amp; !t_iseq(state-&gt;buf, <span class="Constant">'&quot;'</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;buf++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *lenval = state-&gt;buf - *strval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> closing quote if not end of the string */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*state-&gt;buf != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;buf++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;state = WAITOPERATOR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;count++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PT_VAL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (ISOPERATOR(state-&gt;buf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* or else <a href="tsvector_parser.c.html#L176" title="utils/adt/tsvector_parser.c:176">gettoken_tsvector</a>() will raise an error */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;buf++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;state = WAITOPERAND;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!<a href="../../tsearch/ts_locale.c.html#L50" title="tsearch/ts_locale.c:50">t_isspace</a>(state-&gt;buf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We rely on the tsvector parser to <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> the value for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * us<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="tsvector_parser.c.html#L81" title="utils/adt/tsvector_parser.c:81">reset_tsvector_parser</a>(state-&gt;valstate, state-&gt;buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="tsvector_parser.c.html#L176" title="utils/adt/tsvector_parser.c:176">gettoken_tsvector</a>(state-&gt;valstate, strval, lenval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">NULL</span>, &amp;state-&gt;buf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;state = WAITOPERATOR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PT_VAL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (SOFT_ERROR_OCCURRED(state-&gt;escontext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="tsvector_parser.c.html#L176" title="utils/adt/tsvector_parser.c:176">gettoken_tsvector</a> reported a soft error */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PT_ERR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (state-&gt;state == WAITFIRSTOPERAND)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PT_END;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* finally, we have to provide an operand */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L620" title="utils/adt/tsquery.c:620">pushStop</a>(state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PT_END;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WAITOPERATOR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (t_iseq(state-&gt;buf, <span class="Constant">'&quot;'</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * put implicit AND after an operand and handle this quote<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in WAITOPERAND<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;state = WAITOPERAND;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *operator = OP_AND;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PT_OPR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L244" title="utils/adt/tsquery.c:244">parse_or_operator</a>(state))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;state = WAITOPERAND;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *operator = OP_OR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PT_OPR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*state-&gt;buf == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PT_END;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!<a href="../../tsearch/ts_locale.c.html#L50" title="tsearch/ts_locale.c:50">t_isspace</a>(state-&gt;buf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* put implicit AND after an operand */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *operator = OP_AND;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;state = WAITOPERAND;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PT_OPR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;buf += <a href="../mb/mbutils.c.html#L1023" title="utils/mb/mbutils.c:1023">pg_mblen</a>(state-&gt;buf);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <a href="#L58" title="utils/adt/tsquery.c:58">ts_tokentype</a><br/></li>
<li><a id="L514">&#x200c;</a><span class="linkable">gettoken_query_plain</span>(TSQueryParserState state, int8 *operator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> *lenval, <span class="Type">char</span> **strval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; int16 *weight, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *prefix)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; *weight = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; *prefix = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*state-&gt;buf == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PT_END;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *strval = state-&gt;buf;<br/></li>
<li>&nbsp; &nbsp; *lenval = strlen(state-&gt;buf);<br/></li>
<li>&nbsp; &nbsp; state-&gt;buf += *lenval;<br/></li>
<li>&nbsp; &nbsp; state-&gt;count++;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> PT_VAL;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Push an operator to state-&gt;polstr<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L535">&#x200c;</a></span><span class="linkable">pushOperator</span>(TSQueryParserState state, int8 <a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a>, int16 distance)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; QueryOperator *tmp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a> == OP_NOT || <a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a> == OP_AND || <a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a> == OP_OR || <a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a> == OP_PHRASE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tmp = (QueryOperator *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(QueryOperator));<br/></li>
<li>&nbsp; &nbsp; tmp-&gt;type = QI_OPR;<br/></li>
<li>&nbsp; &nbsp; tmp-&gt;<a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a> = <a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a>;<br/></li>
<li>&nbsp; &nbsp; tmp-&gt;distance = (<a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a> == OP_PHRASE) ? distance : <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* left is filled in later with <a href="#L788" title="utils/adt/tsquery.c:788">findoprnd</a> */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; state-&gt;polstr = <a href="../../nodes/list.c.html#L495" title="nodes/list.c:495">lcons</a>(tmp, state-&gt;polstr);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L551">&#x200c;</a></span><span class="linkable">pushValue_internal</span>(TSQueryParserState state, pg_crc32 valcrc, <span class="Type">int</span> distance, <span class="Type">int</span> lenval, <span class="Type">int</span> weight, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> prefix)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; QueryOperand *tmp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (distance &gt;= MAXSTRPOS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereturn(state-&gt;escontext,,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;value is too big in tsquery: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;buffer)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lenval &gt;= MAXSTRLEN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereturn(state-&gt;escontext,,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;operand is too long in tsquery: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;buffer)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tmp = (QueryOperand *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(QueryOperand));<br/></li>
<li>&nbsp; &nbsp; tmp-&gt;type = QI_VAL;<br/></li>
<li>&nbsp; &nbsp; tmp-&gt;weight = weight;<br/></li>
<li>&nbsp; &nbsp; tmp-&gt;prefix = prefix;<br/></li>
<li>&nbsp; &nbsp; tmp-&gt;valcrc = (int32) valcrc;<br/></li>
<li>&nbsp; &nbsp; tmp-&gt;length = lenval;<br/></li>
<li>&nbsp; &nbsp; tmp-&gt;distance = distance;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;polstr = <a href="../../nodes/list.c.html#L495" title="nodes/list.c:495">lcons</a>(tmp, state-&gt;polstr);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Push an operand to state-&gt;polstr.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * strval must point to a string <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to state-&gt;curop. lenval is the length<br/></li>
<li></span><span class="Comment"> * of the string.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L584">&#x200c;</a></span><span class="linkable">pushValue</span>(TSQueryParserState state, <span class="Type">char</span> *strval, <span class="Type">int</span> lenval, int16 weight, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> prefix)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pg_crc32&nbsp; &nbsp; valcrc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lenval &gt;= MAXSTRLEN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereturn(state-&gt;escontext,,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;<a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> is too long in tsquery: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;buffer)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; INIT_LEGACY_CRC32(valcrc);<br/></li>
<li>&nbsp; &nbsp; COMP_LEGACY_CRC32(valcrc, strval, lenval);<br/></li>
<li>&nbsp; &nbsp; FIN_LEGACY_CRC32(valcrc);<br/></li>
<li>&nbsp; &nbsp; <a href="#L551" title="utils/adt/tsquery.c:551">pushValue_internal</a>(state, valcrc, state-&gt;curop - state-&gt;op, lenval, weight, prefix);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* append the value string to state.op, enlarging buffer if needed first */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (state-&gt;curop - state-&gt;op + lenval + <span class="Constant">1</span> &gt;= state-&gt;lenop)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; used = state-&gt;curop - state-&gt;op;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;lenop *= <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;op = (<span class="Type">char</span> *) <a href="../mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(state-&gt;op, state-&gt;lenop);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;curop = state-&gt;op + used;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; memcpy(state-&gt;curop, strval, lenval);<br/></li>
<li>&nbsp; &nbsp; state-&gt;curop += lenval;<br/></li>
<li>&nbsp; &nbsp; *(state-&gt;curop) = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;curop++;<br/></li>
<li>&nbsp; &nbsp; state-&gt;sumlen += lenval + <span class="Constant">1</span> <span class="Comment">/* \0 */</span> ;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Push a stopword placeholder to state-&gt;polstr<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L620">&#x200c;</a></span><span class="linkable">pushStop</span>(TSQueryParserState state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; QueryOperand *tmp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tmp = (QueryOperand *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(QueryOperand));<br/></li>
<li>&nbsp; &nbsp; tmp-&gt;type = QI_VALSTOP;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;polstr = <a href="../../nodes/list.c.html#L495" title="nodes/list.c:495">lcons</a>(tmp, state-&gt;polstr);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L631">&#x200c;</a><span class="PreProc">#define <span class="linkable">STACKDEPTH</span>&nbsp; &nbsp; </span><span class="Constant">32<br/></li>
<li></span><br/></li>
<li><a id="L633">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">OperatorElement</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int8&nbsp; &nbsp; &nbsp; &nbsp; op;<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; distance;<br/></li>
<li><a id="L637">&#x200c;</a>} <span class="linkable">OperatorElement</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L640">&#x200c;</a></span><span class="linkable">pushOpStack</span>(<a href="#L633" title="utils/adt/tsquery.c:633">OperatorElement</a> *stack, <span class="Type">int</span> *lenstack, int8 op, int16 distance)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*lenstack == <a href="#L631" title="utils/adt/tsquery.c:631">STACKDEPTH</a>)&nbsp; &nbsp; <span class="Comment">/* <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> error */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;tsquery stack too small&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; stack[*lenstack].op = op;<br/></li>
<li>&nbsp; &nbsp; stack[*lenstack].distance = distance;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; (*lenstack)++;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L652">&#x200c;</a></span><span class="linkable">cleanOpStack</span>(TSQueryParserState state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L633" title="utils/adt/tsquery.c:633">OperatorElement</a> *stack, <span class="Type">int</span> *lenstack, int8 op)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opPriority = OP_PRIORITY(op);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (*lenstack)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* NOT is right associative unlike to others */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((op != OP_NOT &amp;&amp; opPriority &gt; OP_PRIORITY(stack[*lenstack - <span class="Constant">1</span>].op)) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (op == OP_NOT &amp;&amp; opPriority &gt;= OP_PRIORITY(stack[*lenstack - <span class="Constant">1</span>].op)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (*lenstack)--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L535" title="utils/adt/tsquery.c:535">pushOperator</a>(state, stack[*lenstack].op,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; stack[*lenstack].distance);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Make polish (prefix) notation of query.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See <a href="#L821" title="utils/adt/tsquery.c:821">parse_tsquery</a> for explanation of pushval.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L676">&#x200c;</a></span><span class="linkable">makepol</span>(TSQueryParserState state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PushFunction pushval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum opaque)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int8&nbsp; &nbsp; &nbsp; &nbsp; operator = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L58" title="utils/adt/tsquery.c:58">ts_tokentype</a> type;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lenval = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *strval = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L633" title="utils/adt/tsquery.c:633">OperatorElement</a> opstack[<a href="#L631" title="utils/adt/tsquery.c:631">STACKDEPTH</a>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lenstack = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; weight = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; prefix;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* since this function recurses, it could be driven to stack overflow */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((type = state-&gt;gettoken(state, &amp;operator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;lenval, &amp;strval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;weight, &amp;prefix)) != PT_END)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (type)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PT_VAL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pushval(opaque, state, strval, lenval, weight, prefix);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PT_OPR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L652" title="utils/adt/tsquery.c:652">cleanOpStack</a>(state, opstack, &amp;lenstack, operator);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L640" title="utils/adt/tsquery.c:640">pushOpStack</a>(opstack, &amp;lenstack, operator, weight);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PT_OPEN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L676" title="utils/adt/tsquery.c:676">makepol</a>(state, pushval, opaque);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PT_CLOSE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L652" title="utils/adt/tsquery.c:652">cleanOpStack</a>(state, opstack, &amp;lenstack, OP_OR <span class="Comment">/* lowest */</span> );<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PT_ERR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* don't overwrite a soft error saved by gettoken function */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!SOFT_ERROR_OCCURRED(state-&gt;escontext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errsave(state-&gt;escontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;syntax error in tsquery: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;buffer)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* detect soft error in pushval or recursion */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (SOFT_ERROR_OCCURRED(state-&gt;escontext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L652" title="utils/adt/tsquery.c:652">cleanOpStack</a>(state, opstack, &amp;lenstack, OP_OR <span class="Comment">/* lowest */</span> );<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L730">&#x200c;</a></span><span class="linkable">findoprnd_recurse</span>(QueryItem *ptr, uint32 *pos, <span class="Type">int</span> nnodes, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *needcleanup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* since this function recurses, it could be driven to stack overflow. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*pos &gt;= nnodes)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;malformed tsquery: operand not found&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ptr[*pos].type == QI_VAL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (*pos)++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (ptr[*pos].type == QI_VALSTOP)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *needcleanup = <span class="Constant">true</span>;&nbsp; &nbsp; <span class="Comment">/* we'll have to remove stop words */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; (*pos)++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(ptr[*pos].type == QI_OPR);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ptr[*pos].qoperator.<a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a> == OP_NOT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr[*pos].qoperator.left = <span class="Constant">1</span>;&nbsp; &nbsp; <span class="Comment">/* fixed offset */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (*pos)++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* process the only argument */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L730" title="utils/adt/tsquery.c:730">findoprnd_recurse</a>(ptr, pos, nnodes, needcleanup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QueryOperator *curitem = &amp;ptr[*pos].qoperator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp = *pos; <span class="Comment">/* save current position */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(curitem-&gt;<a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a> == OP_AND ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; curitem-&gt;<a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a> == OP_OR ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; curitem-&gt;<a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a> == OP_PHRASE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (*pos)++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* process RIGHT argument */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L730" title="utils/adt/tsquery.c:730">findoprnd_recurse</a>(ptr, pos, nnodes, needcleanup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curitem-&gt;left = *pos - tmp; <span class="Comment">/* set LEFT arg's offset */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* process LEFT argument */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L730" title="utils/adt/tsquery.c:730">findoprnd_recurse</a>(ptr, pos, nnodes, needcleanup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Fill in the left-fields previously left unfilled.<br/></li>
<li></span><span class="Comment"> * The input QueryItems must be in polish (prefix) notation.<br/></li>
<li></span><span class="Comment"> * Also, set *needcleanup to true if there are <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> QI_VALSTOP nodes.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L788">&#x200c;</a></span><span class="linkable">findoprnd</span>(QueryItem *ptr, <span class="Type">int</span> size, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *needcleanup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; pos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *needcleanup = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pos = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L730" title="utils/adt/tsquery.c:730">findoprnd_recurse</a>(ptr, &amp;pos, size, needcleanup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pos != size)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;malformed tsquery: extra nodes&quot;</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Parse the tsquery stored in &quot;buf&quot;.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Each value (operand) in the query is passed to pushval. pushval can<br/></li>
<li></span><span class="Comment"> * transform the simple value to an arbitrarily complex expression using<br/></li>
<li></span><span class="Comment"> * <a href="#L584" title="utils/adt/tsquery.c:584">pushValue</a> and <a href="#L535" title="utils/adt/tsquery.c:535">pushOperator</a>. It must <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> a single value with <a href="#L584" title="utils/adt/tsquery.c:584">pushValue</a>,<br/></li>
<li></span><span class="Comment"> * a complete expression with all operands, or a stopword placeholder<br/></li>
<li></span><span class="Comment"> * with <a href="#L620" title="utils/adt/tsquery.c:620">pushStop</a>, otherwise the prefix notation representation will be broken,<br/></li>
<li></span><span class="Comment"> * having an operator with no operand.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * opaque is passed on to pushval as is, pushval can use it to store its<br/></li>
<li></span><span class="Comment"> * private state.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The pushval function can record soft errors via escontext.<br/></li>
<li></span><span class="Comment"> * Callers must check SOFT_ERROR_OCCURRED to detect that.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A bitmask of flags (see ts_utils.h) and an error context object<br/></li>
<li></span><span class="Comment"> * can be provided as well.&nbsp; If a soft error occurs, NULL is returned.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TSQuery<br/></li>
<li><a id="L821">&#x200c;</a><span class="linkable">parse_tsquery</span>(<span class="Type">char</span> *buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PushFunction pushval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum opaque,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> flags,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node *escontext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L78" title="utils/adt/tsquery.c:78">TSQueryParserStateData</a> state;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; TSQuery&nbsp; &nbsp; &nbsp; &nbsp; query;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; commonlen;<br/></li>
<li>&nbsp; &nbsp; QueryItem&nbsp; *ptr;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *cell;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; noisy;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; needcleanup;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tsv_flags = P_TSV_OPR_IS_DELIM | P_TSV_IS_TSQUERY;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* plain should not be used with web */<br/></li>
<li></span>&nbsp; &nbsp; Assert((flags &amp; (P_TSQ_PLAIN | P_TSQ_WEB)) != (P_TSQ_PLAIN | P_TSQ_WEB));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> suitable tokenizer */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (flags &amp; P_TSQ_PLAIN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state.gettoken = <a href="#L514" title="utils/adt/tsquery.c:514">gettoken_query_plain</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (flags &amp; P_TSQ_WEB)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state.gettoken = <a href="#L398" title="utils/adt/tsquery.c:398">gettoken_query_websearch</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tsv_flags |= P_TSV_IS_WEB;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; state.gettoken = <a href="#L286" title="utils/adt/tsquery.c:286">gettoken_query_standard</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* emit nuisance NOTICEs only if not doing soft errors */<br/></li>
<li></span>&nbsp; &nbsp; noisy = !(escontext &amp;&amp; IsA(escontext, ErrorSaveContext));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* init state */<br/></li>
<li></span>&nbsp; &nbsp; state.buffer = buf;<br/></li>
<li>&nbsp; &nbsp; state.buf = buf;<br/></li>
<li>&nbsp; &nbsp; state.count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; state.state = WAITFIRSTOPERAND;<br/></li>
<li>&nbsp; &nbsp; state.polstr = NIL;<br/></li>
<li>&nbsp; &nbsp; state.escontext = escontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* init value parser's state */<br/></li>
<li></span>&nbsp; &nbsp; state.valstate = <a href="tsvector_parser.c.html#L57" title="utils/adt/tsvector_parser.c:57">init_tsvector_parser</a>(state.buffer, tsv_flags, escontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* init list of operand */<br/></li>
<li></span>&nbsp; &nbsp; state.sumlen = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; state.lenop = <span class="Constant">64</span>;<br/></li>
<li>&nbsp; &nbsp; state.curop = state.op = (<span class="Type">char</span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(state.lenop);<br/></li>
<li>&nbsp; &nbsp; *(state.curop) = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> query &amp; make polish notation (postfix, but in reverse order) */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L676" title="utils/adt/tsquery.c:676">makepol</a>(&amp;state, pushval, opaque);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="tsvector_parser.c.html#L90" title="utils/adt/tsvector_parser.c:90">close_tsvector_parser</a>(state.valstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (SOFT_ERROR_OCCURRED(escontext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state.polstr == NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (noisy)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(NOTICE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;text-search query doesn't contain lexemes: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state.buffer)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; query = (TSQuery) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(HDRSIZETQ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SET_VARSIZE(query, HDRSIZETQ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; query-&gt;size = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> query;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (TSQUERY_TOO_BIG(list_length(state.polstr), state.sumlen))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;tsquery is too large&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; commonlen = COMPUTESIZE(list_length(state.polstr), state.sumlen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Pack the QueryItems in the final TSQuery struct to return to caller */<br/></li>
<li></span>&nbsp; &nbsp; query = (TSQuery) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(commonlen);<br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(query, commonlen);<br/></li>
<li>&nbsp; &nbsp; query-&gt;size = list_length(state.polstr);<br/></li>
<li>&nbsp; &nbsp; ptr = GETQUERY(query);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Copy QueryItems to TSQuery */<br/></li>
<li></span>&nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(cell, state.polstr)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; QueryItem&nbsp; *item = (QueryItem *) lfirst(cell);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (item-&gt;type)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> QI_VAL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;ptr[i], item, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(QueryOperand));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> QI_VALSTOP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr[i].type = QI_VALSTOP;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> QI_OPR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;ptr[i], item, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(QueryOperator));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized QueryItem type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, item-&gt;type);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Copy all the operand strings to TSQuery */<br/></li>
<li></span>&nbsp; &nbsp; memcpy(GETOPERAND(query), state.op, state.sumlen);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(state.op);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set left operand pointers for every operator.&nbsp; While we're at it,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * detect whether there are <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> QI_VALSTOP nodes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L788" title="utils/adt/tsquery.c:788">findoprnd</a>(ptr, query-&gt;size, &amp;needcleanup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there are QI_VALSTOP nodes, delete them and simplify the tree.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (needcleanup)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; query = <a href="tsquery_cleanup.c.html#L387" title="utils/adt/tsquery_cleanup.c:387">cleanup_tsquery_stopwords</a>(query, noisy);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> query;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L946">&#x200c;</a></span><span class="linkable">pushval_asis</span>(Datum opaque, TSQueryParserState state, <span class="Type">char</span> *strval, <span class="Type">int</span> lenval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; int16 weight, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> prefix)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L584" title="utils/adt/tsquery.c:584">pushValue</a>(state, strval, lenval, weight, prefix);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * in without morphology<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L956">&#x200c;</a><span class="linkable">tsqueryin</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *in = PG_GETARG_CSTRING(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *escontext = fcinfo-&gt;context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TSQUERY(<a href="#L821" title="utils/adt/tsquery.c:821">parse_tsquery</a>(in,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L946" title="utils/adt/tsquery.c:946">pushval_asis</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(<span class="Constant">NULL</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; escontext));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * out function<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; QueryItem&nbsp; *curpol;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *buf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *cur;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *op;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buflen;<br/></li>
<li><a id="L978">&#x200c;</a>} <span class="linkable">INFIX</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Makes sure inf-&gt;buf is large enough for adding 'addsize' bytes */<br/></li>
<li><a id="L981">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RESIZEBUF</span>(inf, addsize) \<br/></li>
<li></span><span class="Statement">while</span><span class="PreProc">( ( (inf)-&gt;cur - (inf)-&gt;buf ) + (addsize) + </span><span class="Constant">1</span><span class="PreProc"> &gt;= (inf)-&gt;buflen ) \<br/></li>
<li></span><span class="PreProc">{ \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Type">int</span><span class="PreProc"> len = (inf)-&gt;cur - (inf)-&gt;buf; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (inf)-&gt;buflen *= </span><span class="Constant">2</span><span class="PreProc">; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (inf)-&gt;buf = (</span><span class="Type">char</span><span class="PreProc">*) <a href="../mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>( (</span><span class="Type">void</span><span class="PreProc">*)(inf)-&gt;buf, (inf)-&gt;buflen ); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (inf)-&gt;cur = (inf)-&gt;buf + len; \<br/></li>
<li></span><span class="PreProc">}<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * recursively traverse the tree and<br/></li>
<li></span><span class="Comment"> * <a href="../../nodes/print.c.html#L36" title="nodes/print.c:36">print</a> it in <a href="#L995" title="utils/adt/tsquery.c:995">infix</a> (human-readable) form<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L995">&#x200c;</a></span><span class="linkable">infix</span>(<a href="#L978" title="utils/adt/tsquery.c:978">INFIX</a> *in, <span class="Type">int</span> parentPriority, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> rightPhraseOp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* since this function recurses, it could be driven to stack overflow. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (in-&gt;curpol-&gt;type == QI_VAL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; QueryOperand *curpol = &amp;in-&gt;curpol-&gt;qoperand;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *op = in-&gt;op + curpol-&gt;distance;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L981" title="utils/adt/tsquery.c:981">RESIZEBUF</a>(in, curpol-&gt;length * (<a href="../mb/mbutils.c.html#L1546" title="utils/mb/mbutils.c:1546">pg_database_encoding_max_length</a>() + <span class="Constant">1</span>) + <span class="Constant">2</span> + <span class="Constant">6</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *(in-&gt;cur) = <span class="Special">'\''</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; in-&gt;cur++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (*op)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (t_iseq(op, <span class="Special">'\''</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *(in-&gt;cur) = <span class="Special">'\''</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in-&gt;cur++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (t_iseq(op, <span class="Special">'\\'</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *(in-&gt;cur) = <span class="Special">'\\'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in-&gt;cur++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; COPYCHAR(in-&gt;cur, op);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clen = <a href="../mb/mbutils.c.html#L1023" title="utils/mb/mbutils.c:1023">pg_mblen</a>(op);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op += clen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in-&gt;cur += clen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *(in-&gt;cur) = <span class="Special">'\''</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; in-&gt;cur++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (curpol-&gt;weight || curpol-&gt;prefix)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *(in-&gt;cur) = <span class="Constant">':'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in-&gt;cur++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (curpol-&gt;prefix)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *(in-&gt;cur) = <span class="Constant">'*'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in-&gt;cur++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (curpol-&gt;weight &amp; (<span class="Constant">1</span> &lt;&lt; <span class="Constant">3</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *(in-&gt;cur) = <span class="Constant">'A'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in-&gt;cur++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (curpol-&gt;weight &amp; (<span class="Constant">1</span> &lt;&lt; <span class="Constant">2</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *(in-&gt;cur) = <span class="Constant">'B'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in-&gt;cur++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (curpol-&gt;weight &amp; (<span class="Constant">1</span> &lt;&lt; <span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *(in-&gt;cur) = <span class="Constant">'C'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in-&gt;cur++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (curpol-&gt;weight &amp; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *(in-&gt;cur) = <span class="Constant">'D'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in-&gt;cur++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *(in-&gt;cur) = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; in-&gt;curpol++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (in-&gt;curpol-&gt;qoperator.<a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a> == OP_NOT)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; priority = QO_PRIORITY(in-&gt;curpol);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (priority &lt; parentPriority)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L981" title="utils/adt/tsquery.c:981">RESIZEBUF</a>(in, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sprintf(in-&gt;cur, <span class="Constant">&quot;( &quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in-&gt;cur = strchr(in-&gt;cur, <span class="Special">'\0'</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L981" title="utils/adt/tsquery.c:981">RESIZEBUF</a>(in, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *(in-&gt;cur) = <span class="Constant">'!'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; in-&gt;cur++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *(in-&gt;cur) = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; in-&gt;curpol++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L995" title="utils/adt/tsquery.c:995">infix</a>(in, priority, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (priority &lt; parentPriority)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L981" title="utils/adt/tsquery.c:981">RESIZEBUF</a>(in, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sprintf(in-&gt;cur, <span class="Constant">&quot; )&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in-&gt;cur = strchr(in-&gt;cur, <span class="Special">'\0'</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int8&nbsp; &nbsp; &nbsp; &nbsp; op = in-&gt;curpol-&gt;qoperator.<a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; priority = QO_PRIORITY(in-&gt;curpol);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; distance = in-&gt;curpol-&gt;qoperator.distance;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L978" title="utils/adt/tsquery.c:978">INFIX</a>&nbsp; &nbsp; &nbsp; &nbsp; nrm;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; needParenthesis = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; in-&gt;curpol++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (priority &lt; parentPriority ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* phrase operator depends on order */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (op == OP_PHRASE &amp;&amp; rightPhraseOp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; needParenthesis = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L981" title="utils/adt/tsquery.c:981">RESIZEBUF</a>(in, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sprintf(in-&gt;cur, <span class="Constant">&quot;( &quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in-&gt;cur = strchr(in-&gt;cur, <span class="Special">'\0'</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nrm.curpol = in-&gt;curpol;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nrm.op = in-&gt;op;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nrm.buflen = <span class="Constant">16</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nrm.cur = nrm.buf = (<span class="Type">char</span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">char</span>) * nrm.buflen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* get right operand */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L995" title="utils/adt/tsquery.c:995">infix</a>(&amp;nrm, priority, (op == OP_PHRASE));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* get &amp; <a href="../../nodes/print.c.html#L36" title="nodes/print.c:36">print</a> left operand */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; in-&gt;curpol = nrm.curpol;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L995" title="utils/adt/tsquery.c:995">infix</a>(in, priority, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../nodes/print.c.html#L36" title="nodes/print.c:36">print</a> operator &amp; right operand */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L981" title="utils/adt/tsquery.c:981">RESIZEBUF</a>(in, <span class="Constant">3</span> + (<span class="Constant">2</span> + <span class="Constant">10</span> <span class="Comment">/* distance */</span> ) + (nrm.cur - nrm.buf));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (op)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OP_OR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sprintf(in-&gt;cur, <span class="Constant">&quot; | </span><span class="Special">%s</span><span class="Constant">&quot;</span>, nrm.buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OP_AND:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sprintf(in-&gt;cur, <span class="Constant">&quot; &amp; </span><span class="Special">%s</span><span class="Constant">&quot;</span>, nrm.buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OP_PHRASE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (distance != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sprintf(in-&gt;cur, <span class="Constant">&quot; &lt;</span><span class="Special">%d</span><span class="Constant">&gt; </span><span class="Special">%s</span><span class="Constant">&quot;</span>, distance, nrm.buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sprintf(in-&gt;cur, <span class="Constant">&quot; &lt;-&gt; </span><span class="Special">%s</span><span class="Constant">&quot;</span>, nrm.buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OP_NOT is handled in above if-branch */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized operator type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, op);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; in-&gt;cur = strchr(in-&gt;cur, <span class="Special">'\0'</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(nrm.buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (needParenthesis)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L981" title="utils/adt/tsquery.c:981">RESIZEBUF</a>(in, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sprintf(in-&gt;cur, <span class="Constant">&quot; )&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in-&gt;cur = strchr(in-&gt;cur, <span class="Special">'\0'</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1150">&#x200c;</a><span class="linkable">tsqueryout</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TSQuery&nbsp; &nbsp; &nbsp; &nbsp; query = PG_GETARG_TSQUERY(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L978" title="utils/adt/tsquery.c:978">INFIX</a>&nbsp; &nbsp; &nbsp; &nbsp; nrm;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (query-&gt;size == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *b = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *b = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_POINTER(b);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; nrm.curpol = GETQUERY(query);<br/></li>
<li>&nbsp; &nbsp; nrm.buflen = <span class="Constant">32</span>;<br/></li>
<li>&nbsp; &nbsp; nrm.cur = nrm.buf = (<span class="Type">char</span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">char</span>) * nrm.buflen);<br/></li>
<li>&nbsp; &nbsp; *(nrm.cur) = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; nrm.op = GETOPERAND(query);<br/></li>
<li>&nbsp; &nbsp; <a href="#L995" title="utils/adt/tsquery.c:995">infix</a>(&amp;nrm, -<span class="Constant">1</span> <span class="Comment">/* lowest priority */</span> , <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(query, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CSTRING(nrm.buf);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Binary Input / Output <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>. The binary format is as follows:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * uint32&nbsp; &nbsp;&nbsp; number of operators/operands in the query<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Followed by the operators and operands, in prefix notation. For each<br/></li>
<li></span><span class="Comment"> * operand:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * uint8&nbsp; &nbsp; type, QI_VAL<br/></li>
<li></span><span class="Comment"> * uint8&nbsp; &nbsp; weight<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; operand text in client encoding, null-terminated<br/></li>
<li></span><span class="Comment"> * uint8&nbsp; &nbsp; prefix<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For each operator:<br/></li>
<li></span><span class="Comment"> * uint8&nbsp; &nbsp; type, QI_OPR<br/></li>
<li></span><span class="Comment"> * uint8&nbsp; &nbsp; operator, one of OP_AND, OP_PHRASE OP_OR, OP_NOT.<br/></li>
<li></span><span class="Comment"> * uint16&nbsp; &nbsp; distance (only for OP_PHRASE)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1192">&#x200c;</a><span class="linkable">tsquerysend</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TSQuery&nbsp; &nbsp; &nbsp; &nbsp; query = PG_GETARG_TSQUERY(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; QueryItem&nbsp; *item = GETQUERY(query);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L326" title="libpq/pqformat.c:326">pq_begintypsend</a>(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pq_sendint32(&amp;buf, query-&gt;size);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; query-&gt;size; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pq_sendint8(&amp;buf, item-&gt;type);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (item-&gt;type)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> QI_VAL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pq_sendint8(&amp;buf, item-&gt;qoperand.weight);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pq_sendint8(&amp;buf, item-&gt;qoperand.prefix);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L195" title="libpq/pqformat.c:195">pq_sendstring</a>(&amp;buf, GETOPERAND(query) + item-&gt;qoperand.distance);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> QI_OPR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pq_sendint8(&amp;buf, item-&gt;qoperator.<a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (item-&gt;qoperator.<a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a> == OP_PHRASE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pq_sendint16(&amp;buf, item-&gt;qoperator.distance);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized tsquery node type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, item-&gt;type);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; item++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(query, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BYTEA_P(<a href="../../libpq/pqformat.c.html#L346" title="libpq/pqformat.c:346">pq_endtypsend</a>(&amp;buf));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1230">&#x200c;</a><span class="linkable">tsqueryrecv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; buf = (StringInfo) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TSQuery&nbsp; &nbsp; &nbsp; &nbsp; query;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; QueryItem&nbsp; *item;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datalen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ptr;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> **operands;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; needcleanup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; size = <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(buf, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (size &gt; (MaxAllocSize / <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(QueryItem)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid size of tsquery&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allocate space to temporarily hold operand strings */<br/></li>
<li></span>&nbsp; &nbsp; operands = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(size * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">char</span> *));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allocate space for all the QueryItems. */<br/></li>
<li></span>&nbsp; &nbsp; len = HDRSIZETQ + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(QueryItem) * size;<br/></li>
<li>&nbsp; &nbsp; query = (TSQuery) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(len);<br/></li>
<li>&nbsp; &nbsp; query-&gt;size = size;<br/></li>
<li>&nbsp; &nbsp; item = GETQUERY(query);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; datalen = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; size; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; item-&gt;type = (int8) <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(buf, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int8));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (item-&gt;type == QI_VAL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; val_len;&nbsp; &nbsp; <span class="Comment">/* length after recoding to server<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * encoding */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; weight;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; prefix;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_crc32&nbsp; &nbsp; valcrc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; weight = (uint8) <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(buf, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint8));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prefix = (uint8) <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(buf, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint8));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val = <a href="../../libpq/pqformat.c.html#L579" title="libpq/pqformat.c:579">pq_getmsgstring</a>(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val_len = strlen(val);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Sanity checks */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (weight &gt; <span class="Constant">0xF</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid tsquery: invalid weight bitmap&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (val_len &gt; MAXSTRLEN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid tsquery: operand too long&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (datalen &gt; MAXSTRPOS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid tsquery: total operand length exceeded&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Looks valid. */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INIT_LEGACY_CRC32(valcrc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; COMP_LEGACY_CRC32(valcrc, val, val_len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FIN_LEGACY_CRC32(valcrc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item-&gt;qoperand.weight = weight;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item-&gt;qoperand.prefix = (prefix) ? <span class="Constant">true</span> : <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item-&gt;qoperand.valcrc = (int32) valcrc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item-&gt;qoperand.length = val_len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item-&gt;qoperand.distance = datalen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Operand strings are copied to the final struct after this loop;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * here we just collect them to an array<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; operands[i] = val;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datalen += val_len + <span class="Constant">1</span>; <span class="Comment">/* + 1 for the '\0' terminator */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (item-&gt;type == QI_OPR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int8&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a> = (int8) <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(buf, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int8));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a> != OP_NOT &amp;&amp; <a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a> != OP_OR &amp;&amp; <a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a> != OP_AND &amp;&amp; <a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a> != OP_PHRASE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid tsquery: unrecognized operator type </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) <a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i == size - <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid pointer to right operand&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item-&gt;qoperator.<a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a> = <a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a> == OP_PHRASE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item-&gt;qoperator.distance = (int16) <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(buf, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int16));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized tsquery node type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, item-&gt;type);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; item++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Enlarge buffer to make room for the operand <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>. */<br/></li>
<li></span>&nbsp; &nbsp; query = (TSQuery) <a href="../mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(query, len + datalen);<br/></li>
<li>&nbsp; &nbsp; item = GETQUERY(query);<br/></li>
<li>&nbsp; &nbsp; ptr = GETOPERAND(query);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fill in the left-pointers. Checks that the tree is well-formed as a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * side-effect.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L788" title="utils/adt/tsquery.c:788">findoprnd</a>(item, size, &amp;needcleanup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Can't have found <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> QI_VALSTOP nodes */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!needcleanup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Copy operands to output struct */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; size; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (item-&gt;type == QI_VAL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(ptr, operands[i], item-&gt;qoperand.length + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr += item-&gt;qoperand.length + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; item++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(operands);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(ptr - GETOPERAND(query) == datalen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(query, len + datalen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TSQUERY(query);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * debug function, used only for view query<br/></li>
<li></span><span class="Comment"> * which will be executed in non-leaf pages in index<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1366">&#x200c;</a><span class="linkable">tsquerytree</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TSQuery&nbsp; &nbsp; &nbsp; &nbsp; query = PG_GETARG_TSQUERY(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L978" title="utils/adt/tsquery.c:978">INFIX</a>&nbsp; &nbsp; &nbsp; &nbsp; nrm;<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *res;<br/></li>
<li>&nbsp; &nbsp; QueryItem&nbsp; *q;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (query-&gt;size == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res = (text *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(VARHDRSZ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SET_VARSIZE(res, VARHDRSZ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_POINTER(res);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; q = <a href="tsquery_cleanup.c.html#L190" title="utils/adt/tsquery_cleanup.c:190">clean_NOT</a>(GETQUERY(query), &amp;len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!q)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res = <a href="varlena.c.html#L184" title="utils/adt/varlena.c:184">cstring_to_text</a>(<span class="Constant">&quot;T&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nrm.curpol = q;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nrm.buflen = <span class="Constant">32</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nrm.cur = nrm.buf = (<span class="Type">char</span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">char</span>) * nrm.buflen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *(nrm.cur) = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nrm.op = GETOPERAND(query);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L995" title="utils/adt/tsquery.c:995">infix</a>(&amp;nrm, -<span class="Constant">1</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res = <a href="varlena.c.html#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(nrm.buf, nrm.cur - nrm.buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(q);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(query, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(res);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
