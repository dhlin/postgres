<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/adt/json.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/adt/json.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L76">JsonAggState</a></li>
<li><a href="#L84">JsonAggState</a></li>
<li><a href="#L67">JsonUniqueBuilderState</a></li>
<li><a href="#L72">JsonUniqueBuilderState</a></li>
<li><a href="#L39">JsonUniqueCheckState</a></li>
<li><a href="#L42">JsonUniqueHashEntry</a></li>
<li><a href="#L47">JsonUniqueHashEntry</a></li>
<li><a href="#L57">JsonUniqueParsingState</a></li>
<li><a href="#L64">JsonUniqueParsingState</a></li>
<li><a href="#L50">JsonUniqueStackEntry</a></li>
<li><a href="#L54">JsonUniqueStackEntry</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L301">JsonEncodeDateTime</a></li>
<li><a href="#L593">add_json</a></li>
<li><a href="#L422">array_dim_to_json</a></li>
<li><a href="#L621">array_to_json</a></li>
<li><a href="#L465">array_to_json_internal</a></li>
<li><a href="#L637">array_to_json_pretty</a></li>
<li><a href="#L1193">catenate_stringinfo_string</a></li>
<li><a href="#L512">composite_to_json</a></li>
<li><a href="#L754">datum_to_json</a></li>
<li><a href="#L177">datum_to_json_internal</a></li>
<li><a href="#L1549">escape_json</a></li>
<li><a href="#L870">json_agg_finalfn</a></li>
<li><a href="#L861">json_agg_strict_transfn</a></li>
<li><a href="#L852">json_agg_transfn</a></li>
<li><a href="#L770">json_agg_transfn_worker</a></li>
<li><a href="#L1351">json_build_array</a></li>
<li><a href="#L1371">json_build_array_noargs</a></li>
<li><a href="#L1321">json_build_array_worker</a></li>
<li><a href="#L1295">json_build_object</a></li>
<li><a href="#L1315">json_build_object_noargs</a></li>
<li><a href="#L1208">json_build_object_worker</a></li>
<li><a href="#L105">json_in</a></li>
<li><a href="#L1383">json_object</a></li>
<li><a href="#L1170">json_object_agg_finalfn</a></li>
<li><a href="#L1143">json_object_agg_strict_transfn</a></li>
<li><a href="#L1134">json_object_agg_transfn</a></li>
<li><a href="#L993">json_object_agg_transfn_worker</a></li>
<li><a href="#L1161">json_object_agg_unique_strict_transfn</a></li>
<li><a href="#L1152">json_object_agg_unique_transfn</a></li>
<li><a href="#L1471">json_object_two_arg</a></li>
<li><a href="#L124">json_out</a></li>
<li><a href="#L150">json_recv</a></li>
<li><a href="#L136">json_send</a></li>
<li><a href="#L1712">json_typeof</a></li>
<li><a href="#L969">json_unique_builder_get_throwawaybuf</a></li>
<li><a href="#L941">json_unique_builder_init</a></li>
<li><a href="#L923">json_unique_check_init</a></li>
<li><a href="#L949">json_unique_check_key</a></li>
<li><a href="#L891">json_unique_hash</a></li>
<li><a href="#L902">json_unique_hash_match</a></li>
<li><a href="#L1610">json_unique_object_end</a></li>
<li><a href="#L1625">json_unique_object_field_start</a></li>
<li><a href="#L1592">json_unique_object_start</a></li>
<li><a href="#L1650">json_validate</a></li>
<li><a href="#L654">row_to_json</a></li>
<li><a href="#L670">row_to_json_pretty</a></li>
<li><a href="#L730">to_json</a></li>
<li><a href="#L691">to_json_is_immutable</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * json.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; JSON data type support.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/adt/json.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_proc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/hashfn.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;funcapi.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/pqformat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/array.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/date.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/datetime.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/json.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/jsonfuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/typcache.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Support for fast key uniqueness checking.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We maintain a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table of used keys in JSON objects for fast detection<br/></li>
<li></span><span class="Comment"> * of duplicates.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Comment">/* Common context for key uniqueness check */<br/></li>
<li><a id="L39">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <a href="../hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *<span class="linkable">JsonUniqueCheckState</span>;&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table for key names */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Hash entry for <a href="#L39" title="utils/adt/json.c:39">JsonUniqueCheckState</a> */<br/></li>
<li><a id="L42">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">JsonUniqueHashEntry</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *key;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key_len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; object_id;<br/></li>
<li><a id="L47">&#x200c;</a>} <span class="linkable">JsonUniqueHashEntry</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Stack <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> for key uniqueness check during JSON parsing */<br/></li>
<li><a id="L50">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">JsonUniqueStackEntry</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L50" title="utils/adt/json.c:50">JsonUniqueStackEntry</a> *parent;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; object_id;<br/></li>
<li><a id="L54">&#x200c;</a>} <span class="linkable">JsonUniqueStackEntry</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Context struct for key uniqueness check during JSON parsing */<br/></li>
<li><a id="L57">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">JsonUniqueParsingState</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JsonLexContext *lex;<br/></li>
<li>&nbsp; &nbsp; <a href="#L39" title="utils/adt/json.c:39">JsonUniqueCheckState</a> check;<br/></li>
<li>&nbsp; &nbsp; <a href="#L50" title="utils/adt/json.c:50">JsonUniqueStackEntry</a> *stack;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; id_counter;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; unique;<br/></li>
<li><a id="L64">&#x200c;</a>} <span class="linkable">JsonUniqueParsingState</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Context struct for key uniqueness check during JSON building */<br/></li>
<li><a id="L67">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">JsonUniqueBuilderState</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L39" title="utils/adt/json.c:39">JsonUniqueCheckState</a> check; <span class="Comment">/* unique check */<br/></li>
<li></span>&nbsp; &nbsp; StringInfoData skipped_keys;&nbsp; &nbsp; <span class="Comment">/* skipped keys with NULL <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContext mcxt;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* context for saving skipped keys */<br/></li>
<li><a id="L72">&#x200c;</a></span>} <span class="linkable">JsonUniqueBuilderState</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* State struct for JSON aggregation */<br/></li>
<li><a id="L76">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">JsonAggState</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; str;<br/></li>
<li>&nbsp; &nbsp; JsonTypeCategory key_category;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key_output_func;<br/></li>
<li>&nbsp; &nbsp; JsonTypeCategory val_category;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val_output_func;<br/></li>
<li>&nbsp; &nbsp; <a href="#L67" title="utils/adt/json.c:67">JsonUniqueBuilderState</a> unique_check;<br/></li>
<li><a id="L84">&#x200c;</a>} <span class="linkable">JsonAggState</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L512" title="utils/adt/json.c:512">composite_to_json</a>(Datum composite, StringInfo result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> use_line_feeds);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L422" title="utils/adt/json.c:422">array_dim_to_json</a>(StringInfo result, <span class="Type">int</span> dim, <span class="Type">int</span> ndims, <span class="Type">int</span> *dims,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum *vals, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *nulls, <span class="Type">int</span> *valcount,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JsonTypeCategory tcategory, Oid outfuncoid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> use_line_feeds);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L465" title="utils/adt/json.c:465">array_to_json_internal</a>(Datum array, StringInfo result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> use_line_feeds);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L177" title="utils/adt/json.c:177">datum_to_json_internal</a>(Datum val, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_null, StringInfo result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; JsonTypeCategory tcategory, Oid outfuncoid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> key_scalar);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L593" title="utils/adt/json.c:593">add_json</a>(Datum val, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_null, StringInfo result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid val_type, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> key_scalar);<br/></li>
<li><span class="Type">static</span> text *<a href="#L1193" title="utils/adt/json.c:1193">catenate_stringinfo_string</a>(StringInfo buffer, <span class="Type">const</span> <span class="Type">char</span> *addon);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Input.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L105">&#x200c;</a><span class="linkable">json_in</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *json = PG_GETARG_CSTRING(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *result = <a href="varlena.c.html#L184" title="utils/adt/varlena.c:184">cstring_to_text</a>(json);<br/></li>
<li>&nbsp; &nbsp; JsonLexContext lex;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* validate it */<br/></li>
<li></span>&nbsp; &nbsp; <a href="jsonfuncs.c.html#L537" title="utils/adt/jsonfuncs.c:537">makeJsonLexContext</a>(&amp;lex, result, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="jsonfuncs.c.html#L516" title="utils/adt/jsonfuncs.c:516">pg_parse_json_or_errsave</a>(&amp;lex, &amp;nullSemAction, fcinfo-&gt;context))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Internal representation is the same as text */<br/></li>
<li></span>&nbsp; &nbsp; PG_RETURN_TEXT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Output.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L124">&#x200c;</a><span class="linkable">json_out</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we needn't detoast because <a href="varlena.c.html#L217" title="utils/adt/varlena.c:217">text_to_cstring</a> will handle that */<br/></li>
<li></span>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; txt = PG_GETARG_DATUM(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CSTRING(TextDatumGetCString(txt));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Binary <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L136">&#x200c;</a><span class="linkable">json_send</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *t = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L326" title="libpq/pqformat.c:326">pq_begintypsend</a>(&amp;buf);<br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L172" title="libpq/pqformat.c:172">pq_sendtext</a>(&amp;buf, VARDATA_ANY(t), VARSIZE_ANY_EXHDR(t));<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BYTEA_P(<a href="../../libpq/pqformat.c.html#L346" title="libpq/pqformat.c:346">pq_endtypsend</a>(&amp;buf));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Binary receive.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L150">&#x200c;</a><span class="linkable">json_recv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; buf = (StringInfo) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *str;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbytes;<br/></li>
<li>&nbsp; &nbsp; JsonLexContext lex;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; str = <a href="../../libpq/pqformat.c.html#L546" title="libpq/pqformat.c:546">pq_getmsgtext</a>(buf, buf-&gt;len - buf-&gt;cursor, &amp;nbytes);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Validate it. */<br/></li>
<li></span>&nbsp; &nbsp; makeJsonLexContextCstringLen(&amp;lex, str, nbytes, <a href="../mb/mbutils.c.html#L1261" title="utils/mb/mbutils.c:1261">GetDatabaseEncoding</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; pg_parse_json_or_ereport(&amp;lex, &amp;nullSemAction);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(<a href="varlena.c.html#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(str, nbytes));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Turn a Datum into JSON text, appending the string to &quot;result&quot;.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * tcategory and outfuncoid are from a previous call to <a href="jsonfuncs.c.html#L5953" title="utils/adt/jsonfuncs.c:5953">json_categorize_type</a>,<br/></li>
<li></span><span class="Comment"> * except that if is_null is true then they can be invalid.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If key_scalar is true, the value is being printed as a key, so insist<br/></li>
<li></span><span class="Comment"> * it's of an acceptable type, and force it to be quoted.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L177">&#x200c;</a></span><span class="linkable">datum_to_json_internal</span>(Datum val, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_null, StringInfo result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; JsonTypeCategory tcategory, Oid outfuncoid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> key_scalar)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *outputstr;<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *jsontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* callers are expected to ensure that null keys are not passed in */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!(key_scalar &amp;&amp; is_null));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (is_null)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendBinaryStringInfo(result, <span class="Constant">&quot;null&quot;</span>, strlen(<span class="Constant">&quot;null&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (key_scalar &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (tcategory == JSONTYPE_ARRAY ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tcategory == JSONTYPE_COMPOSITE ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tcategory == JSONTYPE_JSON ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tcategory == JSONTYPE_CAST))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;key value must be scalar, not array, composite, or json&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (tcategory)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JSONTYPE_ARRAY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L465" title="utils/adt/json.c:465">array_to_json_internal</a>(val, result, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JSONTYPE_COMPOSITE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L512" title="utils/adt/json.c:512">composite_to_json</a>(val, result, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JSONTYPE_BOOL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (key_scalar)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(result, <span class="Constant">'&quot;'</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (DatumGetBool(val))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendBinaryStringInfo(result, <span class="Constant">&quot;true&quot;</span>, strlen(<span class="Constant">&quot;true&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendBinaryStringInfo(result, <span class="Constant">&quot;false&quot;</span>, strlen(<span class="Constant">&quot;false&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (key_scalar)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(result, <span class="Constant">'&quot;'</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JSONTYPE_NUMERIC:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outputstr = <a href="../fmgr/fmgr.c.html#L1763" title="utils/fmgr/fmgr.c:1763">OidOutputFunctionCall</a>(outfuncoid, val);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Don't quote a non-key if it's a valid JSON number (i.e., not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * &quot;Infinity&quot;, &quot;-Infinity&quot;, or &quot;NaN&quot;).&nbsp; Since we know this is a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> data type's output, we simplify and open-code the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * validation for better performance.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!key_scalar &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((*outputstr &gt;= <span class="Constant">'0'</span> &amp;&amp; *outputstr &lt;= <span class="Constant">'9'</span>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (*outputstr == <span class="Constant">'-'</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (outputstr[<span class="Constant">1</span>] &gt;= <span class="Constant">'0'</span> &amp;&amp; outputstr[<span class="Constant">1</span>] &lt;= <span class="Constant">'9'</span>))))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(result, outputstr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(result, <span class="Constant">'&quot;'</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(result, outputstr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(result, <span class="Constant">'&quot;'</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(outputstr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JSONTYPE_DATE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; buf[MAXDATELEN + <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L301" title="utils/adt/json.c:301">JsonEncodeDateTime</a>(buf, val, DATEOID, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(result, <span class="Constant">'&quot;'</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(result, buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(result, <span class="Constant">'&quot;'</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JSONTYPE_TIMESTAMP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; buf[MAXDATELEN + <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L301" title="utils/adt/json.c:301">JsonEncodeDateTime</a>(buf, val, TIMESTAMPOID, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(result, <span class="Constant">'&quot;'</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(result, buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(result, <span class="Constant">'&quot;'</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JSONTYPE_TIMESTAMPTZ:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; buf[MAXDATELEN + <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L301" title="utils/adt/json.c:301">JsonEncodeDateTime</a>(buf, val, TIMESTAMPTZOID, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(result, <span class="Constant">'&quot;'</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(result, buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(result, <span class="Constant">'&quot;'</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JSONTYPE_JSON:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* JSON and JSONB output will already be escaped */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outputstr = <a href="../fmgr/fmgr.c.html#L1763" title="utils/fmgr/fmgr.c:1763">OidOutputFunctionCall</a>(outfuncoid, val);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(result, outputstr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(outputstr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JSONTYPE_CAST:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* outfuncoid refers to a cast function, not an output function */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jsontext = DatumGetTextPP(OidFunctionCall1(outfuncoid, val));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendBinaryStringInfo(result, VARDATA_ANY(jsontext),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VARSIZE_ANY_EXHDR(jsontext));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(jsontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outputstr = <a href="../fmgr/fmgr.c.html#L1763" title="utils/fmgr/fmgr.c:1763">OidOutputFunctionCall</a>(outfuncoid, val);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1549" title="utils/adt/json.c:1549">escape_json</a>(result, outputstr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(outputstr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Encode 'value' of datetime type 'typid' into JSON string in ISO format using<br/></li>
<li></span><span class="Comment"> * optionally preallocated buffer 'buf'.&nbsp; Optional 'tzp' determines time-zone<br/></li>
<li></span><span class="Comment"> * offset (in seconds) in which we want to show timestamptz.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L301">&#x200c;</a><span class="linkable">JsonEncodeDateTime</span>(<span class="Type">char</span> *buf, Datum value, Oid typid, <span class="Type">const</span> <span class="Type">int</span> *tzp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!buf)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(MAXDATELEN + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (typid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DATEOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; date;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> pg_tm tm;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; date = DatumGetDateADT(value);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Same as <a href="date.c.html#L184" title="utils/adt/date.c:184">date_out</a>(), but forcing <a href="../init/globals.c.html#L122" title="utils/init/globals.c:122">DateStyle</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (DATE_NOT_FINITE(date))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="date.c.html#L294" title="utils/adt/date.c:294">EncodeSpecialDate</a>(date, buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="datetime.c.html#L311" title="utils/adt/datetime.c:311">j2date</a>(date + POSTGRES_EPOCH_JDATE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;(tm.tm_year), &amp;(tm.tm_mon), &amp;(tm.tm_mday));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="datetime.c.html#L4216" title="utils/adt/datetime.c:4216">EncodeDateOnly</a>(&amp;tm, USE_XSD_DATES, buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TIMEOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimeADT&nbsp; &nbsp; &nbsp; &nbsp; time = DatumGetTimeADT(value);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> pg_tm tt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *tm = &amp;tt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fsec_t&nbsp; &nbsp; &nbsp; &nbsp; fsec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Same as <a href="date.c.html#L1501" title="utils/adt/date.c:1501">time_out</a>(), but forcing <a href="../init/globals.c.html#L122" title="utils/init/globals.c:122">DateStyle</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="date.c.html#L1488" title="utils/adt/date.c:1488">time2tm</a>(time, tm, &amp;fsec);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="datetime.c.html#L4301" title="utils/adt/datetime.c:4301">EncodeTimeOnly</a>(tm, fsec, <span class="Constant">false</span>, <span class="Constant">0</span>, USE_XSD_DATES, buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TIMETZOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimeTzADT&nbsp; *time = DatumGetTimeTzADTP(value);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> pg_tm tt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *tm = &amp;tt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fsec_t&nbsp; &nbsp; &nbsp; &nbsp; fsec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Same as <a href="date.c.html#L2314" title="utils/adt/date.c:2314">timetz_out</a>(), but forcing <a href="../init/globals.c.html#L122" title="utils/init/globals.c:122">DateStyle</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="date.c.html#L2403" title="utils/adt/date.c:2403">timetz2tm</a>(time, tm, &amp;fsec, &amp;tz);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="datetime.c.html#L4301" title="utils/adt/datetime.c:4301">EncodeTimeOnly</a>(tm, fsec, <span class="Constant">true</span>, tz, USE_XSD_DATES, buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TIMESTAMPOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Timestamp&nbsp; &nbsp; timestamp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> pg_tm tm;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fsec_t&nbsp; &nbsp; &nbsp; &nbsp; fsec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; timestamp = DatumGetTimestamp(value);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Same as <a href="timestamp.c.html#L232" title="utils/adt/timestamp.c:232">timestamp_out</a>(), but forcing <a href="../init/globals.c.html#L122" title="utils/init/globals.c:122">DateStyle</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TIMESTAMP_NOT_FINITE(timestamp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="timestamp.c.html#L1596" title="utils/adt/timestamp.c:1596">EncodeSpecialTimestamp</a>(timestamp, buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="timestamp.c.html#L1901" title="utils/adt/timestamp.c:1901">timestamp2tm</a>(timestamp, <span class="Constant">NULL</span>, &amp;tm, &amp;fsec, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="datetime.c.html#L4331" title="utils/adt/datetime.c:4331">EncodeDateTime</a>(&amp;tm, fsec, <span class="Constant">false</span>, <span class="Constant">0</span>, <span class="Constant">NULL</span>, USE_XSD_DATES, buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TIMESTAMPTZOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimestampTz timestamp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> pg_tm tm;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tz;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fsec_t&nbsp; &nbsp; &nbsp; &nbsp; fsec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *tzn = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; timestamp = DatumGetTimestampTz(value);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If a time zone is specified, we apply the time-zone shift,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * convert timestamptz to pg_tm as if it were without a time<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * zone, and then use the specified time zone for converting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the timestamp into a string.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tzp)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tz = *tzp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; timestamp -= (TimestampTz) tz * USECS_PER_SEC;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Same as <a href="timestamp.c.html#L785" title="utils/adt/timestamp.c:785">timestamptz_out</a>(), but forcing <a href="../init/globals.c.html#L122" title="utils/init/globals.c:122">DateStyle</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TIMESTAMP_NOT_FINITE(timestamp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="timestamp.c.html#L1596" title="utils/adt/timestamp.c:1596">EncodeSpecialTimestamp</a>(timestamp, buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="timestamp.c.html#L1901" title="utils/adt/timestamp.c:1901">timestamp2tm</a>(timestamp, tzp ? <span class="Constant">NULL</span> : &amp;tz, &amp;tm, &amp;fsec,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tzp ? <span class="Constant">NULL</span> : &amp;tzn, <span class="Constant">NULL</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tzp)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm.tm_isdst = <span class="Constant">1</span>;&nbsp; &nbsp; <span class="Comment">/* set time-zone presence flag */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="datetime.c.html#L4331" title="utils/adt/datetime.c:4331">EncodeDateTime</a>(&amp;tm, fsec, <span class="Constant">true</span>, tz, tzn, USE_XSD_DATES, buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unknown jsonb value datetime type oid </span><span class="Special">%u</span><span class="Constant">&quot;</span>, typid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> buf;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Process a single dimension of an array.<br/></li>
<li></span><span class="Comment"> * If it's the innermost dimension, output the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, otherwise call<br/></li>
<li></span><span class="Comment"> * ourselves recursively to process the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> dimension.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L422">&#x200c;</a></span><span class="linkable">array_dim_to_json</span>(StringInfo result, <span class="Type">int</span> dim, <span class="Type">int</span> ndims, <span class="Type">int</span> *dims, Datum *vals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *nulls, <span class="Type">int</span> *valcount, JsonTypeCategory tcategory,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid outfuncoid, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> use_line_feeds)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *sep;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(dim &lt; ndims);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sep = use_line_feeds ? <span class="Constant">&quot;,</span><span class="Special">\n</span><span class="Constant"> &quot;</span> : <span class="Constant">&quot;,&quot;</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfoChar(result, <span class="Constant">'['</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt;= dims[dim]; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(result, sep);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dim + <span class="Constant">1</span> == ndims)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L177" title="utils/adt/json.c:177">datum_to_json_internal</a>(vals[*valcount], nulls[*valcount],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; result, tcategory,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; outfuncoid, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (*valcount)++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Do we want line feeds on inner dimensions of arrays? For <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we'll say no.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L422" title="utils/adt/json.c:422">array_dim_to_json</a>(result, dim + <span class="Constant">1</span>, ndims, dims, vals, nulls,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; valcount, tcategory, outfuncoid, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfoChar(result, <span class="Constant">']'</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Turn an array into JSON.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L465">&#x200c;</a></span><span class="linkable">array_to_json_internal</span>(Datum array, StringInfo result, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> use_line_feeds)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *v = DatumGetArrayTypeP(array);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; element_type = ARR_ELEMTYPE(v);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *dim;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndim;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nitems;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *elements;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *nulls;<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; typlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; typbyval;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; typalign;<br/></li>
<li>&nbsp; &nbsp; JsonTypeCategory tcategory;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outfuncoid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ndim = ARR_NDIM(v);<br/></li>
<li>&nbsp; &nbsp; dim = ARR_DIMS(v);<br/></li>
<li>&nbsp; &nbsp; nitems = <a href="arrayutils.c.html#L57" title="utils/adt/arrayutils.c:57">ArrayGetNItems</a>(ndim, dim);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nitems &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(result, <span class="Constant">&quot;[]&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L2271" title="utils/cache/lsyscache.c:2271">get_typlenbyvalalign</a>(element_type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;typlen, &amp;typbyval, &amp;typalign);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="jsonfuncs.c.html#L5953" title="utils/adt/jsonfuncs.c:5953">json_categorize_type</a>(element_type, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;tcategory, &amp;outfuncoid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="arrayfuncs.c.html#L3612" title="utils/adt/arrayfuncs.c:3612">deconstruct_array</a>(v, element_type, typlen, typbyval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typalign, &amp;elements, &amp;nulls,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;nitems);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L422" title="utils/adt/json.c:422">array_dim_to_json</a>(result, <span class="Constant">0</span>, ndim, dim, elements, nulls, &amp;count, tcategory,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outfuncoid, use_line_feeds);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(elements);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(nulls);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Turn a composite / record into JSON.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L512">&#x200c;</a></span><span class="linkable">composite_to_json</span>(Datum composite, StringInfo result, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> use_line_feeds)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeader td;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupType;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; tupTypmod;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc;<br/></li>
<li>&nbsp; &nbsp; HeapTupleData tmptup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *tuple;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; needsep = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *sep;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seplen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can avoid expensive strlen() calls by precalculating the separator<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * length.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; sep = use_line_feeds ? <span class="Constant">&quot;,</span><span class="Special">\n</span><span class="Constant"> &quot;</span> : <span class="Constant">&quot;,&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; seplen = use_line_feeds ? strlen(<span class="Constant">&quot;,</span><span class="Special">\n</span><span class="Constant"> &quot;</span>) : strlen(<span class="Constant">&quot;,&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; td = DatumGetHeapTupleHeader(composite);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Extract rowtype info and <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a tupdesc */<br/></li>
<li></span>&nbsp; &nbsp; tupType = HeapTupleHeaderGetTypeId(td);<br/></li>
<li>&nbsp; &nbsp; tupTypmod = HeapTupleHeaderGetTypMod(td);<br/></li>
<li>&nbsp; &nbsp; tupdesc = <a href="../cache/typcache.c.html#L1833" title="utils/cache/typcache.c:1833">lookup_rowtype_tupdesc</a>(tupType, tupTypmod);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Build a temporary HeapTuple control structure */<br/></li>
<li></span>&nbsp; &nbsp; tmptup.t_len = HeapTupleHeaderGetDatumLength(td);<br/></li>
<li>&nbsp; &nbsp; tmptup.t_data = td;<br/></li>
<li>&nbsp; &nbsp; tuple = &amp;tmptup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfoChar(result, <span class="Constant">'{'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; tupdesc-&gt;natts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *attname;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; JsonTypeCategory tcategory;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outfuncoid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att = TupleDescAttr(tupdesc, i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (att-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (needsep)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendBinaryStringInfo(result, sep, seplen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; needsep = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attname = NameStr(att-&gt;attname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1549" title="utils/adt/json.c:1549">escape_json</a>(result, attname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(result, <span class="Constant">':'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; val = heap_getattr(tuple, i + <span class="Constant">1</span>, tupdesc, &amp;isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tcategory = JSONTYPE_NULL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outfuncoid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="jsonfuncs.c.html#L5953" title="utils/adt/jsonfuncs.c:5953">json_categorize_type</a>(att-&gt;atttypid, <span class="Constant">false</span>, &amp;tcategory,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;outfuncoid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L177" title="utils/adt/json.c:177">datum_to_json_internal</a>(val, isnull, result, tcategory, outfuncoid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfoChar(result, <span class="Constant">'}'</span>);<br/></li>
<li>&nbsp; &nbsp; ReleaseTupleDesc(tupdesc);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Append JSON text for &quot;val&quot; to &quot;result&quot;.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is just a thin wrapper around <a href="#L754" title="utils/adt/json.c:754">datum_to_json</a>.&nbsp; If the same type will be<br/></li>
<li></span><span class="Comment"> * printed many times, avoid using this; better to do the <a href="jsonfuncs.c.html#L5953" title="utils/adt/jsonfuncs.c:5953">json_categorize_type</a><br/></li>
<li></span><span class="Comment"> * lookups only once.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L593">&#x200c;</a></span><span class="linkable">add_json</span>(Datum val, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_null, StringInfo result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid val_type, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> key_scalar)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JsonTypeCategory tcategory;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outfuncoid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (val_type == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not determine input data type&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (is_null)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tcategory = JSONTYPE_NULL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; outfuncoid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="jsonfuncs.c.html#L5953" title="utils/adt/jsonfuncs.c:5953">json_categorize_type</a>(val_type, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;tcategory, &amp;outfuncoid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L177" title="utils/adt/json.c:177">datum_to_json_internal</a>(val, is_null, result, tcategory, outfuncoid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; key_scalar);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * SQL function <a href="#L621" title="utils/adt/json.c:621">array_to_json</a>(row)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L621">&#x200c;</a><span class="linkable">array_to_json</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; array = PG_GETARG_DATUM(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = makeStringInfo();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L465" title="utils/adt/json.c:465">array_to_json_internal</a>(array, result, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(<a href="varlena.c.html#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(result-&gt;data, result-&gt;len));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * SQL function <a href="#L621" title="utils/adt/json.c:621">array_to_json</a>(row, prettybool)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L637">&#x200c;</a><span class="linkable">array_to_json_pretty</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; array = PG_GETARG_DATUM(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; use_line_feeds = PG_GETARG_BOOL(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = makeStringInfo();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L465" title="utils/adt/json.c:465">array_to_json_internal</a>(array, result, use_line_feeds);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(<a href="varlena.c.html#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(result-&gt;data, result-&gt;len));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * SQL function <a href="#L654" title="utils/adt/json.c:654">row_to_json</a>(row)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L654">&#x200c;</a><span class="linkable">row_to_json</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; array = PG_GETARG_DATUM(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = makeStringInfo();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L512" title="utils/adt/json.c:512">composite_to_json</a>(array, result, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(<a href="varlena.c.html#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(result-&gt;data, result-&gt;len));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * SQL function <a href="#L654" title="utils/adt/json.c:654">row_to_json</a>(row, prettybool)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L670">&#x200c;</a><span class="linkable">row_to_json_pretty</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; array = PG_GETARG_DATUM(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; use_line_feeds = PG_GETARG_BOOL(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = makeStringInfo();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L512" title="utils/adt/json.c:512">composite_to_json</a>(array, result, use_line_feeds);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(<a href="varlena.c.html#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(result-&gt;data, result-&gt;len));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Is the given type immutable when coming out of a JSON context?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * At present, datetimes are all considered mutable, because they<br/></li>
<li></span><span class="Comment"> * depend on timezone.&nbsp; </span><span class="Todo">XXX</span><span class="Comment"> we should also drill down into objects<br/></li>
<li></span><span class="Comment"> * and arrays, but do not.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L691">&#x200c;</a></span><span class="linkable">to_json_is_immutable</span>(Oid typoid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JsonTypeCategory tcategory;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outfuncoid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="jsonfuncs.c.html#L5953" title="utils/adt/jsonfuncs.c:5953">json_categorize_type</a>(typoid, <span class="Constant">false</span>, &amp;tcategory, &amp;outfuncoid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (tcategory)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JSONTYPE_BOOL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JSONTYPE_JSON:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JSONTYPE_JSONB:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JSONTYPE_NULL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JSONTYPE_DATE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JSONTYPE_TIMESTAMP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JSONTYPE_TIMESTAMPTZ:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JSONTYPE_ARRAY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">TODO</span><span class="Comment"> recurse into elements */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JSONTYPE_COMPOSITE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">TODO</span><span class="Comment"> recurse into fields */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JSONTYPE_NUMERIC:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JSONTYPE_CAST:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JSONTYPE_OTHER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../cache/lsyscache.c.html#L1780" title="utils/cache/lsyscache.c:1780">func_volatile</a>(outfuncoid) == PROVOLATILE_IMMUTABLE;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not reached */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * SQL function <a href="#L730" title="utils/adt/json.c:730">to_json</a>(anyvalue)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L730">&#x200c;</a><span class="linkable">to_json</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; val = PG_GETARG_DATUM(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val_type = <a href="../fmgr/fmgr.c.html#L1910" title="utils/fmgr/fmgr.c:1910">get_fn_expr_argtype</a>(fcinfo-&gt;flinfo, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; JsonTypeCategory tcategory;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outfuncoid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (val_type == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not determine input data type&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="jsonfuncs.c.html#L5953" title="utils/adt/jsonfuncs.c:5953">json_categorize_type</a>(val_type, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;tcategory, &amp;outfuncoid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_DATUM(<a href="#L754" title="utils/adt/json.c:754">datum_to_json</a>(val, tcategory, outfuncoid));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Turn a Datum into JSON text.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * tcategory and outfuncoid are from a previous call to <a href="jsonfuncs.c.html#L5953" title="utils/adt/jsonfuncs.c:5953">json_categorize_type</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L754">&#x200c;</a><span class="linkable">datum_to_json</span>(Datum val, JsonTypeCategory tcategory, Oid outfuncoid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; result = makeStringInfo();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L177" title="utils/adt/json.c:177">datum_to_json_internal</a>(val, <span class="Constant">false</span>, result, tcategory, outfuncoid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> PointerGetDatum(<a href="varlena.c.html#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(result-&gt;data, result-&gt;len));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * json_agg transition function<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * aggregate input column as a json array value.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Datum<br/></li>
<li><a id="L770">&#x200c;</a><span class="linkable">json_agg_transfn_worker</span>(FunctionCallInfo fcinfo, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> absent_on_null)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext aggcontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldcontext;<br/></li>
<li>&nbsp; &nbsp; <a href="#L76" title="utils/adt/json.c:76">JsonAggState</a> *state;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../executor/nodeAgg.c.html#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>(fcinfo, &amp;aggcontext))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* cannot be called directly because of <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a>-type argument */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L852" title="utils/adt/json.c:852">json_agg_transfn</a> called in non-aggregate context&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PG_ARGISNULL(<span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arg_type = <a href="../fmgr/fmgr.c.html#L1910" title="utils/fmgr/fmgr.c:1910">get_fn_expr_argtype</a>(fcinfo-&gt;flinfo, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (arg_type == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not determine input data type&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make this state object in a context where it will persist for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * duration of the aggregate call.&nbsp; MemoryContextSwitchTo is only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * needed the first time, as the StringInfo routines make sure they<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * use the right context to enlarge the object if necessary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(aggcontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state = (<a href="#L76" title="utils/adt/json.c:76">JsonAggState</a> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L76" title="utils/adt/json.c:76">JsonAggState</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;str = makeStringInfo();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(state-&gt;str, <span class="Constant">'['</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="jsonfuncs.c.html#L5953" title="utils/adt/jsonfuncs.c:5953">json_categorize_type</a>(arg_type, <span class="Constant">false</span>, &amp;state-&gt;val_category,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;state-&gt;val_output_func);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state = (<a href="#L76" title="utils/adt/json.c:76">JsonAggState</a> *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (absent_on_null &amp;&amp; PG_ARGISNULL(<span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_POINTER(state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;str-&gt;len &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(state-&gt;str, <span class="Constant">&quot;, &quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fast path for NULLs */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PG_ARGISNULL(<span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L177" title="utils/adt/json.c:177">datum_to_json_internal</a>((Datum) <span class="Constant">0</span>, <span class="Constant">true</span>, state-&gt;str, JSONTYPE_NULL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_POINTER(state);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; val = PG_GETARG_DATUM(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* add some whitespace if structured type and not first item */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!PG_ARGISNULL(<span class="Constant">0</span>) &amp;&amp; state-&gt;str-&gt;len &gt; <span class="Constant">1</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (state-&gt;val_category == JSONTYPE_ARRAY ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;val_category == JSONTYPE_COMPOSITE))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(state-&gt;str, <span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant"> &quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L177" title="utils/adt/json.c:177">datum_to_json_internal</a>(val, <span class="Constant">false</span>, state-&gt;str, state-&gt;val_category,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;val_output_func, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The transition type for json_agg() is declared to be &quot;<a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a>&quot;, which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is a pass-by-value type the same size as a pointer.&nbsp; So we can safely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pass the <a href="#L76" title="utils/adt/json.c:76">JsonAggState</a> pointer through nodeAgg.c's machinations.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; PG_RETURN_POINTER(state);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * json_agg aggregate function<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L852">&#x200c;</a><span class="linkable">json_agg_transfn</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L770" title="utils/adt/json.c:770">json_agg_transfn_worker</a>(fcinfo, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * json_agg_strict aggregate function<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L861">&#x200c;</a><span class="linkable">json_agg_strict_transfn</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L770" title="utils/adt/json.c:770">json_agg_transfn_worker</a>(fcinfo, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * json_agg final function<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L870">&#x200c;</a><span class="linkable">json_agg_finalfn</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L76" title="utils/adt/json.c:76">JsonAggState</a> *state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* cannot be called directly because of <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a>-type argument */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../../executor/nodeAgg.c.html#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>(fcinfo, <span class="Constant">NULL</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = PG_ARGISNULL(<span class="Constant">0</span>) ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span> :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L76" title="utils/adt/json.c:76">JsonAggState</a> *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* NULL result for no rows in, as is standard with aggregates */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Else return state with appropriate array terminator added */<br/></li>
<li></span>&nbsp; &nbsp; PG_RETURN_TEXT_P(<a href="#L1193" title="utils/adt/json.c:1193">catenate_stringinfo_string</a>(state-&gt;str, <span class="Constant">&quot;]&quot;</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Functions implementing <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table for key uniqueness check */<br/></li>
<li></span><span class="Type">static</span> uint32<br/></li>
<li><a id="L891">&#x200c;</a><span class="linkable">json_unique_hash</span>(<span class="Type">const</span> <span class="Type">void</span> *key, Size keysize)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="#L42" title="utils/adt/json.c:42">JsonUniqueHashEntry</a> *entry = (<a href="#L42" title="utils/adt/json.c:42">JsonUniqueHashEntry</a> *) key;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> = hash_bytes_uint32(entry-&gt;object_id);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> ^= hash_bytes((<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">char</span> *) entry-&gt;key, entry-&gt;key_len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> DatumGetUInt32(<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L902">&#x200c;</a></span><span class="linkable">json_unique_hash_match</span>(<span class="Type">const</span> <span class="Type">void</span> *key1, <span class="Type">const</span> <span class="Type">void</span> *key2, Size keysize)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="#L42" title="utils/adt/json.c:42">JsonUniqueHashEntry</a> *entry1 = (<span class="Type">const</span> <a href="#L42" title="utils/adt/json.c:42">JsonUniqueHashEntry</a> *) key1;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="#L42" title="utils/adt/json.c:42">JsonUniqueHashEntry</a> *entry2 = (<span class="Type">const</span> <a href="#L42" title="utils/adt/json.c:42">JsonUniqueHashEntry</a> *) key2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (entry1-&gt;object_id != entry2-&gt;object_id)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> entry1-&gt;object_id &gt; entry2-&gt;object_id ? <span class="Constant">1</span> : -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (entry1-&gt;key_len != entry2-&gt;key_len)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> entry1-&gt;key_len &gt; entry2-&gt;key_len ? <span class="Constant">1</span> : -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> strncmp(entry1-&gt;key, entry2-&gt;key, entry1-&gt;key_len);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Uniqueness detection support.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In order to detect uniqueness during building or parsing of a JSON<br/></li>
<li></span><span class="Comment"> * object, we maintain a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table of key names already seen.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L923">&#x200c;</a></span><span class="linkable">json_unique_check_init</span>(<a href="#L39" title="utils/adt/json.c:39">JsonUniqueCheckState</a> *cxt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASHCTL&nbsp; &nbsp; &nbsp; &nbsp; ctl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memset(&amp;ctl, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ctl));<br/></li>
<li>&nbsp; &nbsp; ctl.keysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L42" title="utils/adt/json.c:42">JsonUniqueHashEntry</a>);<br/></li>
<li>&nbsp; &nbsp; ctl.entrysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L42" title="utils/adt/json.c:42">JsonUniqueHashEntry</a>);<br/></li>
<li>&nbsp; &nbsp; ctl.hcxt = <a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li>&nbsp; &nbsp; ctl.<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> = <a href="#L891" title="utils/adt/json.c:891">json_unique_hash</a>;<br/></li>
<li>&nbsp; &nbsp; ctl.match = <a href="#L902" title="utils/adt/json.c:902">json_unique_hash_match</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *cxt = <a href="../hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(<span class="Constant">&quot;json object hashtable&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">32</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;ctl,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_ELEM | HASH_CONTEXT | HASH_FUNCTION | HASH_COMPARE);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L941">&#x200c;</a></span><span class="linkable">json_unique_builder_init</span>(<a href="#L67" title="utils/adt/json.c:67">JsonUniqueBuilderState</a> *cxt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L923" title="utils/adt/json.c:923">json_unique_check_init</a>(&amp;cxt-&gt;check);<br/></li>
<li>&nbsp; &nbsp; cxt-&gt;mcxt = <a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li>&nbsp; &nbsp; cxt-&gt;skipped_keys.data = <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L949">&#x200c;</a></span><span class="linkable">json_unique_check_key</span>(<a href="#L39" title="utils/adt/json.c:39">JsonUniqueCheckState</a> *cxt, <span class="Type">const</span> <span class="Type">char</span> *key, <span class="Type">int</span> object_id)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L42" title="utils/adt/json.c:42">JsonUniqueHashEntry</a> entry;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; entry.key = key;<br/></li>
<li>&nbsp; &nbsp; entry.key_len = strlen(key);<br/></li>
<li>&nbsp; &nbsp; entry.object_id = object_id;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="../hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(*cxt, &amp;entry, HASH_ENTER, &amp;found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> !found;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * On-demand initialization of a throwaway StringInfo.&nbsp; This is used to<br/></li>
<li></span><span class="Comment"> * read a key name that we don't need to store in the output object, for<br/></li>
<li></span><span class="Comment"> * duplicate key detection when the value is NULL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> StringInfo<br/></li>
<li><a id="L969">&#x200c;</a><span class="linkable">json_unique_builder_get_throwawaybuf</span>(<a href="#L67" title="utils/adt/json.c:67">JsonUniqueBuilderState</a> *cxt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; out = &amp;cxt-&gt;skipped_keys;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!out-&gt;data)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldcxt = MemoryContextSwitchTo(cxt-&gt;mcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; initStringInfo(out);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Just reset the string to empty */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; out-&gt;len = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> out;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * json_object_agg transition function.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * aggregate two input columns as a single json object value.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Datum<br/></li>
<li><a id="L993">&#x200c;</a><span class="linkable">json_object_agg_transfn_worker</span>(FunctionCallInfo fcinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> absent_on_null, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> unique_keys)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext aggcontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldcontext;<br/></li>
<li>&nbsp; &nbsp; <a href="#L76" title="utils/adt/json.c:76">JsonAggState</a> *state;<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; out;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; arg;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key_offset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../executor/nodeAgg.c.html#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>(fcinfo, &amp;aggcontext))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* cannot be called directly because of <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a>-type argument */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L1134" title="utils/adt/json.c:1134">json_object_agg_transfn</a> called in non-aggregate context&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PG_ARGISNULL(<span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arg_type;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make the StringInfo in a context where it will persist for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * duration of the aggregate call. Switching context is only needed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for this initial step, as the StringInfo and dynahash routines make<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sure they use the right context to enlarge the object if necessary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(aggcontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state = (<a href="#L76" title="utils/adt/json.c:76">JsonAggState</a> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L76" title="utils/adt/json.c:76">JsonAggState</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;str = makeStringInfo();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unique_keys)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L941" title="utils/adt/json.c:941">json_unique_builder_init</a>(&amp;state-&gt;unique_check);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memset(&amp;state-&gt;unique_check, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(state-&gt;unique_check));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; arg_type = <a href="../fmgr/fmgr.c.html#L1910" title="utils/fmgr/fmgr.c:1910">get_fn_expr_argtype</a>(fcinfo-&gt;flinfo, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (arg_type == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not determine data type for argument </span><span class="Special">%d</span><span class="Constant">&quot;</span>, <span class="Constant">1</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="jsonfuncs.c.html#L5953" title="utils/adt/jsonfuncs.c:5953">json_categorize_type</a>(arg_type, <span class="Constant">false</span>, &amp;state-&gt;key_category,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;state-&gt;key_output_func);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; arg_type = <a href="../fmgr/fmgr.c.html#L1910" title="utils/fmgr/fmgr.c:1910">get_fn_expr_argtype</a>(fcinfo-&gt;flinfo, <span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (arg_type == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not determine data type for argument </span><span class="Special">%d</span><span class="Constant">&quot;</span>, <span class="Constant">2</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="jsonfuncs.c.html#L5953" title="utils/adt/jsonfuncs.c:5953">json_categorize_type</a>(arg_type, <span class="Constant">false</span>, &amp;state-&gt;val_category,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;state-&gt;val_output_func);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(state-&gt;str, <span class="Constant">&quot;{ &quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state = (<a href="#L76" title="utils/adt/json.c:76">JsonAggState</a> *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: since json_object_agg() is declared as taking type &quot;<a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>&quot;, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parser will not do <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> type conversion on unknown-type literals (that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is, undecorated strings or NULLs).&nbsp; Such <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> will arrive here as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * type UNKNOWN, which fortunately does not matter to us, since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="varlena.c.html#L646" title="utils/adt/varlena.c:646">unknownout</a>() works fine.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PG_ARGISNULL(<span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NULL_VALUE_NOT_ALLOWED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;null value not allowed for object key&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Skip null <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> if absent_on_null */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> = absent_on_null &amp;&amp; PG_ARGISNULL(<span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We got a NULL value and we're not storing those; if we're not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * testing key uniqueness, we're done.&nbsp; If we are, use the throwaway<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * buffer to store the key name so that we can check it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!unique_keys)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_POINTER(state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; out = <a href="#L969" title="utils/adt/json.c:969">json_unique_builder_get_throwawaybuf</a>(&amp;state-&gt;unique_check);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; out = state-&gt;str;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Append comma delimiter only if we have already output some fields<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * after the initial string &quot;{ &quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (out-&gt;len &gt; <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(out, <span class="Constant">&quot;, &quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; arg = PG_GETARG_DATUM(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; key_offset = out-&gt;len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L177" title="utils/adt/json.c:177">datum_to_json_internal</a>(arg, <span class="Constant">false</span>, out, state-&gt;key_category,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;key_output_func, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unique_keys)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *key = &amp;out-&gt;data[key_offset];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L949" title="utils/adt/json.c:949">json_unique_check_key</a>(&amp;state-&gt;unique_check.check, key, <span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DUPLICATE_JSON_OBJECT_KEY_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;duplicate JSON object key value: </span><span class="Special">%s</span><span class="Constant">&quot;</span>, key));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_POINTER(state);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfoString(state-&gt;str, <span class="Constant">&quot; : &quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PG_ARGISNULL(<span class="Constant">2</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; arg = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; arg = PG_GETARG_DATUM(<span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L177" title="utils/adt/json.c:177">datum_to_json_internal</a>(arg, PG_ARGISNULL(<span class="Constant">2</span>), state-&gt;str,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;val_category,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;val_output_func, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(state);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * json_object_agg aggregate function<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1134">&#x200c;</a><span class="linkable">json_object_agg_transfn</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L993" title="utils/adt/json.c:993">json_object_agg_transfn_worker</a>(fcinfo, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * json_object_agg_strict aggregate function<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1143">&#x200c;</a><span class="linkable">json_object_agg_strict_transfn</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L993" title="utils/adt/json.c:993">json_object_agg_transfn_worker</a>(fcinfo, <span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * json_object_agg_unique aggregate function<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1152">&#x200c;</a><span class="linkable">json_object_agg_unique_transfn</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L993" title="utils/adt/json.c:993">json_object_agg_transfn_worker</a>(fcinfo, <span class="Constant">false</span>, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * json_object_agg_unique_strict aggregate function<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1161">&#x200c;</a><span class="linkable">json_object_agg_unique_strict_transfn</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L993" title="utils/adt/json.c:993">json_object_agg_transfn_worker</a>(fcinfo, <span class="Constant">true</span>, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * json_object_agg final function.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1170">&#x200c;</a><span class="linkable">json_object_agg_finalfn</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L76" title="utils/adt/json.c:76">JsonAggState</a> *state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* cannot be called directly because of <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a>-type argument */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../../executor/nodeAgg.c.html#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>(fcinfo, <span class="Constant">NULL</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = PG_ARGISNULL(<span class="Constant">0</span>) ? <span class="Constant">NULL</span> : (<a href="#L76" title="utils/adt/json.c:76">JsonAggState</a> *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* NULL result for no rows in, as is standard with aggregates */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Else return state with appropriate object terminator added */<br/></li>
<li></span>&nbsp; &nbsp; PG_RETURN_TEXT_P(<a href="#L1193" title="utils/adt/json.c:1193">catenate_stringinfo_string</a>(state-&gt;str, <span class="Constant">&quot; }&quot;</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Helper function for aggregates: return given StringInfo's contents plus<br/></li>
<li></span><span class="Comment"> * specified trailing string, as a text datum.&nbsp; We need this because aggregate<br/></li>
<li></span><span class="Comment"> * final <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> are not allowed to modify the aggregate state.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> text *<br/></li>
<li><a id="L1193">&#x200c;</a><span class="linkable">catenate_stringinfo_string</span>(StringInfo buffer, <span class="Type">const</span> <span class="Type">char</span> *addon)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* custom version of <a href="varlena.c.html#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buflen = buffer-&gt;len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addlen = strlen(addon);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *result = (text *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(buflen + addlen + VARHDRSZ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(result, buflen + addlen + VARHDRSZ);<br/></li>
<li>&nbsp; &nbsp; memcpy(VARDATA(result), buffer-&gt;data, buflen);<br/></li>
<li>&nbsp; &nbsp; memcpy(VARDATA(result) + buflen, addon, addlen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1208">&#x200c;</a><span class="linkable">json_build_object_worker</span>(<span class="Type">int</span> nargs, <span class="Type">const</span> Datum *args, <span class="Type">const</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *nulls, <span class="Type">const</span> Oid *types,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> absent_on_null, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> unique_keys)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *sep = <span class="Constant">&quot;&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <a href="#L67" title="utils/adt/json.c:67">JsonUniqueBuilderState</a> unique_check;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nargs % <span class="Constant">2</span> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;argument list must have even number of elements&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: %s is a SQL function name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;The arguments of </span><span class="Special">%s</span><span class="Constant"> must consist of alternating keys and <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;<a href="#L1295" title="utils/adt/json.c:1295">json_build_object</a>()&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = makeStringInfo();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfoChar(result, <span class="Constant">'{'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unique_keys)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L941" title="utils/adt/json.c:941">json_unique_builder_init</a>(&amp;unique_check);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nargs; i += <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; StringInfo&nbsp; &nbsp; out;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key_offset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Skip null <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> if absent_on_null */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> = absent_on_null &amp;&amp; nulls[i + <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If key uniqueness check is needed we must save skipped keys */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!unique_keys)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; out = <a href="#L969" title="utils/adt/json.c:969">json_unique_builder_get_throwawaybuf</a>(&amp;unique_check);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(result, sep);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sep = <span class="Constant">&quot;, &quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; out = result;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* process key */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nulls[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NULL_VALUE_NOT_ALLOWED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;null value not allowed for object key&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* save key offset <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> appending it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; key_offset = out-&gt;len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L593" title="utils/adt/json.c:593">add_json</a>(args[i], <span class="Constant">false</span>, out, types[i], <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unique_keys)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check key uniqueness after key appending */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *key = &amp;out-&gt;data[key_offset];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L949" title="utils/adt/json.c:949">json_unique_check_key</a>(&amp;unique_check.check, key, <span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DUPLICATE_JSON_OBJECT_KEY_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;duplicate JSON object key value: </span><span class="Special">%s</span><span class="Constant">&quot;</span>, key));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(result, <span class="Constant">&quot; : &quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* process value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L593" title="utils/adt/json.c:593">add_json</a>(args[i + <span class="Constant">1</span>], nulls[i + <span class="Constant">1</span>], result, types[i + <span class="Constant">1</span>], <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfoChar(result, <span class="Constant">'}'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> PointerGetDatum(<a href="varlena.c.html#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(result-&gt;data, result-&gt;len));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * SQL function <a href="#L1295" title="utils/adt/json.c:1295">json_build_object</a>(variadic &quot;<a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>&quot;)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1295">&#x200c;</a><span class="linkable">json_build_object</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *args;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *nulls;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *types;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* build argument <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to build the object */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nargs = <a href="../fmgr/funcapi.c.html#L2005" title="utils/fmgr/funcapi.c:2005">extract_variadic_args</a>(fcinfo, <span class="Constant">0</span>, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;args, &amp;types, &amp;nulls);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nargs &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_DATUM(<a href="#L1208" title="utils/adt/json.c:1208">json_build_object_worker</a>(nargs, args, nulls, types, <span class="Constant">false</span>, <span class="Constant">false</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * degenerate case of <a href="#L1295" title="utils/adt/json.c:1295">json_build_object</a> where it gets 0 arguments.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1315">&#x200c;</a><span class="linkable">json_build_object_noargs</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(<a href="varlena.c.html#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(<span class="Constant">&quot;{}&quot;</span>, <span class="Constant">2</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1321">&#x200c;</a><span class="linkable">json_build_array_worker</span>(<span class="Type">int</span> nargs, <span class="Type">const</span> Datum *args, <span class="Type">const</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *nulls, <span class="Type">const</span> Oid *types,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> absent_on_null)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *sep = <span class="Constant">&quot;&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = makeStringInfo();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfoChar(result, <span class="Constant">'['</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nargs; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (absent_on_null &amp;&amp; nulls[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(result, sep);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sep = <span class="Constant">&quot;, &quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L593" title="utils/adt/json.c:593">add_json</a>(args[i], nulls[i], result, types[i], <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfoChar(result, <span class="Constant">']'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> PointerGetDatum(<a href="varlena.c.html#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(result-&gt;data, result-&gt;len));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * SQL function <a href="#L1351" title="utils/adt/json.c:1351">json_build_array</a>(variadic &quot;<a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>&quot;)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1351">&#x200c;</a><span class="linkable">json_build_array</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *args;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *nulls;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *types;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* build argument <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to build the object */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nargs = <a href="../fmgr/funcapi.c.html#L2005" title="utils/fmgr/funcapi.c:2005">extract_variadic_args</a>(fcinfo, <span class="Constant">0</span>, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;args, &amp;types, &amp;nulls);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nargs &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_DATUM(<a href="#L1321" title="utils/adt/json.c:1321">json_build_array_worker</a>(nargs, args, nulls, types, <span class="Constant">false</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * degenerate case of <a href="#L1351" title="utils/adt/json.c:1351">json_build_array</a> where it gets 0 arguments.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1371">&#x200c;</a><span class="linkable">json_build_array_noargs</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(<a href="varlena.c.html#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(<span class="Constant">&quot;[]&quot;</span>, <span class="Constant">2</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * SQL function <a href="#L1383" title="utils/adt/json.c:1383">json_object</a>(text[])<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * take a one or two dimensional array of text as key/value pairs<br/></li>
<li></span><span class="Comment"> * for a json object.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1383">&#x200c;</a><span class="linkable">json_object</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *in_array = PG_GETARG_ARRAYTYPE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndims = ARR_NDIM(in_array);<br/></li>
<li>&nbsp; &nbsp; StringInfoData result;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *in_datums;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *in_nulls;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in_count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *rval;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *v;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (ndims)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">0</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_DATUM(CStringGetTextDatum(<span class="Constant">&quot;{}&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">1</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((ARR_DIMS(in_array)[<span class="Constant">0</span>]) % <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ARRAY_SUBSCRIPT_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;array must have even number of elements&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">2</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((ARR_DIMS(in_array)[<span class="Constant">1</span>]) != <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ARRAY_SUBSCRIPT_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;array must have two columns&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ARRAY_SUBSCRIPT_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;wrong number of array subscripts&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="arrayfuncs.c.html#L3678" title="utils/adt/arrayfuncs.c:3678">deconstruct_array_builtin</a>(in_array, TEXTOID, &amp;in_datums, &amp;in_nulls, &amp;in_count);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; count = in_count / <span class="Constant">2</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfoChar(&amp;result, <span class="Constant">'{'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; count; ++i)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (in_nulls[i * <span class="Constant">2</span>])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NULL_VALUE_NOT_ALLOWED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;null value not allowed for object key&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; v = TextDatumGetCString(in_datums[i * <span class="Constant">2</span>]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;result, <span class="Constant">&quot;, &quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1549" title="utils/adt/json.c:1549">escape_json</a>(&amp;result, v);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;result, <span class="Constant">&quot; : &quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(v);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (in_nulls[i * <span class="Constant">2</span> + <span class="Constant">1</span>])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;result, <span class="Constant">&quot;null&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v = TextDatumGetCString(in_datums[i * <span class="Constant">2</span> + <span class="Constant">1</span>]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1549" title="utils/adt/json.c:1549">escape_json</a>(&amp;result, v);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(v);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfoChar(&amp;result, <span class="Constant">'}'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(in_datums);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(in_nulls);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rval = <a href="varlena.c.html#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(result.data, result.len);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(result.data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(rval);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * SQL function <a href="#L1383" title="utils/adt/json.c:1383">json_object</a>(text[], text[])<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * take separate key and value arrays of text to construct a json object<br/></li>
<li></span><span class="Comment"> * pairwise.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1471">&#x200c;</a><span class="linkable">json_object_two_arg</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *key_array = PG_GETARG_ARRAYTYPE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *val_array = PG_GETARG_ARRAYTYPE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nkdims = ARR_NDIM(key_array);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nvdims = ARR_NDIM(val_array);<br/></li>
<li>&nbsp; &nbsp; StringInfoData result;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *key_datums,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *val_datums;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *key_nulls,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *val_nulls;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key_count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val_count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *rval;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *v;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nkdims &gt; <span class="Constant">1</span> || nkdims != nvdims)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ARRAY_SUBSCRIPT_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;wrong number of array subscripts&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nkdims == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_DATUM(CStringGetTextDatum(<span class="Constant">&quot;{}&quot;</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="arrayfuncs.c.html#L3678" title="utils/adt/arrayfuncs.c:3678">deconstruct_array_builtin</a>(key_array, TEXTOID, &amp;key_datums, &amp;key_nulls, &amp;key_count);<br/></li>
<li>&nbsp; &nbsp; <a href="arrayfuncs.c.html#L3678" title="utils/adt/arrayfuncs.c:3678">deconstruct_array_builtin</a>(val_array, TEXTOID, &amp;val_datums, &amp;val_nulls, &amp;val_count);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (key_count != val_count)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ARRAY_SUBSCRIPT_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;mismatched array dimensions&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfoChar(&amp;result, <span class="Constant">'{'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; key_count; ++i)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (key_nulls[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NULL_VALUE_NOT_ALLOWED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;null value not allowed for object key&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; v = TextDatumGetCString(key_datums[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;result, <span class="Constant">&quot;, &quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1549" title="utils/adt/json.c:1549">escape_json</a>(&amp;result, v);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;result, <span class="Constant">&quot; : &quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(v);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (val_nulls[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;result, <span class="Constant">&quot;null&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v = TextDatumGetCString(val_datums[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1549" title="utils/adt/json.c:1549">escape_json</a>(&amp;result, v);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(v);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfoChar(&amp;result, <span class="Constant">'}'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(key_datums);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(key_nulls);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(val_datums);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(val_nulls);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rval = <a href="varlena.c.html#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(result.data, result.len);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(result.data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(rval);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Produce a JSON string literal, properly escaping characters in the text.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1549">&#x200c;</a></span><span class="linkable">escape_json</span>(StringInfo buf, <span class="Type">const</span> <span class="Type">char</span> *str)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *p;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfoCharMacro(buf, <span class="Constant">'&quot;'</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (p = str; *p; p++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (*p)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Special">'\b'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(buf, <span class="Constant">&quot;</span><span class="Special">\\</span><span class="Constant">b&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Special">'\f'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(buf, <span class="Constant">&quot;</span><span class="Special">\\</span><span class="Constant">f&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Special">'\n'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(buf, <span class="Constant">&quot;</span><span class="Special">\\</span><span class="Constant">n&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Special">'\r'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(buf, <span class="Constant">&quot;</span><span class="Special">\\</span><span class="Constant">r&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Special">'\t'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(buf, <span class="Constant">&quot;</span><span class="Special">\\</span><span class="Constant">t&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'&quot;'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(buf, <span class="Constant">&quot;</span><span class="Special">\\\&quot;</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Special">'\\'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(buf, <span class="Constant">&quot;</span><span class="Special">\\\\</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((<span class="Type">unsigned</span> <span class="Type">char</span>) *p &lt; <span class="Constant">' '</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf, <span class="Constant">&quot;</span><span class="Special">\\</span><span class="Constant">u</span><span class="Special">%04x</span><span class="Constant">&quot;</span>, (<span class="Type">int</span>) *p);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoCharMacro(buf, *p);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; appendStringInfoCharMacro(buf, <span class="Constant">'&quot;'</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Semantic actions for key uniqueness check */<br/></li>
<li></span><span class="Type">static</span> JsonParseErrorType<br/></li>
<li><a id="L1592">&#x200c;</a><span class="linkable">json_unique_object_start</span>(<span class="Type">void</span> *_state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L57" title="utils/adt/json.c:57">JsonUniqueParsingState</a> *state = _state;<br/></li>
<li>&nbsp; &nbsp; <a href="#L50" title="utils/adt/json.c:50">JsonUniqueStackEntry</a> *entry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!state-&gt;unique)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> object entry to stack */<br/></li>
<li></span>&nbsp; &nbsp; entry = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(*entry));<br/></li>
<li>&nbsp; &nbsp; entry-&gt;object_id = state-&gt;id_counter++;<br/></li>
<li>&nbsp; &nbsp; entry-&gt;parent = state-&gt;stack;<br/></li>
<li>&nbsp; &nbsp; state-&gt;stack = entry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> JsonParseErrorType<br/></li>
<li><a id="L1610">&#x200c;</a><span class="linkable">json_unique_object_end</span>(<span class="Type">void</span> *_state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L57" title="utils/adt/json.c:57">JsonUniqueParsingState</a> *state = _state;<br/></li>
<li>&nbsp; &nbsp; <a href="#L50" title="utils/adt/json.c:50">JsonUniqueStackEntry</a> *entry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!state-&gt;unique)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; entry = state-&gt;stack;<br/></li>
<li>&nbsp; &nbsp; state-&gt;stack = entry-&gt;parent;&nbsp; &nbsp; <span class="Comment">/* pop object from stack */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(entry);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> JsonParseErrorType<br/></li>
<li><a id="L1625">&#x200c;</a><span class="linkable">json_unique_object_field_start</span>(<span class="Type">void</span> *_state, <span class="Type">char</span> *field, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L57" title="utils/adt/json.c:57">JsonUniqueParsingState</a> *state = _state;<br/></li>
<li>&nbsp; &nbsp; <a href="#L50" title="utils/adt/json.c:50">JsonUniqueStackEntry</a> *entry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!state-&gt;unique)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> key collision in the current object */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L949" title="utils/adt/json.c:949">json_unique_check_key</a>(&amp;state-&gt;check, field, state-&gt;stack-&gt;object_id))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;unique = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* pop all objects entries */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> ((entry = state-&gt;stack))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;stack = entry-&gt;parent;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(entry);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> JSON_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Validate JSON text and additionally check key uniqueness */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1650">&#x200c;</a></span><span class="linkable">json_validate</span>(text *json, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> check_unique_keys, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> throw_error)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JsonLexContext lex;<br/></li>
<li>&nbsp; &nbsp; JsonSemAction uniqueSemAction = {<span class="Constant">0</span>};<br/></li>
<li>&nbsp; &nbsp; <a href="#L57" title="utils/adt/json.c:57">JsonUniqueParsingState</a> state;<br/></li>
<li>&nbsp; &nbsp; JsonParseErrorType result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="jsonfuncs.c.html#L537" title="utils/adt/jsonfuncs.c:537">makeJsonLexContext</a>(&amp;lex, json, check_unique_keys);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (check_unique_keys)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state.lex = &amp;lex;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state.stack = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state.id_counter = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state.unique = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L923" title="utils/adt/json.c:923">json_unique_check_init</a>(&amp;state.check);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uniqueSemAction.semstate = &amp;state;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uniqueSemAction.object_start = <a href="#L1592" title="utils/adt/json.c:1592">json_unique_object_start</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uniqueSemAction.object_field_start = <a href="#L1625" title="utils/adt/json.c:1625">json_unique_object_field_start</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uniqueSemAction.object_end = <a href="#L1610" title="utils/adt/json.c:1610">json_unique_object_end</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = pg_parse_json(&amp;lex, check_unique_keys ? &amp;uniqueSemAction : &amp;nullSemAction);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result != JSON_SUCCESS)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (throw_error)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="jsonfuncs.c.html#L638" title="utils/adt/jsonfuncs.c:638">json_errsave_error</a>(result, &amp;lex, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* invalid json */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (check_unique_keys &amp;&amp; !state.unique)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (throw_error)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DUPLICATE_JSON_OBJECT_KEY_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;duplicate JSON object key value&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not unique keys */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (check_unique_keys)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; freeJsonLexContext(&amp;lex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ok */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * SQL function <a href="#L1712" title="utils/adt/json.c:1712">json_typeof</a>(json) -&gt; text<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the type of the outermost JSON value as TEXT.&nbsp; Possible types are<br/></li>
<li></span><span class="Comment"> * &quot;object&quot;, &quot;array&quot;, &quot;string&quot;, &quot;number&quot;, &quot;boolean&quot;, and &quot;null&quot;.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Performs a single call to json_lex() to get the first token of the supplied<br/></li>
<li></span><span class="Comment"> * value.&nbsp; This initial token uniquely determines the value's type.&nbsp; As our<br/></li>
<li></span><span class="Comment"> * input must already have been validated by <a href="#L105" title="utils/adt/json.c:105">json_in</a>() or <a href="#L150" title="utils/adt/json.c:150">json_recv</a>(), the<br/></li>
<li></span><span class="Comment"> * initial token should never be JSON_TOKEN_OBJECT_END, JSON_TOKEN_ARRAY_END,<br/></li>
<li></span><span class="Comment"> * JSON_TOKEN_COLON, JSON_TOKEN_COMMA, or JSON_TOKEN_END.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1712">&#x200c;</a><span class="linkable">json_typeof</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *json = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; JsonLexContext lex;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *type;<br/></li>
<li>&nbsp; &nbsp; JsonParseErrorType result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Lex exactly one token from the input and check its type. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="jsonfuncs.c.html#L537" title="utils/adt/jsonfuncs.c:537">makeJsonLexContext</a>(&amp;lex, json, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; result = json_lex(&amp;lex);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result != JSON_SUCCESS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="jsonfuncs.c.html#L638" title="utils/adt/jsonfuncs.c:638">json_errsave_error</a>(result, &amp;lex, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (lex.token_type)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JSON_TOKEN_OBJECT_START:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type = <span class="Constant">&quot;object&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JSON_TOKEN_ARRAY_START:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type = <span class="Constant">&quot;array&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JSON_TOKEN_STRING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type = <span class="Constant">&quot;string&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JSON_TOKEN_NUMBER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type = <span class="Constant">&quot;number&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JSON_TOKEN_TRUE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JSON_TOKEN_FALSE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type = <span class="Constant">&quot;boolean&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JSON_TOKEN_NULL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type = <span class="Constant">&quot;null&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected json token: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, lex.token_type);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(<a href="varlena.c.html#L184" title="utils/adt/varlena.c:184">cstring_to_text</a>(type));<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
