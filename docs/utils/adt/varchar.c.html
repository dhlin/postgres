<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/adt/varchar.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/adt/varchar.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L33">anychar_typmodin</a></li>
<li><a href="#L72">anychar_typmodout</a></li>
<li><a href="#L670">bcTruelen</a></li>
<li><a href="#L271">bpchar</a></li>
<li><a href="#L130">bpchar_input</a></li>
<li><a href="#L955">bpchar_larger</a></li>
<li><a href="#L371">bpchar_name</a></li>
<li><a href="#L1169">bpchar_pattern_ge</a></li>
<li><a href="#L1185">bpchar_pattern_gt</a></li>
<li><a href="#L1153">bpchar_pattern_le</a></li>
<li><a href="#L1137">bpchar_pattern_lt</a></li>
<li><a href="#L973">bpchar_smaller</a></li>
<li><a href="#L938">bpchar_sortsupport</a></li>
<li><a href="#L917">bpcharcmp</a></li>
<li><a href="#L743">bpchareq</a></li>
<li><a href="#L896">bpcharge</a></li>
<li><a href="#L875">bpchargt</a></li>
<li><a href="#L198">bpcharin</a></li>
<li><a href="#L854">bpcharle</a></li>
<li><a href="#L693">bpcharlen</a></li>
<li><a href="#L833">bpcharlt</a></li>
<li><a href="#L788">bpcharne</a></li>
<li><a href="#L709">bpcharoctetlen</a></li>
<li><a href="#L219">bpcharout</a></li>
<li><a href="#L230">bpcharrecv</a></li>
<li><a href="#L251">bpcharsend</a></li>
<li><a href="#L676">bpchartruelen</a></li>
<li><a href="#L417">bpchartypmodin</a></li>
<li><a href="#L425">bpchartypmodout</a></li>
<li><a href="#L1201">btbpchar_pattern_cmp</a></li>
<li><a href="#L1217">btbpchar_pattern_sortsupport</a></li>
<li><a href="#L353">char_bpchar</a></li>
<li><a href="#L727">check_collation_set</a></li>
<li><a href="#L996">hashbpchar</a></li>
<li><a href="#L1051">hashbpcharextended</a></li>
<li><a href="#L1115">internal_bpchar_pattern_compare</a></li>
<li><a href="#L407">name_bpchar</a></li>
<li><a href="#L609">varchar</a></li>
<li><a href="#L457">varchar_input</a></li>
<li><a href="#L565">varchar_support</a></li>
<li><a href="#L495">varcharin</a></li>
<li><a href="#L516">varcharout</a></li>
<li><a href="#L527">varcharrecv</a></li>
<li><a href="#L548">varcharsend</a></li>
<li><a href="#L648">varchartypmodin</a></li>
<li><a href="#L656">varchartypmodout</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L609" title="utils/adt/varchar.c:609">varchar</a>.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Functions for the built-in types char(n) and <a href="#L609" title="utils/adt/varchar.c:609">varchar</a>(n).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/adt/<a href="#L609" title="utils/adt/varchar.c:609">varchar</a>.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/detoast.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_collation.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/hashfn.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/pqformat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;mb/pg_wchar.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/nodeFuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/supportnodes.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/array.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/pg_locale.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/varlena.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* common code for <a href="#L417" title="utils/adt/varchar.c:417">bpchartypmodin</a> and <a href="#L648" title="utils/adt/varchar.c:648">varchartypmodin</a> */<br/></li>
<li></span><span class="Type">static</span> int32<br/></li>
<li><a id="L33">&#x200c;</a><span class="linkable">anychar_typmodin</span>(ArrayType *ta, <span class="Type">const</span> <span class="Type">char</span> *typename)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; typmod;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp;&nbsp; *tl;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tl = <a href="arrayutils.c.html#L233" title="utils/adt/arrayutils.c:233">ArrayGetIntegerTypmods</a>(ta, &amp;n);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we're not too tense about good error message here because grammar<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * shouldn't allow wrong number of modifiers for CHAR<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (n != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid type modifier&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*tl &lt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;length for type </span><span class="Special">%s</span><span class="Constant"> must be at least 1&quot;</span>, typename)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*tl &gt; MaxAttrSize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;length for type </span><span class="Special">%s</span><span class="Constant"> cannot exceed </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typename, MaxAttrSize)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For largely historical reasons, the typmod is VARHDRSZ plus the number<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of characters; there is enough client-side code that knows about that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that we'd better not change it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; typmod = VARHDRSZ + *tl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> typmod;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* common code for <a href="#L425" title="utils/adt/varchar.c:425">bpchartypmodout</a> and <a href="#L656" title="utils/adt/varchar.c:656">varchartypmodout</a> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L72">&#x200c;</a><span class="linkable">anychar_typmodout</span>(int32 typmod)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *res = (<span class="Type">char</span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Constant">64</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (typmod &gt; VARHDRSZ)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(res, <span class="Constant">64</span>, <span class="Constant">&quot;(</span><span class="Special">%d</span><span class="Constant">)&quot;</span>, (<span class="Type">int</span>) (typmod - VARHDRSZ));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *res = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * CHAR() and VARCHAR() types are part of the SQL standard. CHAR()<br/></li>
<li></span><span class="Comment"> * is for blank-padded string whose length is specified in CREATE TABLE.<br/></li>
<li></span><span class="Comment"> * VARCHAR is for storing string whose length is at most the length specified<br/></li>
<li></span><span class="Comment"> * at CREATE TABLE time.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It's hard to implement these types because we cannot figure out<br/></li>
<li></span><span class="Comment"> * the length of the type from the type itself. I changed (hopefully all) the<br/></li>
<li></span><span class="Comment"> * fmgr calls that invoke input <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> of a data type to supply the<br/></li>
<li></span><span class="Comment"> * length also. (eg. in INSERTs, we have the tupleDescriptor which contains<br/></li>
<li></span><span class="Comment"> * the length of the attributes and hence the exact length of the char() or<br/></li>
<li></span><span class="Comment"> * <a href="#L609" title="utils/adt/varchar.c:609">varchar</a>(). We pass this to <a href="#L198" title="utils/adt/varchar.c:198">bpcharin</a>() or <a href="#L495" title="utils/adt/varchar.c:495">varcharin</a>().) In the case where<br/></li>
<li></span><span class="Comment"> * we cannot determine the length, we pass in -1 instead and the input<br/></li>
<li></span><span class="Comment"> * converter does not enforce <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> length check.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We actually implement this as a varlena so that we don't have to pass in<br/></li>
<li></span><span class="Comment"> * the length for the comparison <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>. (The difference between these<br/></li>
<li></span><span class="Comment"> * types and &quot;text&quot; is that we truncate and possibly blank-pad the string<br/></li>
<li></span><span class="Comment"> * at insertion time.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - ay 6/95<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*****************************************************************************<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; <a href="#L271" title="utils/adt/varchar.c:271">bpchar</a> - char()&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment"> *****************************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L130" title="utils/adt/varchar.c:130">bpchar_input</a> -- common guts of <a href="#L198" title="utils/adt/varchar.c:198">bpcharin</a> and <a href="#L230" title="utils/adt/varchar.c:230">bpcharrecv</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * s is the input text of length len (may not be null-terminated)<br/></li>
<li></span><span class="Comment"> * atttypmod is the typmod value to apply<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that atttypmod is measured in characters, which<br/></li>
<li></span><span class="Comment"> * is not necessarily the same as the number of bytes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the input string is too long, raise an error, unless the extra<br/></li>
<li></span><span class="Comment"> * characters are spaces, in which case they're truncated.&nbsp; (per SQL)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If escontext points to an ErrorSaveContext node, that is filled instead<br/></li>
<li></span><span class="Comment"> * of throwing an error; the caller must check SOFT_ERROR_OCCURRED()<br/></li>
<li></span><span class="Comment"> * to detect errors.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> BpChar *<br/></li>
<li><a id="L130">&#x200c;</a><span class="linkable">bpchar_input</span>(<span class="Type">const</span> <span class="Type">char</span> *s, <span class="Type">size_t</span> len, int32 atttypmod, Node *escontext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BpChar&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *r;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; maxlen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If typmod is -1 (or invalid), use the actual string length */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (atttypmod &lt; (int32) VARHDRSZ)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; maxlen = len;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; charlen;&nbsp; &nbsp; <span class="Comment">/* number of CHARACTERS in the input */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; maxlen = atttypmod - VARHDRSZ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; charlen = <a href="../mb/mbutils.c.html#L1057" title="utils/mb/mbutils.c:1057">pg_mbstrlen_with_len</a>(s, len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (charlen &gt; maxlen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Verify that extra characters are spaces, and clip them off */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; mbmaxlen = <a href="../mb/mbutils.c.html#L1125" title="utils/mb/mbutils.c:1125">pg_mbcharcliplen</a>(s, len, maxlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * at this point, len is the actual BYTE length of the input<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * string, maxlen is the max number of CHARACTERS allowed for this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L271" title="utils/adt/varchar.c:271">bpchar</a> type, mbmaxlen is the length in BYTES of those chars.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = mbmaxlen; j &lt; len; j++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s[j] != <span class="Constant">' '</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_STRING_DATA_RIGHT_TRUNCATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;value too long for type character(</span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">int</span>) maxlen)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now we set maxlen to the necessary byte length, not the number<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of CHARACTERS!<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxlen = len = mbmaxlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now we set maxlen to the necessary byte length, not the number<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of CHARACTERS!<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxlen = len + (maxlen - charlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (BpChar *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(maxlen + VARHDRSZ);<br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(result, maxlen + VARHDRSZ);<br/></li>
<li>&nbsp; &nbsp; r = VARDATA(result);<br/></li>
<li>&nbsp; &nbsp; memcpy(r, s, len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* blank pad the string if necessary */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (maxlen &gt; len)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memset(r + len, <span class="Constant">' '</span>, maxlen - len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert a C string to CHARACTER <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> representation.&nbsp; atttypmod<br/></li>
<li></span><span class="Comment"> * is the declared length of the type plus VARHDRSZ.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L198">&#x200c;</a><span class="linkable">bpcharin</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *s = PG_GETARG_CSTRING(<span class="Constant">0</span>);<br/></li>
<li><span class="PreProc">#ifdef NOT_USED<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typelem = PG_GETARG_OID(<span class="Constant">1</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; atttypmod = PG_GETARG_INT32(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; BpChar&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L130" title="utils/adt/varchar.c:130">bpchar_input</a>(s, strlen(s), atttypmod, fcinfo-&gt;context);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BPCHAR_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert a CHARACTER value to a C string.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Uses the text conversion <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, which is only appropriate if BpChar<br/></li>
<li></span><span class="Comment"> * and text are equivalent types.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L219">&#x200c;</a><span class="linkable">bpcharout</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; txt = PG_GETARG_DATUM(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CSTRING(TextDatumGetCString(txt));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L230" title="utils/adt/varchar.c:230">bpcharrecv</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts external binary format to <a href="#L271" title="utils/adt/varchar.c:271">bpchar</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L230">&#x200c;</a><span class="linkable">bpcharrecv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; buf = (StringInfo) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><span class="PreProc">#ifdef NOT_USED<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typelem = PG_GETARG_OID(<span class="Constant">1</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; atttypmod = PG_GETARG_INT32(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; BpChar&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *str;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbytes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; str = <a href="../../libpq/pqformat.c.html#L546" title="libpq/pqformat.c:546">pq_getmsgtext</a>(buf, buf-&gt;len - buf-&gt;cursor, &amp;nbytes);<br/></li>
<li>&nbsp; &nbsp; result = <a href="#L130" title="utils/adt/varchar.c:130">bpchar_input</a>(str, nbytes, atttypmod, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(str);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BPCHAR_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L251" title="utils/adt/varchar.c:251">bpcharsend</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts <a href="#L271" title="utils/adt/varchar.c:271">bpchar</a> to binary format<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L251">&#x200c;</a><span class="linkable">bpcharsend</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Exactly the same as <a href="varlena.c.html#L619" title="utils/adt/varlena.c:619">textsend</a>, so share code */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="varlena.c.html#L619" title="utils/adt/varlena.c:619">textsend</a>(fcinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Converts a CHARACTER type to the specified size.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * maxlen is the typmod, ie, declared length plus VARHDRSZ bytes.<br/></li>
<li></span><span class="Comment"> * isExplicit is true if this is for an explicit cast to char(N).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Truncation rules: for an explicit cast, silently truncate to the given<br/></li>
<li></span><span class="Comment"> * length; for an implicit cast, raise error unless extra characters are<br/></li>
<li></span><span class="Comment"> * all spaces.&nbsp; (This is sort-of per SQL: the spec would actually have us<br/></li>
<li></span><span class="Comment"> * raise a &quot;completion condition&quot; for the explicit cast case, but Postgres<br/></li>
<li></span><span class="Comment"> * hasn't got such a concept.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L271">&#x200c;</a><span class="linkable">bpchar</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BpChar&nbsp; &nbsp; &nbsp;&nbsp; *source = PG_GETARG_BPCHAR_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; maxlen = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isExplicit = PG_GETARG_BOOL(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; BpChar&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *r;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *s;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; charlen;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* number of characters in the input string +<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * VARHDRSZ */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No work if typmod is invalid */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (maxlen &lt; (int32) VARHDRSZ)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BPCHAR_P(source);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; maxlen -= VARHDRSZ;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len = VARSIZE_ANY_EXHDR(source);<br/></li>
<li>&nbsp; &nbsp; s = VARDATA_ANY(source);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; charlen = <a href="../mb/mbutils.c.html#L1057" title="utils/mb/mbutils.c:1057">pg_mbstrlen_with_len</a>(s, len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No work if supplied data matches typmod already */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (charlen == maxlen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BPCHAR_P(source);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (charlen &gt; maxlen)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Verify that extra characters are spaces, and clip them off */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; maxmblen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; maxmblen = <a href="../mb/mbutils.c.html#L1125" title="utils/mb/mbutils.c:1125">pg_mbcharcliplen</a>(s, len, maxlen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!isExplicit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = maxmblen; i &lt; len; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s[i] != <span class="Constant">' '</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_STRING_DATA_RIGHT_TRUNCATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;value too long for type character(</span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxlen)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len = maxmblen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * At this point, maxlen is the necessary byte length, not the number<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of CHARACTERS!<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; maxlen = len;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * At this point, maxlen is the necessary byte length, not the number<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of CHARACTERS!<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; maxlen = len + (maxlen - charlen);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(maxlen &gt;= len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(maxlen + VARHDRSZ);<br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(result, maxlen + VARHDRSZ);<br/></li>
<li>&nbsp; &nbsp; r = VARDATA(result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memcpy(r, s, len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* blank pad the string if necessary */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (maxlen &gt; len)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memset(r + len, <span class="Constant">' '</span>, maxlen - len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BPCHAR_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L353" title="utils/adt/varchar.c:353">char_bpchar</a>()<br/></li>
<li></span><span class="Comment"> * Convert char to <a href="#L271" title="utils/adt/varchar.c:271">bpchar</a>(1).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L353">&#x200c;</a><span class="linkable">char_bpchar</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; c = PG_GETARG_CHAR(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BpChar&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (BpChar *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(VARHDRSZ + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(result, VARHDRSZ + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; *(VARDATA(result)) = c;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BPCHAR_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L371" title="utils/adt/varchar.c:371">bpchar_name</a>()<br/></li>
<li></span><span class="Comment"> * Converts a <a href="#L271" title="utils/adt/varchar.c:271">bpchar</a>() type to a NameData type.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L371">&#x200c;</a><span class="linkable">bpchar_name</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BpChar&nbsp; &nbsp; &nbsp;&nbsp; *s = PG_GETARG_BPCHAR_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *s_data;<br/></li>
<li>&nbsp; &nbsp; Name&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len = VARSIZE_ANY_EXHDR(s);<br/></li>
<li>&nbsp; &nbsp; s_data = VARDATA_ANY(s);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Truncate oversize input */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (len &gt;= NAMEDATALEN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len = <a href="../mb/mbutils.c.html#L1083" title="utils/mb/mbutils.c:1083">pg_mbcliplen</a>(s_data, len, NAMEDATALEN - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Remove trailing blanks */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (len &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s_data[len - <span class="Constant">1</span>] != <span class="Constant">' '</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len--;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We use <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a> here to ensure result is zero-padded */<br/></li>
<li></span>&nbsp; &nbsp; result = (Name) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(NAMEDATALEN);<br/></li>
<li>&nbsp; &nbsp; memcpy(NameStr(*result), s_data, len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_NAME(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L407" title="utils/adt/varchar.c:407">name_bpchar</a>()<br/></li>
<li></span><span class="Comment"> * Converts a NameData type to a <a href="#L271" title="utils/adt/varchar.c:271">bpchar</a> type.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Uses the text conversion <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, which is only appropriate if BpChar<br/></li>
<li></span><span class="Comment"> * and text are equivalent types.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L407">&#x200c;</a><span class="linkable">name_bpchar</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Name&nbsp; &nbsp; &nbsp; &nbsp; s = PG_GETARG_NAME(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BpChar&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (BpChar *) <a href="varlena.c.html#L184" title="utils/adt/varlena.c:184">cstring_to_text</a>(NameStr(*s));<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BPCHAR_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L417">&#x200c;</a><span class="linkable">bpchartypmodin</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *ta = PG_GETARG_ARRAYTYPE_P(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(<a href="#L33" title="utils/adt/varchar.c:33">anychar_typmodin</a>(ta, <span class="Constant">&quot;char&quot;</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L425">&#x200c;</a><span class="linkable">bpchartypmodout</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; typmod = PG_GETARG_INT32(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CSTRING(<a href="#L72" title="utils/adt/varchar.c:72">anychar_typmodout</a>(typmod));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*****************************************************************************<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; <a href="#L609" title="utils/adt/varchar.c:609">varchar</a> - <a href="#L609" title="utils/adt/varchar.c:609">varchar</a>(n)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: <a href="#L609" title="utils/adt/varchar.c:609">varchar</a> piggybacks on type text for most operations, and so has no<br/></li>
<li></span><span class="Comment"> * C-coded <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> except for I/O and typmod checking.<br/></li>
<li></span><span class="Comment"> *****************************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L457" title="utils/adt/varchar.c:457">varchar_input</a> -- common guts of <a href="#L495" title="utils/adt/varchar.c:495">varcharin</a> and <a href="#L527" title="utils/adt/varchar.c:527">varcharrecv</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * s is the input text of length len (may not be null-terminated)<br/></li>
<li></span><span class="Comment"> * atttypmod is the typmod value to apply<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that atttypmod is measured in characters, which<br/></li>
<li></span><span class="Comment"> * is not necessarily the same as the number of bytes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the input string is too long, raise an error, unless the extra<br/></li>
<li></span><span class="Comment"> * characters are spaces, in which case they're truncated.&nbsp; (per SQL)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If escontext points to an ErrorSaveContext node, that is filled instead<br/></li>
<li></span><span class="Comment"> * of throwing an error; the caller must check SOFT_ERROR_OCCURRED()<br/></li>
<li></span><span class="Comment"> * to detect errors.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> VarChar *<br/></li>
<li><a id="L457">&#x200c;</a><span class="linkable">varchar_input</span>(<span class="Type">const</span> <span class="Type">char</span> *s, <span class="Type">size_t</span> len, int32 atttypmod, Node *escontext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; VarChar&nbsp; &nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; maxlen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; maxlen = atttypmod - VARHDRSZ;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (atttypmod &gt;= (int32) VARHDRSZ &amp;&amp; len &gt; maxlen)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Verify that extra characters are spaces, and clip them off */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; mbmaxlen = <a href="../mb/mbutils.c.html#L1125" title="utils/mb/mbutils.c:1125">pg_mbcharcliplen</a>(s, len, maxlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = mbmaxlen; j &lt; len; j++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s[j] != <span class="Constant">' '</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_STRING_DATA_RIGHT_TRUNCATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;value too long for type character varying(</span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">int</span>) maxlen)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len = mbmaxlen;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can use <a href="varlena.c.html#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a> because VarChar and text are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * binary-compatible types.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; result = (VarChar *) <a href="varlena.c.html#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(s, len);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert a C string to VARCHAR <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> representation.&nbsp; atttypmod<br/></li>
<li></span><span class="Comment"> * is the declared length of the type plus VARHDRSZ.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L495">&#x200c;</a><span class="linkable">varcharin</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *s = PG_GETARG_CSTRING(<span class="Constant">0</span>);<br/></li>
<li><span class="PreProc">#ifdef NOT_USED<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typelem = PG_GETARG_OID(<span class="Constant">1</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; atttypmod = PG_GETARG_INT32(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; VarChar&nbsp; &nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L457" title="utils/adt/varchar.c:457">varchar_input</a>(s, strlen(s), atttypmod, fcinfo-&gt;context);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VARCHAR_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert a VARCHAR value to a C string.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Uses the text to C string conversion function, which is only appropriate<br/></li>
<li></span><span class="Comment"> * if VarChar and text are equivalent types.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L516">&#x200c;</a><span class="linkable">varcharout</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; txt = PG_GETARG_DATUM(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CSTRING(TextDatumGetCString(txt));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L527" title="utils/adt/varchar.c:527">varcharrecv</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts external binary format to <a href="#L609" title="utils/adt/varchar.c:609">varchar</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L527">&#x200c;</a><span class="linkable">varcharrecv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; buf = (StringInfo) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><span class="PreProc">#ifdef NOT_USED<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typelem = PG_GETARG_OID(<span class="Constant">1</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; atttypmod = PG_GETARG_INT32(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; VarChar&nbsp; &nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *str;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbytes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; str = <a href="../../libpq/pqformat.c.html#L546" title="libpq/pqformat.c:546">pq_getmsgtext</a>(buf, buf-&gt;len - buf-&gt;cursor, &amp;nbytes);<br/></li>
<li>&nbsp; &nbsp; result = <a href="#L457" title="utils/adt/varchar.c:457">varchar_input</a>(str, nbytes, atttypmod, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(str);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VARCHAR_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L548" title="utils/adt/varchar.c:548">varcharsend</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts <a href="#L609" title="utils/adt/varchar.c:609">varchar</a> to binary format<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L548">&#x200c;</a><span class="linkable">varcharsend</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Exactly the same as <a href="varlena.c.html#L619" title="utils/adt/varlena.c:619">textsend</a>, so share code */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="varlena.c.html#L619" title="utils/adt/varlena.c:619">textsend</a>(fcinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L565" title="utils/adt/varchar.c:565">varchar_support</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Planner support function for the <a href="#L609" title="utils/adt/varchar.c:609">varchar</a>() length coercion function.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Currently, the only interesting thing we can do is flatten calls that set<br/></li>
<li></span><span class="Comment"> * the new maximum length &gt;= the previous maximum length.&nbsp; We can ignore the<br/></li>
<li></span><span class="Comment"> * isExplicit argument, since that only affects truncation cases.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L565">&#x200c;</a><span class="linkable">varchar_support</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *rawreq = (Node *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *ret = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(rawreq, SupportRequestSimplify))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SupportRequestSimplify *req = (SupportRequestSimplify *) rawreq;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FuncExpr&nbsp;&nbsp; *expr = req-&gt;fcall;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *typmod;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(list_length(expr-&gt;args) &gt;= <span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typmod = (Node *) lsecond(expr-&gt;args);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(typmod, Const) &amp;&amp; !((Const *) typmod)-&gt;constisnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *source = (Node *) linitial(expr-&gt;args);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; old_typmod = <a href="../../nodes/nodeFuncs.c.html#L298" title="nodes/nodeFuncs.c:298">exprTypmod</a>(source);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; new_typmod = DatumGetInt32(((Const *) typmod)-&gt;constvalue);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; old_max = old_typmod - VARHDRSZ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; new_max = new_typmod - VARHDRSZ;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (new_typmod &lt; <span class="Constant">0</span> || (old_typmod &gt;= <span class="Constant">0</span> &amp;&amp; old_max &lt;= new_max))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret = <a href="../../nodes/nodeFuncs.c.html#L684" title="nodes/nodeFuncs.c:684">relabel_to_typmod</a>(source, new_typmod);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(ret);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Converts a VARCHAR type to the specified size.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * maxlen is the typmod, ie, declared length plus VARHDRSZ bytes.<br/></li>
<li></span><span class="Comment"> * isExplicit is true if this is for an explicit cast to <a href="#L609" title="utils/adt/varchar.c:609">varchar</a>(N).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Truncation rules: for an explicit cast, silently truncate to the given<br/></li>
<li></span><span class="Comment"> * length; for an implicit cast, raise error unless extra characters are<br/></li>
<li></span><span class="Comment"> * all spaces.&nbsp; (This is sort-of per SQL: the spec would actually have us<br/></li>
<li></span><span class="Comment"> * raise a &quot;completion condition&quot; for the explicit cast case, but Postgres<br/></li>
<li></span><span class="Comment"> * hasn't got such a concept.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L609">&#x200c;</a><span class="linkable">varchar</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; VarChar&nbsp; &nbsp; *source = PG_GETARG_VARCHAR_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; typmod = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isExplicit = PG_GETARG_BOOL(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; maxmblen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *s_data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len = VARSIZE_ANY_EXHDR(source);<br/></li>
<li>&nbsp; &nbsp; s_data = VARDATA_ANY(source);<br/></li>
<li>&nbsp; &nbsp; maxlen = typmod - VARHDRSZ;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No work if typmod is invalid or supplied data fits it already */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (maxlen &lt; <span class="Constant">0</span> || len &lt;= maxlen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_VARCHAR_P(source);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* only reach here if string is too long... */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* truncate multibyte string preserving multibyte boundary */<br/></li>
<li></span>&nbsp; &nbsp; maxmblen = <a href="../mb/mbutils.c.html#L1125" title="utils/mb/mbutils.c:1125">pg_mbcharcliplen</a>(s_data, len, maxlen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!isExplicit)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = maxmblen; i &lt; len; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s_data[i] != <span class="Constant">' '</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_STRING_DATA_RIGHT_TRUNCATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;value too long for type character varying(</span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxlen)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VARCHAR_P((VarChar *) <a href="varlena.c.html#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(s_data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; maxmblen));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L648">&#x200c;</a><span class="linkable">varchartypmodin</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *ta = PG_GETARG_ARRAYTYPE_P(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(<a href="#L33" title="utils/adt/varchar.c:33">anychar_typmodin</a>(ta, <span class="Constant">&quot;<a href="#L609" title="utils/adt/varchar.c:609">varchar</a>&quot;</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L656">&#x200c;</a><span class="linkable">varchartypmodout</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; typmod = PG_GETARG_INT32(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CSTRING(<a href="#L72" title="utils/adt/varchar.c:72">anychar_typmodout</a>(typmod));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*****************************************************************************<br/></li>
<li></span><span class="Comment"> * Exported <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> *****************************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* &quot;True&quot; length (not counting trailing blanks) of a BpChar */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">int<br/></li>
<li><a id="L670">&#x200c;</a></span><span class="linkable">bcTruelen</span>(BpChar *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L676" title="utils/adt/varchar.c:676">bpchartruelen</a>(VARDATA_ANY(arg), VARSIZE_ANY_EXHDR(arg));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">int<br/></li>
<li><a id="L676">&#x200c;</a></span><span class="linkable">bpchartruelen</span>(<span class="Type">char</span> *s, <span class="Type">int</span> len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that we rely on the assumption that ' ' is a singleton unit on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * every supported multibyte server encoding.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = len - <span class="Constant">1</span>; i &gt;= <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s[i] != <span class="Constant">' '</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> i + <span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L693">&#x200c;</a><span class="linkable">bpcharlen</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BpChar&nbsp; &nbsp; &nbsp;&nbsp; *arg = PG_GETARG_BPCHAR_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* get number of bytes, ignoring trailing spaces */<br/></li>
<li></span>&nbsp; &nbsp; len = <a href="#L670" title="utils/adt/varchar.c:670">bcTruelen</a>(arg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* in multibyte encoding, convert to number of characters */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../mb/mbutils.c.html#L1546" title="utils/mb/mbutils.c:1546">pg_database_encoding_max_length</a>() != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len = <a href="../mb/mbutils.c.html#L1057" title="utils/mb/mbutils.c:1057">pg_mbstrlen_with_len</a>(VARDATA_ANY(arg), len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(len);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L709">&#x200c;</a><span class="linkable">bpcharoctetlen</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; arg = PG_GETARG_DATUM(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We need not detoast the input at all */<br/></li>
<li></span>&nbsp; &nbsp; PG_RETURN_INT32(<a href="../../access/common/detoast.c.html#L545" title="access/common/detoast.c:545">toast_raw_datum_size</a>(arg) - VARHDRSZ);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*****************************************************************************<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Comparison Functions used for <a href="#L271" title="utils/adt/varchar.c:271">bpchar</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: btree indexes need these routines not to leak memory; therefore,<br/></li>
<li></span><span class="Comment"> * be careful to free working copies of toasted datums.&nbsp; Most places don't<br/></li>
<li></span><span class="Comment"> * need to be so careful.<br/></li>
<li></span><span class="Comment"> *****************************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L727">&#x200c;</a></span><span class="linkable">check_collation_set</span>(Oid collid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(collid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This typically means that the parser could not resolve a conflict<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of implicit collations, so report it that way.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INDETERMINATE_COLLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not determine which collation to use for string comparison&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Use the COLLATE clause to set the collation explicitly.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L743">&#x200c;</a><span class="linkable">bpchareq</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BpChar&nbsp; &nbsp; &nbsp;&nbsp; *arg1 = PG_GETARG_BPCHAR_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BpChar&nbsp; &nbsp; &nbsp;&nbsp; *arg2 = PG_GETARG_BPCHAR_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collid = PG_GET_COLLATION();<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; locale_is_c = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pg_locale_t mylocale = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L727" title="utils/adt/varchar.c:727">check_collation_set</a>(collid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len1 = <a href="#L670" title="utils/adt/varchar.c:670">bcTruelen</a>(arg1);<br/></li>
<li>&nbsp; &nbsp; len2 = <a href="#L670" title="utils/adt/varchar.c:670">bcTruelen</a>(arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="pg_locale.c.html#L1317" title="utils/adt/pg_locale.c:1317">lc_collate_is_c</a>(collid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; locale_is_c = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; mylocale = <a href="pg_locale.c.html#L1551" title="utils/adt/pg_locale.c:1551">pg_newlocale_from_collation</a>(collid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (locale_is_c || <a href="pg_locale.c.html#L1531" title="utils/adt/pg_locale.c:1531">pg_locale_deterministic</a>(mylocale))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since we only care about equality or not-equality, we can avoid all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the expense of strcoll() here, and just do bitwise comparison.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (len1 != len2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = (memcmp(VARDATA_ANY(arg1), VARDATA_ANY(arg2), len1) == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = (<a href="varlena.c.html#L1539" title="utils/adt/varlena.c:1539">varstr_cmp</a>(VARDATA_ANY(arg1), len1, VARDATA_ANY(arg2), len2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; collid) == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg2, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L788">&#x200c;</a><span class="linkable">bpcharne</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BpChar&nbsp; &nbsp; &nbsp;&nbsp; *arg1 = PG_GETARG_BPCHAR_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BpChar&nbsp; &nbsp; &nbsp;&nbsp; *arg2 = PG_GETARG_BPCHAR_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collid = PG_GET_COLLATION();<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; locale_is_c = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pg_locale_t mylocale = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L727" title="utils/adt/varchar.c:727">check_collation_set</a>(collid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len1 = <a href="#L670" title="utils/adt/varchar.c:670">bcTruelen</a>(arg1);<br/></li>
<li>&nbsp; &nbsp; len2 = <a href="#L670" title="utils/adt/varchar.c:670">bcTruelen</a>(arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="pg_locale.c.html#L1317" title="utils/adt/pg_locale.c:1317">lc_collate_is_c</a>(collid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; locale_is_c = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; mylocale = <a href="pg_locale.c.html#L1551" title="utils/adt/pg_locale.c:1551">pg_newlocale_from_collation</a>(collid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (locale_is_c || <a href="pg_locale.c.html#L1531" title="utils/adt/pg_locale.c:1531">pg_locale_deterministic</a>(mylocale))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since we only care about equality or not-equality, we can avoid all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the expense of strcoll() here, and just do bitwise comparison.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (len1 != len2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = (memcmp(VARDATA_ANY(arg1), VARDATA_ANY(arg2), len1) != <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = (<a href="varlena.c.html#L1539" title="utils/adt/varlena.c:1539">varstr_cmp</a>(VARDATA_ANY(arg1), len1, VARDATA_ANY(arg2), len2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; collid) != <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg2, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L833">&#x200c;</a><span class="linkable">bpcharlt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BpChar&nbsp; &nbsp; &nbsp;&nbsp; *arg1 = PG_GETARG_BPCHAR_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BpChar&nbsp; &nbsp; &nbsp;&nbsp; *arg2 = PG_GETARG_BPCHAR_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len1 = <a href="#L670" title="utils/adt/varchar.c:670">bcTruelen</a>(arg1);<br/></li>
<li>&nbsp; &nbsp; len2 = <a href="#L670" title="utils/adt/varchar.c:670">bcTruelen</a>(arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = <a href="varlena.c.html#L1539" title="utils/adt/varlena.c:1539">varstr_cmp</a>(VARDATA_ANY(arg1), len1, VARDATA_ANY(arg2), len2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PG_GET_COLLATION());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg2, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> &lt; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L854">&#x200c;</a><span class="linkable">bpcharle</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BpChar&nbsp; &nbsp; &nbsp;&nbsp; *arg1 = PG_GETARG_BPCHAR_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BpChar&nbsp; &nbsp; &nbsp;&nbsp; *arg2 = PG_GETARG_BPCHAR_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len1 = <a href="#L670" title="utils/adt/varchar.c:670">bcTruelen</a>(arg1);<br/></li>
<li>&nbsp; &nbsp; len2 = <a href="#L670" title="utils/adt/varchar.c:670">bcTruelen</a>(arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = <a href="varlena.c.html#L1539" title="utils/adt/varlena.c:1539">varstr_cmp</a>(VARDATA_ANY(arg1), len1, VARDATA_ANY(arg2), len2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PG_GET_COLLATION());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg2, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> &lt;= <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L875">&#x200c;</a><span class="linkable">bpchargt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BpChar&nbsp; &nbsp; &nbsp;&nbsp; *arg1 = PG_GETARG_BPCHAR_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BpChar&nbsp; &nbsp; &nbsp;&nbsp; *arg2 = PG_GETARG_BPCHAR_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len1 = <a href="#L670" title="utils/adt/varchar.c:670">bcTruelen</a>(arg1);<br/></li>
<li>&nbsp; &nbsp; len2 = <a href="#L670" title="utils/adt/varchar.c:670">bcTruelen</a>(arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = <a href="varlena.c.html#L1539" title="utils/adt/varlena.c:1539">varstr_cmp</a>(VARDATA_ANY(arg1), len1, VARDATA_ANY(arg2), len2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PG_GET_COLLATION());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg2, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> &gt; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L896">&#x200c;</a><span class="linkable">bpcharge</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BpChar&nbsp; &nbsp; &nbsp;&nbsp; *arg1 = PG_GETARG_BPCHAR_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BpChar&nbsp; &nbsp; &nbsp;&nbsp; *arg2 = PG_GETARG_BPCHAR_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len1 = <a href="#L670" title="utils/adt/varchar.c:670">bcTruelen</a>(arg1);<br/></li>
<li>&nbsp; &nbsp; len2 = <a href="#L670" title="utils/adt/varchar.c:670">bcTruelen</a>(arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = <a href="varlena.c.html#L1539" title="utils/adt/varlena.c:1539">varstr_cmp</a>(VARDATA_ANY(arg1), len1, VARDATA_ANY(arg2), len2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PG_GET_COLLATION());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg2, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> &gt;= <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L917">&#x200c;</a><span class="linkable">bpcharcmp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BpChar&nbsp; &nbsp; &nbsp;&nbsp; *arg1 = PG_GETARG_BPCHAR_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BpChar&nbsp; &nbsp; &nbsp;&nbsp; *arg2 = PG_GETARG_BPCHAR_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len1 = <a href="#L670" title="utils/adt/varchar.c:670">bcTruelen</a>(arg1);<br/></li>
<li>&nbsp; &nbsp; len2 = <a href="#L670" title="utils/adt/varchar.c:670">bcTruelen</a>(arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = <a href="varlena.c.html#L1539" title="utils/adt/varlena.c:1539">varstr_cmp</a>(VARDATA_ANY(arg1), len1, VARDATA_ANY(arg2), len2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PG_GET_COLLATION());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg2, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L938">&#x200c;</a><span class="linkable">bpchar_sortsupport</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SortSupport ssup = (SortSupport) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collid = ssup-&gt;ssup_collation;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(ssup-&gt;ssup_cxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Use generic string SortSupport */<br/></li>
<li></span>&nbsp; &nbsp; <a href="varlena.c.html#L1873" title="utils/adt/varlena.c:1873">varstr_sortsupport</a>(ssup, BPCHAROID, collid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VOID();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L955">&#x200c;</a><span class="linkable">bpchar_larger</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BpChar&nbsp; &nbsp; &nbsp;&nbsp; *arg1 = PG_GETARG_BPCHAR_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BpChar&nbsp; &nbsp; &nbsp;&nbsp; *arg2 = PG_GETARG_BPCHAR_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len1 = <a href="#L670" title="utils/adt/varchar.c:670">bcTruelen</a>(arg1);<br/></li>
<li>&nbsp; &nbsp; len2 = <a href="#L670" title="utils/adt/varchar.c:670">bcTruelen</a>(arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = <a href="varlena.c.html#L1539" title="utils/adt/varlena.c:1539">varstr_cmp</a>(VARDATA_ANY(arg1), len1, VARDATA_ANY(arg2), len2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PG_GET_COLLATION());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BPCHAR_P((<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> &gt;= <span class="Constant">0</span>) ? arg1 : arg2);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L973">&#x200c;</a><span class="linkable">bpchar_smaller</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BpChar&nbsp; &nbsp; &nbsp;&nbsp; *arg1 = PG_GETARG_BPCHAR_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BpChar&nbsp; &nbsp; &nbsp;&nbsp; *arg2 = PG_GETARG_BPCHAR_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len1 = <a href="#L670" title="utils/adt/varchar.c:670">bcTruelen</a>(arg1);<br/></li>
<li>&nbsp; &nbsp; len2 = <a href="#L670" title="utils/adt/varchar.c:670">bcTruelen</a>(arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = <a href="varlena.c.html#L1539" title="utils/adt/varlena.c:1539">varstr_cmp</a>(VARDATA_ANY(arg1), len1, VARDATA_ANY(arg2), len2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PG_GET_COLLATION());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BPCHAR_P((<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> &lt;= <span class="Constant">0</span>) ? arg1 : arg2);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L271" title="utils/adt/varchar.c:271">bpchar</a> needs a specialized <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> function because we want to ignore<br/></li>
<li></span><span class="Comment"> * trailing blanks in comparisons.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L996">&#x200c;</a><span class="linkable">hashbpchar</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BpChar&nbsp; &nbsp; &nbsp;&nbsp; *key = PG_GETARG_BPCHAR_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collid = PG_GET_COLLATION();<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *keydata;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keylen;<br/></li>
<li>&nbsp; &nbsp; pg_locale_t mylocale = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!collid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INDETERMINATE_COLLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not determine which collation to use for string hashing&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Use the COLLATE clause to set the collation explicitly.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; keydata = VARDATA_ANY(key);<br/></li>
<li>&nbsp; &nbsp; keylen = <a href="#L670" title="utils/adt/varchar.c:670">bcTruelen</a>(key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="pg_locale.c.html#L1317" title="utils/adt/pg_locale.c:1317">lc_collate_is_c</a>(collid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mylocale = <a href="pg_locale.c.html#L1551" title="utils/adt/pg_locale.c:1551">pg_newlocale_from_collation</a>(collid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="pg_locale.c.html#L1531" title="utils/adt/pg_locale.c:1531">pg_locale_deterministic</a>(mylocale))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = hash_any((<span class="Type">unsigned</span> <span class="Type">char</span> *) keydata, keylen);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; bsize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rsize;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bsize = <a href="pg_locale.c.html#L2417" title="utils/adt/pg_locale.c:2417">pg_strnxfrm</a>(<span class="Constant">NULL</span>, <span class="Constant">0</span>, keydata, keylen, mylocale);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(bsize + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rsize = <a href="pg_locale.c.html#L2417" title="utils/adt/pg_locale.c:2417">pg_strnxfrm</a>(buf, bsize + <span class="Constant">1</span>, keydata, keylen, mylocale);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rsize != bsize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="pg_locale.c.html#L2417" title="utils/adt/pg_locale.c:2417">pg_strnxfrm</a>() returned unexpected result&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In principle, there's no reason to include the terminating NUL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * character in the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>, but it was done <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> and the behavior must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be preserved.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = hash_any((<span class="Type">uint8_t</span> *) buf, bsize + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(buf);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Avoid leaking memory for toasted inputs */<br/></li>
<li></span>&nbsp; &nbsp; PG_FREE_IF_COPY(key, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1051">&#x200c;</a><span class="linkable">hashbpcharextended</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BpChar&nbsp; &nbsp; &nbsp;&nbsp; *key = PG_GETARG_BPCHAR_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collid = PG_GET_COLLATION();<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *keydata;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keylen;<br/></li>
<li>&nbsp; &nbsp; pg_locale_t mylocale = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!collid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INDETERMINATE_COLLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not determine which collation to use for string hashing&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Use the COLLATE clause to set the collation explicitly.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; keydata = VARDATA_ANY(key);<br/></li>
<li>&nbsp; &nbsp; keylen = <a href="#L670" title="utils/adt/varchar.c:670">bcTruelen</a>(key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="pg_locale.c.html#L1317" title="utils/adt/pg_locale.c:1317">lc_collate_is_c</a>(collid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mylocale = <a href="pg_locale.c.html#L1551" title="utils/adt/pg_locale.c:1551">pg_newlocale_from_collation</a>(collid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="pg_locale.c.html#L1531" title="utils/adt/pg_locale.c:1531">pg_locale_deterministic</a>(mylocale))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = hash_any_extended((<span class="Type">unsigned</span> <span class="Type">char</span> *) keydata, keylen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PG_GETARG_INT64(<span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; bsize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rsize;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bsize = <a href="pg_locale.c.html#L2417" title="utils/adt/pg_locale.c:2417">pg_strnxfrm</a>(<span class="Constant">NULL</span>, <span class="Constant">0</span>, keydata, keylen, mylocale);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(bsize + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rsize = <a href="pg_locale.c.html#L2417" title="utils/adt/pg_locale.c:2417">pg_strnxfrm</a>(buf, bsize + <span class="Constant">1</span>, keydata, keylen, mylocale);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rsize != bsize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="pg_locale.c.html#L2417" title="utils/adt/pg_locale.c:2417">pg_strnxfrm</a>() returned unexpected result&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In principle, there's no reason to include the terminating NUL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * character in the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>, but it was done <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> and the behavior must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be preserved.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = hash_any_extended((<span class="Type">uint8_t</span> *) buf, bsize + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PG_GETARG_INT64(<span class="Constant">1</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(buf);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(key, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The following operators support character-by-character comparison<br/></li>
<li></span><span class="Comment"> * of <a href="#L271" title="utils/adt/varchar.c:271">bpchar</a> datums, to allow building indexes suitable for LIKE clauses.<br/></li>
<li></span><span class="Comment"> * Note that the regular <a href="#L743" title="utils/adt/varchar.c:743">bpchareq</a>/<a href="#L788" title="utils/adt/varchar.c:788">bpcharne</a> comparison operators, and<br/></li>
<li></span><span class="Comment"> * regular support <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> 1 and 2 with &quot;C&quot; collation are assumed to be<br/></li>
<li></span><span class="Comment"> * compatible with these!<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1115">&#x200c;</a></span><span class="linkable">internal_bpchar_pattern_compare</span>(BpChar *arg1, BpChar *arg2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len1 = <a href="#L670" title="utils/adt/varchar.c:670">bcTruelen</a>(arg1);<br/></li>
<li>&nbsp; &nbsp; len2 = <a href="#L670" title="utils/adt/varchar.c:670">bcTruelen</a>(arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = memcmp(VARDATA_ANY(arg1), VARDATA_ANY(arg2), <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(len1, len2));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (len1 &lt; len2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (len1 &gt; len2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1137">&#x200c;</a><span class="linkable">bpchar_pattern_lt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BpChar&nbsp; &nbsp; &nbsp;&nbsp; *arg1 = PG_GETARG_BPCHAR_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BpChar&nbsp; &nbsp; &nbsp;&nbsp; *arg2 = PG_GETARG_BPCHAR_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L1115" title="utils/adt/varchar.c:1115">internal_bpchar_pattern_compare</a>(arg1, arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg2, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result &lt; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1153">&#x200c;</a><span class="linkable">bpchar_pattern_le</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BpChar&nbsp; &nbsp; &nbsp;&nbsp; *arg1 = PG_GETARG_BPCHAR_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BpChar&nbsp; &nbsp; &nbsp;&nbsp; *arg2 = PG_GETARG_BPCHAR_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L1115" title="utils/adt/varchar.c:1115">internal_bpchar_pattern_compare</a>(arg1, arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg2, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result &lt;= <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1169">&#x200c;</a><span class="linkable">bpchar_pattern_ge</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BpChar&nbsp; &nbsp; &nbsp;&nbsp; *arg1 = PG_GETARG_BPCHAR_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BpChar&nbsp; &nbsp; &nbsp;&nbsp; *arg2 = PG_GETARG_BPCHAR_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L1115" title="utils/adt/varchar.c:1115">internal_bpchar_pattern_compare</a>(arg1, arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg2, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result &gt;= <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1185">&#x200c;</a><span class="linkable">bpchar_pattern_gt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BpChar&nbsp; &nbsp; &nbsp;&nbsp; *arg1 = PG_GETARG_BPCHAR_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BpChar&nbsp; &nbsp; &nbsp;&nbsp; *arg2 = PG_GETARG_BPCHAR_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L1115" title="utils/adt/varchar.c:1115">internal_bpchar_pattern_compare</a>(arg1, arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg2, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result &gt; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1201">&#x200c;</a><span class="linkable">btbpchar_pattern_cmp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BpChar&nbsp; &nbsp; &nbsp;&nbsp; *arg1 = PG_GETARG_BPCHAR_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BpChar&nbsp; &nbsp; &nbsp;&nbsp; *arg2 = PG_GETARG_BPCHAR_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L1115" title="utils/adt/varchar.c:1115">internal_bpchar_pattern_compare</a>(arg1, arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg2, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1217">&#x200c;</a><span class="linkable">btbpchar_pattern_sortsupport</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SortSupport ssup = (SortSupport) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(ssup-&gt;ssup_cxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Use generic string SortSupport, forcing &quot;C&quot; collation */<br/></li>
<li></span>&nbsp; &nbsp; <a href="varlena.c.html#L1873" title="utils/adt/varlena.c:1873">varstr_sortsupport</a>(ssup, BPCHAROID, C_COLLATION_OID);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VOID();<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
