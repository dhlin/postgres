<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/adt/ri_triggers.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/adt/ri_triggers.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L183">ri_compare_cache</a></li>
<li><a href="#L181">ri_constraint_cache</a></li>
<li><a href="#L184">ri_constraint_cache_valid_list</a></li>
<li><a href="#L182">ri_query_cache</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L169">RI_CompareHashEntry</a></li>
<li><a href="#L175">RI_CompareHashEntry</a></li>
<li><a href="#L160">RI_CompareKey</a></li>
<li><a href="#L164">RI_CompareKey</a></li>
<li><a href="#L105">RI_ConstraintInfo</a></li>
<li><a href="#L133">RI_ConstraintInfo</a></li>
<li><a href="#L149">RI_QueryHashEntry</a></li>
<li><a href="#L153">RI_QueryHashEntry</a></li>
<li><a href="#L140">RI_QueryKey</a></li>
<li><a href="#L144">RI_QueryKey</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L2327">InvalidateConstraintCacheCallBack</a></li>
<li><a href="#L827">RI_FKey_cascade_del</a></li>
<li><a href="#L933">RI_FKey_cascade_upd</a></li>
<li><a href="#L247">RI_FKey_check</a></li>
<li><a href="#L471">RI_FKey_check_ins</a></li>
<li><a href="#L487">RI_FKey_check_upd</a></li>
<li><a href="#L1342">RI_FKey_fk_upd_check_required</a></li>
<li><a href="#L635">RI_FKey_noaction_del</a></li>
<li><a href="#L672">RI_FKey_noaction_upd</a></li>
<li><a href="#L1310">RI_FKey_pk_upd_check_required</a></li>
<li><a href="#L655">RI_FKey_restrict_del</a></li>
<li><a href="#L692">RI_FKey_restrict_upd</a></li>
<li><a href="#L1084">RI_FKey_setdefault_del</a></li>
<li><a href="#L1099">RI_FKey_setdefault_upd</a></li>
<li><a href="#L1054">RI_FKey_setnull_del</a></li>
<li><a href="#L1069">RI_FKey_setnull_upd</a></li>
<li><a href="#L3123">RI_FKey_trigger_type</a></li>
<li><a href="#L1443">RI_Initial_Check</a></li>
<li><a href="#L1738">RI_PartitionRemove_Check</a></li>
<li><a href="#L2293">get_ri_constraint_root</a></li>
<li><a href="#L1957">quoteOneName</a></li>
<li><a href="#L1977">quoteRelationName</a></li>
<li><a href="#L2064">ri_BuildQueryKey</a></li>
<li><a href="#L2096">ri_CheckTrigger</a></li>
<li><a href="#L508">ri_Check_Pk_Match</a></li>
<li><a href="#L2982">ri_CompareWithCast</a></li>
<li><a href="#L2548">ri_ExtractValues</a></li>
<li><a href="#L2142">ri_FetchConstraintInfo</a></li>
<li><a href="#L2808">ri_FetchPreparedPlan</a></li>
<li><a href="#L1994">ri_GenerateQual</a></li>
<li><a href="#L2023">ri_GenerateQualCollation</a></li>
<li><a href="#L3030">ri_HashCompareOp</a></li>
<li><a href="#L2860">ri_HashPreparedPlan</a></li>
<li><a href="#L2772">ri_InitHashTables</a></li>
<li><a href="#L2897">ri_KeysEqual</a></li>
<li><a href="#L2196">ri_LoadConstraintInfo</a></li>
<li><a href="#L2735">ri_NullCheck</a></li>
<li><a href="#L2411">ri_PerformCheck</a></li>
<li><a href="#L2368">ri_PlanCheck</a></li>
<li><a href="#L2577">ri_ReportViolation</a></li>
<li><a href="#L708">ri_restrict</a></li>
<li><a href="#L1115">ri_set</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L84">MAX_QUOTED_NAME_LEN</a></li>
<li><a href="#L85">MAX_QUOTED_REL_NAME_LEN</a></li>
<li><a href="#L89">RIAttCollation</a></li>
<li><a href="#L87">RIAttName</a></li>
<li><a href="#L88">RIAttType</a></li>
<li><a href="#L62">RI_INIT_CONSTRAINTHASHSIZE</a></li>
<li><a href="#L63">RI_INIT_QUERYHASHSIZE</a></li>
<li><a href="#L65">RI_KEYS_ALL_NULL</a></li>
<li><a href="#L67">RI_KEYS_NONE_NULL</a></li>
<li><a href="#L66">RI_KEYS_SOME_NULL</a></li>
<li><a href="#L60">RI_MAX_NUMKEYS</a></li>
<li><a href="#L75">RI_PLAN_CASCADE_ONDELETE</a></li>
<li><a href="#L76">RI_PLAN_CASCADE_ONUPDATE</a></li>
<li><a href="#L71">RI_PLAN_CHECK_LOOKUPPK</a></li>
<li><a href="#L72">RI_PLAN_CHECK_LOOKUPPK_FROM_PK</a></li>
<li><a href="#L73">RI_PLAN_LAST_ON_PK</a></li>
<li><a href="#L78">RI_PLAN_RESTRICT</a></li>
<li><a href="#L81">RI_PLAN_SETDEFAULT_ONDELETE</a></li>
<li><a href="#L82">RI_PLAN_SETDEFAULT_ONUPDATE</a></li>
<li><a href="#L79">RI_PLAN_SETNULL_ONDELETE</a></li>
<li><a href="#L80">RI_PLAN_SETNULL_ONUPDATE</a></li>
<li><a href="#L93">RI_TRIGTYPE_DELETE</a></li>
<li><a href="#L91">RI_TRIGTYPE_INSERT</a></li>
<li><a href="#L92">RI_TRIGTYPE_UPDATE</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * ri_triggers.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Generic <a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> procedures for referential integrity constraint<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; checks.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Note about memory management: the private hashtables kept here live<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; across query and transaction boundaries, in fact they live as long as<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; the backend does.&nbsp; This works because the hashtable structures<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; themselves are allocated by dynahash.c in its permanent DynaHashCxt,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; and the SPI plans they point to are saved using <a href="../../executor/spi.c.html#L973" title="executor/spi.c:973">SPI_keepplan</a>().<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; There is not currently <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> provision for throwing away a no-longer-needed<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; plan --- consider improving this someday.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * src/backend/utils/adt/ri_triggers.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/sysattr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/table.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/tableam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_collation.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_constraint.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_proc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/<a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/executor.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/spi.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lib/ilist.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_coerce.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_relation.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/acl.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/datum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgroids.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/guc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/inval.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rangetypes.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rls.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/ruleutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/snapmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/syscache.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Local definitions<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><a id="L60">&#x200c;</a><span class="PreProc">#define <span class="linkable">RI_MAX_NUMKEYS</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INDEX_MAX_KEYS<br/></li>
<li></span><br/></li>
<li><a id="L62">&#x200c;</a><span class="PreProc">#define <span class="linkable">RI_INIT_CONSTRAINTHASHSIZE</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">64<br/></li>
<li><a id="L63">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RI_INIT_QUERYHASHSIZE</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L62" title="utils/adt/ri_triggers.c:62">RI_INIT_CONSTRAINTHASHSIZE</a> * </span><span class="Constant">4</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><a id="L65">&#x200c;</a><span class="PreProc">#define <span class="linkable">RI_KEYS_ALL_NULL</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0<br/></li>
<li><a id="L66">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RI_KEYS_SOME_NULL</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">1<br/></li>
<li><a id="L67">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RI_KEYS_NONE_NULL</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">2<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* RI query type codes */<br/></li>
<li></span><span class="Comment">/* these queries are executed against the PK (referenced) table: */<br/></li>
<li><a id="L71">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RI_PLAN_CHECK_LOOKUPPK</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">1<br/></li>
<li><a id="L72">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RI_PLAN_CHECK_LOOKUPPK_FROM_PK</span>&nbsp; &nbsp; </span><span class="Constant">2<br/></li>
<li><a id="L73">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RI_PLAN_LAST_ON_PK</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L72" title="utils/adt/ri_triggers.c:72">RI_PLAN_CHECK_LOOKUPPK_FROM_PK</a><br/></li>
<li></span><span class="Comment">/* these queries are executed against the FK (referencing) table: */<br/></li>
<li><a id="L75">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RI_PLAN_CASCADE_ONDELETE</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">3<br/></li>
<li><a id="L76">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RI_PLAN_CASCADE_ONUPDATE</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">4<br/></li>
<li></span><span class="Comment">/* For RESTRICT, the same plan can be used for both ON DELETE and ON UPDATE triggers. */<br/></li>
<li><a id="L78">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RI_PLAN_RESTRICT</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">5<br/></li>
<li><a id="L79">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RI_PLAN_SETNULL_ONDELETE</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">6<br/></li>
<li><a id="L80">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RI_PLAN_SETNULL_ONUPDATE</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">7<br/></li>
<li><a id="L81">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RI_PLAN_SETDEFAULT_ONDELETE</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">8<br/></li>
<li><a id="L82">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RI_PLAN_SETDEFAULT_ONUPDATE</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">9<br/></li>
<li></span><br/></li>
<li><a id="L84">&#x200c;</a><span class="PreProc">#define <span class="linkable">MAX_QUOTED_NAME_LEN</span>&nbsp; (NAMEDATALEN*</span><span class="Constant">2</span><span class="PreProc">+</span><span class="Constant">3</span><span class="PreProc">)<br/></li>
<li><a id="L85">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MAX_QUOTED_REL_NAME_LEN</span>&nbsp; (<a href="#L84" title="utils/adt/ri_triggers.c:84">MAX_QUOTED_NAME_LEN</a>*</span><span class="Constant">2</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><a id="L87">&#x200c;</a><span class="PreProc">#define <span class="linkable">RIAttName</span>(rel, attnum)&nbsp; &nbsp; NameStr(*<a href="../../parser/parse_relation.c.html#L3533" title="parser/parse_relation.c:3533">attnumAttName</a>(rel, attnum))<br/></li>
<li><a id="L88">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RIAttType</span>(rel, attnum)&nbsp; &nbsp; <a href="../../parser/parse_relation.c.html#L3555" title="parser/parse_relation.c:3555">attnumTypeId</a>(rel, attnum)<br/></li>
<li><a id="L89">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RIAttCollation</span>(rel, attnum) <a href="../../parser/parse_relation.c.html#L3575" title="parser/parse_relation.c:3575">attnumCollationId</a>(rel, attnum)<br/></li>
<li></span><br/></li>
<li><a id="L91">&#x200c;</a><span class="PreProc">#define <span class="linkable">RI_TRIGTYPE_INSERT</span> </span><span class="Constant">1<br/></li>
<li><a id="L92">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RI_TRIGTYPE_UPDATE</span> </span><span class="Constant">2<br/></li>
<li><a id="L93">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RI_TRIGTYPE_DELETE</span> </span><span class="Constant">3<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L105" title="utils/adt/ri_triggers.c:105">RI_ConstraintInfo</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Information extracted from an FK pg_constraint entry.&nbsp; This is cached in<br/></li>
<li></span><span class="Comment"> * <a href="#L181" title="utils/adt/ri_triggers.c:181">ri_constraint_cache</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that pf/pp/ff_eq_oprs may hold the overlaps operator instead of equals<br/></li>
<li></span><span class="Comment"> * for the PERIOD part of a temporal foreign key.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L105">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">RI_ConstraintInfo</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constraint_id;&nbsp; &nbsp; <span class="Comment">/* OID of pg_constraint entry (<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> key) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; valid;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* successfully initialized? */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constraint_root_id; <span class="Comment">/* OID of topmost ancestor constraint;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * same as constraint_id if not inherited */<br/></li>
<li></span>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; oidHashValue;&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> value of constraint_id */<br/></li>
<li></span>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; rootHashValue;&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> value of constraint_root_id */<br/></li>
<li></span>&nbsp; &nbsp; NameData&nbsp; &nbsp; conname;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* name of the FK constraint */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pk_relid;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* referenced relation */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fk_relid;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* referencing relation */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; confupdtype;&nbsp; &nbsp; <span class="Comment">/* foreign key's ON UPDATE action */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; confdeltype;&nbsp; &nbsp; <span class="Comment">/* foreign key's ON DELETE action */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndelsetcols;&nbsp; &nbsp; <span class="Comment">/* number of columns referenced in ON DELETE<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> clause */<br/></li>
<li></span>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; confdelsetcols[<a href="#L60" title="utils/adt/ri_triggers.c:60">RI_MAX_NUMKEYS</a>]; <span class="Comment">/* attnums of cols to set on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * delete */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; confmatchtype;&nbsp; &nbsp; <span class="Comment">/* foreign key's match type */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; hasperiod;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if the foreign key uses PERIOD */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nkeys;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* number of key columns */<br/></li>
<li></span>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; pk_attnums[<a href="#L60" title="utils/adt/ri_triggers.c:60">RI_MAX_NUMKEYS</a>]; <span class="Comment">/* attnums of referenced cols */<br/></li>
<li></span>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; fk_attnums[<a href="#L60" title="utils/adt/ri_triggers.c:60">RI_MAX_NUMKEYS</a>]; <span class="Comment">/* attnums of referencing cols */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pf_eq_oprs[<a href="#L60" title="utils/adt/ri_triggers.c:60">RI_MAX_NUMKEYS</a>]; <span class="Comment">/* equality operators (PK = FK) */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pp_eq_oprs[<a href="#L60" title="utils/adt/ri_triggers.c:60">RI_MAX_NUMKEYS</a>]; <span class="Comment">/* equality operators (PK = PK) */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ff_eq_oprs[<a href="#L60" title="utils/adt/ri_triggers.c:60">RI_MAX_NUMKEYS</a>]; <span class="Comment">/* equality operators (FK = FK) */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; period_contained_by_oper;&nbsp; &nbsp; <span class="Comment">/* <a href="pseudotypes.c.html#L207" title="utils/adt/pseudotypes.c:207">anyrange</a> &lt;@ <a href="pseudotypes.c.html#L207" title="utils/adt/pseudotypes.c:207">anyrange</a> */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; agged_period_contained_by_oper; <span class="Comment">/* fkattr &lt;@ range_agg(pkattr) */<br/></li>
<li></span>&nbsp; &nbsp; dlist_node&nbsp; &nbsp; valid_link;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Link in list of valid entries */<br/></li>
<li><a id="L133">&#x200c;</a></span>} <span class="linkable">RI_ConstraintInfo</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L140" title="utils/adt/ri_triggers.c:140">RI_QueryKey</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The key identifying a prepared SPI plan in our query hashtable<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L140">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">RI_QueryKey</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constr_id;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OID of pg_constraint entry */<br/></li>
<li></span>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; constr_queryno; <span class="Comment">/* query type ID, see RI_PLAN_XXX above */<br/></li>
<li><a id="L144">&#x200c;</a></span>} <span class="linkable">RI_QueryKey</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L149" title="utils/adt/ri_triggers.c:149">RI_QueryHashEntry</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L149">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">RI_QueryHashEntry</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L140" title="utils/adt/ri_triggers.c:140">RI_QueryKey</a> key;<br/></li>
<li>&nbsp; &nbsp; SPIPlanPtr&nbsp; &nbsp; plan;<br/></li>
<li><a id="L153">&#x200c;</a>} <span class="linkable">RI_QueryHashEntry</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L160" title="utils/adt/ri_triggers.c:160">RI_CompareKey</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The key identifying an entry showing how to <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> two <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L160">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">RI_CompareKey</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eq_opr;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the equality operator to apply */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typeid;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the data type to apply it to */<br/></li>
<li><a id="L164">&#x200c;</a></span>} <span class="linkable">RI_CompareKey</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L169" title="utils/adt/ri_triggers.c:169">RI_CompareHashEntry</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L169">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">RI_CompareHashEntry</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L160" title="utils/adt/ri_triggers.c:160">RI_CompareKey</a> key;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; valid;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* successfully initialized? */<br/></li>
<li></span>&nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; eq_opr_finfo;&nbsp; &nbsp; <span class="Comment">/* call info for equality fn */<br/></li>
<li></span>&nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; cast_func_finfo;&nbsp; &nbsp; <span class="Comment">/* in case we must coerce input */<br/></li>
<li><a id="L175">&#x200c;</a></span>} <span class="linkable">RI_CompareHashEntry</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Local data<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L181">&#x200c;</a></span><span class="Type">static</span> <a href="../hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *<span class="linkable">ri_constraint_cache</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L182">&#x200c;</a><span class="Type">static</span> <a href="../hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *<span class="linkable">ri_query_cache</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L183">&#x200c;</a><span class="Type">static</span> <a href="../hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *<span class="linkable">ri_compare_cache</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L184">&#x200c;</a><span class="Type">static</span> dclist_head <span class="linkable">ri_constraint_cache_valid_list</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Local function prototypes<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L508" title="utils/adt/ri_triggers.c:508">ri_Check_Pk_Match</a>(Relation pk_rel, Relation fk_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot *oldslot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <a href="#L105" title="utils/adt/ri_triggers.c:105">RI_ConstraintInfo</a> *riinfo);<br/></li>
<li><span class="Type">static</span> Datum <a href="#L708" title="utils/adt/ri_triggers.c:708">ri_restrict</a>(TriggerData *trigdata, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_no_action);<br/></li>
<li><span class="Type">static</span> Datum <a href="#L1115" title="utils/adt/ri_triggers.c:1115">ri_set</a>(TriggerData *trigdata, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_set_null, <span class="Type">int</span> tgkind);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1957" title="utils/adt/ri_triggers.c:1957">quoteOneName</a>(<span class="Type">char</span> *buffer, <span class="Type">const</span> <span class="Type">char</span> *name);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1977" title="utils/adt/ri_triggers.c:1977">quoteRelationName</a>(<span class="Type">char</span> *buffer, Relation rel);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1994" title="utils/adt/ri_triggers.c:1994">ri_GenerateQual</a>(StringInfo buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *sep,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *leftop, Oid leftoptype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid opoid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *rightop, Oid rightoptype);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2023" title="utils/adt/ri_triggers.c:2023">ri_GenerateQualCollation</a>(StringInfo buf, Oid collation);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L2735" title="utils/adt/ri_triggers.c:2735">ri_NullCheck</a>(TupleDesc tupDesc, TupleTableSlot *slot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <a href="#L105" title="utils/adt/ri_triggers.c:105">RI_ConstraintInfo</a> *riinfo, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> rel_is_pk);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2064" title="utils/adt/ri_triggers.c:2064">ri_BuildQueryKey</a>(<a href="#L140" title="utils/adt/ri_triggers.c:140">RI_QueryKey</a> *key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <a href="#L105" title="utils/adt/ri_triggers.c:105">RI_ConstraintInfo</a> *riinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; int32 constr_queryno);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2897" title="utils/adt/ri_triggers.c:2897">ri_KeysEqual</a>(Relation rel, TupleTableSlot *oldslot, TupleTableSlot *newslot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <a href="#L105" title="utils/adt/ri_triggers.c:105">RI_ConstraintInfo</a> *riinfo, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> rel_is_pk);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2982" title="utils/adt/ri_triggers.c:2982">ri_CompareWithCast</a>(Oid eq_opr, Oid typeid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum lhs, Datum rhs);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2772" title="utils/adt/ri_triggers.c:2772">ri_InitHashTables</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2327" title="utils/adt/ri_triggers.c:2327">InvalidateConstraintCacheCallBack</a>(Datum arg, <span class="Type">int</span> cacheid, uint32 hashvalue);<br/></li>
<li><span class="Type">static</span> SPIPlanPtr <a href="#L2808" title="utils/adt/ri_triggers.c:2808">ri_FetchPreparedPlan</a>(<a href="#L140" title="utils/adt/ri_triggers.c:140">RI_QueryKey</a> *key);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2860" title="utils/adt/ri_triggers.c:2860">ri_HashPreparedPlan</a>(<a href="#L140" title="utils/adt/ri_triggers.c:140">RI_QueryKey</a> *key, SPIPlanPtr plan);<br/></li>
<li><span class="Type">static</span> <a href="#L169" title="utils/adt/ri_triggers.c:169">RI_CompareHashEntry</a> *<a href="#L3030" title="utils/adt/ri_triggers.c:3030">ri_HashCompareOp</a>(Oid eq_opr, Oid typeid);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2096" title="utils/adt/ri_triggers.c:2096">ri_CheckTrigger</a>(FunctionCallInfo fcinfo, <span class="Type">const</span> <span class="Type">char</span> *funcname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> tgkind);<br/></li>
<li><span class="Type">static</span> <span class="Type">const</span> <a href="#L105" title="utils/adt/ri_triggers.c:105">RI_ConstraintInfo</a> *<a href="#L2142" title="utils/adt/ri_triggers.c:2142">ri_FetchConstraintInfo</a>(Trigger *<a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relation trig_rel, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> rel_is_pk);<br/></li>
<li><span class="Type">static</span> <span class="Type">const</span> <a href="#L105" title="utils/adt/ri_triggers.c:105">RI_ConstraintInfo</a> *<a href="#L2196" title="utils/adt/ri_triggers.c:2196">ri_LoadConstraintInfo</a>(Oid constraintOid);<br/></li>
<li><span class="Type">static</span> Oid&nbsp; &nbsp; <a href="#L2293" title="utils/adt/ri_triggers.c:2293">get_ri_constraint_root</a>(Oid constrOid);<br/></li>
<li><span class="Type">static</span> SPIPlanPtr <a href="#L2368" title="utils/adt/ri_triggers.c:2368">ri_PlanCheck</a>(<span class="Type">const</span> <span class="Type">char</span> *querystr, <span class="Type">int</span> nargs, Oid *argtypes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L140" title="utils/adt/ri_triggers.c:140">RI_QueryKey</a> *qkey, Relation fk_rel, Relation pk_rel);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2411" title="utils/adt/ri_triggers.c:2411">ri_PerformCheck</a>(<span class="Type">const</span> <a href="#L105" title="utils/adt/ri_triggers.c:105">RI_ConstraintInfo</a> *riinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L140" title="utils/adt/ri_triggers.c:140">RI_QueryKey</a> *qkey, SPIPlanPtr qplan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation fk_rel, Relation pk_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot *oldslot, TupleTableSlot *newslot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> detectNewRows, <span class="Type">int</span> expect_OK);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2548" title="utils/adt/ri_triggers.c:2548">ri_ExtractValues</a>(Relation rel, TupleTableSlot *slot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <a href="#L105" title="utils/adt/ri_triggers.c:105">RI_ConstraintInfo</a> *riinfo, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> rel_is_pk,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum *vals, <span class="Type">char</span> *nulls);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2577" title="utils/adt/ri_triggers.c:2577">ri_ReportViolation</a>(<span class="Type">const</span> <a href="#L105" title="utils/adt/ri_triggers.c:105">RI_ConstraintInfo</a> *riinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relation pk_rel, Relation fk_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TupleTableSlot *violatorslot, TupleDesc tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> queryno, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> partgone) pg_attribute_noreturn();<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L247" title="utils/adt/ri_triggers.c:247">RI_FKey_check</a> -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Check foreign key existence (combined for INSERT and UPDATE).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Datum<br/></li>
<li><a id="L247">&#x200c;</a><span class="linkable">RI_FKey_check</span>(TriggerData *trigdata)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="#L105" title="utils/adt/ri_triggers.c:105">RI_ConstraintInfo</a> *riinfo;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; fk_rel;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; pk_rel;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *newslot;<br/></li>
<li>&nbsp; &nbsp; <a href="#L140" title="utils/adt/ri_triggers.c:140">RI_QueryKey</a> qkey;<br/></li>
<li>&nbsp; &nbsp; SPIPlanPtr&nbsp; &nbsp; qplan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; riinfo = <a href="#L2142" title="utils/adt/ri_triggers.c:2142">ri_FetchConstraintInfo</a>(trigdata-&gt;tg_trigger,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; trigdata-&gt;tg_relation, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (TRIGGER_FIRED_BY_UPDATE(trigdata-&gt;tg_event))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newslot = trigdata-&gt;tg_newslot;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; newslot = trigdata-&gt;tg_trigslot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We should not even consider checking the row if it is no longer valid,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * since it was either deleted (so the deferred check should be skipped)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * or updated (in which case only the latest version of the row should be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * checked).&nbsp; Test its liveness according to SnapshotSelf.&nbsp; We need pin<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and lock on the buffer to call <a href="../../access/heap/heapam_visibility.c.html#L1767" title="access/heap/heapam_visibility.c:1767">HeapTupleSatisfiesVisibility</a>.&nbsp; Caller<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * should be holding pin, but not lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!table_tuple_satisfies_snapshot(trigdata-&gt;tg_relation, newslot, SnapshotSelf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PointerGetDatum(<span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get the relation descriptors of the FK and PK tables.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pk_rel is opened in RowShareLock mode since that's what our eventual<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * SELECT FOR <a href="../cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a> SHARE will get on it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; fk_rel = trigdata-&gt;tg_relation;<br/></li>
<li>&nbsp; &nbsp; pk_rel = <a href="../../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(riinfo-&gt;pk_relid, RowShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (<a href="#L2735" title="utils/adt/ri_triggers.c:2735">ri_NullCheck</a>(RelationGetDescr(fk_rel), newslot, riinfo, <span class="Constant">false</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L65" title="utils/adt/ri_triggers.c:65">RI_KEYS_ALL_NULL</a>:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No further check needed - an all-NULL key passes every type of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * foreign key constraint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(pk_rel, RowShareLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PointerGetDatum(<span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L66" title="utils/adt/ri_triggers.c:66">RI_KEYS_SOME_NULL</a>:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is the only case that differs between the three kinds of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../nodes/readfuncs.c.html#L571" title="nodes/readfuncs.c:571">MATCH</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (riinfo-&gt;confmatchtype)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> FKCONSTR_MATCH_FULL:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Not allowed - <a href="../../nodes/readfuncs.c.html#L571" title="nodes/readfuncs.c:571">MATCH</a> FULL says either all or <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * attributes can be NULLs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FOREIGN_KEY_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;insert or update on table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> violates foreign key constraint </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(fk_rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(riinfo-&gt;conname)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;<a href="../../nodes/readfuncs.c.html#L571" title="nodes/readfuncs.c:571">MATCH</a> FULL does not allow mixing of null and nonnull key <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../cache/relcache.c.html#L5999" title="utils/cache/relcache.c:5999">errtableconstraint</a>(fk_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(riinfo-&gt;conname))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(pk_rel, RowShareLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PointerGetDatum(<span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> FKCONSTR_MATCH_SIMPLE:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../nodes/readfuncs.c.html#L571" title="nodes/readfuncs.c:571">MATCH</a> SIMPLE - if ANY column is null, the key passes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the constraint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(pk_rel, RowShareLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PointerGetDatum(<span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef NOT_USED<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> FKCONSTR_MATCH_PARTIAL:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../nodes/readfuncs.c.html#L571" title="nodes/readfuncs.c:571">MATCH</a> PARTIAL - all non-null columns must match. (not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * implemented, can be done by modifying the query below<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to only include non-null columns, or by writing a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * special version here)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L67" title="utils/adt/ri_triggers.c:67">RI_KEYS_NONE_NULL</a>:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Have a full qualified key - continue below for all three kinds<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of <a href="../../nodes/readfuncs.c.html#L571" title="nodes/readfuncs.c:571">MATCH</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../executor/spi.c.html#L94" title="executor/spi.c:94">SPI_connect</a>() != SPI_OK_CONNECT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../../executor/spi.c.html#L94" title="executor/spi.c:94">SPI_connect</a> failed&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fetch or prepare a saved plan for the real check */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2064" title="utils/adt/ri_triggers.c:2064">ri_BuildQueryKey</a>(&amp;qkey, riinfo, <a href="#L71" title="utils/adt/ri_triggers.c:71">RI_PLAN_CHECK_LOOKUPPK</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((qplan = <a href="#L2808" title="utils/adt/ri_triggers.c:2808">ri_FetchPreparedPlan</a>(&amp;qkey)) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; StringInfoData querybuf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; pkrelname[<a href="#L85" title="utils/adt/ri_triggers.c:85">MAX_QUOTED_REL_NAME_LEN</a>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; attname[<a href="#L84" title="utils/adt/ri_triggers.c:84">MAX_QUOTED_NAME_LEN</a>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; paramname[<span class="Constant">16</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *querysep;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; queryoids[<a href="#L60" title="utils/adt/ri_triggers.c:60">RI_MAX_NUMKEYS</a>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *pk_only;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The query string built is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; SELECT 1 FROM [ONLY] &lt;pktable&gt; x WHERE pkatt1 = $1 [AND ...]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; FOR <a href="../cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a> SHARE OF x<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The type id's for the $ parameters are those of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * corresponding FK attributes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * But for temporal FKs we need to make sure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the FK's <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> is completely covered.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * So we use this query instead:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; SELECT 1<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; FROM&nbsp; &nbsp; (<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; SELECT pkperiodatt AS r<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; FROM&nbsp;&nbsp; [ONLY] pktable x<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; WHERE&nbsp; pkatt1 = $1 [AND ...]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; AND&nbsp; &nbsp; pkperiodatt &amp;&amp; $n<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; FOR <a href="../cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a> SHARE OF x<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; ) x1<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; HAVING $n &lt;@ range_agg(x1.r)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note if FOR <a href="../cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a> SHARE ever allows GROUP BY and HAVING<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we can make this a <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> simpler.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; initStringInfo(&amp;querybuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pk_only = pk_rel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;&quot;</span> : <span class="Constant">&quot;ONLY &quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1977" title="utils/adt/ri_triggers.c:1977">quoteRelationName</a>(pkrelname, pk_rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (riinfo-&gt;hasperiod)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1957" title="utils/adt/ri_triggers.c:1957">quoteOneName</a>(attname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L87" title="utils/adt/ri_triggers.c:87">RIAttName</a>(pk_rel, riinfo-&gt;pk_attnums[riinfo-&gt;nkeys - <span class="Constant">1</span>]));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;querybuf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;SELECT 1 FROM (SELECT </span><span class="Special">%s</span><span class="Constant"> AS r FROM </span><span class="Special">%s%s</span><span class="Constant"> x&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attname, pk_only, pkrelname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;querybuf, <span class="Constant">&quot;SELECT 1 FROM </span><span class="Special">%s%s</span><span class="Constant"> x&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pk_only, pkrelname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; querysep = <span class="Constant">&quot;WHERE&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; riinfo-&gt;nkeys; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pk_type = <a href="#L88" title="utils/adt/ri_triggers.c:88">RIAttType</a>(pk_rel, riinfo-&gt;pk_attnums[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fk_type = <a href="#L88" title="utils/adt/ri_triggers.c:88">RIAttType</a>(fk_rel, riinfo-&gt;fk_attnums[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1957" title="utils/adt/ri_triggers.c:1957">quoteOneName</a>(attname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L87" title="utils/adt/ri_triggers.c:87">RIAttName</a>(pk_rel, riinfo-&gt;pk_attnums[i]));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sprintf(paramname, <span class="Constant">&quot;$</span><span class="Special">%d</span><span class="Constant">&quot;</span>, i + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1994" title="utils/adt/ri_triggers.c:1994">ri_GenerateQual</a>(&amp;querybuf, querysep,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attname, pk_type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; riinfo-&gt;pf_eq_oprs[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paramname, fk_type);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; querysep = <span class="Constant">&quot;AND&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; queryoids[i] = fk_type;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;querybuf, <span class="Constant">&quot; FOR <a href="../cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a> SHARE OF x&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (riinfo-&gt;hasperiod)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fk_type = <a href="#L88" title="utils/adt/ri_triggers.c:88">RIAttType</a>(fk_rel, riinfo-&gt;fk_attnums[riinfo-&gt;nkeys - <span class="Constant">1</span>]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;querybuf, <span class="Constant">&quot;) x1 HAVING &quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sprintf(paramname, <span class="Constant">&quot;$</span><span class="Special">%d</span><span class="Constant">&quot;</span>, riinfo-&gt;nkeys);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1994" title="utils/adt/ri_triggers.c:1994">ri_GenerateQual</a>(&amp;querybuf, <span class="Constant">&quot;&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paramname, fk_type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; riinfo-&gt;agged_period_contained_by_oper,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;pg_catalog.range_agg&quot;</span>, ANYMULTIRANGEOID);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;querybuf, <span class="Constant">&quot;(x1.r)&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Prepare and save the plan */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; qplan = <a href="#L2368" title="utils/adt/ri_triggers.c:2368">ri_PlanCheck</a>(querybuf.data, riinfo-&gt;nkeys, queryoids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;qkey, fk_rel, pk_rel);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now check that foreign key exists in PK table<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> detectNewRows must be true when a partitioned table is on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * referenced side.&nbsp; The reason is that our snapshot must be fresh in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * order for the hack in <a href="../../catalog/pg_inherits.c.html#L58" title="catalog/pg_inherits.c:58">find_inheritance_children</a>() to work.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2411" title="utils/adt/ri_triggers.c:2411">ri_PerformCheck</a>(riinfo, &amp;qkey, qplan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fk_rel, pk_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, newslot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pk_rel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SPI_OK_SELECT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../executor/spi.c.html#L182" title="executor/spi.c:182">SPI_finish</a>() != SPI_OK_FINISH)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../../executor/spi.c.html#L182" title="executor/spi.c:182">SPI_finish</a> failed&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(pk_rel, RowShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> PointerGetDatum(<span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L471" title="utils/adt/ri_triggers.c:471">RI_FKey_check_ins</a> -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Check foreign key existence at insert event on FK table.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L471">&#x200c;</a><span class="linkable">RI_FKey_check_ins</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check that this is a valid <a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> call on the right time and event. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2096" title="utils/adt/ri_triggers.c:2096">ri_CheckTrigger</a>(fcinfo, <span class="Constant">&quot;<a href="#L471" title="utils/adt/ri_triggers.c:471">RI_FKey_check_ins</a>&quot;</span>, <a href="#L91" title="utils/adt/ri_triggers.c:91">RI_TRIGTYPE_INSERT</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Share code with UPDATE case. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L247" title="utils/adt/ri_triggers.c:247">RI_FKey_check</a>((TriggerData *) fcinfo-&gt;context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L487" title="utils/adt/ri_triggers.c:487">RI_FKey_check_upd</a> -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Check foreign key existence at update event on FK table.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L487">&#x200c;</a><span class="linkable">RI_FKey_check_upd</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check that this is a valid <a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> call on the right time and event. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2096" title="utils/adt/ri_triggers.c:2096">ri_CheckTrigger</a>(fcinfo, <span class="Constant">&quot;<a href="#L487" title="utils/adt/ri_triggers.c:487">RI_FKey_check_upd</a>&quot;</span>, <a href="#L92" title="utils/adt/ri_triggers.c:92">RI_TRIGTYPE_UPDATE</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Share code with INSERT case. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L247" title="utils/adt/ri_triggers.c:247">RI_FKey_check</a>((TriggerData *) fcinfo-&gt;context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L508" title="utils/adt/ri_triggers.c:508">ri_Check_Pk_Match</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Check to see if another PK row has been created that provides the same<br/></li>
<li></span><span class="Comment"> * key <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> as the &quot;oldslot&quot; that's been modified or deleted in our <a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a><br/></li>
<li></span><span class="Comment"> * event.&nbsp; Returns true if a match is found in the PK table.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We assume the caller checked that the oldslot contains no NULL key <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>,<br/></li>
<li></span><span class="Comment"> * since otherwise a match is impossible.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L508">&#x200c;</a></span><span class="linkable">ri_Check_Pk_Match</span>(Relation pk_rel, Relation fk_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot *oldslot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <a href="#L105" title="utils/adt/ri_triggers.c:105">RI_ConstraintInfo</a> *riinfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SPIPlanPtr&nbsp; &nbsp; qplan;<br/></li>
<li>&nbsp; &nbsp; <a href="#L140" title="utils/adt/ri_triggers.c:140">RI_QueryKey</a> qkey;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Only called for non-null rows */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="#L2735" title="utils/adt/ri_triggers.c:2735">ri_NullCheck</a>(RelationGetDescr(pk_rel), oldslot, riinfo, <span class="Constant">true</span>) == <a href="#L67" title="utils/adt/ri_triggers.c:67">RI_KEYS_NONE_NULL</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../executor/spi.c.html#L94" title="executor/spi.c:94">SPI_connect</a>() != SPI_OK_CONNECT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../../executor/spi.c.html#L94" title="executor/spi.c:94">SPI_connect</a> failed&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fetch or prepare a saved plan for checking PK table with <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> coming<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from a PK row<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2064" title="utils/adt/ri_triggers.c:2064">ri_BuildQueryKey</a>(&amp;qkey, riinfo, <a href="#L72" title="utils/adt/ri_triggers.c:72">RI_PLAN_CHECK_LOOKUPPK_FROM_PK</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((qplan = <a href="#L2808" title="utils/adt/ri_triggers.c:2808">ri_FetchPreparedPlan</a>(&amp;qkey)) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; StringInfoData querybuf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; pkrelname[<a href="#L85" title="utils/adt/ri_triggers.c:85">MAX_QUOTED_REL_NAME_LEN</a>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; attname[<a href="#L84" title="utils/adt/ri_triggers.c:84">MAX_QUOTED_NAME_LEN</a>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; paramname[<span class="Constant">16</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *querysep;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *pk_only;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; queryoids[<a href="#L60" title="utils/adt/ri_triggers.c:60">RI_MAX_NUMKEYS</a>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The query string built is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; SELECT 1 FROM [ONLY] &lt;pktable&gt; x WHERE pkatt1 = $1 [AND ...]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; FOR <a href="../cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a> SHARE OF x<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The type id's for the $ parameters are those of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * PK attributes themselves.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * But for temporal FKs we need to make sure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the FK's <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> is completely covered.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * So we use this query instead:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; SELECT 1<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; FROM&nbsp; &nbsp; (<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; SELECT pkperiodatt AS r<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; FROM&nbsp;&nbsp; [ONLY] pktable x<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; WHERE&nbsp; pkatt1 = $1 [AND ...]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; AND&nbsp; &nbsp; pkperiodatt &amp;&amp; $n<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; FOR <a href="../cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a> SHARE OF x<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; ) x1<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; HAVING $n &lt;@ range_agg(x1.r)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note if FOR <a href="../cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a> SHARE ever allows GROUP BY and HAVING<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we can make this a <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> simpler.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; initStringInfo(&amp;querybuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pk_only = pk_rel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;&quot;</span> : <span class="Constant">&quot;ONLY &quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1977" title="utils/adt/ri_triggers.c:1977">quoteRelationName</a>(pkrelname, pk_rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (riinfo-&gt;hasperiod)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1957" title="utils/adt/ri_triggers.c:1957">quoteOneName</a>(attname, <a href="#L87" title="utils/adt/ri_triggers.c:87">RIAttName</a>(pk_rel, riinfo-&gt;pk_attnums[riinfo-&gt;nkeys - <span class="Constant">1</span>]));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;querybuf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;SELECT 1 FROM (SELECT </span><span class="Special">%s</span><span class="Constant"> AS r FROM </span><span class="Special">%s%s</span><span class="Constant"> x&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attname, pk_only, pkrelname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;querybuf, <span class="Constant">&quot;SELECT 1 FROM </span><span class="Special">%s%s</span><span class="Constant"> x&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pk_only, pkrelname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; querysep = <span class="Constant">&quot;WHERE&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; riinfo-&gt;nkeys; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pk_type = <a href="#L88" title="utils/adt/ri_triggers.c:88">RIAttType</a>(pk_rel, riinfo-&gt;pk_attnums[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1957" title="utils/adt/ri_triggers.c:1957">quoteOneName</a>(attname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L87" title="utils/adt/ri_triggers.c:87">RIAttName</a>(pk_rel, riinfo-&gt;pk_attnums[i]));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sprintf(paramname, <span class="Constant">&quot;$</span><span class="Special">%d</span><span class="Constant">&quot;</span>, i + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1994" title="utils/adt/ri_triggers.c:1994">ri_GenerateQual</a>(&amp;querybuf, querysep,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attname, pk_type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; riinfo-&gt;pp_eq_oprs[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paramname, pk_type);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; querysep = <span class="Constant">&quot;AND&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; queryoids[i] = pk_type;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;querybuf, <span class="Constant">&quot; FOR <a href="../cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a> SHARE OF x&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (riinfo-&gt;hasperiod)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fk_type = <a href="#L88" title="utils/adt/ri_triggers.c:88">RIAttType</a>(fk_rel, riinfo-&gt;fk_attnums[riinfo-&gt;nkeys - <span class="Constant">1</span>]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;querybuf, <span class="Constant">&quot;) x1 HAVING &quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sprintf(paramname, <span class="Constant">&quot;$</span><span class="Special">%d</span><span class="Constant">&quot;</span>, riinfo-&gt;nkeys);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1994" title="utils/adt/ri_triggers.c:1994">ri_GenerateQual</a>(&amp;querybuf, <span class="Constant">&quot;&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paramname, fk_type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; riinfo-&gt;agged_period_contained_by_oper,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;pg_catalog.range_agg&quot;</span>, ANYMULTIRANGEOID);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;querybuf, <span class="Constant">&quot;(x1.r)&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Prepare and save the plan */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; qplan = <a href="#L2368" title="utils/adt/ri_triggers.c:2368">ri_PlanCheck</a>(querybuf.data, riinfo-&gt;nkeys, queryoids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;qkey, fk_rel, pk_rel);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We have a plan <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>. Run it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; result = <a href="#L2411" title="utils/adt/ri_triggers.c:2411">ri_PerformCheck</a>(riinfo, &amp;qkey, qplan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fk_rel, pk_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; oldslot, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>,&nbsp; &nbsp; <span class="Comment">/* treat like update */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; SPI_OK_SELECT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../executor/spi.c.html#L182" title="executor/spi.c:182">SPI_finish</a>() != SPI_OK_FINISH)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../../executor/spi.c.html#L182" title="executor/spi.c:182">SPI_finish</a> failed&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L635" title="utils/adt/ri_triggers.c:635">RI_FKey_noaction_del</a> -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Give an error and roll back the current transaction if the<br/></li>
<li></span><span class="Comment"> * delete has resulted in a violation of the given referential<br/></li>
<li></span><span class="Comment"> * integrity constraint.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L635">&#x200c;</a><span class="linkable">RI_FKey_noaction_del</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check that this is a valid <a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> call on the right time and event. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2096" title="utils/adt/ri_triggers.c:2096">ri_CheckTrigger</a>(fcinfo, <span class="Constant">&quot;<a href="#L635" title="utils/adt/ri_triggers.c:635">RI_FKey_noaction_del</a>&quot;</span>, <a href="#L93" title="utils/adt/ri_triggers.c:93">RI_TRIGTYPE_DELETE</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Share code with RESTRICT/UPDATE cases. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L708" title="utils/adt/ri_triggers.c:708">ri_restrict</a>((TriggerData *) fcinfo-&gt;context, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L655" title="utils/adt/ri_triggers.c:655">RI_FKey_restrict_del</a> -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Restrict delete from PK table to rows unreferenced by foreign key.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The SQL standard intends that this referential action occur exactly when<br/></li>
<li></span><span class="Comment"> * the delete is performed, rather than after.&nbsp; This appears to be<br/></li>
<li></span><span class="Comment"> * the only difference between &quot;NO ACTION&quot; and &quot;RESTRICT&quot;.&nbsp; In Postgres<br/></li>
<li></span><span class="Comment"> * we still implement this as an AFTER <a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>, but it's non-deferrable.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L655">&#x200c;</a><span class="linkable">RI_FKey_restrict_del</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check that this is a valid <a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> call on the right time and event. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2096" title="utils/adt/ri_triggers.c:2096">ri_CheckTrigger</a>(fcinfo, <span class="Constant">&quot;<a href="#L655" title="utils/adt/ri_triggers.c:655">RI_FKey_restrict_del</a>&quot;</span>, <a href="#L93" title="utils/adt/ri_triggers.c:93">RI_TRIGTYPE_DELETE</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Share code with NO ACTION/UPDATE cases. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L708" title="utils/adt/ri_triggers.c:708">ri_restrict</a>((TriggerData *) fcinfo-&gt;context, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L672" title="utils/adt/ri_triggers.c:672">RI_FKey_noaction_upd</a> -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Give an error and roll back the current transaction if the<br/></li>
<li></span><span class="Comment"> * update has resulted in a violation of the given referential<br/></li>
<li></span><span class="Comment"> * integrity constraint.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L672">&#x200c;</a><span class="linkable">RI_FKey_noaction_upd</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check that this is a valid <a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> call on the right time and event. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2096" title="utils/adt/ri_triggers.c:2096">ri_CheckTrigger</a>(fcinfo, <span class="Constant">&quot;<a href="#L672" title="utils/adt/ri_triggers.c:672">RI_FKey_noaction_upd</a>&quot;</span>, <a href="#L92" title="utils/adt/ri_triggers.c:92">RI_TRIGTYPE_UPDATE</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Share code with RESTRICT/DELETE cases. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L708" title="utils/adt/ri_triggers.c:708">ri_restrict</a>((TriggerData *) fcinfo-&gt;context, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L692" title="utils/adt/ri_triggers.c:692">RI_FKey_restrict_upd</a> -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Restrict update of PK to rows unreferenced by foreign key.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The SQL standard intends that this referential action occur exactly when<br/></li>
<li></span><span class="Comment"> * the update is performed, rather than after.&nbsp; This appears to be<br/></li>
<li></span><span class="Comment"> * the only difference between &quot;NO ACTION&quot; and &quot;RESTRICT&quot;.&nbsp; In Postgres<br/></li>
<li></span><span class="Comment"> * we still implement this as an AFTER <a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>, but it's non-deferrable.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L692">&#x200c;</a><span class="linkable">RI_FKey_restrict_upd</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check that this is a valid <a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> call on the right time and event. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2096" title="utils/adt/ri_triggers.c:2096">ri_CheckTrigger</a>(fcinfo, <span class="Constant">&quot;<a href="#L692" title="utils/adt/ri_triggers.c:692">RI_FKey_restrict_upd</a>&quot;</span>, <a href="#L92" title="utils/adt/ri_triggers.c:92">RI_TRIGTYPE_UPDATE</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Share code with NO ACTION/DELETE cases. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L708" title="utils/adt/ri_triggers.c:708">ri_restrict</a>((TriggerData *) fcinfo-&gt;context, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L708" title="utils/adt/ri_triggers.c:708">ri_restrict</a> -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Common code for ON DELETE RESTRICT, ON DELETE NO ACTION,<br/></li>
<li></span><span class="Comment"> * ON UPDATE RESTRICT, and ON UPDATE NO ACTION.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Datum<br/></li>
<li><a id="L708">&#x200c;</a><span class="linkable">ri_restrict</span>(TriggerData *trigdata, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_no_action)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="#L105" title="utils/adt/ri_triggers.c:105">RI_ConstraintInfo</a> *riinfo;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; fk_rel;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; pk_rel;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *oldslot;<br/></li>
<li>&nbsp; &nbsp; <a href="#L140" title="utils/adt/ri_triggers.c:140">RI_QueryKey</a> qkey;<br/></li>
<li>&nbsp; &nbsp; SPIPlanPtr&nbsp; &nbsp; qplan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; riinfo = <a href="#L2142" title="utils/adt/ri_triggers.c:2142">ri_FetchConstraintInfo</a>(trigdata-&gt;tg_trigger,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; trigdata-&gt;tg_relation, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get the relation descriptors of the FK and PK tables and the old tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fk_rel is opened in RowShareLock mode since that's what our eventual<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * SELECT FOR <a href="../cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a> SHARE will get on it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; fk_rel = <a href="../../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(riinfo-&gt;fk_relid, RowShareLock);<br/></li>
<li>&nbsp; &nbsp; pk_rel = trigdata-&gt;tg_relation;<br/></li>
<li>&nbsp; &nbsp; oldslot = trigdata-&gt;tg_trigslot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If another PK row <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> exists providing the old key <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, we should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not do anything.&nbsp; However, this check should only be made in the NO<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ACTION case; in RESTRICT cases we don't wish to allow another row to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * substituted.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (is_no_action &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L508" title="utils/adt/ri_triggers.c:508">ri_Check_Pk_Match</a>(pk_rel, fk_rel, oldslot, riinfo))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(fk_rel, RowShareLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PointerGetDatum(<span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../executor/spi.c.html#L94" title="executor/spi.c:94">SPI_connect</a>() != SPI_OK_CONNECT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../../executor/spi.c.html#L94" title="executor/spi.c:94">SPI_connect</a> failed&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fetch or prepare a saved plan for the restrict lookup (it's the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * query for delete and update cases)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2064" title="utils/adt/ri_triggers.c:2064">ri_BuildQueryKey</a>(&amp;qkey, riinfo, <a href="#L78" title="utils/adt/ri_triggers.c:78">RI_PLAN_RESTRICT</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((qplan = <a href="#L2808" title="utils/adt/ri_triggers.c:2808">ri_FetchPreparedPlan</a>(&amp;qkey)) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; StringInfoData querybuf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; fkrelname[<a href="#L85" title="utils/adt/ri_triggers.c:85">MAX_QUOTED_REL_NAME_LEN</a>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; attname[<a href="#L84" title="utils/adt/ri_triggers.c:84">MAX_QUOTED_NAME_LEN</a>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; paramname[<span class="Constant">16</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *querysep;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; queryoids[<a href="#L60" title="utils/adt/ri_triggers.c:60">RI_MAX_NUMKEYS</a>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *fk_only;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The query string built is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; SELECT 1 FROM [ONLY] &lt;fktable&gt; x WHERE $1 = fkatt1 [AND ...]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; FOR <a href="../cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a> SHARE OF x<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The type id's for the $ parameters are those of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * corresponding PK attributes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; initStringInfo(&amp;querybuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fk_only = fk_rel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;&quot;</span> : <span class="Constant">&quot;ONLY &quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1977" title="utils/adt/ri_triggers.c:1977">quoteRelationName</a>(fkrelname, fk_rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;querybuf, <span class="Constant">&quot;SELECT 1 FROM </span><span class="Special">%s%s</span><span class="Constant"> x&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fk_only, fkrelname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; querysep = <span class="Constant">&quot;WHERE&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; riinfo-&gt;nkeys; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pk_type = <a href="#L88" title="utils/adt/ri_triggers.c:88">RIAttType</a>(pk_rel, riinfo-&gt;pk_attnums[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fk_type = <a href="#L88" title="utils/adt/ri_triggers.c:88">RIAttType</a>(fk_rel, riinfo-&gt;fk_attnums[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pk_coll = <a href="#L89" title="utils/adt/ri_triggers.c:89">RIAttCollation</a>(pk_rel, riinfo-&gt;pk_attnums[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fk_coll = <a href="#L89" title="utils/adt/ri_triggers.c:89">RIAttCollation</a>(fk_rel, riinfo-&gt;fk_attnums[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1957" title="utils/adt/ri_triggers.c:1957">quoteOneName</a>(attname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L87" title="utils/adt/ri_triggers.c:87">RIAttName</a>(fk_rel, riinfo-&gt;fk_attnums[i]));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sprintf(paramname, <span class="Constant">&quot;$</span><span class="Special">%d</span><span class="Constant">&quot;</span>, i + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1994" title="utils/adt/ri_triggers.c:1994">ri_GenerateQual</a>(&amp;querybuf, querysep,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paramname, pk_type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; riinfo-&gt;pf_eq_oprs[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attname, fk_type);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pk_coll != fk_coll &amp;&amp; !<a href="../cache/lsyscache.c.html#L1054" title="utils/cache/lsyscache.c:1054">get_collation_isdeterministic</a>(pk_coll))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2023" title="utils/adt/ri_triggers.c:2023">ri_GenerateQualCollation</a>(&amp;querybuf, pk_coll);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; querysep = <span class="Constant">&quot;AND&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; queryoids[i] = pk_type;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;querybuf, <span class="Constant">&quot; FOR <a href="../cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a> SHARE OF x&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Prepare and save the plan */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; qplan = <a href="#L2368" title="utils/adt/ri_triggers.c:2368">ri_PlanCheck</a>(querybuf.data, riinfo-&gt;nkeys, queryoids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;qkey, fk_rel, pk_rel);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We have a plan <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>. Run it to check for existing references.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2411" title="utils/adt/ri_triggers.c:2411">ri_PerformCheck</a>(riinfo, &amp;qkey, qplan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fk_rel, pk_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldslot, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>,&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* must detect new rows */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SPI_OK_SELECT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../executor/spi.c.html#L182" title="executor/spi.c:182">SPI_finish</a>() != SPI_OK_FINISH)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../../executor/spi.c.html#L182" title="executor/spi.c:182">SPI_finish</a> failed&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(fk_rel, RowShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> PointerGetDatum(<span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L827" title="utils/adt/ri_triggers.c:827">RI_FKey_cascade_del</a> -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Cascaded delete foreign key references at delete event on PK table.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L827">&#x200c;</a><span class="linkable">RI_FKey_cascade_del</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TriggerData *trigdata = (TriggerData *) fcinfo-&gt;context;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="#L105" title="utils/adt/ri_triggers.c:105">RI_ConstraintInfo</a> *riinfo;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; fk_rel;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; pk_rel;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *oldslot;<br/></li>
<li>&nbsp; &nbsp; <a href="#L140" title="utils/adt/ri_triggers.c:140">RI_QueryKey</a> qkey;<br/></li>
<li>&nbsp; &nbsp; SPIPlanPtr&nbsp; &nbsp; qplan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check that this is a valid <a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> call on the right time and event. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2096" title="utils/adt/ri_triggers.c:2096">ri_CheckTrigger</a>(fcinfo, <span class="Constant">&quot;<a href="#L827" title="utils/adt/ri_triggers.c:827">RI_FKey_cascade_del</a>&quot;</span>, <a href="#L93" title="utils/adt/ri_triggers.c:93">RI_TRIGTYPE_DELETE</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; riinfo = <a href="#L2142" title="utils/adt/ri_triggers.c:2142">ri_FetchConstraintInfo</a>(trigdata-&gt;tg_trigger,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; trigdata-&gt;tg_relation, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get the relation descriptors of the FK and PK tables and the old tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fk_rel is opened in RowExclusiveLock mode since that's what our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * eventual DELETE will get on it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; fk_rel = <a href="../../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(riinfo-&gt;fk_relid, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; pk_rel = trigdata-&gt;tg_relation;<br/></li>
<li>&nbsp; &nbsp; oldslot = trigdata-&gt;tg_trigslot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../executor/spi.c.html#L94" title="executor/spi.c:94">SPI_connect</a>() != SPI_OK_CONNECT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../../executor/spi.c.html#L94" title="executor/spi.c:94">SPI_connect</a> failed&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fetch or prepare a saved plan for the cascaded delete */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2064" title="utils/adt/ri_triggers.c:2064">ri_BuildQueryKey</a>(&amp;qkey, riinfo, <a href="#L75" title="utils/adt/ri_triggers.c:75">RI_PLAN_CASCADE_ONDELETE</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((qplan = <a href="#L2808" title="utils/adt/ri_triggers.c:2808">ri_FetchPreparedPlan</a>(&amp;qkey)) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; StringInfoData querybuf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; fkrelname[<a href="#L85" title="utils/adt/ri_triggers.c:85">MAX_QUOTED_REL_NAME_LEN</a>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; attname[<a href="#L84" title="utils/adt/ri_triggers.c:84">MAX_QUOTED_NAME_LEN</a>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; paramname[<span class="Constant">16</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *querysep;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; queryoids[<a href="#L60" title="utils/adt/ri_triggers.c:60">RI_MAX_NUMKEYS</a>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *fk_only;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The query string built is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; DELETE FROM [ONLY] &lt;fktable&gt; WHERE $1 = fkatt1 [AND ...]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The type id's for the $ parameters are those of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * corresponding PK attributes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; initStringInfo(&amp;querybuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fk_only = fk_rel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;&quot;</span> : <span class="Constant">&quot;ONLY &quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1977" title="utils/adt/ri_triggers.c:1977">quoteRelationName</a>(fkrelname, fk_rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;querybuf, <span class="Constant">&quot;DELETE FROM </span><span class="Special">%s%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fk_only, fkrelname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; querysep = <span class="Constant">&quot;WHERE&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; riinfo-&gt;nkeys; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pk_type = <a href="#L88" title="utils/adt/ri_triggers.c:88">RIAttType</a>(pk_rel, riinfo-&gt;pk_attnums[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fk_type = <a href="#L88" title="utils/adt/ri_triggers.c:88">RIAttType</a>(fk_rel, riinfo-&gt;fk_attnums[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pk_coll = <a href="#L89" title="utils/adt/ri_triggers.c:89">RIAttCollation</a>(pk_rel, riinfo-&gt;pk_attnums[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fk_coll = <a href="#L89" title="utils/adt/ri_triggers.c:89">RIAttCollation</a>(fk_rel, riinfo-&gt;fk_attnums[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1957" title="utils/adt/ri_triggers.c:1957">quoteOneName</a>(attname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L87" title="utils/adt/ri_triggers.c:87">RIAttName</a>(fk_rel, riinfo-&gt;fk_attnums[i]));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sprintf(paramname, <span class="Constant">&quot;$</span><span class="Special">%d</span><span class="Constant">&quot;</span>, i + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1994" title="utils/adt/ri_triggers.c:1994">ri_GenerateQual</a>(&amp;querybuf, querysep,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paramname, pk_type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; riinfo-&gt;pf_eq_oprs[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attname, fk_type);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pk_coll != fk_coll &amp;&amp; !<a href="../cache/lsyscache.c.html#L1054" title="utils/cache/lsyscache.c:1054">get_collation_isdeterministic</a>(pk_coll))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2023" title="utils/adt/ri_triggers.c:2023">ri_GenerateQualCollation</a>(&amp;querybuf, pk_coll);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; querysep = <span class="Constant">&quot;AND&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; queryoids[i] = pk_type;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Prepare and save the plan */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; qplan = <a href="#L2368" title="utils/adt/ri_triggers.c:2368">ri_PlanCheck</a>(querybuf.data, riinfo-&gt;nkeys, queryoids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;qkey, fk_rel, pk_rel);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We have a plan <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>. Build up the arguments from the key <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * deleted PK tuple and delete the referencing rows<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2411" title="utils/adt/ri_triggers.c:2411">ri_PerformCheck</a>(riinfo, &amp;qkey, qplan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fk_rel, pk_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldslot, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>,&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* must detect new rows */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SPI_OK_DELETE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../executor/spi.c.html#L182" title="executor/spi.c:182">SPI_finish</a>() != SPI_OK_FINISH)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../../executor/spi.c.html#L182" title="executor/spi.c:182">SPI_finish</a> failed&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(fk_rel, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> PointerGetDatum(<span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L933" title="utils/adt/ri_triggers.c:933">RI_FKey_cascade_upd</a> -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Cascaded update foreign key references at update event on PK table.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L933">&#x200c;</a><span class="linkable">RI_FKey_cascade_upd</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TriggerData *trigdata = (TriggerData *) fcinfo-&gt;context;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="#L105" title="utils/adt/ri_triggers.c:105">RI_ConstraintInfo</a> *riinfo;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; fk_rel;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; pk_rel;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *newslot;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *oldslot;<br/></li>
<li>&nbsp; &nbsp; <a href="#L140" title="utils/adt/ri_triggers.c:140">RI_QueryKey</a> qkey;<br/></li>
<li>&nbsp; &nbsp; SPIPlanPtr&nbsp; &nbsp; qplan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check that this is a valid <a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> call on the right time and event. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2096" title="utils/adt/ri_triggers.c:2096">ri_CheckTrigger</a>(fcinfo, <span class="Constant">&quot;<a href="#L933" title="utils/adt/ri_triggers.c:933">RI_FKey_cascade_upd</a>&quot;</span>, <a href="#L92" title="utils/adt/ri_triggers.c:92">RI_TRIGTYPE_UPDATE</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; riinfo = <a href="#L2142" title="utils/adt/ri_triggers.c:2142">ri_FetchConstraintInfo</a>(trigdata-&gt;tg_trigger,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; trigdata-&gt;tg_relation, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get the relation descriptors of the FK and PK tables and the new and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * old tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fk_rel is opened in RowExclusiveLock mode since that's what our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * eventual UPDATE will get on it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; fk_rel = <a href="../../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(riinfo-&gt;fk_relid, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; pk_rel = trigdata-&gt;tg_relation;<br/></li>
<li>&nbsp; &nbsp; newslot = trigdata-&gt;tg_newslot;<br/></li>
<li>&nbsp; &nbsp; oldslot = trigdata-&gt;tg_trigslot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../executor/spi.c.html#L94" title="executor/spi.c:94">SPI_connect</a>() != SPI_OK_CONNECT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../../executor/spi.c.html#L94" title="executor/spi.c:94">SPI_connect</a> failed&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fetch or prepare a saved plan for the cascaded update */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2064" title="utils/adt/ri_triggers.c:2064">ri_BuildQueryKey</a>(&amp;qkey, riinfo, <a href="#L76" title="utils/adt/ri_triggers.c:76">RI_PLAN_CASCADE_ONUPDATE</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((qplan = <a href="#L2808" title="utils/adt/ri_triggers.c:2808">ri_FetchPreparedPlan</a>(&amp;qkey)) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; StringInfoData querybuf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; StringInfoData qualbuf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; fkrelname[<a href="#L85" title="utils/adt/ri_triggers.c:85">MAX_QUOTED_REL_NAME_LEN</a>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; attname[<a href="#L84" title="utils/adt/ri_triggers.c:84">MAX_QUOTED_NAME_LEN</a>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; paramname[<span class="Constant">16</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *querysep;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *qualsep;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; queryoids[<a href="#L60" title="utils/adt/ri_triggers.c:60">RI_MAX_NUMKEYS</a> * <span class="Constant">2</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *fk_only;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The query string built is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; UPDATE [ONLY] &lt;fktable&gt; <a href="../../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> fkatt1 = $1 [, ...]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WHERE $n = fkatt1 [AND ...]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The type id's for the $ parameters are those of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * corresponding PK attributes.&nbsp; Note that we are assuming<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there is an assignment cast from the PK to the FK type;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * else the parser will fail.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; initStringInfo(&amp;querybuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; initStringInfo(&amp;qualbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fk_only = fk_rel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;&quot;</span> : <span class="Constant">&quot;ONLY &quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1977" title="utils/adt/ri_triggers.c:1977">quoteRelationName</a>(fkrelname, fk_rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;querybuf, <span class="Constant">&quot;UPDATE </span><span class="Special">%s%s</span><span class="Constant"> <a href="../../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fk_only, fkrelname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; querysep = <span class="Constant">&quot;&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qualsep = <span class="Constant">&quot;WHERE&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>, j = riinfo-&gt;nkeys; i &lt; riinfo-&gt;nkeys; i++, j++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pk_type = <a href="#L88" title="utils/adt/ri_triggers.c:88">RIAttType</a>(pk_rel, riinfo-&gt;pk_attnums[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fk_type = <a href="#L88" title="utils/adt/ri_triggers.c:88">RIAttType</a>(fk_rel, riinfo-&gt;fk_attnums[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pk_coll = <a href="#L89" title="utils/adt/ri_triggers.c:89">RIAttCollation</a>(pk_rel, riinfo-&gt;pk_attnums[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fk_coll = <a href="#L89" title="utils/adt/ri_triggers.c:89">RIAttCollation</a>(fk_rel, riinfo-&gt;fk_attnums[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1957" title="utils/adt/ri_triggers.c:1957">quoteOneName</a>(attname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L87" title="utils/adt/ri_triggers.c:87">RIAttName</a>(fk_rel, riinfo-&gt;fk_attnums[i]));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;querybuf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> = $</span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; querysep, attname, i + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sprintf(paramname, <span class="Constant">&quot;$</span><span class="Special">%d</span><span class="Constant">&quot;</span>, j + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1994" title="utils/adt/ri_triggers.c:1994">ri_GenerateQual</a>(&amp;qualbuf, qualsep,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paramname, pk_type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; riinfo-&gt;pf_eq_oprs[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attname, fk_type);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pk_coll != fk_coll &amp;&amp; !<a href="../cache/lsyscache.c.html#L1054" title="utils/cache/lsyscache.c:1054">get_collation_isdeterministic</a>(pk_coll))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2023" title="utils/adt/ri_triggers.c:2023">ri_GenerateQualCollation</a>(&amp;querybuf, pk_coll);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; querysep = <span class="Constant">&quot;,&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qualsep = <span class="Constant">&quot;AND&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; queryoids[i] = pk_type;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; queryoids[j] = pk_type;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendBinaryStringInfo(&amp;querybuf, qualbuf.data, qualbuf.len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Prepare and save the plan */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; qplan = <a href="#L2368" title="utils/adt/ri_triggers.c:2368">ri_PlanCheck</a>(querybuf.data, riinfo-&gt;nkeys * <span class="Constant">2</span>, queryoids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;qkey, fk_rel, pk_rel);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We have a plan <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>. Run it to update the existing references.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2411" title="utils/adt/ri_triggers.c:2411">ri_PerformCheck</a>(riinfo, &amp;qkey, qplan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fk_rel, pk_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldslot, newslot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>,&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* must detect new rows */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SPI_OK_UPDATE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../executor/spi.c.html#L182" title="executor/spi.c:182">SPI_finish</a>() != SPI_OK_FINISH)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../../executor/spi.c.html#L182" title="executor/spi.c:182">SPI_finish</a> failed&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(fk_rel, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> PointerGetDatum(<span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1054" title="utils/adt/ri_triggers.c:1054">RI_FKey_setnull_del</a> -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Set foreign key references to NULL <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> at delete event on PK table.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1054">&#x200c;</a><span class="linkable">RI_FKey_setnull_del</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check that this is a valid <a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> call on the right time and event. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2096" title="utils/adt/ri_triggers.c:2096">ri_CheckTrigger</a>(fcinfo, <span class="Constant">&quot;<a href="#L1054" title="utils/adt/ri_triggers.c:1054">RI_FKey_setnull_del</a>&quot;</span>, <a href="#L93" title="utils/adt/ri_triggers.c:93">RI_TRIGTYPE_DELETE</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Share code with UPDATE case */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1115" title="utils/adt/ri_triggers.c:1115">ri_set</a>((TriggerData *) fcinfo-&gt;context, <span class="Constant">true</span>, <a href="#L93" title="utils/adt/ri_triggers.c:93">RI_TRIGTYPE_DELETE</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1069" title="utils/adt/ri_triggers.c:1069">RI_FKey_setnull_upd</a> -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Set foreign key references to NULL at update event on PK table.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1069">&#x200c;</a><span class="linkable">RI_FKey_setnull_upd</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check that this is a valid <a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> call on the right time and event. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2096" title="utils/adt/ri_triggers.c:2096">ri_CheckTrigger</a>(fcinfo, <span class="Constant">&quot;<a href="#L1069" title="utils/adt/ri_triggers.c:1069">RI_FKey_setnull_upd</a>&quot;</span>, <a href="#L92" title="utils/adt/ri_triggers.c:92">RI_TRIGTYPE_UPDATE</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Share code with DELETE case */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1115" title="utils/adt/ri_triggers.c:1115">ri_set</a>((TriggerData *) fcinfo-&gt;context, <span class="Constant">true</span>, <a href="#L92" title="utils/adt/ri_triggers.c:92">RI_TRIGTYPE_UPDATE</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1084" title="utils/adt/ri_triggers.c:1084">RI_FKey_setdefault_del</a> -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Set foreign key references to defaults at delete event on PK table.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1084">&#x200c;</a><span class="linkable">RI_FKey_setdefault_del</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check that this is a valid <a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> call on the right time and event. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2096" title="utils/adt/ri_triggers.c:2096">ri_CheckTrigger</a>(fcinfo, <span class="Constant">&quot;<a href="#L1084" title="utils/adt/ri_triggers.c:1084">RI_FKey_setdefault_del</a>&quot;</span>, <a href="#L93" title="utils/adt/ri_triggers.c:93">RI_TRIGTYPE_DELETE</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Share code with UPDATE case */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1115" title="utils/adt/ri_triggers.c:1115">ri_set</a>((TriggerData *) fcinfo-&gt;context, <span class="Constant">false</span>, <a href="#L93" title="utils/adt/ri_triggers.c:93">RI_TRIGTYPE_DELETE</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1099" title="utils/adt/ri_triggers.c:1099">RI_FKey_setdefault_upd</a> -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Set foreign key references to defaults at update event on PK table.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1099">&#x200c;</a><span class="linkable">RI_FKey_setdefault_upd</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check that this is a valid <a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> call on the right time and event. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2096" title="utils/adt/ri_triggers.c:2096">ri_CheckTrigger</a>(fcinfo, <span class="Constant">&quot;<a href="#L1099" title="utils/adt/ri_triggers.c:1099">RI_FKey_setdefault_upd</a>&quot;</span>, <a href="#L92" title="utils/adt/ri_triggers.c:92">RI_TRIGTYPE_UPDATE</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Share code with DELETE case */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1115" title="utils/adt/ri_triggers.c:1115">ri_set</a>((TriggerData *) fcinfo-&gt;context, <span class="Constant">false</span>, <a href="#L92" title="utils/adt/ri_triggers.c:92">RI_TRIGTYPE_UPDATE</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1115" title="utils/adt/ri_triggers.c:1115">ri_set</a> -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Common code for ON DELETE <a href="../../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> NULL, ON DELETE <a href="../../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> DEFAULT, ON UPDATE <a href="../../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a><br/></li>
<li></span><span class="Comment"> * NULL, and ON UPDATE <a href="../../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> DEFAULT.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Datum<br/></li>
<li><a id="L1115">&#x200c;</a><span class="linkable">ri_set</span>(TriggerData *trigdata, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_set_null, <span class="Type">int</span> tgkind)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="#L105" title="utils/adt/ri_triggers.c:105">RI_ConstraintInfo</a> *riinfo;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; fk_rel;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; pk_rel;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *oldslot;<br/></li>
<li>&nbsp; &nbsp; <a href="#L140" title="utils/adt/ri_triggers.c:140">RI_QueryKey</a> qkey;<br/></li>
<li>&nbsp; &nbsp; SPIPlanPtr&nbsp; &nbsp; qplan;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; queryno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; riinfo = <a href="#L2142" title="utils/adt/ri_triggers.c:2142">ri_FetchConstraintInfo</a>(trigdata-&gt;tg_trigger,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; trigdata-&gt;tg_relation, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get the relation descriptors of the FK and PK tables and the old tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fk_rel is opened in RowExclusiveLock mode since that's what our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * eventual UPDATE will get on it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; fk_rel = <a href="../../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(riinfo-&gt;fk_relid, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; pk_rel = trigdata-&gt;tg_relation;<br/></li>
<li>&nbsp; &nbsp; oldslot = trigdata-&gt;tg_trigslot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../executor/spi.c.html#L94" title="executor/spi.c:94">SPI_connect</a>() != SPI_OK_CONNECT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../../executor/spi.c.html#L94" title="executor/spi.c:94">SPI_connect</a> failed&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fetch or prepare a saved plan for the <a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (tgkind)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L92" title="utils/adt/ri_triggers.c:92">RI_TRIGTYPE_UPDATE</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; queryno = is_set_null<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ? <a href="#L80" title="utils/adt/ri_triggers.c:80">RI_PLAN_SETNULL_ONUPDATE</a><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : <a href="#L82" title="utils/adt/ri_triggers.c:82">RI_PLAN_SETDEFAULT_ONUPDATE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L93" title="utils/adt/ri_triggers.c:93">RI_TRIGTYPE_DELETE</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; queryno = is_set_null<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ? <a href="#L79" title="utils/adt/ri_triggers.c:79">RI_PLAN_SETNULL_ONDELETE</a><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : <a href="#L81" title="utils/adt/ri_triggers.c:81">RI_PLAN_SETDEFAULT_ONDELETE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid tgkind passed to <a href="#L1115" title="utils/adt/ri_triggers.c:1115">ri_set</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2064" title="utils/adt/ri_triggers.c:2064">ri_BuildQueryKey</a>(&amp;qkey, riinfo, queryno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((qplan = <a href="#L2808" title="utils/adt/ri_triggers.c:2808">ri_FetchPreparedPlan</a>(&amp;qkey)) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; StringInfoData querybuf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; fkrelname[<a href="#L85" title="utils/adt/ri_triggers.c:85">MAX_QUOTED_REL_NAME_LEN</a>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; attname[<a href="#L84" title="utils/adt/ri_triggers.c:84">MAX_QUOTED_NAME_LEN</a>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; paramname[<span class="Constant">16</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *querysep;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *qualsep;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; queryoids[<a href="#L60" title="utils/adt/ri_triggers.c:60">RI_MAX_NUMKEYS</a>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *fk_only;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_cols_to_set;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> int16 *set_cols;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (tgkind)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L92" title="utils/adt/ri_triggers.c:92">RI_TRIGTYPE_UPDATE</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_cols_to_set = riinfo-&gt;nkeys;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; set_cols = riinfo-&gt;fk_attnums;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L93" title="utils/adt/ri_triggers.c:93">RI_TRIGTYPE_DELETE</a>:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If confdelsetcols are present, then we only update the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * columns specified in that array, otherwise we update all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the referencing columns.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (riinfo-&gt;ndelsetcols != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_cols_to_set = riinfo-&gt;ndelsetcols;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; set_cols = riinfo-&gt;confdelsetcols;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_cols_to_set = riinfo-&gt;nkeys;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; set_cols = riinfo-&gt;fk_attnums;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid tgkind passed to <a href="#L1115" title="utils/adt/ri_triggers.c:1115">ri_set</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The query string built is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; UPDATE [ONLY] &lt;fktable&gt; <a href="../../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> fkatt1 = {NULL|DEFAULT} [, ...]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WHERE $1 = fkatt1 [AND ...]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The type id's for the $ parameters are those of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * corresponding PK attributes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; initStringInfo(&amp;querybuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fk_only = fk_rel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;&quot;</span> : <span class="Constant">&quot;ONLY &quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1977" title="utils/adt/ri_triggers.c:1977">quoteRelationName</a>(fkrelname, fk_rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;querybuf, <span class="Constant">&quot;UPDATE </span><span class="Special">%s%s</span><span class="Constant"> <a href="../../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fk_only, fkrelname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Add assignment clauses<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; querysep = <span class="Constant">&quot;&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; num_cols_to_set; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1957" title="utils/adt/ri_triggers.c:1957">quoteOneName</a>(attname, <a href="#L87" title="utils/adt/ri_triggers.c:87">RIAttName</a>(fk_rel, set_cols[i]));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;querybuf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> = </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; querysep, attname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; is_set_null ? <span class="Constant">&quot;NULL&quot;</span> : <span class="Constant">&quot;DEFAULT&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; querysep = <span class="Constant">&quot;,&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Add WHERE clause<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; qualsep = <span class="Constant">&quot;WHERE&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; riinfo-&gt;nkeys; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pk_type = <a href="#L88" title="utils/adt/ri_triggers.c:88">RIAttType</a>(pk_rel, riinfo-&gt;pk_attnums[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fk_type = <a href="#L88" title="utils/adt/ri_triggers.c:88">RIAttType</a>(fk_rel, riinfo-&gt;fk_attnums[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pk_coll = <a href="#L89" title="utils/adt/ri_triggers.c:89">RIAttCollation</a>(pk_rel, riinfo-&gt;pk_attnums[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fk_coll = <a href="#L89" title="utils/adt/ri_triggers.c:89">RIAttCollation</a>(fk_rel, riinfo-&gt;fk_attnums[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1957" title="utils/adt/ri_triggers.c:1957">quoteOneName</a>(attname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L87" title="utils/adt/ri_triggers.c:87">RIAttName</a>(fk_rel, riinfo-&gt;fk_attnums[i]));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sprintf(paramname, <span class="Constant">&quot;$</span><span class="Special">%d</span><span class="Constant">&quot;</span>, i + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1994" title="utils/adt/ri_triggers.c:1994">ri_GenerateQual</a>(&amp;querybuf, qualsep,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paramname, pk_type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; riinfo-&gt;pf_eq_oprs[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attname, fk_type);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pk_coll != fk_coll &amp;&amp; !<a href="../cache/lsyscache.c.html#L1054" title="utils/cache/lsyscache.c:1054">get_collation_isdeterministic</a>(pk_coll))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2023" title="utils/adt/ri_triggers.c:2023">ri_GenerateQualCollation</a>(&amp;querybuf, pk_coll);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qualsep = <span class="Constant">&quot;AND&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; queryoids[i] = pk_type;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Prepare and save the plan */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; qplan = <a href="#L2368" title="utils/adt/ri_triggers.c:2368">ri_PlanCheck</a>(querybuf.data, riinfo-&gt;nkeys, queryoids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;qkey, fk_rel, pk_rel);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We have a plan <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>. Run it to update the existing references.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2411" title="utils/adt/ri_triggers.c:2411">ri_PerformCheck</a>(riinfo, &amp;qkey, qplan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fk_rel, pk_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldslot, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>,&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* must detect new rows */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SPI_OK_UPDATE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../executor/spi.c.html#L182" title="executor/spi.c:182">SPI_finish</a>() != SPI_OK_FINISH)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../../executor/spi.c.html#L182" title="executor/spi.c:182">SPI_finish</a> failed&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(fk_rel, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (is_set_null)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PointerGetDatum(<span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we just deleted or updated the PK row whose key was <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * FK columns' default <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, and a referencing row exists in the FK<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * table, we would have updated that row to the same <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> it already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * had --- and <a href="#L1342" title="utils/adt/ri_triggers.c:1342">RI_FKey_fk_upd_check_required</a> would hence believe no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * check is necessary.&nbsp; So we need to do another lookup <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> and in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * case a reference still exists, abort the operation.&nbsp; That is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already implemented in the NO ACTION <a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>, so just run it. (This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * recheck is only needed in the <a href="../../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> DEFAULT case, since CASCADE would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * remove such rows in case of a DELETE operation or would change the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * FK key <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in case of an UPDATE, while <a href="../../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> NULL is certain to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * result in rows that satisfy the FK constraint.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L708" title="utils/adt/ri_triggers.c:708">ri_restrict</a>(trigdata, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1310" title="utils/adt/ri_triggers.c:1310">RI_FKey_pk_upd_check_required</a> -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Check if we really need to fire the RI <a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> for an update or delete to a PK<br/></li>
<li></span><span class="Comment"> * relation.&nbsp; This is called by the AFTER <a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> queue manager to see if<br/></li>
<li></span><span class="Comment"> * it can <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> queuing an instance of an RI <a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>.&nbsp; Returns true if the<br/></li>
<li></span><span class="Comment"> * <a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> must be fired, false if we can prove the constraint will still<br/></li>
<li></span><span class="Comment"> * be satisfied.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * newslot will be NULL if this is called for a delete.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1310">&#x200c;</a></span><span class="linkable">RI_FKey_pk_upd_check_required</span>(Trigger *<a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>, Relation pk_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot *oldslot, TupleTableSlot *newslot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="#L105" title="utils/adt/ri_triggers.c:105">RI_ConstraintInfo</a> *riinfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; riinfo = <a href="#L2142" title="utils/adt/ri_triggers.c:2142">ri_FetchConstraintInfo</a>(<a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>, pk_rel, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> old key value is NULL, the row could not have been referenced by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * an FK row, so no check is needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2735" title="utils/adt/ri_triggers.c:2735">ri_NullCheck</a>(RelationGetDescr(pk_rel), oldslot, riinfo, <span class="Constant">true</span>) != <a href="#L67" title="utils/adt/ri_triggers.c:67">RI_KEYS_NONE_NULL</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If all old and new key <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>, no check is needed */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (newslot &amp;&amp; <a href="#L2897" title="utils/adt/ri_triggers.c:2897">ri_KeysEqual</a>(pk_rel, oldslot, newslot, riinfo, <span class="Constant">true</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Else we need to fire the <a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1342" title="utils/adt/ri_triggers.c:1342">RI_FKey_fk_upd_check_required</a> -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Check if we really need to fire the RI <a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> for an update to an FK<br/></li>
<li></span><span class="Comment"> * relation.&nbsp; This is called by the AFTER <a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> queue manager to see if<br/></li>
<li></span><span class="Comment"> * it can <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> queuing an instance of an RI <a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>.&nbsp; Returns true if the<br/></li>
<li></span><span class="Comment"> * <a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> must be fired, false if we can prove the constraint will still<br/></li>
<li></span><span class="Comment"> * be satisfied.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1342">&#x200c;</a></span><span class="linkable">RI_FKey_fk_upd_check_required</span>(Trigger *<a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>, Relation fk_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot *oldslot, TupleTableSlot *newslot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="#L105" title="utils/adt/ri_triggers.c:105">RI_ConstraintInfo</a> *riinfo;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ri_nullcheck;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../commands/trigger.c.html#L6061" title="commands/trigger.c:6061">AfterTriggerSaveEvent</a>() handles things such that this function is never<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * called for partitioned tables.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(fk_rel-&gt;rd_rel-&gt;relkind != RELKIND_PARTITIONED_TABLE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; riinfo = <a href="#L2142" title="utils/adt/ri_triggers.c:2142">ri_FetchConstraintInfo</a>(<a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>, fk_rel, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ri_nullcheck = <a href="#L2735" title="utils/adt/ri_triggers.c:2735">ri_NullCheck</a>(RelationGetDescr(fk_rel), newslot, riinfo, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If all new key <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are NULL, the row satisfies the constraint, so no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * check is needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ri_nullcheck == <a href="#L65" title="utils/adt/ri_triggers.c:65">RI_KEYS_ALL_NULL</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If some new key <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are NULL, the behavior depends on the match<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * type.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (ri_nullcheck == <a href="#L66" title="utils/adt/ri_triggers.c:66">RI_KEYS_SOME_NULL</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (riinfo-&gt;confmatchtype)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> FKCONSTR_MATCH_SIMPLE:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> new key value is NULL, the row must satisfy the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * constraint, so no check is needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> FKCONSTR_MATCH_PARTIAL:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Don't know, must run full check.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> FKCONSTR_MATCH_FULL:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If some new key <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are NULL, the row fails the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * constraint.&nbsp; We must not throw error here, because the row<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * might get invalidated <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the constraint is to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * checked, but we should queue the event to apply the check<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Continues here for no new key <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are NULL, or we couldn't decide<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * yet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the original row was inserted by our own transaction, we must fire<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the <a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> whether or not the keys are <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>.&nbsp; This is because our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * UPDATE will invalidate the INSERT so that the INSERT RI <a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not do anything; so we had better do the UPDATE check.&nbsp; (We could <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this if we knew the INSERT <a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> already fired, but there is no easy<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * way to know that.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (slot_is_current_xact_tuple(oldslot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If all old and new key <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>, no check is needed */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2897" title="utils/adt/ri_triggers.c:2897">ri_KeysEqual</a>(fk_rel, oldslot, newslot, riinfo, <span class="Constant">false</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Else we need to fire the <a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1443" title="utils/adt/ri_triggers.c:1443">RI_Initial_Check</a> -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Check an entire table for non-matching <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> using a single query.<br/></li>
<li></span><span class="Comment"> * This is not a <a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> procedure, but is called during ALTER TABLE<br/></li>
<li></span><span class="Comment"> * ADD FOREIGN <a href="../cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a> to validate the initial table contents.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We expect that the caller has made provision to prevent <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> problems<br/></li>
<li></span><span class="Comment"> * caused by concurrent actions. This could be either by locking rel and<br/></li>
<li></span><span class="Comment"> * pkrel at ShareRowExclusiveLock or higher, or by otherwise ensuring<br/></li>
<li></span><span class="Comment"> * that triggers implementing the checks are already active.<br/></li>
<li></span><span class="Comment"> * Hence, we do not need to lock individual rows for the check.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the check fails because the current user doesn't have permissions<br/></li>
<li></span><span class="Comment"> * to read both tables, return false to let our caller know that they will<br/></li>
<li></span><span class="Comment"> * need to do something else to check the constraint.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1443">&#x200c;</a></span><span class="linkable">RI_Initial_Check</span>(Trigger *<a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>, Relation fk_rel, Relation pk_rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="#L105" title="utils/adt/ri_triggers.c:105">RI_ConstraintInfo</a> *riinfo;<br/></li>
<li>&nbsp; &nbsp; StringInfoData querybuf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; pkrelname[<a href="#L85" title="utils/adt/ri_triggers.c:85">MAX_QUOTED_REL_NAME_LEN</a>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; fkrelname[<a href="#L85" title="utils/adt/ri_triggers.c:85">MAX_QUOTED_REL_NAME_LEN</a>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; pkattname[<a href="#L84" title="utils/adt/ri_triggers.c:84">MAX_QUOTED_NAME_LEN</a> + <span class="Constant">3</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; fkattname[<a href="#L84" title="utils/adt/ri_triggers.c:84">MAX_QUOTED_NAME_LEN</a> + <span class="Constant">3</span>];<br/></li>
<li>&nbsp; &nbsp; RangeTblEntry *rte;<br/></li>
<li>&nbsp; &nbsp; RTEPermissionInfo *pk_perminfo;<br/></li>
<li>&nbsp; &nbsp; RTEPermissionInfo *fk_perminfo;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *rtes = NIL;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *perminfos = NIL;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *sep;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *fk_only;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *pk_only;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_nestlevel;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; workmembuf[<span class="Constant">32</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; spi_result;<br/></li>
<li>&nbsp; &nbsp; SPIPlanPtr&nbsp; &nbsp; qplan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; riinfo = <a href="#L2142" title="utils/adt/ri_triggers.c:2142">ri_FetchConstraintInfo</a>(<a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>, fk_rel, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check to make sure current user has enough permissions to do the test<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * query.&nbsp; (If not, caller can fall back to the <a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> method, which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * works because it changes user IDs on the fly.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> are there <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other show-stopper conditions to check?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pk_perminfo = makeNode(RTEPermissionInfo);<br/></li>
<li>&nbsp; &nbsp; pk_perminfo-&gt;relid = RelationGetRelid(pk_rel);<br/></li>
<li>&nbsp; &nbsp; pk_perminfo-&gt;requiredPerms = ACL_SELECT;<br/></li>
<li>&nbsp; &nbsp; perminfos = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(perminfos, pk_perminfo);<br/></li>
<li>&nbsp; &nbsp; rte = makeNode(RangeTblEntry);<br/></li>
<li>&nbsp; &nbsp; rte-&gt;rtekind = RTE_RELATION;<br/></li>
<li>&nbsp; &nbsp; rte-&gt;relid = RelationGetRelid(pk_rel);<br/></li>
<li>&nbsp; &nbsp; rte-&gt;relkind = pk_rel-&gt;rd_rel-&gt;relkind;<br/></li>
<li>&nbsp; &nbsp; rte-&gt;rellockmode = AccessShareLock;<br/></li>
<li>&nbsp; &nbsp; rte-&gt;perminfoindex = list_length(perminfos);<br/></li>
<li>&nbsp; &nbsp; rtes = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(rtes, rte);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fk_perminfo = makeNode(RTEPermissionInfo);<br/></li>
<li>&nbsp; &nbsp; fk_perminfo-&gt;relid = RelationGetRelid(fk_rel);<br/></li>
<li>&nbsp; &nbsp; fk_perminfo-&gt;requiredPerms = ACL_SELECT;<br/></li>
<li>&nbsp; &nbsp; perminfos = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(perminfos, fk_perminfo);<br/></li>
<li>&nbsp; &nbsp; rte = makeNode(RangeTblEntry);<br/></li>
<li>&nbsp; &nbsp; rte-&gt;rtekind = RTE_RELATION;<br/></li>
<li>&nbsp; &nbsp; rte-&gt;relid = RelationGetRelid(fk_rel);<br/></li>
<li>&nbsp; &nbsp; rte-&gt;relkind = fk_rel-&gt;rd_rel-&gt;relkind;<br/></li>
<li>&nbsp; &nbsp; rte-&gt;rellockmode = AccessShareLock;<br/></li>
<li>&nbsp; &nbsp; rte-&gt;perminfoindex = list_length(perminfos);<br/></li>
<li>&nbsp; &nbsp; rtes = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(rtes, rte);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; riinfo-&gt;nkeys; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attno = riinfo-&gt;pk_attnums[i] - FirstLowInvalidHeapAttributeNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pk_perminfo-&gt;selectedCols = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(pk_perminfo-&gt;selectedCols, attno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attno = riinfo-&gt;fk_attnums[i] - FirstLowInvalidHeapAttributeNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fk_perminfo-&gt;selectedCols = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(fk_perminfo-&gt;selectedCols, attno);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../executor/execMain.c.html#L579" title="executor/execMain.c:579">ExecCheckPermissions</a>(rtes, perminfos, <span class="Constant">false</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also punt if RLS is enabled on either table unless this role has the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bypassrls right or is the table owner of the table(s) involved which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have RLS enabled.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../catalog/aclchk.c.html#L4230" title="catalog/aclchk.c:4230">has_bypassrls_privilege</a>(<a href="../init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>()) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ((pk_rel-&gt;rd_rel-&gt;relrowsecurity &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="../../catalog/aclchk.c.html#L4130" title="catalog/aclchk.c:4130">object_ownercheck</a>(RelationRelationId, RelationGetRelid(pk_rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>())) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (fk_rel-&gt;rd_rel-&gt;relrowsecurity &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="../../catalog/aclchk.c.html#L4130" title="catalog/aclchk.c:4130">object_ownercheck</a>(RelationRelationId, RelationGetRelid(fk_rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>()))))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The query string built is:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; SELECT fk.keycols FROM [ONLY] relname fk<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp;&nbsp; LEFT OUTER JOIN [ONLY] pkrelname pk<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp;&nbsp; ON (pk.pkkeycol1=fk.keycol1 [AND ...])<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp;&nbsp; WHERE pk.pkkeycol1 IS NULL AND<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For <a href="../../nodes/readfuncs.c.html#L571" title="nodes/readfuncs.c:571">MATCH</a> SIMPLE:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp;&nbsp; (fk.keycol1 IS NOT NULL [AND ...])<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For <a href="../../nodes/readfuncs.c.html#L571" title="nodes/readfuncs.c:571">MATCH</a> FULL:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp;&nbsp; (fk.keycol1 IS NOT NULL [OR ...])<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We attach COLLATE clauses to the operators when comparing columns<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that have different collations.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; initStringInfo(&amp;querybuf);<br/></li>
<li>&nbsp; &nbsp; appendStringInfoString(&amp;querybuf, <span class="Constant">&quot;SELECT &quot;</span>);<br/></li>
<li>&nbsp; &nbsp; sep = <span class="Constant">&quot;&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; riinfo-&gt;nkeys; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1957" title="utils/adt/ri_triggers.c:1957">quoteOneName</a>(fkattname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L87" title="utils/adt/ri_triggers.c:87">RIAttName</a>(fk_rel, riinfo-&gt;fk_attnums[i]));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;querybuf, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">fk.</span><span class="Special">%s</span><span class="Constant">&quot;</span>, sep, fkattname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sep = <span class="Constant">&quot;, &quot;</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1977" title="utils/adt/ri_triggers.c:1977">quoteRelationName</a>(pkrelname, pk_rel);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1977" title="utils/adt/ri_triggers.c:1977">quoteRelationName</a>(fkrelname, fk_rel);<br/></li>
<li>&nbsp; &nbsp; fk_only = fk_rel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;&quot;</span> : <span class="Constant">&quot;ONLY &quot;</span>;<br/></li>
<li>&nbsp; &nbsp; pk_only = pk_rel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;&quot;</span> : <span class="Constant">&quot;ONLY &quot;</span>;<br/></li>
<li>&nbsp; &nbsp; appendStringInfo(&amp;querybuf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot; FROM </span><span class="Special">%s%s</span><span class="Constant"> fk LEFT OUTER JOIN </span><span class="Special">%s%s</span><span class="Constant"> pk ON&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fk_only, fkrelname, pk_only, pkrelname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; strcpy(pkattname, <span class="Constant">&quot;pk.&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; strcpy(fkattname, <span class="Constant">&quot;fk.&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; sep = <span class="Constant">&quot;(&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; riinfo-&gt;nkeys; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pk_type = <a href="#L88" title="utils/adt/ri_triggers.c:88">RIAttType</a>(pk_rel, riinfo-&gt;pk_attnums[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fk_type = <a href="#L88" title="utils/adt/ri_triggers.c:88">RIAttType</a>(fk_rel, riinfo-&gt;fk_attnums[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pk_coll = <a href="#L89" title="utils/adt/ri_triggers.c:89">RIAttCollation</a>(pk_rel, riinfo-&gt;pk_attnums[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fk_coll = <a href="#L89" title="utils/adt/ri_triggers.c:89">RIAttCollation</a>(fk_rel, riinfo-&gt;fk_attnums[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1957" title="utils/adt/ri_triggers.c:1957">quoteOneName</a>(pkattname + <span class="Constant">3</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L87" title="utils/adt/ri_triggers.c:87">RIAttName</a>(pk_rel, riinfo-&gt;pk_attnums[i]));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1957" title="utils/adt/ri_triggers.c:1957">quoteOneName</a>(fkattname + <span class="Constant">3</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L87" title="utils/adt/ri_triggers.c:87">RIAttName</a>(fk_rel, riinfo-&gt;fk_attnums[i]));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1994" title="utils/adt/ri_triggers.c:1994">ri_GenerateQual</a>(&amp;querybuf, sep,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pkattname, pk_type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; riinfo-&gt;pf_eq_oprs[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fkattname, fk_type);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pk_coll != fk_coll)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2023" title="utils/adt/ri_triggers.c:2023">ri_GenerateQualCollation</a>(&amp;querybuf, pk_coll);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sep = <span class="Constant">&quot;AND&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's sufficient to test <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> one pk attribute for null to detect a join<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * failure.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1957" title="utils/adt/ri_triggers.c:1957">quoteOneName</a>(pkattname, <a href="#L87" title="utils/adt/ri_triggers.c:87">RIAttName</a>(pk_rel, riinfo-&gt;pk_attnums[<span class="Constant">0</span>]));<br/></li>
<li>&nbsp; &nbsp; appendStringInfo(&amp;querybuf, <span class="Constant">&quot;) WHERE pk.</span><span class="Special">%s</span><span class="Constant"> IS NULL AND (&quot;</span>, pkattname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sep = <span class="Constant">&quot;&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; riinfo-&gt;nkeys; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1957" title="utils/adt/ri_triggers.c:1957">quoteOneName</a>(fkattname, <a href="#L87" title="utils/adt/ri_triggers.c:87">RIAttName</a>(fk_rel, riinfo-&gt;fk_attnums[i]));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;querybuf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">fk.</span><span class="Special">%s</span><span class="Constant"> IS NOT NULL&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sep, fkattname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (riinfo-&gt;confmatchtype)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> FKCONSTR_MATCH_SIMPLE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sep = <span class="Constant">&quot; AND &quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> FKCONSTR_MATCH_FULL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sep = <span class="Constant">&quot; OR &quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; appendStringInfoChar(&amp;querybuf, <span class="Constant">')'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Temporarily increase <a href="../init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a> so that the check query can be executed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * more efficiently.&nbsp; It seems okay to do this because the query is simple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * enough to not use a multiple of <a href="../init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a>, and one typically would not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have many large foreign-key validations happening concurrently.&nbsp; So<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this seems to meet the criteria for being considered a &quot;maintenance&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operation, and accordingly we use <a href="../init/globals.c.html#L130" title="utils/init/globals.c:130">maintenance_work_mem</a>.&nbsp; However, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * must also set <a href="../init/globals.c.html#L129" title="utils/init/globals.c:129">hash_mem_multiplier</a> to 1, since it is surely not okay to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * let that get applied to the <a href="../init/globals.c.html#L130" title="utils/init/globals.c:130">maintenance_work_mem</a> value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We use the equivalent of a function <a href="../../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> option to allow the setting to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * persist for exactly the duration of the check query.&nbsp; guc.c also takes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * care of undoing the setting on error.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; save_nestlevel = <a href="../misc/guc.c.html#L2237" title="utils/misc/guc.c:2237">NewGUCNestLevel</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snprintf(workmembuf, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(workmembuf), <span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>, <a href="../init/globals.c.html#L130" title="utils/init/globals.c:130">maintenance_work_mem</a>);<br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="../misc/guc.c.html#L3343" title="utils/misc/guc.c:3343">set_config_option</a>(<span class="Constant">&quot;<a href="../init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a>&quot;</span>, workmembuf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PGC_USERSET, PGC_S_SESSION,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GUC_ACTION_SAVE, <span class="Constant">true</span>, <span class="Constant">0</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="../misc/guc.c.html#L3343" title="utils/misc/guc.c:3343">set_config_option</a>(<span class="Constant">&quot;<a href="../init/globals.c.html#L129" title="utils/init/globals.c:129">hash_mem_multiplier</a>&quot;</span>, <span class="Constant">&quot;1&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PGC_USERSET, PGC_S_SESSION,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GUC_ACTION_SAVE, <span class="Constant">true</span>, <span class="Constant">0</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../executor/spi.c.html#L94" title="executor/spi.c:94">SPI_connect</a>() != SPI_OK_CONNECT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../../executor/spi.c.html#L94" title="executor/spi.c:94">SPI_connect</a> failed&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Generate the plan.&nbsp; We don't need to cache it, and there are no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * arguments to the plan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; qplan = <a href="../../executor/spi.c.html#L857" title="executor/spi.c:857">SPI_prepare</a>(querybuf.data, <span class="Constant">0</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (qplan == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../../executor/spi.c.html#L857" title="executor/spi.c:857">SPI_prepare</a> returned </span><span class="Special">%s</span><span class="Constant"> for </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../executor/spi.c.html#L1969" title="executor/spi.c:1969">SPI_result_code_string</a>(<a href="../../executor/spi.c.html#L46" title="executor/spi.c:46">SPI_result</a>), querybuf.data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Run the plan.&nbsp; For safety we force a current snapshot to be used. (In<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction-snapshot mode, this arguably violates transaction isolation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rules, but we really haven't got much choice.) We don't need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * register the snapshot, because <a href="../../executor/spi.c.html#L770" title="executor/spi.c:770">SPI_execute_snapshot</a> will see to it. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need at most one tuple returned, so pass limit = 1.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; spi_result = <a href="../../executor/spi.c.html#L770" title="executor/spi.c:770">SPI_execute_snapshot</a>(qplan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../time/snapmgr.c.html#L291" title="utils/time/snapmgr.c:291">GetLatestSnapshot</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidSnapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>, <span class="Constant">false</span>, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check result */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (spi_result != SPI_OK_SELECT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../../executor/spi.c.html#L770" title="executor/spi.c:770">SPI_execute_snapshot</a> returned </span><span class="Special">%s</span><span class="Constant">&quot;</span>, <a href="../../executor/spi.c.html#L1969" title="executor/spi.c:1969">SPI_result_code_string</a>(spi_result));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Did we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a tuple violating the constraint? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../executor/spi.c.html#L44" title="executor/spi.c:44">SPI_processed</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot *slot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple = <a href="../../executor/spi.c.html#L45" title="executor/spi.c:45">SPI_tuptable</a>-&gt;vals[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc = <a href="../../executor/spi.c.html#L45" title="executor/spi.c:45">SPI_tuptable</a>-&gt;tupdesc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L105" title="utils/adt/ri_triggers.c:105">RI_ConstraintInfo</a> fake_riinfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot = <a href="../../executor/execTuples.c.html#L1325" title="executor/execTuples.c:1325">MakeSingleTupleTableSlot</a>(tupdesc, &amp;<a href="../../executor/execTuples.c.html#L84" title="executor/execTuples.c:84">TTSOpsVirtual</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/common/heaptuple.c.html#L1345" title="access/common/heaptuple.c:1345">heap_deform_tuple</a>(tuple, tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;tts_values, slot-&gt;tts_isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/execTuples.c.html#L1639" title="executor/execTuples.c:1639">ExecStoreVirtualTuple</a>(slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The columns to look at in the result tuple are 1..N, not whatever<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * they are in the fk_rel.&nbsp; Hack up riinfo so that the subroutines<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * called here will behave properly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In addition to this, we have to pass the correct tupdesc to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L2577" title="utils/adt/ri_triggers.c:2577">ri_ReportViolation</a>, overriding its normal habit of using the pk_rel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * or fk_rel's tupdesc.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;fake_riinfo, riinfo, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L105" title="utils/adt/ri_triggers.c:105">RI_ConstraintInfo</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; fake_riinfo.nkeys; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fake_riinfo.fk_attnums[i] = i + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If it's <a href="../../nodes/readfuncs.c.html#L571" title="nodes/readfuncs.c:571">MATCH</a> FULL, and there are <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> nulls in the FK keys,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * complain about that rather than the lack of a match.&nbsp; <a href="../../nodes/readfuncs.c.html#L571" title="nodes/readfuncs.c:571">MATCH</a> FULL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * disallows partially-null FK rows.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fake_riinfo.confmatchtype == FKCONSTR_MATCH_FULL &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2735" title="utils/adt/ri_triggers.c:2735">ri_NullCheck</a>(tupdesc, slot, &amp;fake_riinfo, <span class="Constant">false</span>) != <a href="#L67" title="utils/adt/ri_triggers.c:67">RI_KEYS_NONE_NULL</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FOREIGN_KEY_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;insert or update on table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> violates foreign key constraint </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(fk_rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(fake_riinfo.conname)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;<a href="../../nodes/readfuncs.c.html#L571" title="nodes/readfuncs.c:571">MATCH</a> FULL does not allow mixing of null and nonnull key <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../cache/relcache.c.html#L5999" title="utils/cache/relcache.c:5999">errtableconstraint</a>(fk_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(fake_riinfo.conname))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We tell <a href="#L2577" title="utils/adt/ri_triggers.c:2577">ri_ReportViolation</a> we were doing the <a href="#L71" title="utils/adt/ri_triggers.c:71">RI_PLAN_CHECK_LOOKUPPK</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * query, which isn't true, but will cause it to use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fake_riinfo.fk_attnums as we need.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2577" title="utils/adt/ri_triggers.c:2577">ri_ReportViolation</a>(&amp;fake_riinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pk_rel, fk_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; slot, tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L71" title="utils/adt/ri_triggers.c:71">RI_PLAN_CHECK_LOOKUPPK</a>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/execTuples.c.html#L1341" title="executor/execTuples.c:1341">ExecDropSingleTupleTableSlot</a>(slot);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../executor/spi.c.html#L182" title="executor/spi.c:182">SPI_finish</a>() != SPI_OK_FINISH)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../../executor/spi.c.html#L182" title="executor/spi.c:182">SPI_finish</a> failed&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Restore <a href="../init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a> and <a href="../init/globals.c.html#L129" title="utils/init/globals.c:129">hash_mem_multiplier</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../misc/guc.c.html#L2264" title="utils/misc/guc.c:2264">AtEOXact_GUC</a>(<span class="Constant">true</span>, save_nestlevel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1738" title="utils/adt/ri_triggers.c:1738">RI_PartitionRemove_Check</a> -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Verify no referencing <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> exist, when a partition is detached on<br/></li>
<li></span><span class="Comment"> * the referenced side of a foreign key constraint.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1738">&#x200c;</a></span><span class="linkable">RI_PartitionRemove_Check</span>(Trigger *<a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>, Relation fk_rel, Relation pk_rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="#L105" title="utils/adt/ri_triggers.c:105">RI_ConstraintInfo</a> *riinfo;<br/></li>
<li>&nbsp; &nbsp; StringInfoData querybuf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *constraintDef;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; pkrelname[<a href="#L85" title="utils/adt/ri_triggers.c:85">MAX_QUOTED_REL_NAME_LEN</a>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; fkrelname[<a href="#L85" title="utils/adt/ri_triggers.c:85">MAX_QUOTED_REL_NAME_LEN</a>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; pkattname[<a href="#L84" title="utils/adt/ri_triggers.c:84">MAX_QUOTED_NAME_LEN</a> + <span class="Constant">3</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; fkattname[<a href="#L84" title="utils/adt/ri_triggers.c:84">MAX_QUOTED_NAME_LEN</a> + <span class="Constant">3</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *sep;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *fk_only;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_nestlevel;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; workmembuf[<span class="Constant">32</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; spi_result;<br/></li>
<li>&nbsp; &nbsp; SPIPlanPtr&nbsp; &nbsp; qplan;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; riinfo = <a href="#L2142" title="utils/adt/ri_triggers.c:2142">ri_FetchConstraintInfo</a>(<a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>, fk_rel, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't check permissions <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> displaying the error message, on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * assumption that the user detaching the partition must have enough<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * privileges to examine the table contents anyhow.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The query string built is:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; SELECT fk.keycols FROM [ONLY] relname fk<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; JOIN pkrelname pk<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; ON (pk.pkkeycol1=fk.keycol1 [AND ...])<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; WHERE (&lt;partition constraint&gt;) AND<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For <a href="../../nodes/readfuncs.c.html#L571" title="nodes/readfuncs.c:571">MATCH</a> SIMPLE:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp;&nbsp; (fk.keycol1 IS NOT NULL [AND ...])<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For <a href="../../nodes/readfuncs.c.html#L571" title="nodes/readfuncs.c:571">MATCH</a> FULL:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp;&nbsp; (fk.keycol1 IS NOT NULL [OR ...])<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We attach COLLATE clauses to the operators when comparing columns<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that have different collations.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; initStringInfo(&amp;querybuf);<br/></li>
<li>&nbsp; &nbsp; appendStringInfoString(&amp;querybuf, <span class="Constant">&quot;SELECT &quot;</span>);<br/></li>
<li>&nbsp; &nbsp; sep = <span class="Constant">&quot;&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; riinfo-&gt;nkeys; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1957" title="utils/adt/ri_triggers.c:1957">quoteOneName</a>(fkattname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L87" title="utils/adt/ri_triggers.c:87">RIAttName</a>(fk_rel, riinfo-&gt;fk_attnums[i]));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;querybuf, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">fk.</span><span class="Special">%s</span><span class="Constant">&quot;</span>, sep, fkattname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sep = <span class="Constant">&quot;, &quot;</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1977" title="utils/adt/ri_triggers.c:1977">quoteRelationName</a>(pkrelname, pk_rel);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1977" title="utils/adt/ri_triggers.c:1977">quoteRelationName</a>(fkrelname, fk_rel);<br/></li>
<li>&nbsp; &nbsp; fk_only = fk_rel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;&quot;</span> : <span class="Constant">&quot;ONLY &quot;</span>;<br/></li>
<li>&nbsp; &nbsp; appendStringInfo(&amp;querybuf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot; FROM </span><span class="Special">%s%s</span><span class="Constant"> fk JOIN </span><span class="Special">%s</span><span class="Constant"> pk ON&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fk_only, fkrelname, pkrelname);<br/></li>
<li>&nbsp; &nbsp; strcpy(pkattname, <span class="Constant">&quot;pk.&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; strcpy(fkattname, <span class="Constant">&quot;fk.&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; sep = <span class="Constant">&quot;(&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; riinfo-&gt;nkeys; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pk_type = <a href="#L88" title="utils/adt/ri_triggers.c:88">RIAttType</a>(pk_rel, riinfo-&gt;pk_attnums[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fk_type = <a href="#L88" title="utils/adt/ri_triggers.c:88">RIAttType</a>(fk_rel, riinfo-&gt;fk_attnums[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pk_coll = <a href="#L89" title="utils/adt/ri_triggers.c:89">RIAttCollation</a>(pk_rel, riinfo-&gt;pk_attnums[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fk_coll = <a href="#L89" title="utils/adt/ri_triggers.c:89">RIAttCollation</a>(fk_rel, riinfo-&gt;fk_attnums[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1957" title="utils/adt/ri_triggers.c:1957">quoteOneName</a>(pkattname + <span class="Constant">3</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L87" title="utils/adt/ri_triggers.c:87">RIAttName</a>(pk_rel, riinfo-&gt;pk_attnums[i]));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1957" title="utils/adt/ri_triggers.c:1957">quoteOneName</a>(fkattname + <span class="Constant">3</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L87" title="utils/adt/ri_triggers.c:87">RIAttName</a>(fk_rel, riinfo-&gt;fk_attnums[i]));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1994" title="utils/adt/ri_triggers.c:1994">ri_GenerateQual</a>(&amp;querybuf, sep,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pkattname, pk_type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; riinfo-&gt;pf_eq_oprs[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fkattname, fk_type);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pk_coll != fk_coll)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2023" title="utils/adt/ri_triggers.c:2023">ri_GenerateQualCollation</a>(&amp;querybuf, pk_coll);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sep = <span class="Constant">&quot;AND&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Start the WHERE clause with the partition constraint (except if this is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the default partition and there's no other partition, because the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * partition constraint is the empty string in that case.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; constraintDef = <a href="ruleutils.c.html#L2112" title="utils/adt/ruleutils.c:2112">pg_get_partconstrdef_string</a>(RelationGetRelid(pk_rel), <span class="Constant">&quot;pk&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (constraintDef &amp;&amp; constraintDef[<span class="Constant">0</span>] != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;querybuf, <span class="Constant">&quot;) WHERE </span><span class="Special">%s</span><span class="Constant"> AND (&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; constraintDef);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;querybuf, <span class="Constant">&quot;) WHERE (&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sep = <span class="Constant">&quot;&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; riinfo-&gt;nkeys; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1957" title="utils/adt/ri_triggers.c:1957">quoteOneName</a>(fkattname, <a href="#L87" title="utils/adt/ri_triggers.c:87">RIAttName</a>(fk_rel, riinfo-&gt;fk_attnums[i]));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;querybuf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">fk.</span><span class="Special">%s</span><span class="Constant"> IS NOT NULL&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sep, fkattname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (riinfo-&gt;confmatchtype)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> FKCONSTR_MATCH_SIMPLE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sep = <span class="Constant">&quot; AND &quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> FKCONSTR_MATCH_FULL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sep = <span class="Constant">&quot; OR &quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; appendStringInfoChar(&amp;querybuf, <span class="Constant">')'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Temporarily increase <a href="../init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a> so that the check query can be executed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * more efficiently.&nbsp; It seems okay to do this because the query is simple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * enough to not use a multiple of <a href="../init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a>, and one typically would not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have many large foreign-key validations happening concurrently.&nbsp; So<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this seems to meet the criteria for being considered a &quot;maintenance&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operation, and accordingly we use <a href="../init/globals.c.html#L130" title="utils/init/globals.c:130">maintenance_work_mem</a>.&nbsp; However, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * must also set <a href="../init/globals.c.html#L129" title="utils/init/globals.c:129">hash_mem_multiplier</a> to 1, since it is surely not okay to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * let that get applied to the <a href="../init/globals.c.html#L130" title="utils/init/globals.c:130">maintenance_work_mem</a> value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We use the equivalent of a function <a href="../../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> option to allow the setting to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * persist for exactly the duration of the check query.&nbsp; guc.c also takes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * care of undoing the setting on error.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; save_nestlevel = <a href="../misc/guc.c.html#L2237" title="utils/misc/guc.c:2237">NewGUCNestLevel</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snprintf(workmembuf, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(workmembuf), <span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>, <a href="../init/globals.c.html#L130" title="utils/init/globals.c:130">maintenance_work_mem</a>);<br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="../misc/guc.c.html#L3343" title="utils/misc/guc.c:3343">set_config_option</a>(<span class="Constant">&quot;<a href="../init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a>&quot;</span>, workmembuf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PGC_USERSET, PGC_S_SESSION,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GUC_ACTION_SAVE, <span class="Constant">true</span>, <span class="Constant">0</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="../misc/guc.c.html#L3343" title="utils/misc/guc.c:3343">set_config_option</a>(<span class="Constant">&quot;<a href="../init/globals.c.html#L129" title="utils/init/globals.c:129">hash_mem_multiplier</a>&quot;</span>, <span class="Constant">&quot;1&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PGC_USERSET, PGC_S_SESSION,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GUC_ACTION_SAVE, <span class="Constant">true</span>, <span class="Constant">0</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../executor/spi.c.html#L94" title="executor/spi.c:94">SPI_connect</a>() != SPI_OK_CONNECT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../../executor/spi.c.html#L94" title="executor/spi.c:94">SPI_connect</a> failed&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Generate the plan.&nbsp; We don't need to cache it, and there are no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * arguments to the plan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; qplan = <a href="../../executor/spi.c.html#L857" title="executor/spi.c:857">SPI_prepare</a>(querybuf.data, <span class="Constant">0</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (qplan == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../../executor/spi.c.html#L857" title="executor/spi.c:857">SPI_prepare</a> returned </span><span class="Special">%s</span><span class="Constant"> for </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../executor/spi.c.html#L1969" title="executor/spi.c:1969">SPI_result_code_string</a>(<a href="../../executor/spi.c.html#L46" title="executor/spi.c:46">SPI_result</a>), querybuf.data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Run the plan.&nbsp; For safety we force a current snapshot to be used. (In<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction-snapshot mode, this arguably violates transaction isolation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rules, but we really haven't got much choice.) We don't need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * register the snapshot, because <a href="../../executor/spi.c.html#L770" title="executor/spi.c:770">SPI_execute_snapshot</a> will see to it. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need at most one tuple returned, so pass limit = 1.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; spi_result = <a href="../../executor/spi.c.html#L770" title="executor/spi.c:770">SPI_execute_snapshot</a>(qplan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../time/snapmgr.c.html#L291" title="utils/time/snapmgr.c:291">GetLatestSnapshot</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidSnapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>, <span class="Constant">false</span>, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check result */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (spi_result != SPI_OK_SELECT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../../executor/spi.c.html#L770" title="executor/spi.c:770">SPI_execute_snapshot</a> returned </span><span class="Special">%s</span><span class="Constant">&quot;</span>, <a href="../../executor/spi.c.html#L1969" title="executor/spi.c:1969">SPI_result_code_string</a>(spi_result));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Did we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a tuple that would violate the constraint? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../executor/spi.c.html#L44" title="executor/spi.c:44">SPI_processed</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot *slot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple = <a href="../../executor/spi.c.html#L45" title="executor/spi.c:45">SPI_tuptable</a>-&gt;vals[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc = <a href="../../executor/spi.c.html#L45" title="executor/spi.c:45">SPI_tuptable</a>-&gt;tupdesc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L105" title="utils/adt/ri_triggers.c:105">RI_ConstraintInfo</a> fake_riinfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot = <a href="../../executor/execTuples.c.html#L1325" title="executor/execTuples.c:1325">MakeSingleTupleTableSlot</a>(tupdesc, &amp;<a href="../../executor/execTuples.c.html#L84" title="executor/execTuples.c:84">TTSOpsVirtual</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/common/heaptuple.c.html#L1345" title="access/common/heaptuple.c:1345">heap_deform_tuple</a>(tuple, tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;tts_values, slot-&gt;tts_isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/execTuples.c.html#L1639" title="executor/execTuples.c:1639">ExecStoreVirtualTuple</a>(slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The columns to look at in the result tuple are 1..N, not whatever<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * they are in the fk_rel.&nbsp; Hack up riinfo so that <a href="#L2577" title="utils/adt/ri_triggers.c:2577">ri_ReportViolation</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will behave properly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In addition to this, we have to pass the correct tupdesc to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L2577" title="utils/adt/ri_triggers.c:2577">ri_ReportViolation</a>, overriding its normal habit of using the pk_rel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * or fk_rel's tupdesc.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;fake_riinfo, riinfo, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L105" title="utils/adt/ri_triggers.c:105">RI_ConstraintInfo</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; fake_riinfo.nkeys; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fake_riinfo.pk_attnums[i] = i + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2577" title="utils/adt/ri_triggers.c:2577">ri_ReportViolation</a>(&amp;fake_riinfo, pk_rel, fk_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; slot, tupdesc, <span class="Constant">0</span>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../executor/spi.c.html#L182" title="executor/spi.c:182">SPI_finish</a>() != SPI_OK_FINISH)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../../executor/spi.c.html#L182" title="executor/spi.c:182">SPI_finish</a> failed&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Restore <a href="../init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a> and <a href="../init/globals.c.html#L129" title="utils/init/globals.c:129">hash_mem_multiplier</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../misc/guc.c.html#L2264" title="utils/misc/guc.c:2264">AtEOXact_GUC</a>(<span class="Constant">true</span>, save_nestlevel);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment"> * Local <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> below<br/></li>
<li></span><span class="Comment"> * ----------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1957" title="utils/adt/ri_triggers.c:1957">quoteOneName</a> --- safely quote a single SQL name<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * buffer must be <a href="#L84" title="utils/adt/ri_triggers.c:84">MAX_QUOTED_NAME_LEN</a> long (includes room for \0)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1957">&#x200c;</a></span><span class="linkable">quoteOneName</span>(<span class="Type">char</span> *buffer, <span class="Type">const</span> <span class="Type">char</span> *name)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Rather than trying to be smart, just always quote it. */<br/></li>
<li></span>&nbsp; &nbsp; *buffer++ = <span class="Constant">'&quot;'</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (*name)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*name == <span class="Constant">'&quot;'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *buffer++ = <span class="Constant">'&quot;'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *buffer++ = *name++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; *buffer++ = <span class="Constant">'&quot;'</span>;<br/></li>
<li>&nbsp; &nbsp; *buffer = <span class="Special">'\0'</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1977" title="utils/adt/ri_triggers.c:1977">quoteRelationName</a> --- safely quote a fully qualified relation name<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * buffer must be <a href="#L85" title="utils/adt/ri_triggers.c:85">MAX_QUOTED_REL_NAME_LEN</a> long (includes room for \0)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1977">&#x200c;</a></span><span class="linkable">quoteRelationName</span>(<span class="Type">char</span> *buffer, Relation rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L1957" title="utils/adt/ri_triggers.c:1957">quoteOneName</a>(buffer, <a href="../cache/lsyscache.c.html#L3366" title="utils/cache/lsyscache.c:3366">get_namespace_name</a>(RelationGetNamespace(rel)));<br/></li>
<li>&nbsp; &nbsp; buffer += strlen(buffer);<br/></li>
<li>&nbsp; &nbsp; *buffer++ = <span class="Constant">'.'</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L1957" title="utils/adt/ri_triggers.c:1957">quoteOneName</a>(buffer, RelationGetRelationName(rel));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1994" title="utils/adt/ri_triggers.c:1994">ri_GenerateQual</a> --- generate a WHERE clause equating two variables<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This basically appends &quot; sep leftop op rightop&quot; to buf, adding casts<br/></li>
<li></span><span class="Comment"> * and schema qualification as needed to ensure that the parser will <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a><br/></li>
<li></span><span class="Comment"> * the operator we specify.&nbsp; leftop and rightop should be parenthesized<br/></li>
<li></span><span class="Comment"> * if they aren't variables or parameters.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1994">&#x200c;</a></span><span class="linkable">ri_GenerateQual</span>(StringInfo buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *sep,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *leftop, Oid leftoptype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid opoid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *rightop, Oid rightoptype)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; appendStringInfo(buf, <span class="Constant">&quot; </span><span class="Special">%s</span><span class="Constant"> &quot;</span>, sep);<br/></li>
<li>&nbsp; &nbsp; <a href="ruleutils.c.html#L13031" title="utils/adt/ruleutils.c:13031">generate_operator_clause</a>(buf, leftop, leftoptype, opoid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rightop, rightoptype);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2023" title="utils/adt/ri_triggers.c:2023">ri_GenerateQualCollation</a> --- add a COLLATE spec to a WHERE clause<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * At present, we intentionally do not use this function for RI queries that<br/></li>
<li></span><span class="Comment"> * <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> a variable to a $n parameter.&nbsp; Since parameter symbols always have<br/></li>
<li></span><span class="Comment"> * default collation, the effect will be to use the variable's collation.<br/></li>
<li></span><span class="Comment"> * Now that is only strictly correct when testing the referenced column, since<br/></li>
<li></span><span class="Comment"> * the SQL standard specifies that RI comparisons should use the referenced<br/></li>
<li></span><span class="Comment"> * column's collation.&nbsp; However, so long as all collations have the same<br/></li>
<li></span><span class="Comment"> * notion of equality (which they do, because <a href="varlena.c.html#L1619" title="utils/adt/varlena.c:1619">texteq</a> reduces to bitwise<br/></li>
<li></span><span class="Comment"> * equality), there's no visible semantic impact from using the referencing<br/></li>
<li></span><span class="Comment"> * column's collation when testing it, and this is a good thing to do because<br/></li>
<li></span><span class="Comment"> * it lets us use a normal index on the referencing column.&nbsp; However, we do<br/></li>
<li></span><span class="Comment"> * have to use this function when directly comparing the referencing and<br/></li>
<li></span><span class="Comment"> * referenced columns, if they are of different collations; else the parser<br/></li>
<li></span><span class="Comment"> * will fail to resolve the collation to use.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2023">&#x200c;</a></span><span class="linkable">ri_GenerateQualCollation</span>(StringInfo buf, Oid collation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li>&nbsp; &nbsp; Form_pg_collation colltup;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *collname;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; onename[<a href="#L84" title="utils/adt/ri_triggers.c:84">MAX_QUOTED_NAME_LEN</a>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Nothing to do if it's a noncollatable data type */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(collation))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="../cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(COLLOID, ObjectIdGetDatum(collation));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for collation </span><span class="Special">%u</span><span class="Constant">&quot;</span>, collation);<br/></li>
<li>&nbsp; &nbsp; colltup = (Form_pg_collation) GETSTRUCT(tp);<br/></li>
<li>&nbsp; &nbsp; collname = NameStr(colltup-&gt;collname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We qualify the name always, for simplicity and to ensure the query is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not search-path-dependent.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1957" title="utils/adt/ri_triggers.c:1957">quoteOneName</a>(onename, <a href="../cache/lsyscache.c.html#L3366" title="utils/cache/lsyscache.c:3366">get_namespace_name</a>(colltup-&gt;collnamespace));<br/></li>
<li>&nbsp; &nbsp; appendStringInfo(buf, <span class="Constant">&quot; COLLATE </span><span class="Special">%s</span><span class="Constant">&quot;</span>, onename);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1957" title="utils/adt/ri_triggers.c:1957">quoteOneName</a>(onename, collname);<br/></li>
<li>&nbsp; &nbsp; appendStringInfo(buf, <span class="Constant">&quot;.</span><span class="Special">%s</span><span class="Constant">&quot;</span>, onename);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment"> * <a href="#L2064" title="utils/adt/ri_triggers.c:2064">ri_BuildQueryKey</a> -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Construct a hashtable key for a prepared SPI plan of an FK constraint.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; key: output argument, *key is filled in based on the other arguments<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; riinfo: info derived from pg_constraint entry<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; constr_queryno: an <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> number identifying the query type<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (see RI_PLAN_XXX constants at head of file)<br/></li>
<li></span><span class="Comment"> * ----------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2064">&#x200c;</a></span><span class="linkable">ri_BuildQueryKey</span>(<a href="#L140" title="utils/adt/ri_triggers.c:140">RI_QueryKey</a> *key, <span class="Type">const</span> <a href="#L105" title="utils/adt/ri_triggers.c:105">RI_ConstraintInfo</a> *riinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; int32 constr_queryno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Inherited constraints with a common ancestor can share <a href="#L182" title="utils/adt/ri_triggers.c:182">ri_query_cache</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * entries for all query types except <a href="#L72" title="utils/adt/ri_triggers.c:72">RI_PLAN_CHECK_LOOKUPPK_FROM_PK</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Except in that case, the query processes the other table involved in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the FK constraint (i.e., not the table on which the <a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> has been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fired), and so it will be the same for all members of the inheritance<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tree.&nbsp; So we may use the root constraint's OID in the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> key, rather<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * than the constraint's own OID.&nbsp; This avoids creating duplicate SPI<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * plans, saving lots of work and memory when there are many partitions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with similar FK constraints.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (Note that we must still have a separate <a href="#L105" title="utils/adt/ri_triggers.c:105">RI_ConstraintInfo</a> for each<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * constraint, because partitions can have different column orders,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * resulting in different pk_attnums[] or fk_attnums[] array contents.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We assume struct <a href="#L140" title="utils/adt/ri_triggers.c:140">RI_QueryKey</a> contains no padding bytes, else we'd need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to use memset to clear them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (constr_queryno != <a href="#L72" title="utils/adt/ri_triggers.c:72">RI_PLAN_CHECK_LOOKUPPK_FROM_PK</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; key-&gt;constr_id = riinfo-&gt;constraint_root_id;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; key-&gt;constr_id = riinfo-&gt;constraint_id;<br/></li>
<li>&nbsp; &nbsp; key-&gt;constr_queryno = constr_queryno;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check that RI <a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> function was called in expected context<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2096">&#x200c;</a></span><span class="linkable">ri_CheckTrigger</span>(FunctionCallInfo fcinfo, <span class="Type">const</span> <span class="Type">char</span> *funcname, <span class="Type">int</span> tgkind)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TriggerData *trigdata = (TriggerData *) fcinfo-&gt;context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!CALLED_AS_TRIGGER(fcinfo))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;function </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> was not called by <a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> manager&quot;</span>, funcname)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check proper event<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!TRIGGER_FIRED_AFTER(trigdata-&gt;tg_event) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !TRIGGER_FIRED_FOR_ROW(trigdata-&gt;tg_event))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;function </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> must be fired AFTER ROW&quot;</span>, funcname)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (tgkind)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L91" title="utils/adt/ri_triggers.c:91">RI_TRIGTYPE_INSERT</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!TRIGGER_FIRED_BY_INSERT(trigdata-&gt;tg_event))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;function </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> must be fired for INSERT&quot;</span>, funcname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L92" title="utils/adt/ri_triggers.c:92">RI_TRIGTYPE_UPDATE</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!TRIGGER_FIRED_BY_UPDATE(trigdata-&gt;tg_event))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;function </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> must be fired for UPDATE&quot;</span>, funcname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L93" title="utils/adt/ri_triggers.c:93">RI_TRIGTYPE_DELETE</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!TRIGGER_FIRED_BY_DELETE(trigdata-&gt;tg_event))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;function </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> must be fired for DELETE&quot;</span>, funcname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Fetch the <a href="#L105" title="utils/adt/ri_triggers.c:105">RI_ConstraintInfo</a> struct for the <a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>'s FK constraint.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">const</span> <a href="#L105" title="utils/adt/ri_triggers.c:105">RI_ConstraintInfo</a> *<br/></li>
<li><a id="L2142">&#x200c;</a><span class="linkable">ri_FetchConstraintInfo</span>(Trigger *<a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>, Relation trig_rel, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> rel_is_pk)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constraintOid = <a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>-&gt;tgconstraint;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="#L105" title="utils/adt/ri_triggers.c:105">RI_ConstraintInfo</a> *riinfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check that the FK constraint's OID is available; it might not be if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we've been invoked via an ordinary <a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> or an old-style &quot;constraint<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(constraintOid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_OBJECT_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;no pg_constraint entry for <a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> on table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>-&gt;tgname, RelationGetRelationName(trig_rel)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Remove this referential integrity <a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> and its mates, then do ALTER TABLE ADD CONSTRAINT.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Find or create a hashtable entry for the constraint */<br/></li>
<li></span>&nbsp; &nbsp; riinfo = <a href="#L2196" title="utils/adt/ri_triggers.c:2196">ri_LoadConstraintInfo</a>(constraintOid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Do some easy cross-checks against the <a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> call data */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel_is_pk)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (riinfo-&gt;fk_relid != <a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>-&gt;tgconstrrelid ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; riinfo-&gt;pk_relid != RelationGetRelid(trig_rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;wrong pg_constraint entry for <a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> on table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>-&gt;tgname, RelationGetRelationName(trig_rel));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (riinfo-&gt;fk_relid != RelationGetRelid(trig_rel) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; riinfo-&gt;pk_relid != <a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>-&gt;tgconstrrelid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;wrong pg_constraint entry for <a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> on table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>-&gt;tgname, RelationGetRelationName(trig_rel));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (riinfo-&gt;confmatchtype != FKCONSTR_MATCH_FULL &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; riinfo-&gt;confmatchtype != FKCONSTR_MATCH_PARTIAL &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; riinfo-&gt;confmatchtype != FKCONSTR_MATCH_SIMPLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized confmatchtype: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; riinfo-&gt;confmatchtype);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (riinfo-&gt;confmatchtype == FKCONSTR_MATCH_PARTIAL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;<a href="../../nodes/readfuncs.c.html#L571" title="nodes/readfuncs.c:571">MATCH</a> PARTIAL not yet implemented&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> riinfo;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Fetch or create the <a href="#L105" title="utils/adt/ri_triggers.c:105">RI_ConstraintInfo</a> struct for an FK constraint.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">const</span> <a href="#L105" title="utils/adt/ri_triggers.c:105">RI_ConstraintInfo</a> *<br/></li>
<li><a id="L2196">&#x200c;</a><span class="linkable">ri_LoadConstraintInfo</span>(Oid constraintOid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L105" title="utils/adt/ri_triggers.c:105">RI_ConstraintInfo</a> *riinfo;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tup;<br/></li>
<li>&nbsp; &nbsp; Form_pg_constraint conForm;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * On the first call <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the hashtable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L181" title="utils/adt/ri_triggers.c:181">ri_constraint_cache</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2772" title="utils/adt/ri_triggers.c:2772">ri_InitHashTables</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Find or create a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> entry.&nbsp; If we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a valid one, just return it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; riinfo = (<a href="#L105" title="utils/adt/ri_triggers.c:105">RI_ConstraintInfo</a> *) <a href="../hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L181" title="utils/adt/ri_triggers.c:181">ri_constraint_cache</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;constraintOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_ENTER, &amp;found);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; riinfo-&gt;valid = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (riinfo-&gt;valid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> riinfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fetch the pg_constraint row so we can fill in the entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tup = <a href="../cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(CONSTROID, ObjectIdGetDatum(constraintOid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tup)) <span class="Comment">/* should not happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for constraint </span><span class="Special">%u</span><span class="Constant">&quot;</span>, constraintOid);<br/></li>
<li>&nbsp; &nbsp; conForm = (Form_pg_constraint) GETSTRUCT(tup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (conForm-&gt;contype != CONSTRAINT_FOREIGN) <span class="Comment">/* should not happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;constraint </span><span class="Special">%u</span><span class="Constant"> is not a foreign key constraint&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; constraintOid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And extract data */<br/></li>
<li></span>&nbsp; &nbsp; Assert(riinfo-&gt;constraint_id == constraintOid);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(conForm-&gt;conparentid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; riinfo-&gt;constraint_root_id =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2293" title="utils/adt/ri_triggers.c:2293">get_ri_constraint_root</a>(conForm-&gt;conparentid);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; riinfo-&gt;constraint_root_id = constraintOid;<br/></li>
<li>&nbsp; &nbsp; riinfo-&gt;oidHashValue = GetSysCacheHashValue1(CONSTROID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectIdGetDatum(constraintOid));<br/></li>
<li>&nbsp; &nbsp; riinfo-&gt;rootHashValue = GetSysCacheHashValue1(CONSTROID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(riinfo-&gt;constraint_root_id));<br/></li>
<li>&nbsp; &nbsp; memcpy(&amp;riinfo-&gt;conname, &amp;conForm-&gt;conname, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(NameData));<br/></li>
<li>&nbsp; &nbsp; riinfo-&gt;pk_relid = conForm-&gt;confrelid;<br/></li>
<li>&nbsp; &nbsp; riinfo-&gt;fk_relid = conForm-&gt;conrelid;<br/></li>
<li>&nbsp; &nbsp; riinfo-&gt;confupdtype = conForm-&gt;confupdtype;<br/></li>
<li>&nbsp; &nbsp; riinfo-&gt;confdeltype = conForm-&gt;confdeltype;<br/></li>
<li>&nbsp; &nbsp; riinfo-&gt;confmatchtype = conForm-&gt;confmatchtype;<br/></li>
<li>&nbsp; &nbsp; riinfo-&gt;hasperiod = conForm-&gt;conperiod;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../catalog/pg_constraint.c.html#L1669" title="catalog/pg_constraint.c:1669">DeconstructFkConstraintRow</a>(tup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;riinfo-&gt;nkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; riinfo-&gt;fk_attnums,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; riinfo-&gt;pk_attnums,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; riinfo-&gt;pf_eq_oprs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; riinfo-&gt;pp_eq_oprs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; riinfo-&gt;ff_eq_oprs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;riinfo-&gt;ndelsetcols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; riinfo-&gt;confdelsetcols);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For temporal FKs, get the operators and <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> we need. We ask the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * opclass of the PK <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> for these. This all gets cached (as does the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * generated plan), so there's no performance issue.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (riinfo-&gt;hasperiod)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opclass = <a href="../cache/lsyscache.c.html#L3512" title="utils/cache/lsyscache.c:3512">get_index_column_opclass</a>(conForm-&gt;conindid, riinfo-&gt;nkeys);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/pg_constraint.c.html#L1797" title="catalog/pg_constraint.c:1797">FindFKPeriodOpers</a>(opclass,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;riinfo-&gt;period_contained_by_oper,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;riinfo-&gt;agged_period_contained_by_oper);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For efficient processing of invalidation messages below, we keep a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * doubly-linked count list of all currently valid entries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; dclist_push_tail(&amp;<a href="#L184" title="utils/adt/ri_triggers.c:184">ri_constraint_cache_valid_list</a>, &amp;riinfo-&gt;valid_link);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; riinfo-&gt;valid = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> riinfo;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2293" title="utils/adt/ri_triggers.c:2293">get_ri_constraint_root</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns the OID of the constraint's root parent<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Oid<br/></li>
<li><a id="L2293">&#x200c;</a><span class="linkable">get_ri_constraint_root</span>(Oid constrOid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constrParentOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple = <a href="../cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(CONSTROID, ObjectIdGetDatum(constrOid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for constraint </span><span class="Special">%u</span><span class="Constant">&quot;</span>, constrOid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; constrParentOid = ((Form_pg_constraint) GETSTRUCT(tuple))-&gt;conparentid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(constrParentOid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we reached the root constraint */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; constrOid = constrParentOid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> constrOid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Callback for pg_constraint inval events<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * While most syscache callbacks just flush all their entries, pg_constraint<br/></li>
<li></span><span class="Comment"> * gets enough update traffic that it's probably worth being smarter.<br/></li>
<li></span><span class="Comment"> * Invalidate <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="#L181" title="utils/adt/ri_triggers.c:181">ri_constraint_cache</a> entry associated with the syscache<br/></li>
<li></span><span class="Comment"> * entry with the specified <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> value, or all entries if hashvalue == 0.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: at the time a cache invalidation message is processed there may be<br/></li>
<li></span><span class="Comment"> * active references to the cache.&nbsp; Because of this we never remove entries<br/></li>
<li></span><span class="Comment"> * from the cache, but only mark them invalid, which is harmless to active<br/></li>
<li></span><span class="Comment"> * uses.&nbsp; (Any query using an entry should hold a lock sufficient to keep that<br/></li>
<li></span><span class="Comment"> * data from changing under it --- but we may get cache flushes anyway.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2327">&#x200c;</a></span><span class="linkable">InvalidateConstraintCacheCallBack</span>(Datum arg, <span class="Type">int</span> cacheid, uint32 hashvalue)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dlist_mutable_iter iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L181" title="utils/adt/ri_triggers.c:181">ri_constraint_cache</a> != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the list of currently valid entries gets excessively large, we mark<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * them all invalid so we can empty the list.&nbsp; This arrangement avoids<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * O(N^2) behavior in situations where a session touches many foreign keys<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and also does many ALTER TABLEs, such as a restore from pg_dump.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (dclist_count(&amp;<a href="#L184" title="utils/adt/ri_triggers.c:184">ri_constraint_cache_valid_list</a>) &gt; <span class="Constant">1000</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hashvalue = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* pretend it's a cache reset */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; dclist_foreach_modify(iter, &amp;<a href="#L184" title="utils/adt/ri_triggers.c:184">ri_constraint_cache_valid_list</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L105" title="utils/adt/ri_triggers.c:105">RI_ConstraintInfo</a> *riinfo = dclist_container(<a href="#L105" title="utils/adt/ri_triggers.c:105">RI_ConstraintInfo</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; valid_link, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We must invalidate not only entries directly matching the given<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> value, but also child entries, in case the invalidation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * affects a root constraint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hashvalue == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; riinfo-&gt;oidHashValue == hashvalue ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; riinfo-&gt;rootHashValue == hashvalue)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; riinfo-&gt;valid = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Remove invalidated entries from the list, too */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dclist_delete_from(&amp;<a href="#L184" title="utils/adt/ri_triggers.c:184">ri_constraint_cache_valid_list</a>, iter.cur);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Prepare execution plan for a query to enforce an RI restriction<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> SPIPlanPtr<br/></li>
<li><a id="L2368">&#x200c;</a><span class="linkable">ri_PlanCheck</span>(<span class="Type">const</span> <span class="Type">char</span> *querystr, <span class="Type">int</span> nargs, Oid *argtypes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L140" title="utils/adt/ri_triggers.c:140">RI_QueryKey</a> *qkey, Relation fk_rel, Relation pk_rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SPIPlanPtr&nbsp; &nbsp; qplan;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; query_rel;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_userid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_sec_context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Use the query type code to determine whether the query is run against<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the PK or FK table; we'll do the check as that table's owner<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (qkey-&gt;constr_queryno &lt;= <a href="#L73" title="utils/adt/ri_triggers.c:73">RI_PLAN_LAST_ON_PK</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; query_rel = pk_rel;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; query_rel = fk_rel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Switch to proper UID to perform check as */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../init/miscinit.c.html#L635" title="utils/init/miscinit.c:635">GetUserIdAndSecContext</a>(&amp;save_userid, &amp;save_sec_context);<br/></li>
<li>&nbsp; &nbsp; <a href="../init/miscinit.c.html#L642" title="utils/init/miscinit.c:642">SetUserIdAndSecContext</a>(RelationGetForm(query_rel)-&gt;relowner,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; save_sec_context | SECURITY_LOCAL_USERID_CHANGE |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; SECURITY_NOFORCE_RLS);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create the plan */<br/></li>
<li></span>&nbsp; &nbsp; qplan = <a href="../../executor/spi.c.html#L857" title="executor/spi.c:857">SPI_prepare</a>(querystr, nargs, argtypes);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (qplan == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../../executor/spi.c.html#L857" title="executor/spi.c:857">SPI_prepare</a> returned </span><span class="Special">%s</span><span class="Constant"> for </span><span class="Special">%s</span><span class="Constant">&quot;</span>, <a href="../../executor/spi.c.html#L1969" title="executor/spi.c:1969">SPI_result_code_string</a>(<a href="../../executor/spi.c.html#L46" title="executor/spi.c:46">SPI_result</a>), querystr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Restore UID and security context */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../init/miscinit.c.html#L642" title="utils/init/miscinit.c:642">SetUserIdAndSecContext</a>(save_userid, save_sec_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Save the plan */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../executor/spi.c.html#L973" title="executor/spi.c:973">SPI_keepplan</a>(qplan);<br/></li>
<li>&nbsp; &nbsp; <a href="#L2860" title="utils/adt/ri_triggers.c:2860">ri_HashPreparedPlan</a>(qkey, qplan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> qplan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Perform a query to enforce an RI restriction<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2411">&#x200c;</a></span><span class="linkable">ri_PerformCheck</span>(<span class="Type">const</span> <a href="#L105" title="utils/adt/ri_triggers.c:105">RI_ConstraintInfo</a> *riinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L140" title="utils/adt/ri_triggers.c:140">RI_QueryKey</a> *qkey, SPIPlanPtr qplan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation fk_rel, Relation pk_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot *oldslot, TupleTableSlot *newslot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> detectNewRows, <span class="Type">int</span> expect_OK)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; query_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; source_rel;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; source_is_pk;<br/></li>
<li>&nbsp; &nbsp; Snapshot&nbsp; &nbsp; test_snapshot;<br/></li>
<li>&nbsp; &nbsp; Snapshot&nbsp; &nbsp; crosscheck_snapshot;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; limit;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; spi_result;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_userid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_sec_context;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; vals[<a href="#L60" title="utils/adt/ri_triggers.c:60">RI_MAX_NUMKEYS</a> * <span class="Constant">2</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; nulls[<a href="#L60" title="utils/adt/ri_triggers.c:60">RI_MAX_NUMKEYS</a> * <span class="Constant">2</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Use the query type code to determine whether the query is run against<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the PK or FK table; we'll do the check as that table's owner<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (qkey-&gt;constr_queryno &lt;= <a href="#L73" title="utils/adt/ri_triggers.c:73">RI_PLAN_LAST_ON_PK</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; query_rel = pk_rel;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; query_rel = fk_rel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for the query are taken from the table on which the <a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is called - it is normally the other one with respect to query_rel. An<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exception is <a href="#L508" title="utils/adt/ri_triggers.c:508">ri_Check_Pk_Match</a>(), which uses the PK table for both (and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sets queryno to <a href="#L72" title="utils/adt/ri_triggers.c:72">RI_PLAN_CHECK_LOOKUPPK_FROM_PK</a>).&nbsp; We might eventually<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need some less klugy way to determine this.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (qkey-&gt;constr_queryno == <a href="#L71" title="utils/adt/ri_triggers.c:71">RI_PLAN_CHECK_LOOKUPPK</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; source_rel = fk_rel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; source_is_pk = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; source_rel = pk_rel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; source_is_pk = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Extract the parameters to be passed into the query */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (newslot)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2548" title="utils/adt/ri_triggers.c:2548">ri_ExtractValues</a>(source_rel, newslot, riinfo, source_is_pk,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; vals, nulls);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (oldslot)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2548" title="utils/adt/ri_triggers.c:2548">ri_ExtractValues</a>(source_rel, oldslot, riinfo, source_is_pk,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; vals + riinfo-&gt;nkeys, nulls + riinfo-&gt;nkeys);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2548" title="utils/adt/ri_triggers.c:2548">ri_ExtractValues</a>(source_rel, oldslot, riinfo, source_is_pk,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; vals, nulls);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In READ COMMITTED mode, we just need to use an up-to-date regular<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * snapshot, and we will see all rows that could be interesting. But in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction-snapshot mode, we can't change the transaction snapshot. If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the caller passes detectNewRows == false then it's okay to do the query<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with the transaction snapshot; otherwise we use a current snapshot, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tell the executor to error out if it finds <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> rows under the current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * snapshot that wouldn't be visible per the transaction snapshot.&nbsp; Note<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that <a href="../../executor/spi.c.html#L770" title="executor/spi.c:770">SPI_execute_snapshot</a> will register the snapshots, so we don't need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to bother here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsolationUsesXactSnapshot() &amp;&amp; detectNewRows)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();&nbsp; &nbsp; <span class="Comment">/* be sure all my own work is visible */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; test_snapshot = <a href="../time/snapmgr.c.html#L291" title="utils/time/snapmgr.c:291">GetLatestSnapshot</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; crosscheck_snapshot = <a href="../time/snapmgr.c.html#L216" title="utils/time/snapmgr.c:216">GetTransactionSnapshot</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the default SPI behavior is okay */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; test_snapshot = InvalidSnapshot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; crosscheck_snapshot = InvalidSnapshot;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this is a <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> query (e.g., for a 'no action' or 'restrict'<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>), we only need to see if there is a single row in the table,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * matching the key.&nbsp; Otherwise, limit = 0 - because we want the query to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * affect ALL the matching rows.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; limit = (expect_OK == SPI_OK_SELECT) ? <span class="Constant">1</span> : <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Switch to proper UID to perform check as */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../init/miscinit.c.html#L635" title="utils/init/miscinit.c:635">GetUserIdAndSecContext</a>(&amp;save_userid, &amp;save_sec_context);<br/></li>
<li>&nbsp; &nbsp; <a href="../init/miscinit.c.html#L642" title="utils/init/miscinit.c:642">SetUserIdAndSecContext</a>(RelationGetForm(query_rel)-&gt;relowner,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; save_sec_context | SECURITY_LOCAL_USERID_CHANGE |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; SECURITY_NOFORCE_RLS);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Finally we can run the query. */<br/></li>
<li></span>&nbsp; &nbsp; spi_result = <a href="../../executor/spi.c.html#L770" title="executor/spi.c:770">SPI_execute_snapshot</a>(qplan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vals, nulls,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; test_snapshot, crosscheck_snapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>, <span class="Constant">false</span>, limit);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Restore UID and security context */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../init/miscinit.c.html#L642" title="utils/init/miscinit.c:642">SetUserIdAndSecContext</a>(save_userid, save_sec_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check result */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (spi_result &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../../executor/spi.c.html#L770" title="executor/spi.c:770">SPI_execute_snapshot</a> returned </span><span class="Special">%s</span><span class="Constant">&quot;</span>, <a href="../../executor/spi.c.html#L1969" title="executor/spi.c:1969">SPI_result_code_string</a>(spi_result));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (expect_OK &gt;= <span class="Constant">0</span> &amp;&amp; spi_result != expect_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INTERNAL_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;referential integrity query on </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> from constraint </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> on </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> gave unexpected result&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(pk_rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(riinfo-&gt;conname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(fk_rel)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;This is most likely due to a rule having rewritten the query.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">XXX</span><span class="Comment"> wouldn't it be clearer to do this part at the caller? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (qkey-&gt;constr_queryno != <a href="#L72" title="utils/adt/ri_triggers.c:72">RI_PLAN_CHECK_LOOKUPPK_FROM_PK</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; expect_OK == SPI_OK_SELECT &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../executor/spi.c.html#L44" title="executor/spi.c:44">SPI_processed</a> == <span class="Constant">0</span>) == (qkey-&gt;constr_queryno == <a href="#L71" title="utils/adt/ri_triggers.c:71">RI_PLAN_CHECK_LOOKUPPK</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2577" title="utils/adt/ri_triggers.c:2577">ri_ReportViolation</a>(riinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pk_rel, fk_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; newslot ? newslot : oldslot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; qkey-&gt;constr_queryno, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../executor/spi.c.html#L44" title="executor/spi.c:44">SPI_processed</a> != <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Extract fields from a tuple into Datum/nulls arrays<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2548">&#x200c;</a></span><span class="linkable">ri_ExtractValues</span>(Relation rel, TupleTableSlot *slot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <a href="#L105" title="utils/adt/ri_triggers.c:105">RI_ConstraintInfo</a> *riinfo, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> rel_is_pk,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum *vals, <span class="Type">char</span> *nulls)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> int16 *attnums;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rel_is_pk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attnums = riinfo-&gt;pk_attnums;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; attnums = riinfo-&gt;fk_attnums;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; riinfo-&gt;nkeys; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; vals[i] = slot_getattr(slot, attnums[i], &amp;isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nulls[i] = isnull ? <span class="Constant">'n'</span> : <span class="Constant">' '</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Produce an error report<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the failed constraint was on insert/update to the FK table,<br/></li>
<li></span><span class="Comment"> * we want the key names and <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> extracted from there, and the error<br/></li>
<li></span><span class="Comment"> * message to look like 'key blah is not present in PK'.<br/></li>
<li></span><span class="Comment"> * Otherwise, the attr names and <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> come from the PK table and the<br/></li>
<li></span><span class="Comment"> * message looks like 'key blah is still referenced from FK'.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2577">&#x200c;</a></span><span class="linkable">ri_ReportViolation</span>(<span class="Type">const</span> <a href="#L105" title="utils/adt/ri_triggers.c:105">RI_ConstraintInfo</a> *riinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relation pk_rel, Relation fk_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TupleTableSlot *violatorslot, TupleDesc tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> queryno, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> partgone)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfoData key_names;<br/></li>
<li>&nbsp; &nbsp; StringInfoData key_values;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; onfk;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> int16 *attnums;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel_oid;<br/></li>
<li>&nbsp; &nbsp; AclResult&nbsp; &nbsp; aclresult;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; has_perm = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine which relation to complain about.&nbsp; If tupdesc wasn't passed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * by caller, assume the violator tuple came from there.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; onfk = (queryno == <a href="#L71" title="utils/adt/ri_triggers.c:71">RI_PLAN_CHECK_LOOKUPPK</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (onfk)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attnums = riinfo-&gt;fk_attnums;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel_oid = fk_rel-&gt;rd_id;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tupdesc == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupdesc = fk_rel-&gt;rd_att;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attnums = riinfo-&gt;pk_attnums;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel_oid = pk_rel-&gt;rd_id;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tupdesc == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupdesc = pk_rel-&gt;rd_att;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check permissions- if the user does not have access to view the data in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the key columns then we don't include the <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>() below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check if RLS is enabled on the relation first.&nbsp; If so, we don't return<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> specifics to avoid leaking data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check table-level permissions <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> and, failing that, column-level<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * privileges.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When a partition at the referenced side is being detached/dropped, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * needn't check, since the user must be the table owner anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (partgone)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; has_perm = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../misc/rls.c.html#L52" title="utils/misc/rls.c:52">check_enable_rls</a>(rel_oid, InvalidOid, <span class="Constant">true</span>) != RLS_ENABLED)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aclresult = <a href="../../catalog/aclchk.c.html#L4079" title="catalog/aclchk.c:4079">pg_class_aclcheck</a>(rel_oid, <a href="../init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>(), ACL_SELECT);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aclresult != ACLCHECK_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Try for column-level permissions */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> idx = <span class="Constant">0</span>; idx &lt; riinfo-&gt;nkeys; idx++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aclresult = <a href="../../catalog/aclchk.c.html#L3908" title="catalog/aclchk.c:3908">pg_attribute_aclcheck</a>(rel_oid, attnums[idx],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ACL_SELECT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No access to the key */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aclresult != ACLCHECK_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; has_perm = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; has_perm = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (has_perm)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get printable versions of the keys involved */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; initStringInfo(&amp;key_names);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; initStringInfo(&amp;key_values);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> idx = <span class="Constant">0</span>; idx &lt; riinfo-&gt;nkeys; idx++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fnum = attnums[idx];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att = TupleDescAttr(tupdesc, fnum - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; datum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name = NameStr(att-&gt;attname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datum = slot_getattr(violatorslot, fnum, &amp;isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foutoid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; typisvarlena;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L2907" title="utils/cache/lsyscache.c:2907">getTypeOutputInfo</a>(att-&gt;atttypid, &amp;foutoid, &amp;typisvarlena);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val = <a href="../fmgr/fmgr.c.html#L1763" title="utils/fmgr/fmgr.c:1763">OidOutputFunctionCall</a>(foutoid, datum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val = <span class="Constant">&quot;null&quot;</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (idx &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;key_names, <span class="Constant">&quot;, &quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;key_values, <span class="Constant">&quot;, &quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;key_names, name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;key_values, val);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (partgone)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FOREIGN_KEY_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;removing partition </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> violates foreign key constraint </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(pk_rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(riinfo-&gt;conname)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Key (</span><span class="Special">%s</span><span class="Constant">)=(</span><span class="Special">%s</span><span class="Constant">) is still referenced from table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; key_names.data, key_values.data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(fk_rel)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../cache/relcache.c.html#L5999" title="utils/cache/relcache.c:5999">errtableconstraint</a>(fk_rel, NameStr(riinfo-&gt;conname))));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (onfk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FOREIGN_KEY_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;insert or update on table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> violates foreign key constraint </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(fk_rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(riinfo-&gt;conname)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; has_perm ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Key (</span><span class="Special">%s</span><span class="Constant">)=(</span><span class="Special">%s</span><span class="Constant">) is not present in table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; key_names.data, key_values.data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(pk_rel)) :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Key is not present in table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(pk_rel)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../cache/relcache.c.html#L5999" title="utils/cache/relcache.c:5999">errtableconstraint</a>(fk_rel, NameStr(riinfo-&gt;conname))));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FOREIGN_KEY_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;update or delete on table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> violates foreign key constraint </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> on table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(pk_rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(riinfo-&gt;conname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(fk_rel)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; has_perm ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Key (</span><span class="Special">%s</span><span class="Constant">)=(</span><span class="Special">%s</span><span class="Constant">) is still referenced from table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; key_names.data, key_values.data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(fk_rel)) :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Key is still referenced from table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(fk_rel)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../cache/relcache.c.html#L5999" title="utils/cache/relcache.c:5999">errtableconstraint</a>(fk_rel, NameStr(riinfo-&gt;conname))));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2735" title="utils/adt/ri_triggers.c:2735">ri_NullCheck</a> -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Determine the NULL state of all key <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in a tuple<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns one of <a href="#L65" title="utils/adt/ri_triggers.c:65">RI_KEYS_ALL_NULL</a>, <a href="#L67" title="utils/adt/ri_triggers.c:67">RI_KEYS_NONE_NULL</a> or <a href="#L66" title="utils/adt/ri_triggers.c:66">RI_KEYS_SOME_NULL</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L2735">&#x200c;</a></span><span class="linkable">ri_NullCheck</span>(TupleDesc tupDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TupleTableSlot *slot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <a href="#L105" title="utils/adt/ri_triggers.c:105">RI_ConstraintInfo</a> *riinfo, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> rel_is_pk)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> int16 *attnums;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; allnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nonenull = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rel_is_pk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attnums = riinfo-&gt;pk_attnums;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; attnums = riinfo-&gt;fk_attnums;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; riinfo-&gt;nkeys; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (slot_attisnull(slot, attnums[i]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nonenull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; allnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (allnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L65" title="utils/adt/ri_triggers.c:65">RI_KEYS_ALL_NULL</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nonenull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L67" title="utils/adt/ri_triggers.c:67">RI_KEYS_NONE_NULL</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L66" title="utils/adt/ri_triggers.c:66">RI_KEYS_SOME_NULL</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2772" title="utils/adt/ri_triggers.c:2772">ri_InitHashTables</a> -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Initialize our <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> tables.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2772">&#x200c;</a></span><span class="linkable">ri_InitHashTables</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASHCTL&nbsp; &nbsp; &nbsp; &nbsp; ctl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ctl.keysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid);<br/></li>
<li>&nbsp; &nbsp; ctl.entrysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L105" title="utils/adt/ri_triggers.c:105">RI_ConstraintInfo</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L181" title="utils/adt/ri_triggers.c:181">ri_constraint_cache</a> = <a href="../hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(<span class="Constant">&quot;RI constraint cache&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L62" title="utils/adt/ri_triggers.c:62">RI_INIT_CONSTRAINTHASHSIZE</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;ctl, HASH_ELEM | HASH_BLOBS);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Arrange to flush cache on pg_constraint changes */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../cache/inval.c.html#L1516" title="utils/cache/inval.c:1516">CacheRegisterSyscacheCallback</a>(CONSTROID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2327" title="utils/adt/ri_triggers.c:2327">InvalidateConstraintCacheCallBack</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Datum) <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ctl.keysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L140" title="utils/adt/ri_triggers.c:140">RI_QueryKey</a>);<br/></li>
<li>&nbsp; &nbsp; ctl.entrysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L149" title="utils/adt/ri_triggers.c:149">RI_QueryHashEntry</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L182" title="utils/adt/ri_triggers.c:182">ri_query_cache</a> = <a href="../hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(<span class="Constant">&quot;RI query cache&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L63" title="utils/adt/ri_triggers.c:63">RI_INIT_QUERYHASHSIZE</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;ctl, HASH_ELEM | HASH_BLOBS);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ctl.keysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L160" title="utils/adt/ri_triggers.c:160">RI_CompareKey</a>);<br/></li>
<li>&nbsp; &nbsp; ctl.entrysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L169" title="utils/adt/ri_triggers.c:169">RI_CompareHashEntry</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L183" title="utils/adt/ri_triggers.c:183">ri_compare_cache</a> = <a href="../hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(<span class="Constant">&quot;RI <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> cache&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L63" title="utils/adt/ri_triggers.c:63">RI_INIT_QUERYHASHSIZE</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;ctl, HASH_ELEM | HASH_BLOBS);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2808" title="utils/adt/ri_triggers.c:2808">ri_FetchPreparedPlan</a> -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Lookup for a query key in our private <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table of prepared<br/></li>
<li></span><span class="Comment"> * and saved SPI execution plans. Return the plan if found or NULL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> SPIPlanPtr<br/></li>
<li><a id="L2808">&#x200c;</a><span class="linkable">ri_FetchPreparedPlan</span>(<a href="#L140" title="utils/adt/ri_triggers.c:140">RI_QueryKey</a> *key)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L149" title="utils/adt/ri_triggers.c:149">RI_QueryHashEntry</a> *entry;<br/></li>
<li>&nbsp; &nbsp; SPIPlanPtr&nbsp; &nbsp; plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * On the first call <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the hashtable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L182" title="utils/adt/ri_triggers.c:182">ri_query_cache</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2772" title="utils/adt/ri_triggers.c:2772">ri_InitHashTables</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Lookup for the key<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; entry = (<a href="#L149" title="utils/adt/ri_triggers.c:149">RI_QueryHashEntry</a> *) <a href="../hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L182" title="utils/adt/ri_triggers.c:182">ri_query_cache</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_FIND, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (entry == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check whether the plan is still valid.&nbsp; If it isn't, we don't want to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * simply rely on plancache.c to regenerate it; rather we should start<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from scratch and rebuild the query text too.&nbsp; This is to cover cases<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * such as table/column renames.&nbsp; We depend on the plancache machinery to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * detect possible invalidations, though.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * CAUTION: this check is only trustworthy if the caller has already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * locked both FK and PK rels.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; plan = entry-&gt;plan;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (plan &amp;&amp; <a href="../../executor/spi.c.html#L1945" title="executor/spi.c:1945">SPI_plan_is_valid</a>(plan))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Otherwise we might as well flush the cached plan <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, to free a little<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * memory space <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we make a new one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; entry-&gt;plan = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (plan)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/spi.c.html#L1022" title="executor/spi.c:1022">SPI_freeplan</a>(plan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2860" title="utils/adt/ri_triggers.c:2860">ri_HashPreparedPlan</a> -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Add another plan to our private SPI query plan hashtable.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2860">&#x200c;</a></span><span class="linkable">ri_HashPreparedPlan</span>(<a href="#L140" title="utils/adt/ri_triggers.c:140">RI_QueryKey</a> *key, SPIPlanPtr plan)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L149" title="utils/adt/ri_triggers.c:149">RI_QueryHashEntry</a> *entry;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * On the first call <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the hashtable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L182" title="utils/adt/ri_triggers.c:182">ri_query_cache</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2772" title="utils/adt/ri_triggers.c:2772">ri_InitHashTables</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Add the new plan.&nbsp; We might be overwriting an entry previously found<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * invalid by <a href="#L2808" title="utils/adt/ri_triggers.c:2808">ri_FetchPreparedPlan</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; entry = (<a href="#L149" title="utils/adt/ri_triggers.c:149">RI_QueryHashEntry</a> *) <a href="../hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L182" title="utils/adt/ri_triggers.c:182">ri_query_cache</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ENTER, &amp;found);<br/></li>
<li>&nbsp; &nbsp; Assert(!found || entry-&gt;plan == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; entry-&gt;plan = plan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2897" title="utils/adt/ri_triggers.c:2897">ri_KeysEqual</a> -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Check if all key <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in OLD and NEW are &quot;equivalent&quot;:<br/></li>
<li></span><span class="Comment"> * For normal FKs we check for equality.<br/></li>
<li></span><span class="Comment"> * For temporal FKs we check that the PK side is a superset of its old value,<br/></li>
<li></span><span class="Comment"> * or the FK side is a <a href="../../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> of its old value.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: at some point we might wish to redefine this as checking for<br/></li>
<li></span><span class="Comment"> * &quot;IS NOT DISTINCT&quot; rather than &quot;=&quot;, that is, allow two nulls to be<br/></li>
<li></span><span class="Comment"> * considered <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>.&nbsp; Currently there is no need since all callers have<br/></li>
<li></span><span class="Comment"> * previously found at least one of the rows to contain no nulls.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2897">&#x200c;</a></span><span class="linkable">ri_KeysEqual</span>(Relation rel, TupleTableSlot *oldslot, TupleTableSlot *newslot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <a href="#L105" title="utils/adt/ri_triggers.c:105">RI_ConstraintInfo</a> *riinfo, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> rel_is_pk)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> int16 *attnums;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rel_is_pk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attnums = riinfo-&gt;pk_attnums;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; attnums = riinfo-&gt;fk_attnums;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">XXX</span><span class="Comment">: could be worthwhile to fetch all necessary attrs at once */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; riinfo-&gt;nkeys; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; oldvalue;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; newvalue;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Get one attribute's oldvalue. If it is NULL - they're not <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldvalue = slot_getattr(oldslot, attnums[i], &amp;isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Get one attribute's newvalue. If it is NULL - they're not <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; newvalue = slot_getattr(newslot, attnums[i], &amp;isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel_is_pk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we are looking at the PK table, then do a bytewise<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * comparison.&nbsp; We must propagate PK changes if the value is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * changed to one that &quot;looks&quot; different but would <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> using the equality operator.&nbsp; This only makes a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * difference for ON UPDATE CASCADE, but for consistency we treat<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * all changes to the PK the same.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att = TupleDescAttr(oldslot-&gt;tts_tupleDescriptor, attnums[i] - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="datum.c.html#L266" title="utils/adt/datum.c:266">datum_image_eq</a>(oldvalue, newvalue, att-&gt;attbyval, att-&gt;attlen))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eq_opr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When comparing the PERIOD columns we can <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the check<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * whenever the referencing column stayed <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> or shrank, so test<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with the contained-by operator instead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (riinfo-&gt;hasperiod &amp;&amp; i == riinfo-&gt;nkeys - <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eq_opr = riinfo-&gt;period_contained_by_oper;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eq_opr = riinfo-&gt;ff_eq_oprs[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For the FK table, <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> with the appropriate equality<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * operator.&nbsp; Changes that <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> will still satisfy the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * constraint after the update.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L2982" title="utils/adt/ri_triggers.c:2982">ri_CompareWithCast</a>(eq_opr, <a href="#L88" title="utils/adt/ri_triggers.c:88">RIAttType</a>(rel, attnums[i]),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newvalue, oldvalue))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2982" title="utils/adt/ri_triggers.c:2982">ri_CompareWithCast</a> -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Call the appropriate comparison operator for two <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> * Normally this is equality, but for the PERIOD part of foreign keys<br/></li>
<li></span><span class="Comment"> * it is ContainedBy, so the order of lhs vs rhs is significant.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: we have already checked that neither value is null.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2982">&#x200c;</a></span><span class="linkable">ri_CompareWithCast</span>(Oid eq_opr, Oid typeid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum lhs, Datum rhs)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L169" title="utils/adt/ri_triggers.c:169">RI_CompareHashEntry</a> *entry = <a href="#L3030" title="utils/adt/ri_triggers.c:3030">ri_HashCompareOp</a>(eq_opr, typeid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Do we need to cast the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(entry-&gt;cast_func_finfo.fn_oid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lhs = FunctionCall3(&amp;entry-&gt;cast_func_finfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lhs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Int32GetDatum(-<span class="Constant">1</span>),&nbsp; &nbsp; <span class="Comment">/* typmod */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BoolGetDatum(<span class="Constant">false</span>));&nbsp; &nbsp; <span class="Comment">/* implicit coercion */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rhs = FunctionCall3(&amp;entry-&gt;cast_func_finfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rhs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Int32GetDatum(-<span class="Constant">1</span>),&nbsp; &nbsp; <span class="Comment">/* typmod */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BoolGetDatum(<span class="Constant">false</span>));&nbsp; &nbsp; <span class="Comment">/* implicit coercion */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Apply the comparison operator.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: This function is part of a call stack that determines whether an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * update to a row is significant enough that it needs checking or action<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on the other side of a foreign-key constraint.&nbsp; Therefore, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * comparison here would need to be done with the collation of the *other*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * table.&nbsp; For simplicity (e.g., we might not even have the other table<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * open), we'll just use the default collation here, which could lead to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * some false negatives.&nbsp; All this would break if we ever allow<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * database-wide collations to be nondeterministic.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * With <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>/multirangetypes, the collation of the base type is stored as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * part of the rangetype (pg_range.rngcollation), and always used, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there is no danger of inconsistency even using a non-equals operator.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * But if we support arbitrary types with PERIOD, we should perhaps just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * always force a re-check.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> DatumGetBool(<a href="../fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(&amp;entry-&gt;eq_opr_finfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DEFAULT_COLLATION_OID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lhs, rhs));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3030" title="utils/adt/ri_triggers.c:3030">ri_HashCompareOp</a> -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See if we know how to <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> two <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, and create a new <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> entry<br/></li>
<li></span><span class="Comment"> * if not.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L169" title="utils/adt/ri_triggers.c:169">RI_CompareHashEntry</a> *<br/></li>
<li><a id="L3030">&#x200c;</a><span class="linkable">ri_HashCompareOp</span>(Oid eq_opr, Oid typeid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L160" title="utils/adt/ri_triggers.c:160">RI_CompareKey</a> key;<br/></li>
<li>&nbsp; &nbsp; <a href="#L169" title="utils/adt/ri_triggers.c:169">RI_CompareHashEntry</a> *entry;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * On the first call <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the hashtable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L183" title="utils/adt/ri_triggers.c:183">ri_compare_cache</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2772" title="utils/adt/ri_triggers.c:2772">ri_InitHashTables</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Find or create a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> entry.&nbsp; Note we're assuming <a href="#L160" title="utils/adt/ri_triggers.c:160">RI_CompareKey</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * contains no struct padding.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; key.eq_opr = eq_opr;<br/></li>
<li>&nbsp; &nbsp; key.typeid = typeid;<br/></li>
<li>&nbsp; &nbsp; entry = (<a href="#L169" title="utils/adt/ri_triggers.c:169">RI_CompareHashEntry</a> *) <a href="../hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L183" title="utils/adt/ri_triggers.c:183">ri_compare_cache</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ENTER, &amp;found);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;valid = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If not already initialized, do so.&nbsp; Since we'll keep this <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> entry<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for the life of the backend, put <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> subsidiary info for the function<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cache structs into <a href="../mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!entry-&gt;valid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lefttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; righttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; castfunc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CoercionPathType pathtype;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We always need to know how to call the equality operator */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../fmgr/fmgr.c.html#L137" title="utils/fmgr/fmgr.c:137">fmgr_info_cxt</a>(<a href="../cache/lsyscache.c.html#L1285" title="utils/cache/lsyscache.c:1285">get_opcode</a>(eq_opr), &amp;entry-&gt;eq_opr_finfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we chose to use a cast from FK to PK type, we may have to apply<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the cast function to get to the operator's input type.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> eventually it would be good to support array-coercion cases<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * here and in <a href="#L2982" title="utils/adt/ri_triggers.c:2982">ri_CompareWithCast</a>().&nbsp; At the moment there is no point<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because cases involving nonidentical array types will be rejected<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * at constraint creation time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> perhaps also consider supporting CoerceViaIO?&nbsp; No need at the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * moment since that will never be generated for implicit coercions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L1358" title="utils/cache/lsyscache.c:1358">op_input_types</a>(eq_opr, &amp;lefttype, &amp;righttype);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(lefttype == righttype);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typeid == lefttype)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; castfunc = InvalidOid;&nbsp; &nbsp; <span class="Comment">/* simplest case */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathtype = <a href="../../parser/parse_coerce.c.html#L3118" title="parser/parse_coerce.c:3118">find_coercion_pathway</a>(lefttype, typeid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; COERCION_IMPLICIT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;castfunc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pathtype != COERCION_PATH_FUNC &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathtype != COERCION_PATH_RELABELTYPE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The declared input type of the eq_opr might be a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * polymorphic type such as ANYARRAY or ANYENUM, or other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * special cases such as RECORD; <a href="../../parser/parse_coerce.c.html#L3118" title="parser/parse_coerce.c:3118">find_coercion_pathway</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * currently doesn't subsume these special cases.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../parser/parse_coerce.c.html#L2995" title="parser/parse_coerce.c:2995">IsBinaryCoercible</a>(typeid, lefttype))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;no conversion function from </span><span class="Special">%s</span><span class="Constant"> to </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(typeid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(lefttype));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(castfunc))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../fmgr/fmgr.c.html#L137" title="utils/fmgr/fmgr.c:137">fmgr_info_cxt</a>(castfunc, &amp;entry-&gt;cast_func_finfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;cast_func_finfo.fn_oid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;valid = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> entry;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Given a <a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> function OID, determine whether it is an RI <a href="pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>,<br/></li>
<li></span><span class="Comment"> * and if so whether it is attached to PK or FK relation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L3123">&#x200c;</a></span><span class="linkable">RI_FKey_trigger_type</span>(Oid tgfoid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (tgfoid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> F_RI_FKEY_CASCADE_DEL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> F_RI_FKEY_CASCADE_UPD:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> F_RI_FKEY_RESTRICT_DEL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> F_RI_FKEY_RESTRICT_UPD:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> F_RI_FKEY_SETNULL_DEL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> F_RI_FKEY_SETNULL_UPD:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> F_RI_FKEY_SETDEFAULT_DEL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> F_RI_FKEY_SETDEFAULT_UPD:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> F_RI_FKEY_NOACTION_DEL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> F_RI_FKEY_NOACTION_UPD:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> RI_TRIGGER_PK;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> F_RI_FKEY_CHECK_INS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> F_RI_FKEY_CHECK_UPD:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> RI_TRIGGER_FK;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> RI_TRIGGER_NONE;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
