<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/adt/network.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/adt/network.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L52">network_sortsupport_state</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L1641">addressOK</a></li>
<li><a href="#L1569">bitncmp</a></li>
<li><a href="#L1603">bitncommon</a></li>
<li><a href="#L1240">cidr_abbrev</a></li>
<li><a href="#L129">cidr_in</a></li>
<li><a href="#L173">cidr_out</a></li>
<li><a href="#L258">cidr_recv</a></li>
<li><a href="#L300">cidr_send</a></li>
<li><a href="#L348">cidr_set_masklen</a></li>
<li><a href="#L368">cidr_set_masklen_internal</a></li>
<li><a href="#L2095">clean_ipv6_addr</a></li>
<li><a href="#L1502">convert_network_to_scalar</a></li>
<li><a href="#L880">hashinet</a></li>
<li><a href="#L890">hashinetextended</a></li>
<li><a href="#L1222">inet_abbrev</a></li>
<li><a href="#L1716">inet_client_addr</a></li>
<li><a href="#L1753">inet_client_port</a></li>
<li><a href="#L121">inet_in</a></li>
<li><a href="#L1476">inet_merge</a></li>
<li><a href="#L165">inet_out</a></li>
<li><a href="#L250">inet_recv</a></li>
<li><a href="#L1464">inet_same_family</a></li>
<li><a href="#L292">inet_send</a></li>
<li><a href="#L1788">inet_server_addr</a></li>
<li><a href="#L1825">inet_server_port</a></li>
<li><a href="#L324">inet_set_masklen</a></li>
<li><a href="#L309">inet_to_cidr</a></li>
<li><a href="#L1882">inetand</a></li>
<li><a href="#L2018">inetmi</a></li>
<li><a href="#L2008">inetmi_int8</a></li>
<li><a href="#L1857">inetnot</a></li>
<li><a href="#L1914">inetor</a></li>
<li><a href="#L1998">inetpl</a></li>
<li><a href="#L1946">internal_inetpl</a></li>
<li><a href="#L1028">match_network_function</a></li>
<li><a href="#L1076">match_network_subset</a></li>
<li><a href="#L488">network_abbrev_abort</a></li>
<li><a href="#L625">network_abbrev_convert</a></li>
<li><a href="#L1285">network_broadcast</a></li>
<li><a href="#L425">network_cmp</a></li>
<li><a href="#L405">network_cmp_internal</a></li>
<li><a href="#L814">network_eq</a></li>
<li><a href="#L1266">network_family</a></li>
<li><a href="#L473">network_fast_cmp</a></li>
<li><a href="#L823">network_ge</a></li>
<li><a href="#L832">network_gt</a></li>
<li><a href="#L1173">network_host</a></li>
<li><a href="#L1416">network_hostmask</a></li>
<li><a href="#L75">network_in</a></li>
<li><a href="#L865">network_larger</a></li>
<li><a href="#L805">network_le</a></li>
<li><a href="#L796">network_lt</a></li>
<li><a href="#L1258">network_masklen</a></li>
<li><a href="#L841">network_ne</a></li>
<li><a href="#L1374">network_netmask</a></li>
<li><a href="#L1330">network_network</a></li>
<li><a href="#L141">network_out</a></li>
<li><a href="#L963">network_overlap</a></li>
<li><a href="#L192">network_recv</a></li>
<li><a href="#L1690">network_scan_first</a></li>
<li><a href="#L1704">network_scan_last</a></li>
<li><a href="#L270">network_send</a></li>
<li><a href="#L1199">network_show</a></li>
<li><a href="#L853">network_smaller</a></li>
<li><a href="#L437">network_sortsupport</a></li>
<li><a href="#L903">network_sub</a></li>
<li><a href="#L918">network_subeq</a></li>
<li><a href="#L981">network_subset_support</a></li>
<li><a href="#L933">network_sup</a></li>
<li><a href="#L948">network_supeq</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L42">ABBREV_BITS_INET4_NETMASK_SIZE</a></li>
<li><a href="#L43">ABBREV_BITS_INET4_SUBNET</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; PostgreSQL type definitions for the INET and CIDR types.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; src/backend/utils/adt/network.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Jon Postel RIP 16 Oct 1998<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;sys/<a href="../../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a>.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;netinet/in.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;arpa/inet.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/stratnum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_opfamily.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/hashfn.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/ip.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lib/hyperloglog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/libpq-be.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/pqformat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/makefuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/nodeFuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/supportnodes.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgroids.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/guc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/inet.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/sortsupport.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * An IPv4 netmask size is a value in the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of 0 - 32, which is<br/></li>
<li></span><span class="Comment"> * represented with 6 bits in inet/cidr abbreviated keys where possible.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * An IPv4 inet/cidr abbreviated key can use up to 25 bits for subnet<br/></li>
<li></span><span class="Comment"> * component.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L42">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ABBREV_BITS_INET4_NETMASK_SIZE</span>&nbsp; &nbsp; </span><span class="Constant">6<br/></li>
<li><a id="L43">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ABBREV_BITS_INET4_SUBNET</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">25<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* sortsupport for inet/cidr */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; input_count;&nbsp; &nbsp; <span class="Comment">/* number of non-null <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> seen */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; estimating;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* true if estimating cardinality */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; hyperLogLogState abbr_card; <span class="Comment">/* cardinality estimator */<br/></li>
<li><a id="L52">&#x200c;</a></span>} <span class="linkable">network_sortsupport_state</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> int32 <a href="#L405" title="utils/adt/network.c:405">network_cmp_internal</a>(inet *<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>, inet *<a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L473" title="utils/adt/network.c:473">network_fast_cmp</a>(Datum x, Datum y, SortSupport ssup);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L488" title="utils/adt/network.c:488">network_abbrev_abort</a>(<span class="Type">int</span> memtupcount, SortSupport ssup);<br/></li>
<li><span class="Type">static</span> Datum <a href="#L625" title="utils/adt/network.c:625">network_abbrev_convert</a>(Datum original, SortSupport ssup);<br/></li>
<li><span class="Type">static</span> List *<a href="#L1028" title="utils/adt/network.c:1028">match_network_function</a>(Node *leftop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node *rightop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> indexarg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid funcid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid opfamily);<br/></li>
<li><span class="Type">static</span> List *<a href="#L1076" title="utils/adt/network.c:1076">match_network_subset</a>(Node *leftop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node *rightop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_eq,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid opfamily);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1641" title="utils/adt/network.c:1641">addressOK</a>(<span class="Type">unsigned</span> <span class="Type">char</span> *a, <span class="Type">int</span> bits, <span class="Type">int</span> family);<br/></li>
<li><span class="Type">static</span> inet *<a href="#L1946" title="utils/adt/network.c:1946">internal_inetpl</a>(inet *ip, int64 addend);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Common INET/CIDR input routine<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> inet *<br/></li>
<li><a id="L75">&#x200c;</a><span class="linkable">network_in</span>(<span class="Type">char</span> *src, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_cidr, Node *escontext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bits;<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *dst;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dst = (inet *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(inet));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First, check to see if this is an IPv6 or IPv4 address.&nbsp; IPv6 addresses<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will have a : somewhere in them (several, in fact) so if there is one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * present, assume it's V6, otherwise assume it's V4.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (strchr(src, <span class="Constant">':'</span>) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ip_family(dst) = PGSQL_AF_INET6;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ip_family(dst) = PGSQL_AF_INET;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; bits = <a href="inet_net_pton.c.html#L62" title="utils/adt/inet_net_pton.c:62">pg_inet_net_pton</a>(ip_family(dst), src, ip_addr(dst),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is_cidr ? ip_addrsize(dst) : -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((bits &lt; <span class="Constant">0</span>) || (bits &gt; ip_maxbits(dst)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: first %s is inet or cidr */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid input syntax for type </span><span class="Special">%s</span><span class="Constant">: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is_cidr ? <span class="Constant">&quot;cidr&quot;</span> : <span class="Constant">&quot;inet&quot;</span>, src)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Error check: CIDR <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> must not have <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> bits set beyond the masklen.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (is_cidr)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L1641" title="utils/adt/network.c:1641">addressOK</a>(ip_addr(dst), bits, ip_family(dst)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid cidr value: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, src),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Value has bits set to right of mask.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ip_bits(dst) = bits;<br/></li>
<li>&nbsp; &nbsp; SET_INET_VARSIZE(dst);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> dst;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L121">&#x200c;</a><span class="linkable">inet_in</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *src = PG_GETARG_CSTRING(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INET_P(<a href="#L75" title="utils/adt/network.c:75">network_in</a>(src, <span class="Constant">false</span>, fcinfo-&gt;context));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L129">&#x200c;</a><span class="linkable">cidr_in</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *src = PG_GETARG_CSTRING(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INET_P(<a href="#L75" title="utils/adt/network.c:75">network_in</a>(src, <span class="Constant">true</span>, fcinfo-&gt;context));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Common INET/CIDR output routine<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L141">&#x200c;</a><span class="linkable">network_out</span>(inet *src, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_cidr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; tmp[<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Constant">&quot;xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:255.255.255.255/128&quot;</span>)];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *dst;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dst = pg_inet_net_ntop(ip_family(src), ip_addr(src), ip_bits(src),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tmp, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(tmp));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dst == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_BINARY_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not format inet value: %m&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* For CIDR, add /n if not present */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (is_cidr &amp;&amp; strchr(tmp, <span class="Constant">'/'</span>) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len = strlen(tmp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(tmp + len, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(tmp) - len, <span class="Constant">&quot;/</span><span class="Special">%u</span><span class="Constant">&quot;</span>, ip_bits(src));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(tmp);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L165">&#x200c;</a><span class="linkable">inet_out</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *src = PG_GETARG_INET_PP(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CSTRING(<a href="#L141" title="utils/adt/network.c:141">network_out</a>(src, <span class="Constant">false</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L173">&#x200c;</a><span class="linkable">cidr_out</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *src = PG_GETARG_INET_PP(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CSTRING(<a href="#L141" title="utils/adt/network.c:141">network_out</a>(src, <span class="Constant">true</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L192" title="utils/adt/network.c:192">network_recv</a>&nbsp; &nbsp; &nbsp; &nbsp; - converts external binary format to inet<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The external representation is (one byte apiece for)<br/></li>
<li></span><span class="Comment"> * family, bits, is_cidr, address length, address in network byte order.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Presence of is_cidr is largely for historical reasons, though it might<br/></li>
<li></span><span class="Comment"> * allow some code-sharing on the client side.&nbsp; We <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> it correctly on<br/></li>
<li></span><span class="Comment"> * output, but ignore the value on input.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> inet *<br/></li>
<li><a id="L192">&#x200c;</a><span class="linkable">network_recv</span>(StringInfo buf, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_cidr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *addr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *addrptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nb,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* make sure <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> unused bits in a CIDR value are zeroed */<br/></li>
<li></span>&nbsp; &nbsp; addr = (inet *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(inet));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ip_family(addr) = <a href="../../libpq/pqformat.c.html#L399" title="libpq/pqformat.c:399">pq_getmsgbyte</a>(buf);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ip_family(addr) != PGSQL_AF_INET &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ip_family(addr) != PGSQL_AF_INET6)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_BINARY_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: %s is inet or cidr */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid address family in external </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> value&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is_cidr ? <span class="Constant">&quot;cidr&quot;</span> : <span class="Constant">&quot;inet&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; bits = <a href="../../libpq/pqformat.c.html#L399" title="libpq/pqformat.c:399">pq_getmsgbyte</a>(buf);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (bits &lt; <span class="Constant">0</span> || bits &gt; ip_maxbits(addr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_BINARY_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: %s is inet or cidr */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid bits in external </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> value&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is_cidr ? <span class="Constant">&quot;cidr&quot;</span> : <span class="Constant">&quot;inet&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; ip_bits(addr) = bits;<br/></li>
<li>&nbsp; &nbsp; i = <a href="../../libpq/pqformat.c.html#L399" title="libpq/pqformat.c:399">pq_getmsgbyte</a>(buf);&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ignore is_cidr */<br/></li>
<li></span>&nbsp; &nbsp; nb = <a href="../../libpq/pqformat.c.html#L399" title="libpq/pqformat.c:399">pq_getmsgbyte</a>(buf);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nb != ip_addrsize(addr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_BINARY_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: %s is inet or cidr */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid length in external </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> value&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is_cidr ? <span class="Constant">&quot;cidr&quot;</span> : <span class="Constant">&quot;inet&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; addrptr = (<span class="Type">char</span> *) ip_addr(addr);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nb; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; addrptr[i] = <a href="../../libpq/pqformat.c.html#L399" title="libpq/pqformat.c:399">pq_getmsgbyte</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Error check: CIDR <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> must not have <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> bits set beyond the masklen.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (is_cidr)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L1641" title="utils/adt/network.c:1641">addressOK</a>(ip_addr(addr), bits, ip_family(addr)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_BINARY_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid external </span><span class="Special">\&quot;</span><span class="Constant">cidr</span><span class="Special">\&quot;</span><span class="Constant"> value&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Value has bits set to right of mask.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_INET_VARSIZE(addr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> addr;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L250">&#x200c;</a><span class="linkable">inet_recv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; buf = (StringInfo) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INET_P(<a href="#L192" title="utils/adt/network.c:192">network_recv</a>(buf, <span class="Constant">false</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L258">&#x200c;</a><span class="linkable">cidr_recv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; buf = (StringInfo) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INET_P(<a href="#L192" title="utils/adt/network.c:192">network_recv</a>(buf, <span class="Constant">true</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L270" title="utils/adt/network.c:270">network_send</a>&nbsp; &nbsp; &nbsp; &nbsp; - converts inet to binary format<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> bytea *<br/></li>
<li><a id="L270">&#x200c;</a><span class="linkable">network_send</span>(inet *addr, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_cidr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *addrptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nb,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L326" title="libpq/pqformat.c:326">pq_begintypsend</a>(&amp;buf);<br/></li>
<li>&nbsp; &nbsp; pq_sendbyte(&amp;buf, ip_family(addr));<br/></li>
<li>&nbsp; &nbsp; pq_sendbyte(&amp;buf, ip_bits(addr));<br/></li>
<li>&nbsp; &nbsp; pq_sendbyte(&amp;buf, is_cidr);<br/></li>
<li>&nbsp; &nbsp; nb = ip_addrsize(addr);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nb &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nb = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; pq_sendbyte(&amp;buf, nb);<br/></li>
<li>&nbsp; &nbsp; addrptr = (<span class="Type">char</span> *) ip_addr(addr);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nb; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pq_sendbyte(&amp;buf, addrptr[i]);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../libpq/pqformat.c.html#L346" title="libpq/pqformat.c:346">pq_endtypsend</a>(&amp;buf);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L292">&#x200c;</a><span class="linkable">inet_send</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *addr = PG_GETARG_INET_PP(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BYTEA_P(<a href="#L270" title="utils/adt/network.c:270">network_send</a>(addr, <span class="Constant">false</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L300">&#x200c;</a><span class="linkable">cidr_send</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *addr = PG_GETARG_INET_PP(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BYTEA_P(<a href="#L270" title="utils/adt/network.c:270">network_send</a>(addr, <span class="Constant">true</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L309">&#x200c;</a><span class="linkable">inet_to_cidr</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *src = PG_GETARG_INET_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bits;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; bits = ip_bits(src);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* safety check */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((bits &lt; <span class="Constant">0</span>) || (bits &gt; ip_maxbits(src)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid inet <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> length: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, bits);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INET_P(<a href="#L368" title="utils/adt/network.c:368">cidr_set_masklen_internal</a>(src, bits));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L324">&#x200c;</a><span class="linkable">inet_set_masklen</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *src = PG_GETARG_INET_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bits = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *dst;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (bits == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bits = ip_maxbits(src);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((bits &lt; <span class="Constant">0</span>) || (bits &gt; ip_maxbits(src)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid mask length: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, bits)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* clone the original data */<br/></li>
<li></span>&nbsp; &nbsp; dst = (inet *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(VARSIZE_ANY(src));<br/></li>
<li>&nbsp; &nbsp; memcpy(dst, src, VARSIZE_ANY(src));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ip_bits(dst) = bits;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INET_P(dst);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L348">&#x200c;</a><span class="linkable">cidr_set_masklen</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *src = PG_GETARG_INET_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bits = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (bits == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bits = ip_maxbits(src);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((bits &lt; <span class="Constant">0</span>) || (bits &gt; ip_maxbits(src)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid mask length: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, bits)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INET_P(<a href="#L368" title="utils/adt/network.c:368">cidr_set_masklen_internal</a>(src, bits));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Copy src and set mask length to 'bits' (which must be valid for the family)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>inet *<br/></li>
<li><a id="L368">&#x200c;</a><span class="linkable">cidr_set_masklen_internal</span>(<span class="Type">const</span> inet *src, <span class="Type">int</span> bits)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *dst = (inet *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(inet));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ip_family(dst) = ip_family(src);<br/></li>
<li>&nbsp; &nbsp; ip_bits(dst) = bits;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (bits &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(bits &lt;= ip_maxbits(dst));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Clone appropriate bytes of the address, leaving the rest 0 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(ip_addr(dst), ip_addr(src), (bits + <span class="Constant">7</span>) / <span class="Constant">8</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Clear <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> unwanted bits in the last partial byte */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bits % <span class="Constant">8</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ip_addr(dst)[bits / <span class="Constant">8</span>] &amp;= ~(<span class="Constant">0xFF</span> &gt;&gt; (bits % <span class="Constant">8</span>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set varlena header correctly */<br/></li>
<li></span>&nbsp; &nbsp; SET_INET_VARSIZE(dst);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> dst;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Basic comparison function for sorting and inet/cidr comparisons.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Comparison is first on the common bits of the network part, then on<br/></li>
<li></span><span class="Comment"> * the length of the network part, and then on the whole unmasked address.<br/></li>
<li></span><span class="Comment"> * The effect is that the network part is the major sort key, and for<br/></li>
<li></span><span class="Comment"> * <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> network parts we sort on the host part.&nbsp; Note this is only sane<br/></li>
<li></span><span class="Comment"> * for CIDR if address bits to the right of the mask are guaranteed zero;<br/></li>
<li></span><span class="Comment"> * otherwise logically-<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> CIDRs might <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> different.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> int32<br/></li>
<li><a id="L405">&#x200c;</a><span class="linkable">network_cmp_internal</span>(inet *<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>, inet *<a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ip_family(<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>) == ip_family(<a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; order;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; order = <a href="#L1569" title="utils/adt/network.c:1569">bitncmp</a>(ip_addr(<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>), ip_addr(<a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(ip_bits(<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>), ip_bits(<a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (order != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> order;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; order = ((<span class="Type">int</span>) ip_bits(<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>)) - ((<span class="Type">int</span>) ip_bits(<a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (order != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> order;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1569" title="utils/adt/network.c:1569">bitncmp</a>(ip_addr(<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>), ip_addr(<a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>), ip_maxbits(<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ip_family(<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>) - ip_family(<a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L425">&#x200c;</a><span class="linkable">network_cmp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a> = PG_GETARG_INET_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a> = PG_GETARG_INET_PP(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(<a href="#L405" title="utils/adt/network.c:405">network_cmp_internal</a>(<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>, <a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * SortSupport strategy routine<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L437">&#x200c;</a><span class="linkable">network_sortsupport</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SortSupport ssup = (SortSupport) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ssup-&gt;comparator = <a href="#L473" title="utils/adt/network.c:473">network_fast_cmp</a>;<br/></li>
<li>&nbsp; &nbsp; ssup-&gt;ssup_extra = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ssup-&gt;abbreviate)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L52" title="utils/adt/network.c:52">network_sortsupport_state</a> *uss;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(ssup-&gt;ssup_cxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uss = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L52" title="utils/adt/network.c:52">network_sortsupport_state</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uss-&gt;input_count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uss-&gt;estimating = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../lib/hyperloglog.c.html#L66" title="lib/hyperloglog.c:66">initHyperLogLog</a>(&amp;uss-&gt;abbr_card, <span class="Constant">10</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ssup-&gt;ssup_extra = uss;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ssup-&gt;comparator = <a href="../sort/tuplesort.c.html#L3177" title="utils/sort/tuplesort.c:3177">ssup_datum_unsigned_cmp</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ssup-&gt;abbrev_converter = <a href="#L625" title="utils/adt/network.c:625">network_abbrev_convert</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ssup-&gt;abbrev_abort = <a href="#L488" title="utils/adt/network.c:488">network_abbrev_abort</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ssup-&gt;abbrev_full_comparator = <a href="#L473" title="utils/adt/network.c:473">network_fast_cmp</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VOID();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * SortSupport comparison func<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L473">&#x200c;</a></span><span class="linkable">network_fast_cmp</span>(Datum x, Datum y, SortSupport ssup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *arg1 = DatumGetInetPP(x);<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *arg2 = DatumGetInetPP(y);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L405" title="utils/adt/network.c:405">network_cmp_internal</a>(arg1, arg2);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Callback for estimating effectiveness of abbreviated key optimization.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We pay no attention to the cardinality of the non-abbreviated data, because<br/></li>
<li></span><span class="Comment"> * there is no equality fast-path within authoritative inet comparator.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L488">&#x200c;</a></span><span class="linkable">network_abbrev_abort</span>(<span class="Type">int</span> memtupcount, SortSupport ssup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L52" title="utils/adt/network.c:52">network_sortsupport_state</a> *uss = ssup-&gt;ssup_extra;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; abbr_card;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (memtupcount &lt; <span class="Constant">10000</span> || uss-&gt;input_count &lt; <span class="Constant">10000</span> || !uss-&gt;estimating)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; abbr_card = <a href="../../lib/hyperloglog.c.html#L186" title="lib/hyperloglog.c:186">estimateHyperLogLog</a>(&amp;uss-&gt;abbr_card);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we have &gt;100k distinct <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, then even if we were sorting many<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * billion rows we'd likely still break even, and the penalty of undoing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that many rows of abbrevs would probably not be worth it. At this point<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we stop counting because we know that we're <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> fully committed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (abbr_card &gt; <span class="Constant">100000.0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li><span class="PreProc">#ifdef TRACE_SORT<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../sort/tuplesort.c.html#L124" title="utils/sort/tuplesort.c:124">trace_sort</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;network_abbrev: estimation ends at cardinality </span><span class="Special">%f</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot; after &quot;</span> INT64_FORMAT <span class="Constant">&quot; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> (</span><span class="Special">%d</span><span class="Constant"> rows)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; abbr_card, uss-&gt;input_count, memtupcount);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; uss-&gt;estimating = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Target minimum cardinality is 1 per ~2k of non-null inputs. 0.5 row<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fudge factor allows us to abort earlier on genuinely pathological data<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * where we've had exactly one abbreviated value in the first 2k<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (non-null) rows.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (abbr_card &lt; uss-&gt;input_count / <span class="Constant">2000.0</span> + <span class="Constant">0.5</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li><span class="PreProc">#ifdef TRACE_SORT<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../sort/tuplesort.c.html#L124" title="utils/sort/tuplesort.c:124">trace_sort</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;network_abbrev: aborting abbreviation at cardinality </span><span class="Special">%f</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot; below threshold </span><span class="Special">%f</span><span class="Constant"> after &quot;</span> INT64_FORMAT <span class="Constant">&quot; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> (</span><span class="Special">%d</span><span class="Constant"> rows)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; abbr_card, uss-&gt;input_count / <span class="Constant">2000.0</span> + <span class="Constant">0.5</span>, uss-&gt;input_count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; memtupcount);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef TRACE_SORT<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../sort/tuplesort.c.html#L124" title="utils/sort/tuplesort.c:124">trace_sort</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;network_abbrev: cardinality </span><span class="Special">%f</span><span class="Constant"> after &quot;</span> INT64_FORMAT<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> (</span><span class="Special">%d</span><span class="Constant"> rows)&quot;</span>, abbr_card, uss-&gt;input_count, memtupcount);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * SortSupport conversion routine. Converts original inet/cidr representation<br/></li>
<li></span><span class="Comment"> * to abbreviated key representation that works with simple 3-way unsigned int<br/></li>
<li></span><span class="Comment"> * comparisons. The <a href="#L405" title="utils/adt/network.c:405">network_cmp_internal</a>() rules for sorting inet/cidr datums<br/></li>
<li></span><span class="Comment"> * are followed by abbreviated comparisons by an encoding scheme that<br/></li>
<li></span><span class="Comment"> * conditions keys through careful use of padding.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Some background: inet <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> have three major components (take for example<br/></li>
<li></span><span class="Comment"> * the address 1.2.3.4/24):<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; * A network, or netmasked bits (1.2.3.0).<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; * A netmask size (/24).<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; * A subnet, or bits outside of the netmask (0.0.0.4).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * cidr <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are the same except that with only the first two components --<br/></li>
<li></span><span class="Comment"> * all their subnet bits *must* be zero (1.2.3.0/24).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IPv4 and IPv6 are identical in this makeup, with the difference being that<br/></li>
<li></span><span class="Comment"> * IPv4 addresses have a maximum of 32 bits compared to IPv6's 64 bits, so in<br/></li>
<li></span><span class="Comment"> * IPv6 each part may be larger.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * inet/cidr types <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> using these sorting rules. If inequality is detected<br/></li>
<li></span><span class="Comment"> * at <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> step, comparison is finished. If <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> rule is a tie, the algorithm<br/></li>
<li></span><span class="Comment"> * drops through to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> to break it:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; 1. IPv4 always appears <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> IPv6.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; 2. Network bits are compared.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; 3. Netmask size is compared.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; 4. All bits are compared (having made it here, we know that both<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; netmasked bits and netmask size are <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>, so we're in effect only<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; comparing subnet bits).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When generating abbreviated keys for SortSupport, we pack as much as we can<br/></li>
<li></span><span class="Comment"> * into a datum while ensuring that when comparing those keys as integers,<br/></li>
<li></span><span class="Comment"> * these rules will be respected. Exact contents depend on IP family and datum<br/></li>
<li></span><span class="Comment"> * size.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IPv4<br/></li>
<li></span><span class="Comment"> * ----<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 4 byte datums:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Start with 1 <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> for the IP family (IPv4 or IPv6; this <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> is present in<br/></li>
<li></span><span class="Comment"> * every case below) followed by all but 1 of the netmasked bits.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * +----------+---------------------+<br/></li>
<li></span><span class="Comment"> * | 1 <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> IP |&nbsp;&nbsp; 31 bits network&nbsp;&nbsp; |&nbsp; &nbsp;&nbsp; (1 <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> network<br/></li>
<li></span><span class="Comment"> * |&nbsp; family&nbsp; |&nbsp; &nbsp;&nbsp; (truncated)&nbsp; &nbsp;&nbsp; |&nbsp; &nbsp; &nbsp; omitted)<br/></li>
<li></span><span class="Comment"> * +----------+---------------------+<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 8 byte datums:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We have space to store all netmasked bits, followed by the netmask size,<br/></li>
<li></span><span class="Comment"> * followed by 25 bits of the subnet (25 bits is usually more than enough in<br/></li>
<li></span><span class="Comment"> * practice). cidr datums always have all-zero subnet bits.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * +----------+-----------------------+--------------+--------------------+<br/></li>
<li></span><span class="Comment"> * | 1 <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> IP |&nbsp; &nbsp; 32 bits network&nbsp; &nbsp; |&nbsp; &nbsp; 6 bits&nbsp; &nbsp; |&nbsp;&nbsp; 25 bits subnet&nbsp;&nbsp; |<br/></li>
<li></span><span class="Comment"> * |&nbsp; family&nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; (full)&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; | network size |&nbsp; &nbsp; (truncated)&nbsp; &nbsp;&nbsp; |<br/></li>
<li></span><span class="Comment"> * +----------+-----------------------+--------------+--------------------+<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IPv6<br/></li>
<li></span><span class="Comment"> * ----<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 4 byte datums:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * +----------+---------------------+<br/></li>
<li></span><span class="Comment"> * | 1 <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> IP |&nbsp;&nbsp; 31 bits network&nbsp;&nbsp; |&nbsp; &nbsp; (up to 97 bits<br/></li>
<li></span><span class="Comment"> * |&nbsp; family&nbsp; |&nbsp; &nbsp;&nbsp; (truncated)&nbsp; &nbsp;&nbsp; |&nbsp;&nbsp; network omitted)<br/></li>
<li></span><span class="Comment"> * +----------+---------------------+<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 8 byte datums:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * +----------+---------------------------------+<br/></li>
<li></span><span class="Comment"> * | 1 <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> IP |&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 63 bits network&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; |&nbsp; &nbsp; (up to 65 bits<br/></li>
<li></span><span class="Comment"> * |&nbsp; family&nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (truncated)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; |&nbsp;&nbsp; network omitted)<br/></li>
<li></span><span class="Comment"> * +----------+---------------------------------+<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Datum<br/></li>
<li><a id="L625">&#x200c;</a><span class="linkable">network_abbrev_convert</span>(Datum original, SortSupport ssup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L52" title="utils/adt/network.c:52">network_sortsupport_state</a> *uss = ssup-&gt;ssup_extra;<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *authoritative = DatumGetInetPP(original);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; res,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ipaddr_datum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subnet_bitmask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; network;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subnet_size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(ip_family(authoritative) == PGSQL_AF_INET ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ip_family(authoritative) == PGSQL_AF_INET6);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get an unsigned integer representation of the IP address by taking its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * first 4 or 8 bytes. Always take all 4 bytes of an IPv4 address. Take<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the first 8 bytes of an IPv6 address with an 8 byte datum and 4 bytes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * otherwise.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We're consuming an array of unsigned char, so byteswap on little endian<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * systems (an inet's ipaddr field stores the most significant byte<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * first).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ip_family(authoritative) == PGSQL_AF_INET)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; ipaddr_datum32;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;ipaddr_datum32, ip_addr(authoritative), <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must byteswap on little-endian machines */<br/></li>
<li></span><span class="PreProc">#ifndef WORDS_BIGENDIAN<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ipaddr_datum = pg_bswap32(ipaddr_datum32);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ipaddr_datum = ipaddr_datum32;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Initialize result without setting ipfamily <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; res = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;ipaddr_datum, ip_addr(authoritative), <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must byteswap on little-endian machines */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ipaddr_datum = DatumBigEndianToNative(ipaddr_datum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Initialize result with ipfamily (most significant) <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> set */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; res = ((Datum) <span class="Constant">1</span>) &lt;&lt; (SIZEOF_DATUM * BITS_PER_BYTE - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ipaddr_datum must be &quot;split&quot;: high order bits go in &quot;network&quot; component<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of abbreviated key (often with zeroed bits at the end due to masking),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * while low order bits go in &quot;subnet&quot; component when there is space for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * one. This is often accomplished by generating a temp datum subnet<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bitmask, which we may reuse later when generating the subnet bits<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * themselves.&nbsp; (Note that subnet bits are only used with IPv4 datums on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * platforms where datum is 8 bytes.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The number of bits in subnet is used to generate a datum subnet<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bitmask. For example, with a /24 IPv4 datum there are 8 subnet bits<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (since 32 - 24 is 8), so the final subnet bitmask is B'1111 1111'. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need explicit handling for cases where the ipaddr bits cannot all fit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in a datum, though (otherwise we'd incorrectly mask the network<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * component with IPv6 <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; subnet_size = ip_maxbits(authoritative) - ip_bits(authoritative);<br/></li>
<li>&nbsp; &nbsp; Assert(subnet_size &gt;= <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* subnet size must work with prefix ipaddr cases */<br/></li>
<li></span>&nbsp; &nbsp; subnet_size %= SIZEOF_DATUM * BITS_PER_BYTE;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ip_bits(authoritative) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fit as many ipaddr bits as possible into subnet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; subnet_bitmask = ((Datum) <span class="Constant">0</span>) - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; network = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (ip_bits(authoritative) &lt; SIZEOF_DATUM * BITS_PER_BYTE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Split ipaddr bits between network and subnet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; subnet_bitmask = (((Datum) <span class="Constant">1</span>) &lt;&lt; subnet_size) - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; network = ipaddr_datum &amp; ~subnet_bitmask;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fit as many ipaddr bits as possible into network */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; subnet_bitmask = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; network = ipaddr_datum;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="PreProc">#if SIZEOF_DATUM == </span><span class="Constant">8<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ip_family(authoritative) == PGSQL_AF_INET)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * IPv4 with 8 byte datums: keep all 32 netmasked bits, netmask size,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and most significant 25 subnet bits<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; netmask_size = (Datum) ip_bits(authoritative);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; subnet;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Shift left 31 bits: 6 bits netmask size + 25 subnet bits.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't make <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> distinction between network bits that are zero<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * due to masking and &quot;true&quot;/non-masked zero bits.&nbsp; An abbreviated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * comparison that is resolved by comparing a non-masked and non-zero<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> to a masked/zeroed <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> is effectively resolved based on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ip_bits(), even though the comparison won't reach the netmask_size<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * bits.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; network &lt;&lt;= (<a href="#L42" title="utils/adt/network.c:42">ABBREV_BITS_INET4_NETMASK_SIZE</a> +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L43" title="utils/adt/network.c:43">ABBREV_BITS_INET4_SUBNET</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Shift size to make room for subnet bits at the end */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; netmask_size &lt;&lt;= <a href="#L43" title="utils/adt/network.c:43">ABBREV_BITS_INET4_SUBNET</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Extract subnet bits without shifting them */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; subnet = ipaddr_datum &amp; subnet_bitmask;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we have more than 25 subnet bits, we can't fit everything. Shift<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * subnet down to avoid clobbering bits that are only supposed to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * used for netmask_size.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Discarding the least significant subnet bits like this is correct<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because abbreviated comparisons that are resolved at the subnet<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * level must have had <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> netmask_size/ip_bits() <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in order to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * get that far.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subnet_size &gt; <a href="#L43" title="utils/adt/network.c:43">ABBREV_BITS_INET4_SUBNET</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subnet &gt;&gt;= subnet_size - <a href="#L43" title="utils/adt/network.c:43">ABBREV_BITS_INET4_SUBNET</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Assemble the final abbreviated key without clobbering the ipfamily<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> that must remain a zero.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; res |= network | netmask_size | subnet;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * 4 byte datums, or IPv6 with 8 byte datums: Use as many of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * netmasked bits as will fit in final abbreviated key. Avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * clobbering the ipfamily <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> that was set earlier.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; res |= network &gt;&gt; <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; uss-&gt;input_count += <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Hash abbreviated key */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (uss-&gt;estimating)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; tmp;<br/></li>
<li><br/></li>
<li><span class="PreProc">#if SIZEOF_DATUM == </span><span class="Constant">8<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tmp = (uint32) res ^ (uint32) ((uint64) res &gt;&gt; <span class="Constant">32</span>);<br/></li>
<li><span class="PreProc">#else</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* SIZEOF_DATUM != 8 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tmp = (uint32) res;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../lib/hyperloglog.c.html#L167" title="lib/hyperloglog.c:167">addHyperLogLog</a>(&amp;uss-&gt;abbr_card, DatumGetUInt32(hash_uint32(tmp)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Boolean ordering tests.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L796">&#x200c;</a><span class="linkable">network_lt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a> = PG_GETARG_INET_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a> = PG_GETARG_INET_PP(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L405" title="utils/adt/network.c:405">network_cmp_internal</a>(<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>, <a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>) &lt; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L805">&#x200c;</a><span class="linkable">network_le</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a> = PG_GETARG_INET_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a> = PG_GETARG_INET_PP(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L405" title="utils/adt/network.c:405">network_cmp_internal</a>(<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>, <a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>) &lt;= <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L814">&#x200c;</a><span class="linkable">network_eq</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a> = PG_GETARG_INET_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a> = PG_GETARG_INET_PP(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L405" title="utils/adt/network.c:405">network_cmp_internal</a>(<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>, <a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>) == <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L823">&#x200c;</a><span class="linkable">network_ge</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a> = PG_GETARG_INET_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a> = PG_GETARG_INET_PP(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L405" title="utils/adt/network.c:405">network_cmp_internal</a>(<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>, <a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>) &gt;= <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L832">&#x200c;</a><span class="linkable">network_gt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a> = PG_GETARG_INET_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a> = PG_GETARG_INET_PP(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L405" title="utils/adt/network.c:405">network_cmp_internal</a>(<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>, <a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>) &gt; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L841">&#x200c;</a><span class="linkable">network_ne</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a> = PG_GETARG_INET_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a> = PG_GETARG_INET_PP(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L405" title="utils/adt/network.c:405">network_cmp_internal</a>(<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>, <a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>) != <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * MIN/MAX support <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L853">&#x200c;</a><span class="linkable">network_smaller</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a> = PG_GETARG_INET_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a> = PG_GETARG_INET_PP(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L405" title="utils/adt/network.c:405">network_cmp_internal</a>(<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>, <a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_INET_P(<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_INET_P(<a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L865">&#x200c;</a><span class="linkable">network_larger</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a> = PG_GETARG_INET_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a> = PG_GETARG_INET_PP(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L405" title="utils/adt/network.c:405">network_cmp_internal</a>(<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>, <a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>) &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_INET_P(<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_INET_P(<a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Support function for <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> indexes on inet/cidr.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L880">&#x200c;</a><span class="linkable">hashinet</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *addr = PG_GETARG_INET_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addrsize = ip_addrsize(addr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">XXX</span><span class="Comment"> this assumes there are no pad bytes in the data structure */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> hash_any((<span class="Type">unsigned</span> <span class="Type">char</span> *) VARDATA_ANY(addr), addrsize + <span class="Constant">2</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L890">&#x200c;</a><span class="linkable">hashinetextended</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *addr = PG_GETARG_INET_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addrsize = ip_addrsize(addr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> hash_any_extended((<span class="Type">unsigned</span> <span class="Type">char</span> *) VARDATA_ANY(addr), addrsize + <span class="Constant">2</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PG_GETARG_INT64(<span class="Constant">1</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Boolean network-inclusion tests.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L903">&#x200c;</a><span class="linkable">network_sub</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a> = PG_GETARG_INET_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a> = PG_GETARG_INET_PP(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ip_family(<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>) == ip_family(<a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(ip_bits(<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>) &gt; ip_bits(<a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L1569" title="utils/adt/network.c:1569">bitncmp</a>(ip_addr(<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>), ip_addr(<a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>), ip_bits(<a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>)) == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L918">&#x200c;</a><span class="linkable">network_subeq</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a> = PG_GETARG_INET_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a> = PG_GETARG_INET_PP(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ip_family(<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>) == ip_family(<a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(ip_bits(<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>) &gt;= ip_bits(<a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L1569" title="utils/adt/network.c:1569">bitncmp</a>(ip_addr(<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>), ip_addr(<a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>), ip_bits(<a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>)) == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L933">&#x200c;</a><span class="linkable">network_sup</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a> = PG_GETARG_INET_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a> = PG_GETARG_INET_PP(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ip_family(<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>) == ip_family(<a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(ip_bits(<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>) &lt; ip_bits(<a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L1569" title="utils/adt/network.c:1569">bitncmp</a>(ip_addr(<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>), ip_addr(<a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>), ip_bits(<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>)) == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L948">&#x200c;</a><span class="linkable">network_supeq</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a> = PG_GETARG_INET_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a> = PG_GETARG_INET_PP(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ip_family(<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>) == ip_family(<a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(ip_bits(<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>) &lt;= ip_bits(<a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L1569" title="utils/adt/network.c:1569">bitncmp</a>(ip_addr(<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>), ip_addr(<a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>), ip_bits(<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>)) == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L963">&#x200c;</a><span class="linkable">network_overlap</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a> = PG_GETARG_INET_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a> = PG_GETARG_INET_PP(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ip_family(<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>) == ip_family(<a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L1569" title="utils/adt/network.c:1569">bitncmp</a>(ip_addr(<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>), ip_addr(<a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(ip_bits(<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>), ip_bits(<a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>))) == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Planner support function for network <a href="../../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a>/superset operators<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L981">&#x200c;</a><span class="linkable">network_subset_support</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *rawreq = (Node *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *ret = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(rawreq, SupportRequestIndexCondition))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Try to convert operator/function call to index conditions */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; SupportRequestIndexCondition *req = (SupportRequestIndexCondition *) rawreq;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (is_opclause(req-&gt;node))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OpExpr&nbsp; &nbsp; &nbsp;&nbsp; *clause = (OpExpr *) req-&gt;node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(list_length(clause-&gt;args) == <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret = (Node *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1028" title="utils/adt/network.c:1028">match_network_function</a>((Node *) linitial(clause-&gt;args),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Node *) lsecond(clause-&gt;args),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; req-&gt;indexarg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; req-&gt;funcid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; req-&gt;opfamily);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (is_funcclause(req-&gt;node))&nbsp; &nbsp; <span class="Comment">/* be paranoid */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FuncExpr&nbsp;&nbsp; *clause = (FuncExpr *) req-&gt;node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(list_length(clause-&gt;args) == <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret = (Node *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1028" title="utils/adt/network.c:1028">match_network_function</a>((Node *) linitial(clause-&gt;args),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Node *) lsecond(clause-&gt;args),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; req-&gt;indexarg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; req-&gt;funcid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; req-&gt;opfamily);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(ret);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1028" title="utils/adt/network.c:1028">match_network_function</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Try to generate an indexqual for a network <a href="../../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a>/superset function.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This layer is just concerned with identifying the function and swapping<br/></li>
<li></span><span class="Comment"> * the arguments if necessary.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L1028">&#x200c;</a><span class="linkable">match_network_function</span>(Node *leftop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Node *rightop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> indexarg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid funcid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid opfamily)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (funcid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> F_NETWORK_SUB:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* indexkey must be on the left */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (indexarg != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1076" title="utils/adt/network.c:1076">match_network_subset</a>(leftop, rightop, <span class="Constant">false</span>, opfamily);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> F_NETWORK_SUBEQ:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* indexkey must be on the left */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (indexarg != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1076" title="utils/adt/network.c:1076">match_network_subset</a>(leftop, rightop, <span class="Constant">true</span>, opfamily);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> F_NETWORK_SUP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* indexkey must be on the right */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (indexarg != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1076" title="utils/adt/network.c:1076">match_network_subset</a>(rightop, leftop, <span class="Constant">false</span>, opfamily);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> F_NETWORK_SUPEQ:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* indexkey must be on the right */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (indexarg != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1076" title="utils/adt/network.c:1076">match_network_subset</a>(rightop, leftop, <span class="Constant">true</span>, opfamily);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We'd only get here if somebody attached this support function<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to an unexpected function.&nbsp; Maybe we should complain, but for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, do nothing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1076" title="utils/adt/network.c:1076">match_network_subset</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Try to generate an indexqual for a network <a href="../../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> function.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L1076">&#x200c;</a><span class="linkable">match_network_subset</span>(Node *leftop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Node *rightop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_eq,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid opfamily)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; rightopval;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datatype = INETOID;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opr1oid;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opr2oid;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; opr1right;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; opr2right;<br/></li>
<li>&nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *expr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Can't do anything with a non-constant or NULL comparison value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that since we restrict ourselves to cases with a hard constant on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the RHS, it's a-fortiori a pseudoconstant, and we don't need to worry<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * about verifying that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!IsA(rightop, Const) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ((Const *) rightop)-&gt;constisnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;<br/></li>
<li>&nbsp; &nbsp; rightopval = ((Const *) rightop)-&gt;constvalue;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Must check that index's opfamily supports the operators we will want to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * apply.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We insist on the opfamily being the specific one we expect, else we'd<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * do the wrong thing if someone were to make a reverse-sort opfamily with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the same operators.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (opfamily != NETWORK_BTREE_FAM_OID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * create clause &quot;key &gt;= <a href="#L1690" title="utils/adt/network.c:1690">network_scan_first</a>( rightopval )&quot;, or &quot;&gt;&quot; if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operator disallows equality.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: seeing that this function supports only fixed <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for opfamily<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and datatype, we could just hard-wire the operator OIDs instead of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * looking them up.&nbsp; But for <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> it seems better to be general.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (is_eq)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; opr1oid = <a href="../cache/lsyscache.c.html#L166" title="utils/cache/lsyscache.c:166">get_opfamily_member</a>(opfamily, datatype, datatype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTGreaterEqualStrategyNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (opr1oid == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;no &gt;= operator for opfamily </span><span class="Special">%u</span><span class="Constant">&quot;</span>, opfamily);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; opr1oid = <a href="../cache/lsyscache.c.html#L166" title="utils/cache/lsyscache.c:166">get_opfamily_member</a>(opfamily, datatype, datatype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTGreaterStrategyNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (opr1oid == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;no &gt; operator for opfamily </span><span class="Special">%u</span><span class="Constant">&quot;</span>, opfamily);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; opr1right = <a href="#L1690" title="utils/adt/network.c:1690">network_scan_first</a>(rightopval);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; expr = <a href="../../nodes/makefuncs.c.html#L628" title="nodes/makefuncs.c:628">make_opclause</a>(opr1oid, BOOLOID, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Expr *) leftop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Expr *) <a href="../../nodes/makefuncs.c.html#L301" title="nodes/makefuncs.c:301">makeConst</a>(datatype, -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidOid, <span class="Comment">/* not collatable */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -<span class="Constant">1</span>, opr1right,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>, <span class="Constant">false</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid, InvalidOid);<br/></li>
<li>&nbsp; &nbsp; result = list_make1(expr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* create clause &quot;key &lt;= <a href="#L1704" title="utils/adt/network.c:1704">network_scan_last</a>( rightopval )&quot; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; opr2oid = <a href="../cache/lsyscache.c.html#L166" title="utils/cache/lsyscache.c:166">get_opfamily_member</a>(opfamily, datatype, datatype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTLessEqualStrategyNumber);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (opr2oid == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;no &lt;= operator for opfamily </span><span class="Special">%u</span><span class="Constant">&quot;</span>, opfamily);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; opr2right = <a href="#L1704" title="utils/adt/network.c:1704">network_scan_last</a>(rightopval);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; expr = <a href="../../nodes/makefuncs.c.html#L628" title="nodes/makefuncs.c:628">make_opclause</a>(opr2oid, BOOLOID, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Expr *) leftop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Expr *) <a href="../../nodes/makefuncs.c.html#L301" title="nodes/makefuncs.c:301">makeConst</a>(datatype, -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidOid, <span class="Comment">/* not collatable */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -<span class="Constant">1</span>, opr2right,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>, <span class="Constant">false</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid, InvalidOid);<br/></li>
<li>&nbsp; &nbsp; result = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(result, expr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Extract data from a network datatype.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1173">&#x200c;</a><span class="linkable">network_host</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *ip = PG_GETARG_INET_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; tmp[<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Constant">&quot;xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:255.255.255.255/128&quot;</span>)];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* force display of max bits, regardless of masklen... */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pg_inet_net_ntop(ip_family(ip), ip_addr(ip), ip_maxbits(ip),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tmp, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(tmp)) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_BINARY_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not format inet value: %m&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Suppress /n if present (shouldn't happen <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((ptr = strchr(tmp, <span class="Constant">'/'</span>)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *ptr = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(<a href="varlena.c.html#L184" title="utils/adt/varlena.c:184">cstring_to_text</a>(tmp));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1199" title="utils/adt/network.c:1199">network_show</a> implements the inet and cidr casts to text.&nbsp; This is not<br/></li>
<li></span><span class="Comment"> * quite the same behavior as <a href="#L141" title="utils/adt/network.c:141">network_out</a>, hence we can't drop it in favor<br/></li>
<li></span><span class="Comment"> * of CoerceViaIO.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1199">&#x200c;</a><span class="linkable">network_show</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *ip = PG_GETARG_INET_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; tmp[<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Constant">&quot;xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:255.255.255.255/128&quot;</span>)];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pg_inet_net_ntop(ip_family(ip), ip_addr(ip), ip_maxbits(ip),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tmp, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(tmp)) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_BINARY_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not format inet value: %m&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Add /n if not present (which it won't be) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (strchr(tmp, <span class="Constant">'/'</span>) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len = strlen(tmp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(tmp + len, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(tmp) - len, <span class="Constant">&quot;/</span><span class="Special">%u</span><span class="Constant">&quot;</span>, ip_bits(ip));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(<a href="varlena.c.html#L184" title="utils/adt/varlena.c:184">cstring_to_text</a>(tmp));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1222">&#x200c;</a><span class="linkable">inet_abbrev</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *ip = PG_GETARG_INET_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *dst;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; tmp[<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Constant">&quot;xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:255.255.255.255/128&quot;</span>)];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dst = pg_inet_net_ntop(ip_family(ip), ip_addr(ip),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ip_bits(ip), tmp, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(tmp));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dst == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_BINARY_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not format inet value: %m&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(<a href="varlena.c.html#L184" title="utils/adt/varlena.c:184">cstring_to_text</a>(tmp));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1240">&#x200c;</a><span class="linkable">cidr_abbrev</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *ip = PG_GETARG_INET_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *dst;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; tmp[<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Constant">&quot;xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:255.255.255.255/128&quot;</span>)];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dst = <a href="inet_cidr_ntop.c.html#L56" title="utils/adt/inet_cidr_ntop.c:56">pg_inet_cidr_ntop</a>(ip_family(ip), ip_addr(ip),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ip_bits(ip), tmp, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(tmp));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dst == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_BINARY_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not format cidr value: %m&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(<a href="varlena.c.html#L184" title="utils/adt/varlena.c:184">cstring_to_text</a>(tmp));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1258">&#x200c;</a><span class="linkable">network_masklen</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *ip = PG_GETARG_INET_PP(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(ip_bits(ip));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1266">&#x200c;</a><span class="linkable">network_family</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *ip = PG_GETARG_INET_PP(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (ip_family(ip))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PGSQL_AF_INET:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_INT32(<span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PGSQL_AF_INET6:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_INT32(<span class="Constant">6</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_INT32(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1285">&#x200c;</a><span class="linkable">network_broadcast</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *ip = PG_GETARG_INET_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *dst;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; byte;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxbytes;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> mask;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> *a,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *b;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* make sure <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> unused bits are zeroed */<br/></li>
<li></span>&nbsp; &nbsp; dst = (inet *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(inet));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; maxbytes = ip_addrsize(ip);<br/></li>
<li>&nbsp; &nbsp; bits = ip_bits(ip);<br/></li>
<li>&nbsp; &nbsp; a = ip_addr(ip);<br/></li>
<li>&nbsp; &nbsp; b = ip_addr(dst);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (byte = <span class="Constant">0</span>; byte &lt; maxbytes; byte++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bits &gt;= <span class="Constant">8</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mask = <span class="Constant">0x00</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bits -= <span class="Constant">8</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (bits == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mask = <span class="Constant">0xff</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mask = <span class="Constant">0xff</span> &gt;&gt; bits;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bits = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; b[byte] = a[byte] | mask;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ip_family(dst) = ip_family(ip);<br/></li>
<li>&nbsp; &nbsp; ip_bits(dst) = ip_bits(ip);<br/></li>
<li>&nbsp; &nbsp; SET_INET_VARSIZE(dst);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INET_P(dst);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1330">&#x200c;</a><span class="linkable">network_network</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *ip = PG_GETARG_INET_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *dst;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; byte;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> mask;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> *a,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *b;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* make sure <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> unused bits are zeroed */<br/></li>
<li></span>&nbsp; &nbsp; dst = (inet *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(inet));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; bits = ip_bits(ip);<br/></li>
<li>&nbsp; &nbsp; a = ip_addr(ip);<br/></li>
<li>&nbsp; &nbsp; b = ip_addr(dst);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; byte = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (bits)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bits &gt;= <span class="Constant">8</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mask = <span class="Constant">0xff</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bits -= <span class="Constant">8</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mask = <span class="Constant">0xff</span> &lt;&lt; (<span class="Constant">8</span> - bits);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bits = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; b[byte] = a[byte] &amp; mask;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; byte++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ip_family(dst) = ip_family(ip);<br/></li>
<li>&nbsp; &nbsp; ip_bits(dst) = ip_bits(ip);<br/></li>
<li>&nbsp; &nbsp; SET_INET_VARSIZE(dst);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INET_P(dst);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1374">&#x200c;</a><span class="linkable">network_netmask</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *ip = PG_GETARG_INET_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *dst;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; byte;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> mask;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> *b;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* make sure <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> unused bits are zeroed */<br/></li>
<li></span>&nbsp; &nbsp; dst = (inet *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(inet));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; bits = ip_bits(ip);<br/></li>
<li>&nbsp; &nbsp; b = ip_addr(dst);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; byte = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (bits)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bits &gt;= <span class="Constant">8</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mask = <span class="Constant">0xff</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bits -= <span class="Constant">8</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mask = <span class="Constant">0xff</span> &lt;&lt; (<span class="Constant">8</span> - bits);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bits = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; b[byte] = mask;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; byte++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ip_family(dst) = ip_family(ip);<br/></li>
<li>&nbsp; &nbsp; ip_bits(dst) = ip_maxbits(ip);<br/></li>
<li>&nbsp; &nbsp; SET_INET_VARSIZE(dst);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INET_P(dst);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1416">&#x200c;</a><span class="linkable">network_hostmask</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *ip = PG_GETARG_INET_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *dst;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; byte;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxbytes;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> mask;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> *b;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* make sure <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> unused bits are zeroed */<br/></li>
<li></span>&nbsp; &nbsp; dst = (inet *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(inet));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; maxbytes = ip_addrsize(ip);<br/></li>
<li>&nbsp; &nbsp; bits = ip_maxbits(ip) - ip_bits(ip);<br/></li>
<li>&nbsp; &nbsp; b = ip_addr(dst);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; byte = maxbytes - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (bits)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bits &gt;= <span class="Constant">8</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mask = <span class="Constant">0xff</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bits -= <span class="Constant">8</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mask = <span class="Constant">0xff</span> &gt;&gt; (<span class="Constant">8</span> - bits);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bits = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; b[byte] = mask;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; byte--;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ip_family(dst) = ip_family(ip);<br/></li>
<li>&nbsp; &nbsp; ip_bits(dst) = ip_maxbits(ip);<br/></li>
<li>&nbsp; &nbsp; SET_INET_VARSIZE(dst);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INET_P(dst);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns true if the addresses are from the same family, or false.&nbsp; Used to<br/></li>
<li></span><span class="Comment"> * check that we can create a network which contains both of the networks.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1464">&#x200c;</a><span class="linkable">inet_same_family</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a> = PG_GETARG_INET_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a> = PG_GETARG_INET_PP(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(ip_family(<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>) == ip_family(<a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns the smallest CIDR which contains both of the inputs.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1476">&#x200c;</a><span class="linkable">inet_merge</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a> = PG_GETARG_INET_PP(<span class="Constant">0</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a> = PG_GETARG_INET_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; commonbits;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ip_family(<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>) != ip_family(<a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> addresses from different families&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; commonbits = <a href="#L1603" title="utils/adt/network.c:1603">bitncommon</a>(ip_addr(<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>), ip_addr(<a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(ip_bits(<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>), ip_bits(<a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INET_P(<a href="#L368" title="utils/adt/network.c:368">cidr_set_masklen_internal</a>(<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>, commonbits));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert a value of a network datatype to an approximate scalar value.<br/></li>
<li></span><span class="Comment"> * This is used for estimating selectivities of inequality operators<br/></li>
<li></span><span class="Comment"> * involving network types.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On failure (e.g., unsupported typid), set *failure to true;<br/></li>
<li></span><span class="Comment"> * otherwise, that variable is not changed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">double<br/></li>
<li><a id="L1502">&#x200c;</a></span><span class="linkable">convert_network_to_scalar</span>(Datum value, Oid typid, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *failure)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (typid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INETOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CIDROID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *ip = DatumGetInetPP(value);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that we don't use the full address for IPv6.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ip_family(ip) == PGSQL_AF_INET)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len = <span class="Constant">4</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len = <span class="Constant">5</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = ip_family(ip);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; len; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res *= <span class="Constant">256</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res += ip_addr(ip)[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> MACADDROID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; macaddr&nbsp; &nbsp; *mac = DatumGetMacaddrP(value);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = (mac-&gt;a &lt;&lt; <span class="Constant">16</span>) | (mac-&gt;b &lt;&lt; <span class="Constant">8</span>) | (mac-&gt;c);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res *= <span class="Constant">256</span> * <span class="Constant">256</span> * <span class="Constant">256</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res += (mac-&gt;d &lt;&lt; <span class="Constant">16</span>) | (mac-&gt;e &lt;&lt; <span class="Constant">8</span>) | (mac-&gt;f);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> MACADDR8OID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; macaddr8&nbsp;&nbsp; *mac = DatumGetMacaddr8P(value);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = (mac-&gt;a &lt;&lt; <span class="Constant">24</span>) | (mac-&gt;b &lt;&lt; <span class="Constant">16</span>) | (mac-&gt;c &lt;&lt; <span class="Constant">8</span>) | (mac-&gt;d);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res *= ((<span class="Type">double</span>) <span class="Constant">256</span>) * <span class="Constant">256</span> * <span class="Constant">256</span> * <span class="Constant">256</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res += (mac-&gt;e &lt;&lt; <span class="Constant">24</span>) | (mac-&gt;f &lt;&lt; <span class="Constant">16</span>) | (mac-&gt;g &lt;&lt; <span class="Constant">8</span>) | (mac-&gt;h);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *failure = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * int<br/></li>
<li></span><span class="Comment"> * <a href="#L1569" title="utils/adt/network.c:1569">bitncmp</a>(l, r, n)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> masks l and r, for n bits.<br/></li>
<li></span><span class="Comment"> * return:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &lt;0, &gt;0, or 0 in the libc tradition.<br/></li>
<li></span><span class="Comment"> * note:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; network byte order assumed.&nbsp; this means 192.5.5.240/28 has<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; 0x11110000 in its fourth octet.<br/></li>
<li></span><span class="Comment"> * author:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Paul Vixie (ISC), June 1996<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1569">&#x200c;</a></span><span class="linkable">bitncmp</span>(<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">char</span> *l, <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">char</span> *r, <span class="Type">int</span> n)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> lb,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rb;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; b = n / <span class="Constant">8</span>;<br/></li>
<li>&nbsp; &nbsp; x = memcmp(l, r, b);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (x || (n % <span class="Constant">8</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> x;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; lb = l[b];<br/></li>
<li>&nbsp; &nbsp; rb = r[b];<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (b = n % <span class="Constant">8</span>; b &gt; <span class="Constant">0</span>; b--)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IS_HIGHBIT_SET(lb) != IS_HIGHBIT_SET(rb))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IS_HIGHBIT_SET(lb))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lb &lt;&lt;= <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rb &lt;&lt;= <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1603" title="utils/adt/network.c:1603">bitncommon</a>: <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> masks l and r, for up to n bits.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the number of leading bits that match (0 to n).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1603">&#x200c;</a></span><span class="linkable">bitncommon</span>(<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">char</span> *l, <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">char</span> *r, <span class="Type">int</span> n)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; byte,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbits;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* number of bits to examine in last byte */<br/></li>
<li></span>&nbsp; &nbsp; nbits = n % <span class="Constant">8</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check whole bytes */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (byte = <span class="Constant">0</span>; byte &lt; n / <span class="Constant">8</span>; byte++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (l[byte] != r[byte])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* at least one <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> in the last byte is not common */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbits = <span class="Constant">7</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check bits in last partial byte */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nbits != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* calculate diff of first non-matching bytes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> diff = l[byte] ^ r[byte];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> the bits from the most to the least */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((diff &gt;&gt; (<span class="Constant">8</span> - nbits)) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbits--;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (<span class="Constant">8</span> * byte) + nbits;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Verify a CIDR address is OK (doesn't have bits set past the masklen)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1641">&#x200c;</a></span><span class="linkable">addressOK</span>(<span class="Type">unsigned</span> <span class="Type">char</span> *a, <span class="Type">int</span> bits, <span class="Type">int</span> family)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; byte;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxbits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxbytes;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> mask;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (family == PGSQL_AF_INET)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; maxbits = <span class="Constant">32</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; maxbytes = <span class="Constant">4</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; maxbits = <span class="Constant">128</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; maxbytes = <span class="Constant">16</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; Assert(bits &lt;= maxbits);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (bits == maxbits)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; byte = bits / <span class="Constant">8</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nbits = bits % <span class="Constant">8</span>;<br/></li>
<li>&nbsp; &nbsp; mask = <span class="Constant">0xff</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (bits != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mask &gt;&gt;= nbits;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (byte &lt; maxbytes)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((a[byte] &amp; mask) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mask = <span class="Constant">0xff</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; byte++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * These <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> are used by <a href="../../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> to generate indexscan limits<br/></li>
<li></span><span class="Comment"> * for clauses a &lt;&lt; b and a &lt;&lt;= b<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* return the minimal value for an IP on a given network */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1690">&#x200c;</a><span class="linkable">network_scan_first</span>(Datum in)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> DirectFunctionCall1(<a href="#L1330" title="utils/adt/network.c:1330">network_network</a>, in);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * return &quot;last&quot; IP on a given network. It's the broadcast address,<br/></li>
<li></span><span class="Comment"> * however, masklen has to be set to its max bits, since<br/></li>
<li></span><span class="Comment"> * 192.168.0.255/24 is considered less than 192.168.0.255/32<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L324" title="utils/adt/network.c:324">inet_set_masklen</a>() hacked to max out the masklength to 128 for IPv6<br/></li>
<li></span><span class="Comment"> * and 32 for IPv4 when given '-1' as argument.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1704">&#x200c;</a><span class="linkable">network_scan_last</span>(Datum in)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> DirectFunctionCall2(<a href="#L324" title="utils/adt/network.c:324">inet_set_masklen</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; DirectFunctionCall1(<a href="#L1285" title="utils/adt/network.c:1285">network_broadcast</a>, in),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Int32GetDatum(-<span class="Constant">1</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * IP address that the client is connecting from (NULL if Unix <a href="../../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a>)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1716">&#x200c;</a><span class="linkable">inet_client_addr</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Port&nbsp; &nbsp; &nbsp;&nbsp; *port = <a href="../init/globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; remote_host[NI_MAXHOST];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (port == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (port-&gt;raddr.addr.ss_family)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AF_INET:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AF_INET6:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; remote_host[<span class="Constant">0</span>] = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ret = pg_getnameinfo_all(&amp;port-&gt;raddr.addr, port-&gt;raddr.salen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; remote_host, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(remote_host),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NI_NUMERICHOST | NI_NUMERICSERV);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ret != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2095" title="utils/adt/network.c:2095">clean_ipv6_addr</a>(port-&gt;raddr.addr.ss_family, remote_host);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INET_P(<a href="#L75" title="utils/adt/network.c:75">network_in</a>(remote_host, <span class="Constant">false</span>, <span class="Constant">NULL</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * port that the client is connecting from (NULL if Unix <a href="../../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a>)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1753">&#x200c;</a><span class="linkable">inet_client_port</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Port&nbsp; &nbsp; &nbsp;&nbsp; *port = <a href="../init/globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; remote_port[NI_MAXSERV];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (port == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (port-&gt;raddr.addr.ss_family)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AF_INET:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AF_INET6:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; remote_port[<span class="Constant">0</span>] = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ret = pg_getnameinfo_all(&amp;port-&gt;raddr.addr, port-&gt;raddr.salen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; remote_port, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(remote_port),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NI_NUMERICHOST | NI_NUMERICSERV);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ret != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_DATUM(DirectFunctionCall1(<a href="int.c.html#L287" title="utils/adt/int.c:287">int4in</a>, CStringGetDatum(remote_port)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * IP address that the server accepted the connection on (NULL if Unix <a href="../../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a>)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1788">&#x200c;</a><span class="linkable">inet_server_addr</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Port&nbsp; &nbsp; &nbsp;&nbsp; *port = <a href="../init/globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; local_host[NI_MAXHOST];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (port == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (port-&gt;laddr.addr.ss_family)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AF_INET:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AF_INET6:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; local_host[<span class="Constant">0</span>] = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ret = pg_getnameinfo_all(&amp;port-&gt;laddr.addr, port-&gt;laddr.salen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; local_host, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(local_host),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NI_NUMERICHOST | NI_NUMERICSERV);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ret != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2095" title="utils/adt/network.c:2095">clean_ipv6_addr</a>(port-&gt;laddr.addr.ss_family, local_host);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INET_P(<a href="#L75" title="utils/adt/network.c:75">network_in</a>(local_host, <span class="Constant">false</span>, <span class="Constant">NULL</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * port that the server accepted the connection on (NULL if Unix <a href="../../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a>)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1825">&#x200c;</a><span class="linkable">inet_server_port</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Port&nbsp; &nbsp; &nbsp;&nbsp; *port = <a href="../init/globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; local_port[NI_MAXSERV];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (port == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (port-&gt;laddr.addr.ss_family)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AF_INET:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AF_INET6:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; local_port[<span class="Constant">0</span>] = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ret = pg_getnameinfo_all(&amp;port-&gt;laddr.addr, port-&gt;laddr.salen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; local_port, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(local_port),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NI_NUMERICHOST | NI_NUMERICSERV);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ret != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_DATUM(DirectFunctionCall1(<a href="int.c.html#L287" title="utils/adt/int.c:287">int4in</a>, CStringGetDatum(local_port)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1857">&#x200c;</a><span class="linkable">inetnot</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *ip = PG_GETARG_INET_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *dst;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dst = (inet *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(inet));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nb = ip_addrsize(ip);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> *pip = ip_addr(ip);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> *pdst = ip_addr(dst);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (--nb &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pdst[nb] = ~pip[nb];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; ip_bits(dst) = ip_bits(ip);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ip_family(dst) = ip_family(ip);<br/></li>
<li>&nbsp; &nbsp; SET_INET_VARSIZE(dst);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INET_P(dst);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1882">&#x200c;</a><span class="linkable">inetand</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *ip = PG_GETARG_INET_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *ip2 = PG_GETARG_INET_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *dst;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dst = (inet *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(inet));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ip_family(ip) != ip_family(ip2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot AND inet <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of different sizes&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nb = ip_addrsize(ip);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> *pip = ip_addr(ip);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> *pip2 = ip_addr(ip2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> *pdst = ip_addr(dst);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (--nb &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pdst[nb] = pip[nb] &amp; pip2[nb];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; ip_bits(dst) = Max(ip_bits(ip), ip_bits(ip2));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ip_family(dst) = ip_family(ip);<br/></li>
<li>&nbsp; &nbsp; SET_INET_VARSIZE(dst);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INET_P(dst);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1914">&#x200c;</a><span class="linkable">inetor</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *ip = PG_GETARG_INET_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *ip2 = PG_GETARG_INET_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *dst;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dst = (inet *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(inet));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ip_family(ip) != ip_family(ip2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot OR inet <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of different sizes&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nb = ip_addrsize(ip);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> *pip = ip_addr(ip);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> *pip2 = ip_addr(ip2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> *pdst = ip_addr(dst);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (--nb &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pdst[nb] = pip[nb] | pip2[nb];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; ip_bits(dst) = Max(ip_bits(ip), ip_bits(ip2));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ip_family(dst) = ip_family(ip);<br/></li>
<li>&nbsp; &nbsp; SET_INET_VARSIZE(dst);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INET_P(dst);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">static</span> inet *<br/></li>
<li><a id="L1946">&#x200c;</a><span class="linkable">internal_inetpl</span>(inet *ip, int64 addend)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *dst;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dst = (inet *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(inet));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nb = ip_addrsize(ip);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> *pip = ip_addr(ip);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> *pdst = ip_addr(dst);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; carry = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (--nb &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; carry = pip[nb] + (<span class="Type">int</span>) (addend &amp; <span class="Constant">0xFF</span>) + carry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pdst[nb] = (<span class="Type">unsigned</span> <span class="Type">char</span>) (carry &amp; <span class="Constant">0xFF</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; carry &gt;&gt;= <span class="Constant">8</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have to be careful about right-shifting addend because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * right-shift isn't portable for negative <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, while simply<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * dividing by 256 doesn't work (the standard rounding is in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * wrong direction, besides which there may be machines out there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that round the wrong way).&nbsp; So, explicitly clear the low-order<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * byte to remove <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> doubt about the correct result of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * division, and then divide rather than shift.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addend &amp;= ~((int64) <span class="Constant">0xFF</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addend /= <span class="Constant">0x100</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * At this point we should have addend and carry both zero if original<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * addend was &gt;= 0, or addend -1 and carry 1 if original addend was &lt;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * 0.&nbsp; Anything else means overflow.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!((addend == <span class="Constant">0</span> &amp;&amp; carry == <span class="Constant">0</span>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (addend == -<span class="Constant">1</span> &amp;&amp; carry == <span class="Constant">1</span>)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;result is out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ip_bits(dst) = ip_bits(ip);<br/></li>
<li>&nbsp; &nbsp; ip_family(dst) = ip_family(ip);<br/></li>
<li>&nbsp; &nbsp; SET_INET_VARSIZE(dst);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> dst;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1998">&#x200c;</a><span class="linkable">inetpl</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *ip = PG_GETARG_INET_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; addend = PG_GETARG_INT64(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INET_P(<a href="#L1946" title="utils/adt/network.c:1946">internal_inetpl</a>(ip, addend));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2008">&#x200c;</a><span class="linkable">inetmi_int8</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *ip = PG_GETARG_INET_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; addend = PG_GETARG_INT64(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INET_P(<a href="#L1946" title="utils/adt/network.c:1946">internal_inetpl</a>(ip, -addend));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2018">&#x200c;</a><span class="linkable">inetmi</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *ip = PG_GETARG_INET_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *ip2 = PG_GETARG_INET_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; res = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ip_family(ip) != ip_family(ip2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot subtract inet <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of different sizes&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We form the difference using the traditional complement, increment,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and add rule, with the increment part being handled by starting the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * carry off at 1.&nbsp; If you don't think integer arithmetic is done in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * two's complement, too bad.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nb = ip_addrsize(ip);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; byte = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> *pip = ip_addr(ip);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> *pip2 = ip_addr(ip2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; carry = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (--nb &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lobyte;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; carry = pip[nb] + (~pip2[nb] &amp; <span class="Constant">0xFF</span>) + carry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lobyte = carry &amp; <span class="Constant">0xFF</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (byte &lt; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int64))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res |= ((int64) lobyte) &lt;&lt; (byte * <span class="Constant">8</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Input wider than int64: check for overflow.&nbsp; All bytes to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the left of what will fit should be 0 or 0xFF, depending on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sign of the <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>-complete result.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((res &lt; <span class="Constant">0</span>) ? (lobyte != <span class="Constant">0xFF</span>) : (lobyte != <span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;result is out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; carry &gt;&gt;= <span class="Constant">8</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; byte++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If input is narrower than int64, overflow is not possible, but we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have to do proper sign extension.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (carry == <span class="Constant">0</span> &amp;&amp; byte &lt; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int64))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res |= ((uint64) (int64) -<span class="Constant">1</span>) &lt;&lt; (byte * <span class="Constant">8</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT64(res);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2095" title="utils/adt/network.c:2095">clean_ipv6_addr</a> --- remove <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> '%zone' part from an IPv6 address string<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment"> This should go away someday!<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is a kluge needed because we don't yet support zones in stored inet<br/></li>
<li></span><span class="Comment"> * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.&nbsp; Since the result of getnameinfo() might include a zone spec,<br/></li>
<li></span><span class="Comment"> * call this to remove it anywhere we want to feed getnameinfo's output to<br/></li>
<li></span><span class="Comment"> * <a href="#L75" title="utils/adt/network.c:75">network_in</a>.&nbsp; Beats failing entirely.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * An alternative approach would be to let <a href="#L75" title="utils/adt/network.c:75">network_in</a> ignore %-parts for<br/></li>
<li></span><span class="Comment"> * itself, but that would mean we'd silently drop zone specs in user input,<br/></li>
<li></span><span class="Comment"> * which seems not such a good idea.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2095">&#x200c;</a></span><span class="linkable">clean_ipv6_addr</span>(<span class="Type">int</span> addr_family, <span class="Type">char</span> *addr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (addr_family == AF_INET6)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *pct = strchr(addr, <span class="Constant">'%'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pct)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *pct = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
