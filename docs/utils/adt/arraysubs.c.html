<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/adt/arraysubs.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/adt/arraysubs.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L29">ArraySubWorkspace</a></li>
<li><a href="#L45">ArraySubWorkspace</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L473">array_exec_setup</a></li>
<li><a href="#L294">array_subscript_assign</a></li>
<li><a href="#L344">array_subscript_assign_slice</a></li>
<li><a href="#L180">array_subscript_check_subscripts</a></li>
<li><a href="#L236">array_subscript_fetch</a></li>
<li><a href="#L399">array_subscript_fetch_old</a></li>
<li><a href="#L439">array_subscript_fetch_old_slice</a></li>
<li><a href="#L264">array_subscript_fetch_slice</a></li>
<li><a href="#L539">array_subscript_handler</a></li>
<li><a href="#L55">array_subscript_transform</a></li>
<li><a href="#L566">raw_array_subscript_handler</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * arraysubs.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Subscripting support <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for arrays.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/adt/arraysubs.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;executor/execExpr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/makefuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/nodeFuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/subscripting.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_coerce.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_expr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/array.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgrprotos.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* SubscriptingRefState.workspace for array subscripting execution */<br/></li>
<li><a id="L29">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">ArraySubWorkspace</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Values determined during expression compilation */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; refelemtype;&nbsp; &nbsp; <span class="Comment">/* OID of the array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type */<br/></li>
<li></span>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; refattrlength;&nbsp; &nbsp; <span class="Comment">/* typlen of array type */<br/></li>
<li></span>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; refelemlength;&nbsp; &nbsp; <span class="Comment">/* typlen of the array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; refelembyval;&nbsp; &nbsp; <span class="Comment">/* is the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type pass-by-value? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; refelemalign;&nbsp; &nbsp; <span class="Comment">/* typalign of the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Subscript <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> converted to integers.&nbsp; Note that these arrays must be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of length MAXDIM even when dealing with fewer subscripts, because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * array_get/set_slice may scribble on the extra entries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upperindex[MAXDIM];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lowerindex[MAXDIM];<br/></li>
<li><a id="L45">&#x200c;</a>} <span class="linkable">ArraySubWorkspace</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Finish <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> analysis of a SubscriptingRef expression for an array.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Transform the subscript expressions, coerce them to integers,<br/></li>
<li></span><span class="Comment"> * and determine the result type of the SubscriptingRef node.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L55">&#x200c;</a></span><span class="linkable">array_subscript_transform</span>(SubscriptingRef *sbsref,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *indirection,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ParseState *pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isSlice,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isAssignment)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *upperIndexpr = NIL;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *lowerIndexpr = NIL;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *idx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Transform the subscript expressions, and separate <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> and <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bounds into two lists.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we have a container slice expression, we convert <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> non-slice<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * indirection items to slices by treating the single subscript as the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound and supplying an assumed <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound of 1.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(idx, indirection)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; A_Indices&nbsp; *ai = lfirst_node(A_Indices, idx);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *subexpr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isSlice)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ai-&gt;lidx)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subexpr = <a href="../../parser/parse_expr.c.html#L121" title="parser/parse_expr.c:121">transformExpr</a>(pstate, ai-&gt;lidx, pstate-&gt;p_expr_kind);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If it's not int4 already, try to coerce */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subexpr = <a href="../../parser/parse_coerce.c.html#L78" title="parser/parse_coerce.c:78">coerce_to_target_type</a>(pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subexpr, <a href="../../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>(subexpr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INT4OID, -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; COERCION_ASSIGNMENT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; COERCE_IMPLICIT_CAST,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subexpr == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;array subscript must have type integer&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../parser/parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(pstate, <a href="../../nodes/nodeFuncs.c.html#L1386" title="nodes/nodeFuncs.c:1386">exprLocation</a>(ai-&gt;lidx))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!ai-&gt;is_slice)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make a constant 1 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subexpr = (Node *) <a href="../../nodes/makefuncs.c.html#L301" title="nodes/makefuncs.c:301">makeConst</a>(INT4OID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int32),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Int32GetDatum(<span class="Constant">1</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>); <span class="Comment">/* pass by value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Slice with omitted <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound, put NULL into the list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subexpr = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lowerIndexpr = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(lowerIndexpr, subexpr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(ai-&gt;lidx == <span class="Constant">NULL</span> &amp;&amp; !ai-&gt;is_slice);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ai-&gt;uidx)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subexpr = <a href="../../parser/parse_expr.c.html#L121" title="parser/parse_expr.c:121">transformExpr</a>(pstate, ai-&gt;uidx, pstate-&gt;p_expr_kind);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If it's not int4 already, try to coerce */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subexpr = <a href="../../parser/parse_coerce.c.html#L78" title="parser/parse_coerce.c:78">coerce_to_target_type</a>(pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subexpr, <a href="../../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>(subexpr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INT4OID, -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; COERCION_ASSIGNMENT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; COERCE_IMPLICIT_CAST,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subexpr == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;array subscript must have type integer&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../parser/parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(pstate, <a href="../../nodes/nodeFuncs.c.html#L1386" title="nodes/nodeFuncs.c:1386">exprLocation</a>(ai-&gt;uidx))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Slice with omitted <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound, put NULL into the list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(isSlice &amp;&amp; ai-&gt;is_slice);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subexpr = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; upperIndexpr = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(upperIndexpr, subexpr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ... and store the transformed lists into the SubscriptRef node */<br/></li>
<li></span>&nbsp; &nbsp; sbsref-&gt;refupperindexpr = upperIndexpr;<br/></li>
<li>&nbsp; &nbsp; sbsref-&gt;reflowerindexpr = lowerIndexpr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Verify subscript list lengths are within implementation limit */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(upperIndexpr) &gt; MAXDIM)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;number of array dimensions (</span><span class="Special">%d</span><span class="Constant">) exceeds the maximum allowed (</span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_length(upperIndexpr), MAXDIM)));<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We need not check lowerIndexpr separately */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine the result type of the subscripting operation.&nbsp; It's the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as the array type if we're slicing, else it's the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type.&nbsp; In<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * either case, the typmod is the same as the array's, so we need not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * change reftypmod.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isSlice)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sbsref-&gt;refrestype = sbsref-&gt;refcontainertype;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sbsref-&gt;refrestype = sbsref-&gt;refelemtype;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * During execution, process the subscripts in a SubscriptingRef expression.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The subscript expressions are already evaluated in Datum form in the<br/></li>
<li></span><span class="Comment"> * SubscriptingRefState's arrays.&nbsp; Check and convert them as necessary.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> subscript is NULL, we throw error in assignment cases, or in fetch<br/></li>
<li></span><span class="Comment"> * cases set result to NULL and return false (instructing caller to <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the<br/></li>
<li></span><span class="Comment"> * rest of the SubscriptingRef sequence).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We convert all the subscripts to plain integers and save them in the<br/></li>
<li></span><span class="Comment"> * sbsrefstate-&gt;workspace arrays.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L180">&#x200c;</a></span><span class="linkable">array_subscript_check_subscripts</span>(ExprState *state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ExprEvalStep *op,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ExprContext *econtext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SubscriptingRefState *sbsrefstate = op-&gt;d.sbsref_subscript.state;<br/></li>
<li>&nbsp; &nbsp; <a href="#L29" title="utils/adt/arraysubs.c:29">ArraySubWorkspace</a> *workspace = (<a href="#L29" title="utils/adt/arraysubs.c:29">ArraySubWorkspace</a> *) sbsrefstate-&gt;workspace;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Process <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> subscripts */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; sbsrefstate-&gt;numupper; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sbsrefstate-&gt;upperprovided[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> index expr yields NULL, result is NULL or error */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sbsrefstate-&gt;upperindexnull[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sbsrefstate-&gt;isassignment)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NULL_VALUE_NOT_ALLOWED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;array subscript in assignment must not be null&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; workspace-&gt;upperindex[i] = DatumGetInt32(sbsrefstate-&gt;upperindex[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Likewise for <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> subscripts */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; sbsrefstate-&gt;numlower; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sbsrefstate-&gt;lowerprovided[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> index expr yields NULL, result is NULL or error */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sbsrefstate-&gt;lowerindexnull[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sbsrefstate-&gt;isassignment)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NULL_VALUE_NOT_ALLOWED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;array subscript in assignment must not be null&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; workspace-&gt;lowerindex[i] = DatumGetInt32(sbsrefstate-&gt;lowerindex[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Evaluate SubscriptingRef fetch for an array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Source container is in step's result variable (it's known not NULL, since<br/></li>
<li></span><span class="Comment"> * we set fetch_strict to true), and indexes have already been evaluated into<br/></li>
<li></span><span class="Comment"> * workspace array.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L236">&#x200c;</a></span><span class="linkable">array_subscript_fetch</span>(ExprState *state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExprEvalStep *op,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExprContext *econtext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SubscriptingRefState *sbsrefstate = op-&gt;d.sbsref.state;<br/></li>
<li>&nbsp; &nbsp; <a href="#L29" title="utils/adt/arraysubs.c:29">ArraySubWorkspace</a> *workspace = (<a href="#L29" title="utils/adt/arraysubs.c:29">ArraySubWorkspace</a> *) sbsrefstate-&gt;workspace;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Should not get here if source array (or <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> subscript) is null */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!(*op-&gt;resnull));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *op-&gt;resvalue = <a href="arrayfuncs.c.html#L1820" title="utils/adt/arrayfuncs.c:1820">array_get_element</a>(*op-&gt;resvalue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sbsrefstate-&gt;numupper,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; workspace-&gt;upperindex,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; workspace-&gt;refattrlength,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; workspace-&gt;refelemlength,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; workspace-&gt;refelembyval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; workspace-&gt;refelemalign,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op-&gt;resnull);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Evaluate SubscriptingRef fetch for an array slice.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Source container is in step's result variable (it's known not NULL, since<br/></li>
<li></span><span class="Comment"> * we set fetch_strict to true), and indexes have already been evaluated into<br/></li>
<li></span><span class="Comment"> * workspace array.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L264">&#x200c;</a></span><span class="linkable">array_subscript_fetch_slice</span>(ExprState *state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExprEvalStep *op,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExprContext *econtext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SubscriptingRefState *sbsrefstate = op-&gt;d.sbsref.state;<br/></li>
<li>&nbsp; &nbsp; <a href="#L29" title="utils/adt/arraysubs.c:29">ArraySubWorkspace</a> *workspace = (<a href="#L29" title="utils/adt/arraysubs.c:29">ArraySubWorkspace</a> *) sbsrefstate-&gt;workspace;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Should not get here if source array (or <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> subscript) is null */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!(*op-&gt;resnull));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *op-&gt;resvalue = <a href="arrayfuncs.c.html#L2030" title="utils/adt/arrayfuncs.c:2030">array_get_slice</a>(*op-&gt;resvalue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sbsrefstate-&gt;numupper,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; workspace-&gt;upperindex,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; workspace-&gt;lowerindex,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sbsrefstate-&gt;upperprovided,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sbsrefstate-&gt;lowerprovided,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; workspace-&gt;refattrlength,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; workspace-&gt;refelemlength,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; workspace-&gt;refelembyval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; workspace-&gt;refelemalign);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The slice is never NULL, so no need to change *op-&gt;resnull */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Evaluate SubscriptingRef assignment for an array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> assignment.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Input container (possibly null) is in result area, replacement value is in<br/></li>
<li></span><span class="Comment"> * SubscriptingRefState's replacevalue/replacenull.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L294">&#x200c;</a></span><span class="linkable">array_subscript_assign</span>(ExprState *state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ExprEvalStep *op,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ExprContext *econtext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SubscriptingRefState *sbsrefstate = op-&gt;d.sbsref.state;<br/></li>
<li>&nbsp; &nbsp; <a href="#L29" title="utils/adt/arraysubs.c:29">ArraySubWorkspace</a> *workspace = (<a href="#L29" title="utils/adt/arraysubs.c:29">ArraySubWorkspace</a> *) sbsrefstate-&gt;workspace;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; arraySource = *op-&gt;resvalue;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For an assignment to a fixed-length array type, both the original array<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and the value to be assigned into it must be non-NULL, else we punt and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * return the original array.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (workspace-&gt;refattrlength &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*op-&gt;resnull || sbsrefstate-&gt;replacenull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For assignment to varlena arrays, we handle a NULL original array by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * substituting an empty (zero-dimensional) array; insertion of the new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> will result in a singleton array value.&nbsp; It does not matter<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * whether the new <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> is NULL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (*op-&gt;resnull)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; arraySource = PointerGetDatum(<a href="arrayfuncs.c.html#L3561" title="utils/adt/arrayfuncs.c:3561">construct_empty_array</a>(workspace-&gt;refelemtype));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *op-&gt;resvalue = <a href="arrayfuncs.c.html#L2201" title="utils/adt/arrayfuncs.c:2201">array_set_element</a>(arraySource,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sbsrefstate-&gt;numupper,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; workspace-&gt;upperindex,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sbsrefstate-&gt;replacevalue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sbsrefstate-&gt;replacenull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; workspace-&gt;refattrlength,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; workspace-&gt;refelemlength,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; workspace-&gt;refelembyval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; workspace-&gt;refelemalign);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The result is never NULL, so no need to change *op-&gt;resnull */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Evaluate SubscriptingRef assignment for an array slice assignment.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Input container (possibly null) is in result area, replacement value is in<br/></li>
<li></span><span class="Comment"> * SubscriptingRefState's replacevalue/replacenull.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L344">&#x200c;</a></span><span class="linkable">array_subscript_assign_slice</span>(ExprState *state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ExprEvalStep *op,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ExprContext *econtext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SubscriptingRefState *sbsrefstate = op-&gt;d.sbsref.state;<br/></li>
<li>&nbsp; &nbsp; <a href="#L29" title="utils/adt/arraysubs.c:29">ArraySubWorkspace</a> *workspace = (<a href="#L29" title="utils/adt/arraysubs.c:29">ArraySubWorkspace</a> *) sbsrefstate-&gt;workspace;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; arraySource = *op-&gt;resvalue;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For an assignment to a fixed-length array type, both the original array<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and the value to be assigned into it must be non-NULL, else we punt and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * return the original array.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (workspace-&gt;refattrlength &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*op-&gt;resnull || sbsrefstate-&gt;replacenull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For assignment to varlena arrays, we handle a NULL original array by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * substituting an empty (zero-dimensional) array; insertion of the new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> will result in a singleton array value.&nbsp; It does not matter<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * whether the new <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> is NULL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (*op-&gt;resnull)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; arraySource = PointerGetDatum(<a href="arrayfuncs.c.html#L3561" title="utils/adt/arrayfuncs.c:3561">construct_empty_array</a>(workspace-&gt;refelemtype));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *op-&gt;resvalue = <a href="arrayfuncs.c.html#L2806" title="utils/adt/arrayfuncs.c:2806">array_set_slice</a>(arraySource,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sbsrefstate-&gt;numupper,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; workspace-&gt;upperindex,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; workspace-&gt;lowerindex,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sbsrefstate-&gt;upperprovided,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sbsrefstate-&gt;lowerprovided,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sbsrefstate-&gt;replacevalue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sbsrefstate-&gt;replacenull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; workspace-&gt;refattrlength,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; workspace-&gt;refelemlength,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; workspace-&gt;refelembyval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; workspace-&gt;refelemalign);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The result is never NULL, so no need to change *op-&gt;resnull */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute old array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> value for a SubscriptingRef assignment<br/></li>
<li></span><span class="Comment"> * expression.&nbsp; Will only be called if the new-value subexpression<br/></li>
<li></span><span class="Comment"> * contains SubscriptingRef or FieldStore.&nbsp; This is the same as the<br/></li>
<li></span><span class="Comment"> * regular fetch case, except that we have to handle a null array,<br/></li>
<li></span><span class="Comment"> * and the value should be stored into the SubscriptingRefState's<br/></li>
<li></span><span class="Comment"> * prevvalue/prevnull fields.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L399">&#x200c;</a></span><span class="linkable">array_subscript_fetch_old</span>(ExprState *state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExprEvalStep *op,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExprContext *econtext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SubscriptingRefState *sbsrefstate = op-&gt;d.sbsref.state;<br/></li>
<li>&nbsp; &nbsp; <a href="#L29" title="utils/adt/arraysubs.c:29">ArraySubWorkspace</a> *workspace = (<a href="#L29" title="utils/adt/arraysubs.c:29">ArraySubWorkspace</a> *) sbsrefstate-&gt;workspace;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*op-&gt;resnull)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* whole array is null, so <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> is too */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sbsrefstate-&gt;prevvalue = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sbsrefstate-&gt;prevnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sbsrefstate-&gt;prevvalue = <a href="arrayfuncs.c.html#L1820" title="utils/adt/arrayfuncs.c:1820">array_get_element</a>(*op-&gt;resvalue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sbsrefstate-&gt;numupper,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; workspace-&gt;upperindex,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; workspace-&gt;refattrlength,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; workspace-&gt;refelemlength,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; workspace-&gt;refelembyval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; workspace-&gt;refelemalign,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;sbsrefstate-&gt;prevnull);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute old array slice value for a SubscriptingRef assignment<br/></li>
<li></span><span class="Comment"> * expression.&nbsp; Will only be called if the new-value subexpression<br/></li>
<li></span><span class="Comment"> * contains SubscriptingRef or FieldStore.&nbsp; This is the same as the<br/></li>
<li></span><span class="Comment"> * regular fetch case, except that we have to handle a null array,<br/></li>
<li></span><span class="Comment"> * and the value should be stored into the SubscriptingRefState's<br/></li>
<li></span><span class="Comment"> * prevvalue/prevnull fields.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this is presently dead code, because the new value for a<br/></li>
<li></span><span class="Comment"> * slice would have to be an array, so it couldn't directly contain a<br/></li>
<li></span><span class="Comment"> * FieldStore; nor could it contain a SubscriptingRef assignment, since<br/></li>
<li></span><span class="Comment"> * we consider adjacent subscripts to index one multidimensional array<br/></li>
<li></span><span class="Comment"> * not nested array types.&nbsp; Future generalizations might make this<br/></li>
<li></span><span class="Comment"> * reachable, however.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L439">&#x200c;</a></span><span class="linkable">array_subscript_fetch_old_slice</span>(ExprState *state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExprEvalStep *op,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExprContext *econtext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SubscriptingRefState *sbsrefstate = op-&gt;d.sbsref.state;<br/></li>
<li>&nbsp; &nbsp; <a href="#L29" title="utils/adt/arraysubs.c:29">ArraySubWorkspace</a> *workspace = (<a href="#L29" title="utils/adt/arraysubs.c:29">ArraySubWorkspace</a> *) sbsrefstate-&gt;workspace;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*op-&gt;resnull)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* whole array is null, so <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> slice is too */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sbsrefstate-&gt;prevvalue = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sbsrefstate-&gt;prevnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sbsrefstate-&gt;prevvalue = <a href="arrayfuncs.c.html#L2030" title="utils/adt/arrayfuncs.c:2030">array_get_slice</a>(*op-&gt;resvalue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sbsrefstate-&gt;numupper,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; workspace-&gt;upperindex,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; workspace-&gt;lowerindex,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sbsrefstate-&gt;upperprovided,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sbsrefstate-&gt;lowerprovided,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; workspace-&gt;refattrlength,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; workspace-&gt;refelemlength,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; workspace-&gt;refelembyval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; workspace-&gt;refelemalign);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* slices of non-null arrays are never null */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sbsrefstate-&gt;prevnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Set up execution state for an array subscript operation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L473">&#x200c;</a></span><span class="linkable">array_exec_setup</span>(<span class="Type">const</span> SubscriptingRef *sbsref,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; SubscriptingRefState *sbsrefstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; SubscriptExecSteps *methods)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_slice = (sbsrefstate-&gt;numlower != <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L29" title="utils/adt/arraysubs.c:29">ArraySubWorkspace</a> *workspace;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Enforce the implementation limit on number of array subscripts.&nbsp; This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * check isn't entirely redundant with checking at <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> time; conceivably<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the expression was stored by a backend with a different MAXDIM value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (sbsrefstate-&gt;numupper &gt; MAXDIM)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;number of array dimensions (</span><span class="Special">%d</span><span class="Constant">) exceeds the maximum allowed (</span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sbsrefstate-&gt;numupper, MAXDIM)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Should be impossible if parser is sane, but check anyway: */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (sbsrefstate-&gt;numlower != <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sbsrefstate-&gt;numupper != sbsrefstate-&gt;numlower)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> and <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> index lists are not same length&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate type-specific workspace.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; workspace = (<a href="#L29" title="utils/adt/arraysubs.c:29">ArraySubWorkspace</a> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L29" title="utils/adt/arraysubs.c:29">ArraySubWorkspace</a>));<br/></li>
<li>&nbsp; &nbsp; sbsrefstate-&gt;workspace = workspace;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Collect datatype details we'll need at execution.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; workspace-&gt;refelemtype = sbsref-&gt;refelemtype;<br/></li>
<li>&nbsp; &nbsp; workspace-&gt;refattrlength = <a href="../cache/lsyscache.c.html#L2197" title="utils/cache/lsyscache.c:2197">get_typlen</a>(sbsref-&gt;refcontainertype);<br/></li>
<li>&nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L2271" title="utils/cache/lsyscache.c:2271">get_typlenbyvalalign</a>(sbsref-&gt;refelemtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;workspace-&gt;refelemlength,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;workspace-&gt;refelembyval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;workspace-&gt;refelemalign);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Pass back pointers to appropriate step execution <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; methods-&gt;sbs_check_subscripts = <a href="#L180" title="utils/adt/arraysubs.c:180">array_subscript_check_subscripts</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (is_slice)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; methods-&gt;sbs_fetch = <a href="#L264" title="utils/adt/arraysubs.c:264">array_subscript_fetch_slice</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; methods-&gt;sbs_assign = <a href="#L344" title="utils/adt/arraysubs.c:344">array_subscript_assign_slice</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; methods-&gt;sbs_fetch_old = <a href="#L439" title="utils/adt/arraysubs.c:439">array_subscript_fetch_old_slice</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; methods-&gt;sbs_fetch = <a href="#L236" title="utils/adt/arraysubs.c:236">array_subscript_fetch</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; methods-&gt;sbs_assign = <a href="#L294" title="utils/adt/arraysubs.c:294">array_subscript_assign</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; methods-&gt;sbs_fetch_old = <a href="#L399" title="utils/adt/arraysubs.c:399">array_subscript_fetch_old</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L539" title="utils/adt/arraysubs.c:539">array_subscript_handler</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Subscripting handler for standard varlena arrays.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This should be used only for &quot;true&quot; array types, which have array headers<br/></li>
<li></span><span class="Comment"> * as understood by the varlena array routines, and are referenced by the<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type's pg_type.typarray field.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L539">&#x200c;</a><span class="linkable">array_subscript_handler</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">const</span> SubscriptRoutines sbsroutines = {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; .transform = <a href="#L55" title="utils/adt/arraysubs.c:55">array_subscript_transform</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; .exec_setup = <a href="#L473" title="utils/adt/arraysubs.c:473">array_exec_setup</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; .fetch_strict = <span class="Constant">true</span>,&nbsp; &nbsp; <span class="Comment">/* fetch returns NULL for NULL inputs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; .fetch_leakproof = <span class="Constant">true</span>,&nbsp; &nbsp; <span class="Comment">/* fetch returns NULL for bad subscript */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; .store_leakproof = <span class="Constant">false</span>&nbsp; &nbsp; <span class="Comment">/* ... but assignment throws error */<br/></li>
<li></span>&nbsp; &nbsp; };<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(&amp;sbsroutines);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L566" title="utils/adt/arraysubs.c:566">raw_array_subscript_handler</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Subscripting handler for &quot;raw&quot; arrays.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A &quot;raw&quot; array just contains N independent instances of the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type.<br/></li>
<li></span><span class="Comment"> * Currently we require both the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type and the array type to be fixed<br/></li>
<li></span><span class="Comment"> * length, but it wouldn't be too hard to relax that for the array type.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As of <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, all the support code is shared with standard varlena arrays.<br/></li>
<li></span><span class="Comment"> * We may split those into separate code paths, but probably that would yield<br/></li>
<li></span><span class="Comment"> * only marginal speedups.&nbsp; The <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> point of having a separate handler is<br/></li>
<li></span><span class="Comment"> * so that pg_type.typsubscript clearly indicates the type's semantics.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L566">&#x200c;</a><span class="linkable">raw_array_subscript_handler</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">const</span> SubscriptRoutines sbsroutines = {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; .transform = <a href="#L55" title="utils/adt/arraysubs.c:55">array_subscript_transform</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; .exec_setup = <a href="#L473" title="utils/adt/arraysubs.c:473">array_exec_setup</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; .fetch_strict = <span class="Constant">true</span>,&nbsp; &nbsp; <span class="Comment">/* fetch returns NULL for NULL inputs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; .fetch_leakproof = <span class="Constant">true</span>,&nbsp; &nbsp; <span class="Comment">/* fetch returns NULL for bad subscript */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; .store_leakproof = <span class="Constant">false</span>&nbsp; &nbsp; <span class="Comment">/* ... but assignment throws error */<br/></li>
<li></span>&nbsp; &nbsp; };<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(&amp;sbsroutines);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
