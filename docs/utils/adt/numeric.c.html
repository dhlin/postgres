<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/adt/numeric.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/adt/numeric.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L422">const_minus_one</a></li>
<li><a href="#L449">const_nan</a></li>
<li><a href="#L455">const_ninf</a></li>
<li><a href="#L419">const_one</a></li>
<li><a href="#L418">const_one_data</a></li>
<li><a href="#L446">const_one_point_one</a></li>
<li><a href="#L440">const_one_point_one_data</a></li>
<li><a href="#L442">const_one_point_one_data</a></li>
<li><a href="#L444">const_one_point_one_data</a></li>
<li><a href="#L452">const_pinf</a></li>
<li><a href="#L426">const_two</a></li>
<li><a href="#L425">const_two_data</a></li>
<li><a href="#L415">const_zero</a></li>
<li><a href="#L414">const_zero_data</a></li>
<li><a href="#L436">const_zero_point_nine</a></li>
<li><a href="#L430">const_zero_point_nine_data</a></li>
<li><a href="#L432">const_zero_point_nine_data</a></li>
<li><a href="#L434">const_zero_point_nine_data</a></li>
<li><a href="#L459">round_powers</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L5467">Int128AggState</a></li>
<li><a href="#L5473">Int128AggState</a></li>
<li><a href="#L6650">Int8TransTypeData</a></li>
<li><a href="#L6654">Int8TransTypeData</a></li>
<li><a href="#L4794">NumericAggState</a></li>
<li><a href="#L4807">NumericAggState</a></li>
<li><a href="#L146">NumericChoice</a></li>
<li><a href="#L153">NumericData</a></li>
<li><a href="#L101">NumericDigit</a></li>
<li><a href="#L139">NumericLong</a></li>
<li><a href="#L133">NumericShort</a></li>
<li><a href="#L337">NumericSortSupport</a></li>
<li><a href="#L370">NumericSumAccum</a></li>
<li><a href="#L379">NumericSumAccum</a></li>
<li><a href="#L303">NumericVar</a></li>
<li><a href="#L311">NumericVar</a></li>
<li><a href="#L5540">PolyNumAggState</a></li>
<li><a href="#L5544">PolyNumAggState</a></li>
<li><a href="#L323">generate_series_numeric_fctx</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L11974">accum_sum_add</a></li>
<li><a href="#L12022">accum_sum_carry</a></li>
<li><a href="#L12252">accum_sum_combine</a></li>
<li><a href="#L12235">accum_sum_copy</a></li>
<li><a href="#L12184">accum_sum_final</a></li>
<li><a href="#L12095">accum_sum_rescale</a></li>
<li><a href="#L11958">accum_sum_reset</a></li>
<li><a href="#L11582">add_abs</a></li>
<li><a href="#L8431">add_var</a></li>
<li><a href="#L6953">alloc_var</a></li>
<li><a href="#L7907">apply_typmod</a></li>
<li><a href="#L7992">apply_typmod_special</a></li>
<li><a href="#L9945">ceil_var</a></li>
<li><a href="#L11504">cmp_abs</a></li>
<li><a href="#L11518">cmp_abs_common</a></li>
<li><a href="#L2505">cmp_numerics</a></li>
<li><a href="#L8373">cmp_var</a></li>
<li><a href="#L8388">cmp_var_common</a></li>
<li><a href="#L1917">compute_bucket</a></li>
<li><a href="#L9875">div_mod_var</a></li>
<li><a href="#L8877">div_var</a></li>
<li><a href="#L9185">div_var_fast</a></li>
<li><a href="#L9549">div_var_int</a></li>
<li><a href="#L9665">div_var_int64</a></li>
<li><a href="#L5518">do_int128_accum</a></li>
<li><a href="#L5531">do_int128_discard</a></li>
<li><a href="#L4857">do_numeric_accum</a></li>
<li><a href="#L4927">do_numeric_discard</a></li>
<li><a href="#L6858">dump_numeric</a></li>
<li><a href="#L6900">dump_var</a></li>
<li><a href="#L7763">duplicate_numeric</a></li>
<li><a href="#L10671">estimate_ln_dweight</a></li>
<li><a href="#L10542">exp_var</a></li>
<li><a href="#L4687">float4_numeric</a></li>
<li><a href="#L4593">float8_numeric</a></li>
<li><a href="#L9969">floor_var</a></li>
<li><a href="#L6969">free_var</a></li>
<li><a href="#L9992">gcd_var</a></li>
<li><a href="#L1686">generate_series_numeric</a></li>
<li><a href="#L1692">generate_series_step_numeric</a></li>
<li><a href="#L4136">get_min_scale</a></li>
<li><a href="#L7494">get_str_from_var</a></li>
<li><a href="#L7647">get_str_from_var_sci</a></li>
<li><a href="#L2697">hash_numeric</a></li>
<li><a href="#L2777">hash_numeric_extended</a></li>
<li><a href="#L2562">in_range_numeric_numeric</a></li>
<li><a href="#L7451">init_var_from_num</a></li>
<li><a href="#L8295">int128_to_numericvar</a></li>
<li><a href="#L5550">int2_accum</a></li>
<li><a href="#L5974">int2_accum_inv</a></li>
<li><a href="#L6657">int2_avg_accum</a></li>
<li><a href="#L6744">int2_avg_accum_inv</a></li>
<li><a href="#L4544">int2_numeric</a></li>
<li><a href="#L6508">int2_sum</a></li>
<li><a href="#L6827">int2int4_sum</a></li>
<li><a href="#L5573">int4_accum</a></li>
<li><a href="#L5999">int4_accum_inv</a></li>
<li><a href="#L6685">int4_avg_accum</a></li>
<li><a href="#L6772">int4_avg_accum_inv</a></li>
<li><a href="#L6713">int4_avg_combine</a></li>
<li><a href="#L4389">int4_numeric</a></li>
<li><a href="#L6557">int4_sum</a></li>
<li><a href="#L4304">int64_div_fast_to_numeric</a></li>
<li><a href="#L4283">int64_to_numeric</a></li>
<li><a href="#L8104">int64_to_numericvar</a></li>
<li><a href="#L5596">int8_accum</a></li>
<li><a href="#L6024">int8_accum_inv</a></li>
<li><a href="#L6800">int8_avg</a></li>
<li><a href="#L5792">int8_avg_accum</a></li>
<li><a href="#L6045">int8_avg_accum_inv</a></li>
<li><a href="#L5819">int8_avg_combine</a></li>
<li><a href="#L5928">int8_avg_deserialize</a></li>
<li><a href="#L5879">int8_avg_serialize</a></li>
<li><a href="#L4477">int8_numeric</a></li>
<li><a href="#L6609">int8_sum</a></li>
<li><a href="#L907">is_valid_numeric_typmod</a></li>
<li><a href="#L10753">ln_var</a></li>
<li><a href="#L10871">log_var</a></li>
<li><a href="#L5480">makeInt128AggState</a></li>
<li><a href="#L5504">makeInt128AggStateCurrentContext</a></li>
<li><a href="#L4817">makeNumericAggState</a></li>
<li><a href="#L4842">makeNumericAggStateCurrentContext</a></li>
<li><a href="#L898">make_numeric_typmod</a></li>
<li><a href="#L7891">make_result</a></li>
<li><a href="#L7782">make_result_opt_error</a></li>
<li><a href="#L9846">mod_var</a></li>
<li><a href="#L8669">mul_var</a></li>
<li><a href="#L1237">numeric</a></li>
<li><a href="#L2108">numeric_abbrev_abort</a></li>
<li><a href="#L2046">numeric_abbrev_convert</a></li>
<li><a href="#L2265">numeric_abbrev_convert_var</a></li>
<li><a href="#L2320">numeric_abbrev_convert_var</a></li>
<li><a href="#L1384">numeric_abs</a></li>
<li><a href="#L5020">numeric_accum</a></li>
<li><a href="#L5431">numeric_accum_inv</a></li>
<li><a href="#L2848">numeric_add</a></li>
<li><a href="#L2867">numeric_add_opt_error</a></li>
<li><a href="#L6128">numeric_avg</a></li>
<li><a href="#L5112">numeric_avg_accum</a></li>
<li><a href="#L5132">numeric_avg_combine</a></li>
<li><a href="#L5256">numeric_avg_deserialize</a></li>
<li><a href="#L5204">numeric_avg_serialize</a></li>
<li><a href="#L1630">numeric_ceil</a></li>
<li><a href="#L2399">numeric_cmp</a></li>
<li><a href="#L2203">numeric_cmp_abbrev</a></li>
<li><a href="#L5040">numeric_combine</a></li>
<li><a href="#L5370">numeric_deserialize</a></li>
<li><a href="#L3124">numeric_div</a></li>
<li><a href="#L3144">numeric_div_opt_error</a></li>
<li><a href="#L3259">numeric_div_trunc</a></li>
<li><a href="#L2415">numeric_eq</a></li>
<li><a href="#L3748">numeric_exp</a></li>
<li><a href="#L3624">numeric_fac</a></li>
<li><a href="#L2181">numeric_fast_cmp</a></li>
<li><a href="#L4722">numeric_float4</a></li>
<li><a href="#L4628">numeric_float8</a></li>
<li><a href="#L4661">numeric_float8_no_overflow</a></li>
<li><a href="#L1658">numeric_floor</a></li>
<li><a href="#L3521">numeric_gcd</a></li>
<li><a href="#L2460">numeric_ge</a></li>
<li><a href="#L2445">numeric_gt</a></li>
<li><a href="#L628">numeric_in</a></li>
<li><a href="#L3437">numeric_inc</a></li>
<li><a href="#L4553">numeric_int2</a></li>
<li><a href="#L4447">numeric_int4</a></li>
<li><a href="#L4397">numeric_int4_opt_error</a></li>
<li><a href="#L4535">numeric_int8</a></li>
<li><a href="#L4485">numeric_int8_opt_error</a></li>
<li><a href="#L853">numeric_is_inf</a></li>
<li><a href="#L864">numeric_is_integral</a></li>
<li><a href="#L842">numeric_is_nan</a></li>
<li><a href="#L3492">numeric_larger</a></li>
<li><a href="#L3564">numeric_lcm</a></li>
<li><a href="#L2490">numeric_le</a></li>
<li><a href="#L3815">numeric_ln</a></li>
<li><a href="#L3864">numeric_log</a></li>
<li><a href="#L2475">numeric_lt</a></li>
<li><a href="#L944">numeric_maximum_size</a></li>
<li><a href="#L4187">numeric_min_scale</a></li>
<li><a href="#L3348">numeric_mod</a></li>
<li><a href="#L3368">numeric_mod_opt_error</a></li>
<li><a href="#L3003">numeric_mul</a></li>
<li><a href="#L3023">numeric_mul_opt_error</a></li>
<li><a href="#L2430">numeric_ne</a></li>
<li><a href="#L1017">numeric_normalize</a></li>
<li><a href="#L807">numeric_out</a></li>
<li><a href="#L983">numeric_out_sci</a></li>
<li><a href="#L4750">numeric_pg_lsn</a></li>
<li><a href="#L6098">numeric_poly_avg</a></li>
<li><a href="#L5616">numeric_poly_combine</a></li>
<li><a href="#L5739">numeric_poly_deserialize</a></li>
<li><a href="#L5681">numeric_poly_serialize</a></li>
<li><a href="#L6359">numeric_poly_stddev_internal</a></li>
<li><a href="#L6467">numeric_poly_stddev_pop</a></li>
<li><a href="#L6425">numeric_poly_stddev_samp</a></li>
<li><a href="#L6070">numeric_poly_sum</a></li>
<li><a href="#L6446">numeric_poly_var_pop</a></li>
<li><a href="#L6404">numeric_poly_var_samp</a></li>
<li><a href="#L3935">numeric_power</a></li>
<li><a href="#L1069">numeric_recv</a></li>
<li><a href="#L1534">numeric_round</a></li>
<li><a href="#L4122">numeric_scale</a></li>
<li><a href="#L1154">numeric_send</a></li>
<li><a href="#L5314">numeric_serialize</a></li>
<li><a href="#L1501">numeric_sign</a></li>
<li><a href="#L1469">numeric_sign_internal</a></li>
<li><a href="#L3470">numeric_smaller</a></li>
<li><a href="#L2005">numeric_sortsupport</a></li>
<li><a href="#L3676">numeric_sqrt</a></li>
<li><a href="#L6206">numeric_stddev_internal</a></li>
<li><a href="#L6341">numeric_stddev_pop</a></li>
<li><a href="#L6307">numeric_stddev_samp</a></li>
<li><a href="#L2925">numeric_sub</a></li>
<li><a href="#L2945">numeric_sub_opt_error</a></li>
<li><a href="#L6163">numeric_sum</a></li>
<li><a href="#L1187">numeric_support</a></li>
<li><a href="#L4207">numeric_trim_scale</a></li>
<li><a href="#L1583">numeric_trunc</a></li>
<li><a href="#L918">numeric_typmod_precision</a></li>
<li><a href="#L933">numeric_typmod_scale</a></li>
<li><a href="#L1411">numeric_uminus</a></li>
<li><a href="#L1453">numeric_uplus</a></li>
<li><a href="#L6324">numeric_var_pop</a></li>
<li><a href="#L6290">numeric_var_samp</a></li>
<li><a href="#L1315">numerictypmodin</a></li>
<li><a href="#L1360">numerictypmodout</a></li>
<li><a href="#L7740">numericvar_deserialize</a></li>
<li><a href="#L7724">numericvar_serialize</a></li>
<li><a href="#L8341">numericvar_to_double_no_overflow</a></li>
<li><a href="#L8224">numericvar_to_int128</a></li>
<li><a href="#L4460">numericvar_to_int32</a></li>
<li><a href="#L8029">numericvar_to_int64</a></li>
<li><a href="#L8151">numericvar_to_uint64</a></li>
<li><a href="#L11296">power_ten_int</a></li>
<li><a href="#L10931">power_var</a></li>
<li><a href="#L11092">power_var_int</a></li>
<li><a href="#L4228">random_numeric</a></li>
<li><a href="#L11321">random_var</a></li>
<li><a href="#L11749">round_var</a></li>
<li><a href="#L9777">select_div_scale</a></li>
<li><a href="#L7242">set_var_from_non_decimal_integer_str</a></li>
<li><a href="#L7420">set_var_from_num</a></li>
<li><a href="#L7012">set_var_from_str</a></li>
<li><a href="#L7468">set_var_from_var</a></li>
<li><a href="#L10062">sqrt_var</a></li>
<li><a href="#L11917">strip_var</a></li>
<li><a href="#L11667">sub_abs</a></li>
<li><a href="#L8548">sub_var</a></li>
<li><a href="#L11855">trunc_var</a></li>
<li><a href="#L1829">width_bucket_numeric</a></li>
<li><a href="#L7215">xdigit_value</a></li>
<li><a href="#L6985">zero_var</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L97">DEC_DIGITS</a></li>
<li><a href="#L99">DIV_GUARD_DIGITS</a></li>
<li><a href="#L397">DatumGetNumericAbbrev</a></li>
<li><a href="#L403">DatumGetNumericAbbrev</a></li>
<li><a href="#L96">HALF_NBASE</a></li>
<li><a href="#L98">MUL_GUARD_DIGITS</a></li>
<li><a href="#L4809">NA_TOTAL_COUNT</a></li>
<li><a href="#L95">NBASE</a></li>
<li><a href="#L394">NUMERIC_ABBREV_BITS</a></li>
<li><a href="#L398">NUMERIC_ABBREV_NAN</a></li>
<li><a href="#L404">NUMERIC_ABBREV_NAN</a></li>
<li><a href="#L400">NUMERIC_ABBREV_NINF</a></li>
<li><a href="#L406">NUMERIC_ABBREV_NINF</a></li>
<li><a href="#L399">NUMERIC_ABBREV_PINF</a></li>
<li><a href="#L405">NUMERIC_ABBREV_PINF</a></li>
<li><a href="#L490">NUMERIC_CAN_BE_SHORT</a></li>
<li><a href="#L486">NUMERIC_DIGITS</a></li>
<li><a href="#L242">NUMERIC_DSCALE</a></li>
<li><a href="#L233">NUMERIC_DSCALE_MASK</a></li>
<li><a href="#L234">NUMERIC_DSCALE_MAX</a></li>
<li><a href="#L202">NUMERIC_EXT_FLAGBITS</a></li>
<li><a href="#L196">NUMERIC_EXT_SIGN_MASK</a></li>
<li><a href="#L170">NUMERIC_FLAGBITS</a></li>
<li><a href="#L174">NUMERIC_HDRSZ</a></li>
<li><a href="#L175">NUMERIC_HDRSZ_SHORT</a></li>
<li><a href="#L182">NUMERIC_HEADER_IS_SHORT</a></li>
<li><a href="#L183">NUMERIC_HEADER_SIZE</a></li>
<li><a href="#L200">NUMERIC_INF_SIGN_MASK</a></li>
<li><a href="#L206">NUMERIC_IS_INF</a></li>
<li><a href="#L203">NUMERIC_IS_NAN</a></li>
<li><a href="#L205">NUMERIC_IS_NINF</a></li>
<li><a href="#L204">NUMERIC_IS_PINF</a></li>
<li><a href="#L171">NUMERIC_IS_SHORT</a></li>
<li><a href="#L172">NUMERIC_IS_SPECIAL</a></li>
<li><a href="#L197">NUMERIC_NAN</a></li>
<li><a href="#L488">NUMERIC_NDIGITS</a></li>
<li><a href="#L166">NUMERIC_NEG</a></li>
<li><a href="#L199">NUMERIC_NINF</a></li>
<li><a href="#L198">NUMERIC_PINF</a></li>
<li><a href="#L165">NUMERIC_POS</a></li>
<li><a href="#L167">NUMERIC_SHORT</a></li>
<li><a href="#L214">NUMERIC_SHORT_DSCALE_MASK</a></li>
<li><a href="#L216">NUMERIC_SHORT_DSCALE_MAX</a></li>
<li><a href="#L215">NUMERIC_SHORT_DSCALE_SHIFT</a></li>
<li><a href="#L213">NUMERIC_SHORT_SIGN_MASK</a></li>
<li><a href="#L219">NUMERIC_SHORT_WEIGHT_MASK</a></li>
<li><a href="#L220">NUMERIC_SHORT_WEIGHT_MAX</a></li>
<li><a href="#L221">NUMERIC_SHORT_WEIGHT_MIN</a></li>
<li><a href="#L218">NUMERIC_SHORT_WEIGHT_SIGN_MASK</a></li>
<li><a href="#L236">NUMERIC_SIGN</a></li>
<li><a href="#L164">NUMERIC_SIGN_MASK</a></li>
<li><a href="#L168">NUMERIC_SPECIAL</a></li>
<li><a href="#L246">NUMERIC_WEIGHT</a></li>
<li><a href="#L396">NumericAbbrevGetDatum</a></li>
<li><a href="#L402">NumericAbbrevGetDatum</a></li>
<li><a href="#L476">digitbuf_alloc</a></li>
<li><a href="#L478">digitbuf_free</a></li>
<li><a href="#L472">dump_numeric</a></li>
<li><a href="#L473">dump_var</a></li>
<li><a href="#L484">init_var</a></li>
<li><a href="#L5541">makePolyNumAggState</a></li>
<li><a href="#L5545">makePolyNumAggState</a></li>
<li><a href="#L5542">makePolyNumAggStateCurrentContext</a></li>
<li><a href="#L5546">makePolyNumAggStateCurrentContext</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a>.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; An exact <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> data type for the Postgres database system<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Original coding 1998, Jan Wieck.&nbsp; Heavily revised 2003, Tom Lane.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Many of the algorithmic ideas are borrowed from David M. Smith's &quot;FM&quot;<br/></li>
<li></span><span class="Comment"> * multiple-precision math library, most recently published as Algorithm<br/></li>
<li></span><span class="Comment"> * 786: Multiple-Precision Complex Arithmetic and Functions, ACM<br/></li>
<li></span><span class="Comment"> * Transactions on Mathematical Software, Vol. 24, No. 4, December 1998,<br/></li>
<li></span><span class="Comment"> * pages 359-367.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Copyright (c) 1998-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/adt/<a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a>.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;ctype.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;float.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;limits.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;math.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;common/hashfn.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/int.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;funcapi.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lib/hyperloglog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/pqformat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/nodeFuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/supportnodes.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/array.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/float.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/guc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/<a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/pg_lsn.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/sortsupport.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment"> * Uncomment the following to enable compilation of <a href="#L472" title="utils/adt/numeric.c:472">dump_numeric</a>()<br/></li>
<li></span><span class="Comment"> * and <a href="#L473" title="utils/adt/numeric.c:473">dump_var</a>() and to get a <a href="../../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a> of <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> result produced by <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>().<br/></li>
<li></span><span class="Comment"> * ----------<br/></li>
<li></span><span class="Comment">#define NUMERIC_DEBUG<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment"> * Local data types<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Numeric <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are represented in a base-<a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> floating point format.<br/></li>
<li></span><span class="Comment"> * Each &quot;digit&quot; ranges from 0 to <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>-1.&nbsp; The type <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> is signed<br/></li>
<li></span><span class="Comment"> * and wide enough to store a digit.&nbsp; We assume that <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>*<a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> can fit in<br/></li>
<li></span><span class="Comment"> * an int.&nbsp; Although the purely calculational routines could handle <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> even<br/></li>
<li></span><span class="Comment"> * <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> that's less than sqrt(INT_MAX), in practice we are only interested<br/></li>
<li></span><span class="Comment"> * in <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> a power of ten, so that I/O conversions and decimal rounding<br/></li>
<li></span><span class="Comment"> * are easy.&nbsp; Also, it's actually more efficient if <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> is rather less than<br/></li>
<li></span><span class="Comment"> * sqrt(INT_MAX), so that there is &quot;headroom&quot; for <a href="#L8669" title="utils/adt/numeric.c:8669">mul_var</a> and <a href="#L9185" title="utils/adt/numeric.c:9185">div_var_fast</a> to<br/></li>
<li></span><span class="Comment"> * postpone processing carries.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Values of <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> other than 10000 are considered of historical interest only<br/></li>
<li></span><span class="Comment"> * and are no longer supported in <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> sense; no mechanism exists for the client<br/></li>
<li></span><span class="Comment"> * to discover the base, so every client supporting binary mode expects the<br/></li>
<li></span><span class="Comment"> * base-10000 format.&nbsp; If you plan to change this, also note the <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a><br/></li>
<li></span><span class="Comment"> * abbreviation code, which assumes <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>=10000.<br/></li>
<li></span><span class="Comment"> * ----------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#if 0<br/></li>
<li></span><span class="Comment">#define <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>&nbsp; &nbsp; &nbsp; &nbsp; 10<br/></li>
<li></span><span class="Comment">#define <a href="#L96" title="utils/adt/numeric.c:96">HALF_NBASE</a>&nbsp; &nbsp; 5<br/></li>
<li></span><span class="Comment">#define <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a>&nbsp; &nbsp; 1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* decimal digits per <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> digit */<br/></li>
<li></span><span class="Comment">#define <a href="#L98" title="utils/adt/numeric.c:98">MUL_GUARD_DIGITS</a>&nbsp; &nbsp; 4&nbsp; &nbsp; /* these are measured in <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> digits */<br/></li>
<li></span><span class="Comment">#define <a href="#L99" title="utils/adt/numeric.c:99">DIV_GUARD_DIGITS</a>&nbsp; &nbsp; 8<br/></li>
<li></span><br/></li>
<li><span class="Comment">typedef signed char <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a>;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#if 0<br/></li>
<li></span><span class="Comment">#define <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>&nbsp; &nbsp; &nbsp; &nbsp; 100<br/></li>
<li></span><span class="Comment">#define <a href="#L96" title="utils/adt/numeric.c:96">HALF_NBASE</a>&nbsp; &nbsp; 50<br/></li>
<li></span><span class="Comment">#define <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a>&nbsp; &nbsp; 2&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* decimal digits per <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> digit */<br/></li>
<li></span><span class="Comment">#define <a href="#L98" title="utils/adt/numeric.c:98">MUL_GUARD_DIGITS</a>&nbsp; &nbsp; 3&nbsp; &nbsp; /* these are measured in <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> digits */<br/></li>
<li></span><span class="Comment">#define <a href="#L99" title="utils/adt/numeric.c:99">DIV_GUARD_DIGITS</a>&nbsp; &nbsp; 6<br/></li>
<li></span><br/></li>
<li><span class="Comment">typedef signed char <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a>;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#if 1<br/></li>
<li><a id="L95">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NBASE</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">10000<br/></li>
<li><a id="L96">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">HALF_NBASE</span>&nbsp; &nbsp; </span><span class="Constant">5000<br/></li>
<li><a id="L97">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">DEC_DIGITS</span>&nbsp; &nbsp; </span><span class="Constant">4</span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* decimal digits per <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> digit */<br/></li>
<li><a id="L98">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MUL_GUARD_DIGITS</span>&nbsp; &nbsp; </span><span class="Constant">2</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* these are measured in <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> digits */<br/></li>
<li><a id="L99">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">DIV_GUARD_DIGITS</span>&nbsp; &nbsp; </span><span class="Constant">4<br/></li>
<li></span><br/></li>
<li><a id="L101">&#x200c;</a><span class="Type">typedef</span><span class="cCppInIf"> int16 <span class="linkable">NumericDigit</span>;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The Numeric type as stored on disk.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the high bits of the first <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> of a <a href="#L146" title="utils/adt/numeric.c:146">NumericChoice</a> (n_header, or<br/></li>
<li></span><span class="Comment"> * n_short.n_header, or n_long.n_sign_dscale) are <a href="#L167" title="utils/adt/numeric.c:167">NUMERIC_SHORT</a>, then the<br/></li>
<li></span><span class="Comment"> * <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> follows the <a href="#L133" title="utils/adt/numeric.c:133">NumericShort</a> format; if they are <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a> or<br/></li>
<li></span><span class="Comment"> * <a href="#L166" title="utils/adt/numeric.c:166">NUMERIC_NEG</a>, it follows the <a href="#L139" title="utils/adt/numeric.c:139">NumericLong</a> format. If they are <a href="#L168" title="utils/adt/numeric.c:168">NUMERIC_SPECIAL</a>,<br/></li>
<li></span><span class="Comment"> * the value is a NaN or Infinity.&nbsp; We currently always store SPECIAL <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment"> * using just two bytes (i.e. only n_header), but previous releases used only<br/></li>
<li></span><span class="Comment"> * the <a href="#L139" title="utils/adt/numeric.c:139">NumericLong</a> format, so we might <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> 4-byte NaNs (though not infinities)<br/></li>
<li></span><span class="Comment"> * on disk if a database has been migrated using pg_upgrade.&nbsp; In either case,<br/></li>
<li></span><span class="Comment"> * the low-order bits of a special value's header are reserved and currently<br/></li>
<li></span><span class="Comment"> * should always be set to zero.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In the <a href="#L133" title="utils/adt/numeric.c:133">NumericShort</a> format, the remaining 14 bits of the header <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a><br/></li>
<li></span><span class="Comment"> * (n_short.n_header) are allocated as follows: 1 for sign (positive or<br/></li>
<li></span><span class="Comment"> * negative), 6 for dynamic scale, and 7 for weight.&nbsp; In practice, most<br/></li>
<li></span><span class="Comment"> * commonly-encountered <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> can be represented this way.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In the <a href="#L139" title="utils/adt/numeric.c:139">NumericLong</a> format, the remaining 14 bits of the header <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a><br/></li>
<li></span><span class="Comment"> * (n_long.n_sign_dscale) represent the display scale; and the weight is<br/></li>
<li></span><span class="Comment"> * stored separately in n_weight.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: by convention, <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in the packed form have been stripped of<br/></li>
<li></span><span class="Comment"> * all leading and trailing zero digits (where a &quot;digit&quot; is of base <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>).<br/></li>
<li></span><span class="Comment"> * In particular, if the value is zero, there will be no digits at all!<br/></li>
<li></span><span class="Comment"> * The weight is arbitrary in that case, but we normally set it to zero.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><a id="L133">&#x200c;</a><span class="Type">struct</span> <span class="linkable">NumericShort</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; n_header;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Sign + display scale + weight */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> n_data[FLEXIBLE_ARRAY_MEMBER]; <span class="Comment">/* Digits */<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><a id="L139">&#x200c;</a><span class="Type">struct</span> <span class="linkable">NumericLong</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; n_sign_dscale;&nbsp; &nbsp; <span class="Comment">/* Sign + display scale */<br/></li>
<li></span>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; n_weight;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Weight of 1st digit&nbsp; &nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> n_data[FLEXIBLE_ARRAY_MEMBER]; <span class="Comment">/* Digits */<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><a id="L146">&#x200c;</a><span class="Type">union</span> <span class="linkable">NumericChoice</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; n_header;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Header <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L139" title="utils/adt/numeric.c:139">NumericLong</a> n_long;&nbsp; &nbsp; <span class="Comment">/* Long form (4-byte header) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L133" title="utils/adt/numeric.c:133">NumericShort</a> n_short;&nbsp; &nbsp; <span class="Comment">/* Short form (2-byte header) */<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><a id="L153">&#x200c;</a><span class="Type">struct</span> <span class="linkable">NumericData</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; vl_len_;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* varlena header (do not touch directly!) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">union</span> <a href="#L146" title="utils/adt/numeric.c:146">NumericChoice</a> choice; <span class="Comment">/* choice of format */<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Interpretation of high bits.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><a id="L164">&#x200c;</a><span class="PreProc">#define <span class="linkable">NUMERIC_SIGN_MASK</span>&nbsp; &nbsp; </span><span class="Constant">0xC000<br/></li>
<li><a id="L165">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NUMERIC_POS</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0x0000<br/></li>
<li><a id="L166">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NUMERIC_NEG</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0x4000<br/></li>
<li><a id="L167">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NUMERIC_SHORT</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0x8000<br/></li>
<li><a id="L168">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NUMERIC_SPECIAL</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0xC000<br/></li>
<li></span><br/></li>
<li><a id="L170">&#x200c;</a><span class="PreProc">#define <span class="linkable">NUMERIC_FLAGBITS</span>(n) ((n)-&gt;choice.n_header &amp; <a href="#L164" title="utils/adt/numeric.c:164">NUMERIC_SIGN_MASK</a>)<br/></li>
<li><a id="L171">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NUMERIC_IS_SHORT</span>(n)&nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L170" title="utils/adt/numeric.c:170">NUMERIC_FLAGBITS</a>(n) == <a href="#L167" title="utils/adt/numeric.c:167">NUMERIC_SHORT</a>)<br/></li>
<li><a id="L172">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NUMERIC_IS_SPECIAL</span>(n)&nbsp; &nbsp; (<a href="#L170" title="utils/adt/numeric.c:170">NUMERIC_FLAGBITS</a>(n) == <a href="#L168" title="utils/adt/numeric.c:168">NUMERIC_SPECIAL</a>)<br/></li>
<li></span><br/></li>
<li><a id="L174">&#x200c;</a><span class="PreProc">#define <span class="linkable">NUMERIC_HDRSZ</span>&nbsp; &nbsp; (VARHDRSZ + </span><span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(uint16) + </span><span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(int16))<br/></li>
<li><a id="L175">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NUMERIC_HDRSZ_SHORT</span> (VARHDRSZ + </span><span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(uint16))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * If the flag bits are <a href="#L167" title="utils/adt/numeric.c:167">NUMERIC_SHORT</a> or <a href="#L168" title="utils/adt/numeric.c:168">NUMERIC_SPECIAL</a>, we want the short<br/></li>
<li></span><span class="Comment"> * header; otherwise, we want the long one.&nbsp; Instead of testing against each<br/></li>
<li></span><span class="Comment"> * value, we can just look at the high <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>, for a slight efficiency gain.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L182">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NUMERIC_HEADER_IS_SHORT</span>(n)&nbsp; &nbsp; (((n)-&gt;choice.n_header &amp; </span><span class="Constant">0x8000</span><span class="PreProc">) != </span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li><a id="L183">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NUMERIC_HEADER_SIZE</span>(n) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (VARHDRSZ + </span><span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(uint16) + \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp;&nbsp; (<a href="#L182" title="utils/adt/numeric.c:182">NUMERIC_HEADER_IS_SHORT</a>(n) ? </span><span class="Constant">0</span><span class="PreProc"> : </span><span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(int16)))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Definitions for special <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> (NaN, positive infinity, negative infinity).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The two bits after the <a href="#L168" title="utils/adt/numeric.c:168">NUMERIC_SPECIAL</a> bits are 00 for NaN, 01 for positive<br/></li>
<li></span><span class="Comment"> * infinity, 11 for negative infinity.&nbsp; (This makes the sign <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> match where<br/></li>
<li></span><span class="Comment"> * it is in a short-format value, though we make no use of that at present.)<br/></li>
<li></span><span class="Comment"> * We could mask off the remaining bits <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> testing the active bits, but<br/></li>
<li></span><span class="Comment"> * currently those bits must be zeroes, so masking would just add cycles.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L196">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NUMERIC_EXT_SIGN_MASK</span>&nbsp; &nbsp; </span><span class="Constant">0xF000</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* high bits plus NaN/Inf flag bits */<br/></li>
<li><a id="L197">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NUMERIC_NAN</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0xC000<br/></li>
<li><a id="L198">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NUMERIC_PINF</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0xD000<br/></li>
<li><a id="L199">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NUMERIC_NINF</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0xF000<br/></li>
<li><a id="L200">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NUMERIC_INF_SIGN_MASK</span>&nbsp; &nbsp; </span><span class="Constant">0x2000<br/></li>
<li></span><br/></li>
<li><a id="L202">&#x200c;</a><span class="PreProc">#define <span class="linkable">NUMERIC_EXT_FLAGBITS</span>(n)&nbsp; &nbsp; ((n)-&gt;choice.n_header &amp; <a href="#L196" title="utils/adt/numeric.c:196">NUMERIC_EXT_SIGN_MASK</a>)<br/></li>
<li><a id="L203">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NUMERIC_IS_NAN</span>(n)&nbsp; &nbsp; &nbsp; &nbsp; ((n)-&gt;choice.n_header == <a href="#L197" title="utils/adt/numeric.c:197">NUMERIC_NAN</a>)<br/></li>
<li><a id="L204">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NUMERIC_IS_PINF</span>(n)&nbsp; &nbsp; &nbsp; &nbsp; ((n)-&gt;choice.n_header == <a href="#L198" title="utils/adt/numeric.c:198">NUMERIC_PINF</a>)<br/></li>
<li><a id="L205">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NUMERIC_IS_NINF</span>(n)&nbsp; &nbsp; &nbsp; &nbsp; ((n)-&gt;choice.n_header == <a href="#L199" title="utils/adt/numeric.c:199">NUMERIC_NINF</a>)<br/></li>
<li><a id="L206">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NUMERIC_IS_INF</span>(n) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (((n)-&gt;choice.n_header &amp; ~<a href="#L200" title="utils/adt/numeric.c:200">NUMERIC_INF_SIGN_MASK</a>) == <a href="#L198" title="utils/adt/numeric.c:198">NUMERIC_PINF</a>)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Short format definitions.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><a id="L213">&#x200c;</a><span class="PreProc">#define <span class="linkable">NUMERIC_SHORT_SIGN_MASK</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0x2000<br/></li>
<li><a id="L214">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NUMERIC_SHORT_DSCALE_MASK</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0x1F80<br/></li>
<li><a id="L215">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NUMERIC_SHORT_DSCALE_SHIFT</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">7<br/></li>
<li><a id="L216">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NUMERIC_SHORT_DSCALE_MAX</span>&nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (<a href="#L214" title="utils/adt/numeric.c:214">NUMERIC_SHORT_DSCALE_MASK</a> &gt;&gt; <a href="#L215" title="utils/adt/numeric.c:215">NUMERIC_SHORT_DSCALE_SHIFT</a>)<br/></li>
<li><a id="L218">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NUMERIC_SHORT_WEIGHT_SIGN_MASK</span>&nbsp; &nbsp; </span><span class="Constant">0x0040<br/></li>
<li><a id="L219">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NUMERIC_SHORT_WEIGHT_MASK</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0x003F<br/></li>
<li><a id="L220">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NUMERIC_SHORT_WEIGHT_MAX</span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L219" title="utils/adt/numeric.c:219">NUMERIC_SHORT_WEIGHT_MASK</a><br/></li>
<li><a id="L221">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NUMERIC_SHORT_WEIGHT_MIN</span>&nbsp; &nbsp; &nbsp; &nbsp; (-(<a href="#L219" title="utils/adt/numeric.c:219">NUMERIC_SHORT_WEIGHT_MASK</a>+</span><span class="Constant">1</span><span class="PreProc">))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Extract sign, display scale, weight.&nbsp; These macros extract field <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment"> * suitable for the <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> format from the Numeric (on-disk) format.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that we don't trouble to ensure that dscale and weight read as zero<br/></li>
<li></span><span class="Comment"> * for an infinity; however, that doesn't matter since we never convert<br/></li>
<li></span><span class="Comment"> * &quot;special&quot; numerics to <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> form.&nbsp; Only the constants defined below<br/></li>
<li></span><span class="Comment"> * (<a href="#L449" title="utils/adt/numeric.c:449">const_nan</a>, etc) ever represent a non-finite value as a <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><a id="L233">&#x200c;</a><span class="PreProc">#define <span class="linkable">NUMERIC_DSCALE_MASK</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0x3FFF<br/></li>
<li><a id="L234">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NUMERIC_DSCALE_MAX</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L233" title="utils/adt/numeric.c:233">NUMERIC_DSCALE_MASK</a><br/></li>
<li></span><br/></li>
<li><a id="L236">&#x200c;</a><span class="PreProc">#define <span class="linkable">NUMERIC_SIGN</span>(n) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (<a href="#L171" title="utils/adt/numeric.c:171">NUMERIC_IS_SHORT</a>(n) ? \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; (((n)-&gt;choice.n_short.n_header &amp; <a href="#L213" title="utils/adt/numeric.c:213">NUMERIC_SHORT_SIGN_MASK</a>) ? \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L166" title="utils/adt/numeric.c:166">NUMERIC_NEG</a> : <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a>) : \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(n) ? \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L202" title="utils/adt/numeric.c:202">NUMERIC_EXT_FLAGBITS</a>(n) : <a href="#L170" title="utils/adt/numeric.c:170">NUMERIC_FLAGBITS</a>(n)))<br/></li>
<li><a id="L242">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NUMERIC_DSCALE</span>(n)&nbsp; &nbsp; (<a href="#L182" title="utils/adt/numeric.c:182">NUMERIC_HEADER_IS_SHORT</a>((n)) ? \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((n)-&gt;choice.n_short.n_header &amp; <a href="#L214" title="utils/adt/numeric.c:214">NUMERIC_SHORT_DSCALE_MASK</a>) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &gt;&gt; <a href="#L215" title="utils/adt/numeric.c:215">NUMERIC_SHORT_DSCALE_SHIFT</a> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; : ((n)-&gt;choice.n_long.n_sign_dscale &amp; <a href="#L233" title="utils/adt/numeric.c:233">NUMERIC_DSCALE_MASK</a>))<br/></li>
<li><a id="L246">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NUMERIC_WEIGHT</span>(n)&nbsp; &nbsp; (<a href="#L182" title="utils/adt/numeric.c:182">NUMERIC_HEADER_IS_SHORT</a>((n)) ? \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (((n)-&gt;choice.n_short.n_header &amp; <a href="#L218" title="utils/adt/numeric.c:218">NUMERIC_SHORT_WEIGHT_SIGN_MASK</a> ? \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; ~<a href="#L219" title="utils/adt/numeric.c:219">NUMERIC_SHORT_WEIGHT_MASK</a> : </span><span class="Constant">0</span><span class="PreProc">) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp;&nbsp; | ((n)-&gt;choice.n_short.n_header &amp; <a href="#L219" title="utils/adt/numeric.c:219">NUMERIC_SHORT_WEIGHT_MASK</a>)) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; : ((n)-&gt;choice.n_long.n_weight))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment"> * <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> is the format we use for arithmetic.&nbsp; The digit-array part<br/></li>
<li></span><span class="Comment"> * is the same as the <a href="#L153" title="utils/adt/numeric.c:153">NumericData</a> storage format, but the header is more<br/></li>
<li></span><span class="Comment"> * complex.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The value represented by a <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> is determined by the sign, weight,<br/></li>
<li></span><span class="Comment"> * ndigits, and digits[] array.&nbsp; If it is a &quot;special&quot; value (NaN or Inf)<br/></li>
<li></span><span class="Comment"> * then only the sign field matters; ndigits should be zero, and the weight<br/></li>
<li></span><span class="Comment"> * and dscale fields are ignored.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: the first digit of a <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>'s value is assumed to be multiplied<br/></li>
<li></span><span class="Comment"> * by <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> ** weight.&nbsp; Another way to say it is that there are weight+1<br/></li>
<li></span><span class="Comment"> * digits <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the decimal point.&nbsp; It is possible to have weight &lt; 0.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * buf points at the physical start of the <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d digit buffer for the<br/></li>
<li></span><span class="Comment"> * <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>.&nbsp; digits points at the first digit in actual use (the one<br/></li>
<li></span><span class="Comment"> * with the specified weight).&nbsp; We normally leave an unused digit or two<br/></li>
<li></span><span class="Comment"> * (preset to zeroes) between buf and digits, so that there is room to store<br/></li>
<li></span><span class="Comment"> * a carry out of the top digit without reallocating space.&nbsp; We just need to<br/></li>
<li></span><span class="Comment"> * decrement digits (and increment weight) to make room for the carry digit.<br/></li>
<li></span><span class="Comment"> * (There is no such extra space in a <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> value stored in the database,<br/></li>
<li></span><span class="Comment"> * only in a <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> in memory.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If buf is NULL then the digit buffer isn't actually <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d and should<br/></li>
<li></span><span class="Comment"> * not be freed --- see the constants below for an example.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * dscale, or display scale, is the nominal precision expressed as number<br/></li>
<li></span><span class="Comment"> * of digits after the decimal point (it must always be &gt;= 0 at present).<br/></li>
<li></span><span class="Comment"> * dscale may be more than the number of physically stored fractional digits,<br/></li>
<li></span><span class="Comment"> * implying that we have suppressed storage of significant trailing zeroes.<br/></li>
<li></span><span class="Comment"> * It should never be less than the number of stored digits, since that would<br/></li>
<li></span><span class="Comment"> * imply hiding digits that are present.&nbsp; <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a> that dscale is always expressed<br/></li>
<li></span><span class="Comment"> * in *decimal* digits, and so it may correspond to a fractional number of<br/></li>
<li></span><span class="Comment"> * base-<a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> digits --- divide by <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> to convert to <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> digits.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * rscale, or result scale, is the target precision for a computation.<br/></li>
<li></span><span class="Comment"> * Like dscale it is expressed as number of *decimal* digits after the decimal<br/></li>
<li></span><span class="Comment"> * point, and is always &gt;= 0 at present.<br/></li>
<li></span><span class="Comment"> * Note that rscale is not stored in variables --- it's figured on-the-fly<br/></li>
<li></span><span class="Comment"> * from the dscales of the inputs.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * While we consistently use &quot;weight&quot; to refer to the base-<a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> weight of<br/></li>
<li></span><span class="Comment"> * a <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> value, it is convenient in some scale-related calculations to<br/></li>
<li></span><span class="Comment"> * make use of the base-10 weight (ie, the approximate log10 of the value).<br/></li>
<li></span><span class="Comment"> * To avoid confusion, such a decimal-units weight is called a &quot;dweight&quot;.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: All the variable-level <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> are written in a style that makes it<br/></li>
<li></span><span class="Comment"> * possible to give one and the same variable as argument and destination.<br/></li>
<li></span><span class="Comment"> * This is feasible because the digit buffer is separate from the variable.<br/></li>
<li></span><span class="Comment"> * ----------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L303">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">NumericVar</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndigits;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* # of digits in digits[] - can be 0! */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; weight;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* weight of first digit */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sign;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a>, _NEG, _NAN, _PINF, or _NINF */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dscale;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* display scale */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> *buf;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* start of <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d space for digits[] */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> *digits;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* base-<a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> digits */<br/></li>
<li><a id="L311">&#x200c;</a></span>} <span class="linkable">NumericVar</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment"> * Data for generate_series<br/></li>
<li></span><span class="Comment"> * ----------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; current;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; stop;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; step;<br/></li>
<li><a id="L323">&#x200c;</a>} <span class="linkable">generate_series_numeric_fctx</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment"> * Sort support.<br/></li>
<li></span><span class="Comment"> * ----------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *buf;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* buffer for short varlenas */<br/></li>
<li></span>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; input_count;&nbsp; &nbsp; <span class="Comment">/* number of non-null <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> seen */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; estimating;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* true if estimating cardinality */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; hyperLogLogState abbr_card; <span class="Comment">/* cardinality estimator */<br/></li>
<li><a id="L337">&#x200c;</a></span>} <span class="linkable">NumericSortSupport</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment"> * Fast sum accumulator.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L370" title="utils/adt/numeric.c:370">NumericSumAccum</a> is used to implement SUM(), and other standard aggregates<br/></li>
<li></span><span class="Comment"> * that track the sum of input <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.&nbsp; It uses 32-<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> integers to store the<br/></li>
<li></span><span class="Comment"> * digits, instead of the normal 16-<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> integers (with <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>=10000).&nbsp; This<br/></li>
<li></span><span class="Comment"> * way, we can safely accumulate up to <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> - 1 <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> without propagating<br/></li>
<li></span><span class="Comment"> * carry, <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> risking overflow of <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the digits.&nbsp; 'num_uncarried'<br/></li>
<li></span><span class="Comment"> * tracks how many <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> have been accumulated without propagating carry.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Positive and negative <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are accumulated separately, in 'pos_digits'<br/></li>
<li></span><span class="Comment"> * and 'neg_digits'.&nbsp; This is simpler and faster than deciding whether to add<br/></li>
<li></span><span class="Comment"> * or subtract from the current value, for each new value (see <a href="#L8548" title="utils/adt/numeric.c:8548">sub_var</a>() for<br/></li>
<li></span><span class="Comment"> * the logic we avoid by doing this).&nbsp; Both buffers are of same size, and<br/></li>
<li></span><span class="Comment"> * have the same weight and scale.&nbsp; In <a href="#L12184" title="utils/adt/numeric.c:12184">accum_sum_final</a>(), the positive and<br/></li>
<li></span><span class="Comment"> * negative sums are added together to produce the final result.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When a new value has a larger ndigits or weight than the accumulator<br/></li>
<li></span><span class="Comment"> * currently does, the accumulator is enlarged to accommodate the new value.<br/></li>
<li></span><span class="Comment"> * We normally have one zero digit reserved for carry propagation, and that<br/></li>
<li></span><span class="Comment"> * is indicated by the 'have_carry_space' flag.&nbsp; When <a href="#L12022" title="utils/adt/numeric.c:12022">accum_sum_carry</a>() uses<br/></li>
<li></span><span class="Comment"> * up the reserved digit, it clears the 'have_carry_space' flag.&nbsp; The <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment"> * call to <a href="#L11974" title="utils/adt/numeric.c:11974">accum_sum_add</a>() will enlarge the buffer, to make room for the<br/></li>
<li></span><span class="Comment"> * extra digit, and set the flag again.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> a new accumulator, simply reset all fields to zeros.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The accumulator does not handle NaNs.<br/></li>
<li></span><span class="Comment"> * ----------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L370">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">NumericSumAccum</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndigits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; weight;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dscale;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_uncarried;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; have_carry_space;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp;&nbsp; *pos_digits;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp;&nbsp; *neg_digits;<br/></li>
<li><a id="L379">&#x200c;</a>} <span class="linkable">NumericSumAccum</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * We define our own macros for packing and unpacking abbreviated-key<br/></li>
<li></span><span class="Comment"> * representations for <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in order to avoid depending on<br/></li>
<li></span><span class="Comment"> * USE_FLOAT8_BYVAL.&nbsp; The type of abbreviation we use is based only on<br/></li>
<li></span><span class="Comment"> * the size of a datum, not the argument-passing convention for float8.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of abbreviations for finite <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> is from +PG_INT64/32_MAX<br/></li>
<li></span><span class="Comment"> * to -PG_INT64/32_MAX.&nbsp; NaN has the abbreviation PG_INT64/32_MIN, and we<br/></li>
<li></span><span class="Comment"> * define the sort ordering to make that work out properly (see further<br/></li>
<li></span><span class="Comment"> * comments below).&nbsp; PINF and NINF share the abbreviations of the largest<br/></li>
<li></span><span class="Comment"> * and smallest finite abbreviation classes.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L394">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NUMERIC_ABBREV_BITS</span> (SIZEOF_DATUM * BITS_PER_BYTE)<br/></li>
<li></span><span class="PreProc">#if SIZEOF_DATUM == </span><span class="Constant">8<br/></li>
<li><a id="L396">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NumericAbbrevGetDatum</span>(X) ((Datum) (X))<br/></li>
<li><a id="L397">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">DatumGetNumericAbbrev</span>(X) ((int64) (X))<br/></li>
<li><a id="L398">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NUMERIC_ABBREV_NAN</span>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L396" title="utils/adt/numeric.c:396">NumericAbbrevGetDatum</a>(PG_INT64_MIN)<br/></li>
<li><a id="L399">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NUMERIC_ABBREV_PINF</span>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L396" title="utils/adt/numeric.c:396">NumericAbbrevGetDatum</a>(-PG_INT64_MAX)<br/></li>
<li><a id="L400">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NUMERIC_ABBREV_NINF</span>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L396" title="utils/adt/numeric.c:396">NumericAbbrevGetDatum</a>(PG_INT64_MAX)<br/></li>
<li></span><span class="PreProc">#else<br/></li>
<li><a id="L402">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NumericAbbrevGetDatum</span>(X) ((Datum) (X))<br/></li>
<li><a id="L403">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">DatumGetNumericAbbrev</span>(X) ((int32) (X))<br/></li>
<li><a id="L404">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NUMERIC_ABBREV_NAN</span>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L396" title="utils/adt/numeric.c:396">NumericAbbrevGetDatum</a>(PG_INT32_MIN)<br/></li>
<li><a id="L405">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NUMERIC_ABBREV_PINF</span>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L396" title="utils/adt/numeric.c:396">NumericAbbrevGetDatum</a>(-PG_INT32_MAX)<br/></li>
<li><a id="L406">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NUMERIC_ABBREV_NINF</span>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L396" title="utils/adt/numeric.c:396">NumericAbbrevGetDatum</a>(PG_INT32_MAX)<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment"> * Some preinitialized constants<br/></li>
<li></span><span class="Comment"> * ----------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L414">&#x200c;</a></span><span class="Type">static</span> <span class="Type">const</span> <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> <span class="linkable">const_zero_data</span>[<span class="Constant">1</span>] = {<span class="Constant">0</span>};<br/></li>
<li><a id="L415">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> <span class="linkable">const_zero</span> =<br/></li>
<li>{<span class="Constant">0</span>, <span class="Constant">0</span>, <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a>, <span class="Constant">0</span>, <span class="Constant">NULL</span>, (<a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> *) <a href="#L414" title="utils/adt/numeric.c:414">const_zero_data</a>};<br/></li>
<li><br/></li>
<li><a id="L418">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> <span class="linkable">const_one_data</span>[<span class="Constant">1</span>] = {<span class="Constant">1</span>};<br/></li>
<li><a id="L419">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> <span class="linkable">const_one</span> =<br/></li>
<li>{<span class="Constant">1</span>, <span class="Constant">0</span>, <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a>, <span class="Constant">0</span>, <span class="Constant">NULL</span>, (<a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> *) <a href="#L418" title="utils/adt/numeric.c:418">const_one_data</a>};<br/></li>
<li><br/></li>
<li><a id="L422">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> <span class="linkable">const_minus_one</span> =<br/></li>
<li>{<span class="Constant">1</span>, <span class="Constant">0</span>, <a href="#L166" title="utils/adt/numeric.c:166">NUMERIC_NEG</a>, <span class="Constant">0</span>, <span class="Constant">NULL</span>, (<a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> *) <a href="#L418" title="utils/adt/numeric.c:418">const_one_data</a>};<br/></li>
<li><br/></li>
<li><a id="L425">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> <span class="linkable">const_two_data</span>[<span class="Constant">1</span>] = {<span class="Constant">2</span>};<br/></li>
<li><a id="L426">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> <span class="linkable">const_two</span> =<br/></li>
<li>{<span class="Constant">1</span>, <span class="Constant">0</span>, <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a>, <span class="Constant">0</span>, <span class="Constant">NULL</span>, (<a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> *) <a href="#L425" title="utils/adt/numeric.c:425">const_two_data</a>};<br/></li>
<li><br/></li>
<li><span class="PreProc">#if <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> == </span><span class="Constant">4<br/></li>
<li><a id="L430">&#x200c;</a></span><span class="Type">static</span> <span class="Type">const</span> <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> <span class="linkable">const_zero_point_nine_data</span>[<span class="Constant">1</span>] = {<span class="Constant">9000</span>};<br/></li>
<li><span class="PreProc">#elif <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> == </span><span class="Constant">2<br/></li>
<li><a id="L432">&#x200c;</a></span><span class="Type">static</span> <span class="Type">const</span> <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> <span class="linkable">const_zero_point_nine_data</span>[<span class="Constant">1</span>] = {<span class="Constant">90</span>};<br/></li>
<li><span class="PreProc">#elif <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> == </span><span class="Constant">1<br/></li>
<li><a id="L434">&#x200c;</a></span><span class="Type">static</span> <span class="Type">const</span> <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> <span class="linkable">const_zero_point_nine_data</span>[<span class="Constant">1</span>] = {<span class="Constant">9</span>};<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li><a id="L436">&#x200c;</a></span><span class="Type">static</span> <span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> <span class="linkable">const_zero_point_nine</span> =<br/></li>
<li>{<span class="Constant">1</span>, -<span class="Constant">1</span>, <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a>, <span class="Constant">1</span>, <span class="Constant">NULL</span>, (<a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> *) <a href="#L430" title="utils/adt/numeric.c:430">const_zero_point_nine_data</a>};<br/></li>
<li><br/></li>
<li><span class="PreProc">#if <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> == </span><span class="Constant">4<br/></li>
<li><a id="L440">&#x200c;</a></span><span class="Type">static</span> <span class="Type">const</span> <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> <span class="linkable">const_one_point_one_data</span>[<span class="Constant">2</span>] = {<span class="Constant">1</span>, <span class="Constant">1000</span>};<br/></li>
<li><span class="PreProc">#elif <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> == </span><span class="Constant">2<br/></li>
<li><a id="L442">&#x200c;</a></span><span class="Type">static</span> <span class="Type">const</span> <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> <span class="linkable">const_one_point_one_data</span>[<span class="Constant">2</span>] = {<span class="Constant">1</span>, <span class="Constant">10</span>};<br/></li>
<li><span class="PreProc">#elif <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> == </span><span class="Constant">1<br/></li>
<li><a id="L444">&#x200c;</a></span><span class="Type">static</span> <span class="Type">const</span> <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> <span class="linkable">const_one_point_one_data</span>[<span class="Constant">2</span>] = {<span class="Constant">1</span>, <span class="Constant">1</span>};<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li><a id="L446">&#x200c;</a></span><span class="Type">static</span> <span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> <span class="linkable">const_one_point_one</span> =<br/></li>
<li>{<span class="Constant">2</span>, <span class="Constant">0</span>, <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a>, <span class="Constant">1</span>, <span class="Constant">NULL</span>, (<a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> *) <a href="#L440" title="utils/adt/numeric.c:440">const_one_point_one_data</a>};<br/></li>
<li><br/></li>
<li><a id="L449">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> <span class="linkable">const_nan</span> =<br/></li>
<li>{<span class="Constant">0</span>, <span class="Constant">0</span>, <a href="#L197" title="utils/adt/numeric.c:197">NUMERIC_NAN</a>, <span class="Constant">0</span>, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>};<br/></li>
<li><br/></li>
<li><a id="L452">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> <span class="linkable">const_pinf</span> =<br/></li>
<li>{<span class="Constant">0</span>, <span class="Constant">0</span>, <a href="#L198" title="utils/adt/numeric.c:198">NUMERIC_PINF</a>, <span class="Constant">0</span>, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>};<br/></li>
<li><br/></li>
<li><a id="L455">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> <span class="linkable">const_ninf</span> =<br/></li>
<li>{<span class="Constant">0</span>, <span class="Constant">0</span>, <a href="#L199" title="utils/adt/numeric.c:199">NUMERIC_NINF</a>, <span class="Constant">0</span>, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>};<br/></li>
<li><br/></li>
<li><span class="PreProc">#if <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> == </span><span class="Constant">4<br/></li>
<li><a id="L459">&#x200c;</a></span><span class="Type">static</span> <span class="Type">const</span> <span class="Type">int</span> <span class="linkable">round_powers</span>[<span class="Constant">4</span>] = {<span class="Constant">0</span>, <span class="Constant">1000</span>, <span class="Constant">100</span>, <span class="Constant">10</span>};<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment"> * Local <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> * ----------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef NUMERIC_DEBUG<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L472" title="utils/adt/numeric.c:472">dump_numeric</a>(<span class="Type">const</span> <span class="Type">char</span> *str, Numeric num);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L473" title="utils/adt/numeric.c:473">dump_var</a>(<span class="Type">const</span> <span class="Type">char</span> *str, <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li><a id="L472">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">dump_numeric</span>(s,n)<br/></li>
<li><a id="L473">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">dump_var</span>(s,v)<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><a id="L476">&#x200c;</a><span class="PreProc">#define <span class="linkable">digitbuf_alloc</span>(ndigits)&nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((<a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>((ndigits) * </span><span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(<a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a>)))<br/></li>
<li><a id="L478">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">digitbuf_free</span>(buf)&nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">do</span><span class="PreProc"> { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="Statement">if</span><span class="PreProc"> ((buf) != </span><span class="Constant">NULL</span><span class="PreProc">) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(buf); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; } </span><span class="Statement">while</span><span class="PreProc"> (</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><a id="L484">&#x200c;</a><span class="PreProc">#define <span class="linkable">init_var</span>(v)&nbsp; &nbsp; &nbsp; &nbsp; memset(v, </span><span class="Constant">0</span><span class="PreProc">, </span><span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(<a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>))<br/></li>
<li></span><br/></li>
<li><a id="L486">&#x200c;</a><span class="PreProc">#define <span class="linkable">NUMERIC_DIGITS</span>(num) (<a href="#L182" title="utils/adt/numeric.c:182">NUMERIC_HEADER_IS_SHORT</a>(num) ? \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (num)-&gt;choice.n_short.n_data : (num)-&gt;choice.n_long.n_data)<br/></li>
<li><a id="L488">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NUMERIC_NDIGITS</span>(num) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((VARSIZE(num) - <a href="#L183" title="utils/adt/numeric.c:183">NUMERIC_HEADER_SIZE</a>(num)) / </span><span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(<a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a>))<br/></li>
<li><a id="L490">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NUMERIC_CAN_BE_SHORT</span>(scale,weight) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((scale) &lt;= <a href="#L216" title="utils/adt/numeric.c:216">NUMERIC_SHORT_DSCALE_MAX</a> &amp;&amp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (weight) &lt;= <a href="#L220" title="utils/adt/numeric.c:220">NUMERIC_SHORT_WEIGHT_MAX</a> &amp;&amp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (weight) &gt;= <a href="#L221" title="utils/adt/numeric.c:221">NUMERIC_SHORT_WEIGHT_MIN</a>)<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L6953" title="utils/adt/numeric.c:6953">alloc_var</a>(<a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var, <span class="Type">int</span> ndigits);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(<a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L6985" title="utils/adt/numeric.c:6985">zero_var</a>(<a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L7012" title="utils/adt/numeric.c:7012">set_var_from_str</a>(<span class="Type">const</span> <span class="Type">char</span> *str, <span class="Type">const</span> <span class="Type">char</span> *cp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *dest, <span class="Type">const</span> <span class="Type">char</span> **endptr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Node *escontext);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L7242" title="utils/adt/numeric.c:7242">set_var_from_non_decimal_integer_str</a>(<span class="Type">const</span> <span class="Type">char</span> *str,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *cp, <span class="Type">int</span> sign,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> base, <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *dest,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> **endptr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Node *escontext);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L7420" title="utils/adt/numeric.c:7420">set_var_from_num</a>(Numeric num, <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *dest);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L7451" title="utils/adt/numeric.c:7451">init_var_from_num</a>(Numeric num, <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *dest);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L7468" title="utils/adt/numeric.c:7468">set_var_from_var</a>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *value, <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *dest);<br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<a href="#L7494" title="utils/adt/numeric.c:7494">get_str_from_var</a>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var);<br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<a href="#L7647" title="utils/adt/numeric.c:7647">get_str_from_var_sci</a>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var, <span class="Type">int</span> rscale);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L7724" title="utils/adt/numeric.c:7724">numericvar_serialize</a>(StringInfo buf, <span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L7740" title="utils/adt/numeric.c:7740">numericvar_deserialize</a>(StringInfo buf, <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> Numeric <a href="#L7763" title="utils/adt/numeric.c:7763">duplicate_numeric</a>(Numeric num);<br/></li>
<li><span class="Type">static</span> Numeric <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var);<br/></li>
<li><span class="Type">static</span> Numeric <a href="#L7782" title="utils/adt/numeric.c:7782">make_result_opt_error</a>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *have_error);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L7907" title="utils/adt/numeric.c:7907">apply_typmod</a>(<a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var, int32 typmod, Node *escontext);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L7992" title="utils/adt/numeric.c:7992">apply_typmod_special</a>(Numeric num, int32 typmod, Node *escontext);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L4460" title="utils/adt/numeric.c:4460">numericvar_to_int32</a>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var, int32 *result);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L8029" title="utils/adt/numeric.c:8029">numericvar_to_int64</a>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var, int64 *result);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L8104" title="utils/adt/numeric.c:8104">int64_to_numericvar</a>(int64 val, <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L8151" title="utils/adt/numeric.c:8151">numericvar_to_uint64</a>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var, uint64 *result);<br/></li>
<li><span class="PreProc">#ifdef HAVE_INT128<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L8224" title="utils/adt/numeric.c:8224">numericvar_to_int128</a>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var, int128 *result);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L8295" title="utils/adt/numeric.c:8295">int128_to_numericvar</a>(int128 val, <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><span class="Type">static</span> <span class="Type">double</span> <a href="#L8341" title="utils/adt/numeric.c:8341">numericvar_to_double_no_overflow</a>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> Datum <a href="#L2046" title="utils/adt/numeric.c:2046">numeric_abbrev_convert</a>(Datum original_datum, SortSupport ssup);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2108" title="utils/adt/numeric.c:2108">numeric_abbrev_abort</a>(<span class="Type">int</span> memtupcount, SortSupport ssup);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L2181" title="utils/adt/numeric.c:2181">numeric_fast_cmp</a>(Datum x, Datum y, SortSupport ssup);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L2203" title="utils/adt/numeric.c:2203">numeric_cmp_abbrev</a>(Datum x, Datum y, SortSupport ssup);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> Datum <a href="#L2265" title="utils/adt/numeric.c:2265">numeric_abbrev_convert_var</a>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L337" title="utils/adt/numeric.c:337">NumericSortSupport</a> *nss);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L2505" title="utils/adt/numeric.c:2505">cmp_numerics</a>(Numeric num1, Numeric num2);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L8373" title="utils/adt/numeric.c:8373">cmp_var</a>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var1, <span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var2);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L8388" title="utils/adt/numeric.c:8388">cmp_var_common</a>(<span class="Type">const</span> <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> *var1digits, <span class="Type">int</span> var1ndigits,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> var1weight, <span class="Type">int</span> var1sign,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> *var2digits, <span class="Type">int</span> var2ndigits,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> var2weight, <span class="Type">int</span> var2sign);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L8431" title="utils/adt/numeric.c:8431">add_var</a>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var1, <span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *result);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L8548" title="utils/adt/numeric.c:8548">sub_var</a>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var1, <span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *result);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L8669" title="utils/adt/numeric.c:8669">mul_var</a>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var1, <span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> rscale);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L8877" title="utils/adt/numeric.c:8877">div_var</a>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var1, <span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> rscale, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> round);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L9185" title="utils/adt/numeric.c:9185">div_var_fast</a>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var1, <span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *result, <span class="Type">int</span> rscale, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> round);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L9549" title="utils/adt/numeric.c:9549">div_var_int</a>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var, <span class="Type">int</span> ival, <span class="Type">int</span> ival_weight,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *result, <span class="Type">int</span> rscale, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> round);<br/></li>
<li><span class="PreProc">#ifdef HAVE_INT128<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L9665" title="utils/adt/numeric.c:9665">div_var_int64</a>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var, int64 ival, <span class="Type">int</span> ival_weight,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *result, <span class="Type">int</span> rscale, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> round);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L9777" title="utils/adt/numeric.c:9777">select_div_scale</a>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var1, <span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var2);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L9846" title="utils/adt/numeric.c:9846">mod_var</a>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var1, <span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *result);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L9875" title="utils/adt/numeric.c:9875">div_mod_var</a>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var1, <span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *quot, <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *rem);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L9945" title="utils/adt/numeric.c:9945">ceil_var</a>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var, <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *result);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L9969" title="utils/adt/numeric.c:9969">floor_var</a>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var, <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *result);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L9992" title="utils/adt/numeric.c:9992">gcd_var</a>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var1, <span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *result);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L10062" title="utils/adt/numeric.c:10062">sqrt_var</a>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *arg, <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *result, <span class="Type">int</span> rscale);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L10542" title="utils/adt/numeric.c:10542">exp_var</a>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *arg, <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *result, <span class="Type">int</span> rscale);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L10671" title="utils/adt/numeric.c:10671">estimate_ln_dweight</a>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L10753" title="utils/adt/numeric.c:10753">ln_var</a>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *arg, <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *result, <span class="Type">int</span> rscale);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L10871" title="utils/adt/numeric.c:10871">log_var</a>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *base, <span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *num,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *result);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L10931" title="utils/adt/numeric.c:10931">power_var</a>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *base, <span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *exp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *result);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L11092" title="utils/adt/numeric.c:11092">power_var_int</a>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *base, <span class="Type">int</span> exp, <span class="Type">int</span> exp_dscale,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *result);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L11296" title="utils/adt/numeric.c:11296">power_ten_int</a>(<span class="Type">int</span> exp, <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *result);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L11321" title="utils/adt/numeric.c:11321">random_var</a>(pg_prng_state *state, <span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *rmin,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *rmax, <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *result);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L11504" title="utils/adt/numeric.c:11504">cmp_abs</a>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var1, <span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var2);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L11518" title="utils/adt/numeric.c:11518">cmp_abs_common</a>(<span class="Type">const</span> <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> *var1digits, <span class="Type">int</span> var1ndigits,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> var1weight,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> *var2digits, <span class="Type">int</span> var2ndigits,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> var2weight);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L11582" title="utils/adt/numeric.c:11582">add_abs</a>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var1, <span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *result);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L11667" title="utils/adt/numeric.c:11667">sub_abs</a>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var1, <span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *result);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L11749" title="utils/adt/numeric.c:11749">round_var</a>(<a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var, <span class="Type">int</span> rscale);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L11855" title="utils/adt/numeric.c:11855">trunc_var</a>(<a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var, <span class="Type">int</span> rscale);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L11917" title="utils/adt/numeric.c:11917">strip_var</a>(<a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1917" title="utils/adt/numeric.c:1917">compute_bucket</a>(Numeric operand, Numeric bound1, Numeric bound2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *count_var, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> reversed_bounds,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *result_var);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L11974" title="utils/adt/numeric.c:11974">accum_sum_add</a>(<a href="#L370" title="utils/adt/numeric.c:370">NumericSumAccum</a> *accum, <span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *val);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L12095" title="utils/adt/numeric.c:12095">accum_sum_rescale</a>(<a href="#L370" title="utils/adt/numeric.c:370">NumericSumAccum</a> *accum, <span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *val);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L12022" title="utils/adt/numeric.c:12022">accum_sum_carry</a>(<a href="#L370" title="utils/adt/numeric.c:370">NumericSumAccum</a> *accum);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L11958" title="utils/adt/numeric.c:11958">accum_sum_reset</a>(<a href="#L370" title="utils/adt/numeric.c:370">NumericSumAccum</a> *accum);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L12184" title="utils/adt/numeric.c:12184">accum_sum_final</a>(<a href="#L370" title="utils/adt/numeric.c:370">NumericSumAccum</a> *accum, <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *result);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L12235" title="utils/adt/numeric.c:12235">accum_sum_copy</a>(<a href="#L370" title="utils/adt/numeric.c:370">NumericSumAccum</a> *dst, <a href="#L370" title="utils/adt/numeric.c:370">NumericSumAccum</a> *src);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L12252" title="utils/adt/numeric.c:12252">accum_sum_combine</a>(<a href="#L370" title="utils/adt/numeric.c:370">NumericSumAccum</a> *accum, <a href="#L370" title="utils/adt/numeric.c:370">NumericSumAccum</a> *accum2);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Input-, output- and rounding-<a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L628" title="utils/adt/numeric.c:628">numeric_in</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Input function for <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> data type<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L628">&#x200c;</a><span class="linkable">numeric_in</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *str = PG_GETARG_CSTRING(<span class="Constant">0</span>);<br/></li>
<li><span class="PreProc">#ifdef NOT_USED<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typelem = PG_GETARG_OID(<span class="Constant">1</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; typmod = PG_GETARG_INT32(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *escontext = fcinfo-&gt;context;<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *cp;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *numstart;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sign;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Skip leading spaces */<br/></li>
<li></span>&nbsp; &nbsp; cp = str;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (*cp)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!isspace((<span class="Type">unsigned</span> <span class="Type">char</span>) *cp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cp++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Process the number's sign. This duplicates logic in <a href="#L7012" title="utils/adt/numeric.c:7012">set_var_from_str</a>(),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but it's worth doing here, since it simplifies the handling of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * infinities and non-decimal integers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; numstart = cp;<br/></li>
<li>&nbsp; &nbsp; sign = <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*cp == <span class="Constant">'+'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cp++;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*cp == <span class="Constant">'-'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sign = <a href="#L166" title="utils/adt/numeric.c:166">NUMERIC_NEG</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cp++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check for NaN and infinities.&nbsp; We recognize the same strings allowed by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="float.c.html#L357" title="utils/adt/float.c:357">float8in</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since all other legal inputs have a digit or a decimal point after the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sign, we need only check for NaN/infinity if that's not the case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!isdigit((<span class="Type">unsigned</span> <span class="Type">char</span>) *cp) &amp;&amp; *cp != <span class="Constant">'.'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The number must be NaN or infinity; anything else can only be a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * syntax error. Note that NaN mustn't have a sign.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pg_strncasecmp(numstart, <span class="Constant">&quot;NaN&quot;</span>, <span class="Constant">3</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L449" title="utils/adt/numeric.c:449">const_nan</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cp = numstart + <span class="Constant">3</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (pg_strncasecmp(cp, <span class="Constant">&quot;Infinity&quot;</span>, <span class="Constant">8</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(sign == <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a> ? &amp;<a href="#L452" title="utils/adt/numeric.c:452">const_pinf</a> : &amp;<a href="#L455" title="utils/adt/numeric.c:455">const_ninf</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cp += <span class="Constant">8</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (pg_strncasecmp(cp, <span class="Constant">&quot;inf&quot;</span>, <span class="Constant">3</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(sign == <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a> ? &amp;<a href="#L452" title="utils/adt/numeric.c:452">const_pinf</a> : &amp;<a href="#L455" title="utils/adt/numeric.c:455">const_ninf</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cp += <span class="Constant">3</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> invalid_syntax;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check for trailing junk; there should be nothing left but spaces.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We intentionally do this check <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> applying the typmod because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we would like to throw <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> trailing-junk syntax error <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * semantic error resulting from <a href="#L7992" title="utils/adt/numeric.c:7992">apply_typmod_special</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (*cp)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!isspace((<span class="Type">unsigned</span> <span class="Type">char</span>) *cp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> invalid_syntax;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cp++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L7992" title="utils/adt/numeric.c:7992">apply_typmod_special</a>(res, typmod, escontext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have a normal <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> value, which may be a non-decimal integer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * or a regular decimal number.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; value;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; base;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; have_error;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;value);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Determine the number's base by looking for a non-decimal prefix<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * indicator (&quot;0x&quot;, &quot;0o&quot;, or &quot;0b&quot;).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cp[<span class="Constant">0</span>] == <span class="Constant">'0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (cp[<span class="Constant">1</span>])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'x'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'X'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; base = <span class="Constant">16</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'o'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'O'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; base = <span class="Constant">8</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'b'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'B'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; base = <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; base = <span class="Constant">10</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; base = <span class="Constant">10</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Parse the rest of the number and apply the sign */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (base == <span class="Constant">10</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L7012" title="utils/adt/numeric.c:7012">set_var_from_str</a>(str, cp, &amp;value, &amp;cp, escontext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value.sign = sign;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L7242" title="utils/adt/numeric.c:7242">set_var_from_non_decimal_integer_str</a>(str, cp + <span class="Constant">2</span>, sign, base,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;value, &amp;cp, escontext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Should be nothing left but spaces. As above, throw <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> typmod error<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * after finishing syntax check.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (*cp)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!isspace((<span class="Type">unsigned</span> <span class="Type">char</span>) *cp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> invalid_syntax;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cp++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L7907" title="utils/adt/numeric.c:7907">apply_typmod</a>(&amp;value, typmod, escontext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res = <a href="#L7782" title="utils/adt/numeric.c:7782">make_result_opt_error</a>(&amp;value, &amp;have_error);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (have_error)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;value overflows <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> format&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;value);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_NUMERIC(res);<br/></li>
<li><br/></li>
<li><span class="Statement">invalid_syntax</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid input syntax for type </span><span class="Special">%s</span><span class="Constant">: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;<a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a>&quot;</span>, str)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L807" title="utils/adt/numeric.c:807">numeric_out</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Output function for <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> data type<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L807">&#x200c;</a><span class="linkable">numeric_out</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num = PG_GETARG_NUMERIC(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; x;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *str;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Handle NaN and infinities<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(num))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L204" title="utils/adt/numeric.c:204">NUMERIC_IS_PINF</a>(num))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_CSTRING(<a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<span class="Constant">&quot;Infinity&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L205" title="utils/adt/numeric.c:205">NUMERIC_IS_NINF</a>(num))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_CSTRING(<a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<span class="Constant">&quot;-Infinity&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_CSTRING(<a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<span class="Constant">&quot;NaN&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get the number in the variable format.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L7451" title="utils/adt/numeric.c:7451">init_var_from_num</a>(num, &amp;x);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; str = <a href="#L7494" title="utils/adt/numeric.c:7494">get_str_from_var</a>(&amp;x);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CSTRING(str);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L842" title="utils/adt/numeric.c:842">numeric_is_nan</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Is Numeric value a NaN?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L842">&#x200c;</a></span><span class="linkable">numeric_is_nan</span>(Numeric num)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L203" title="utils/adt/numeric.c:203">NUMERIC_IS_NAN</a>(num);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L853" title="utils/adt/numeric.c:853">numeric_is_inf</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Is Numeric value an infinity?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L853">&#x200c;</a></span><span class="linkable">numeric_is_inf</span>(Numeric num)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L206" title="utils/adt/numeric.c:206">NUMERIC_IS_INF</a>(num);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L864" title="utils/adt/numeric.c:864">numeric_is_integral</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Is Numeric value integral?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L864">&#x200c;</a></span><span class="linkable">numeric_is_integral</span>(Numeric num)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; arg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reject NaN, but infinities are considered integral */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(num))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L203" title="utils/adt/numeric.c:203">NUMERIC_IS_NAN</a>(num))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Integral if there are no digits to the right of the decimal point */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L7451" title="utils/adt/numeric.c:7451">init_var_from_num</a>(num, &amp;arg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (arg.ndigits == <span class="Constant">0</span> || arg.ndigits &lt;= arg.weight + <span class="Constant">1</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L898" title="utils/adt/numeric.c:898">make_numeric_typmod</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Pack <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> precision and scale <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> into a typmod.&nbsp; The <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> 16 bits<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; are used for the precision (though actually not all these bits are needed,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; since the maximum allowed precision is 1000).&nbsp; The <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> 16 bits are for<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; the scale, but since the scale is constrained to the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> [-1000, 1000],<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; we use just the <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> 11 of those 16 bits, and leave the remaining 5 bits<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; unset, for possible future use.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; For purely historical reasons VARHDRSZ is then added to the result, thus<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; the unused space in the <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> 16 bits is not all as freely available as it<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; might seem.&nbsp; (We can't let the result overflow to a negative int32, as<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; other parts of the system would interpret that as not-a-valid-typmod.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> int32<br/></li>
<li><a id="L898">&#x200c;</a><span class="linkable">make_numeric_typmod</span>(<span class="Type">int</span> precision, <span class="Type">int</span> scale)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ((precision &lt;&lt; <span class="Constant">16</span>) | (scale &amp; <span class="Constant">0x7ff</span>)) + VARHDRSZ;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Because of the offset, valid <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> typmods are at least VARHDRSZ<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L907">&#x200c;</a></span><span class="linkable">is_valid_numeric_typmod</span>(int32 typmod)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> typmod &gt;= (int32) VARHDRSZ;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L918" title="utils/adt/numeric.c:918">numeric_typmod_precision</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Extract the precision from a <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> typmod --- see <a href="#L898" title="utils/adt/numeric.c:898">make_numeric_typmod</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">int<br/></li>
<li><a id="L918">&#x200c;</a></span><span class="linkable">numeric_typmod_precision</span>(int32 typmod)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ((typmod - VARHDRSZ) &gt;&gt; <span class="Constant">16</span>) &amp; <span class="Constant">0xffff</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L933" title="utils/adt/numeric.c:933">numeric_typmod_scale</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Extract the scale from a <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> typmod --- see <a href="#L898" title="utils/adt/numeric.c:898">make_numeric_typmod</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Note that the scale may be negative, so we must do sign extension when<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; unpacking it.&nbsp; We do this using the <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> hack (x^1024)-1024, which sign<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; extends an 11-<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> two's complement number x.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">int<br/></li>
<li><a id="L933">&#x200c;</a></span><span class="linkable">numeric_typmod_scale</span>(int32 typmod)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (((typmod - VARHDRSZ) &amp; <span class="Constant">0x7ff</span>) ^ <span class="Constant">1024</span>) - <span class="Constant">1024</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L944" title="utils/adt/numeric.c:944">numeric_maximum_size</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Maximum size of a <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> with given typmod, or -1 if unlimited/unknown.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>int32<br/></li>
<li><a id="L944">&#x200c;</a><span class="linkable">numeric_maximum_size</span>(int32 typmod)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; precision;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numeric_digits;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L907" title="utils/adt/numeric.c:907">is_valid_numeric_typmod</a>(typmod))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* precision (ie, max # of digits) is in <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bits of typmod */<br/></li>
<li></span>&nbsp; &nbsp; precision = <a href="#L918" title="utils/adt/numeric.c:918">numeric_typmod_precision</a>(typmod);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This formula computes the maximum number of NumericDigits we could need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in order to store the specified number of decimal digits. Because the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * weight is stored as a number of NumericDigits rather than a number of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * decimal digits, it's possible that the first <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> will contain<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * only a single decimal digit.&nbsp; Thus, the first two decimal digits can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * require two NumericDigits to store, but it isn't until we reach<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> + 2 decimal digits that we potentially need a third<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; numeric_digits = (precision + <span class="Constant">2</span> * (<a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> - <span class="Constant">1</span>)) / <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In most cases, the size of a <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> will be smaller than the value<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * computed below, because the varlena header will typically get toasted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * down to a single byte <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> being stored on disk, and it may also be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * possible to use a short <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> header.&nbsp; But our job here is to compute<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the worst case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L174" title="utils/adt/numeric.c:174">NUMERIC_HDRSZ</a> + (numeric_digits * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L983" title="utils/adt/numeric.c:983">numeric_out_sci</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Output function for <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> data type in scientific notation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L983">&#x200c;</a><span class="linkable">numeric_out_sci</span>(Numeric num, <span class="Type">int</span> scale)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; x;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *str;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Handle NaN and infinities<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(num))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L204" title="utils/adt/numeric.c:204">NUMERIC_IS_PINF</a>(num))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<span class="Constant">&quot;Infinity&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L205" title="utils/adt/numeric.c:205">NUMERIC_IS_NINF</a>(num))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<span class="Constant">&quot;-Infinity&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<span class="Constant">&quot;NaN&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L7451" title="utils/adt/numeric.c:7451">init_var_from_num</a>(num, &amp;x);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; str = <a href="#L7647" title="utils/adt/numeric.c:7647">get_str_from_var_sci</a>(&amp;x, scale);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> str;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1017" title="utils/adt/numeric.c:1017">numeric_normalize</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Output function for <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> data type, suppressing insignificant trailing<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; zeroes and then <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> trailing decimal point.&nbsp; The intent of this is to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; produce strings that are <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> if and only if the input <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L1017">&#x200c;</a><span class="linkable">numeric_normalize</span>(Numeric num)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; x;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *str;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Handle NaN and infinities<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(num))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L204" title="utils/adt/numeric.c:204">NUMERIC_IS_PINF</a>(num))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<span class="Constant">&quot;Infinity&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L205" title="utils/adt/numeric.c:205">NUMERIC_IS_NINF</a>(num))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<span class="Constant">&quot;-Infinity&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<span class="Constant">&quot;NaN&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L7451" title="utils/adt/numeric.c:7451">init_var_from_num</a>(num, &amp;x);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; str = <a href="#L7494" title="utils/adt/numeric.c:7494">get_str_from_var</a>(&amp;x);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If there's no decimal point, there's certainly nothing to remove. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (strchr(str, <span class="Constant">'.'</span>) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Back up over trailing fractional zeroes.&nbsp; Since there is a decimal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * point, this loop will terminate safely.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; last = strlen(str) - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (str[last] == <span class="Constant">'0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last--;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We want to get rid of the decimal point too, if it's <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> last. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (str[last] == <span class="Constant">'.'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last--;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> whatever we backed up over. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; str[last + <span class="Constant">1</span>] = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> str;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1069" title="utils/adt/numeric.c:1069">numeric_recv</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts external binary format to <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * External format is a sequence of int16's:<br/></li>
<li></span><span class="Comment"> * ndigits, weight, sign, dscale, NumericDigits.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1069">&#x200c;</a><span class="linkable">numeric_recv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; buf = (StringInfo) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef NOT_USED<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typelem = PG_GETARG_OID(<span class="Constant">1</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; typmod = PG_GETARG_INT32(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; value;<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;value);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len = (uint16) <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(buf, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint16));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6953" title="utils/adt/numeric.c:6953">alloc_var</a>(&amp;value, len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; value.weight = (int16) <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(buf, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int16));<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we allow <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> int16 for weight --- OK? */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; value.sign = (uint16) <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(buf, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint16));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!(value.sign == <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value.sign == <a href="#L166" title="utils/adt/numeric.c:166">NUMERIC_NEG</a> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value.sign == <a href="#L197" title="utils/adt/numeric.c:197">NUMERIC_NAN</a> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value.sign == <a href="#L198" title="utils/adt/numeric.c:198">NUMERIC_PINF</a> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value.sign == <a href="#L199" title="utils/adt/numeric.c:199">NUMERIC_NINF</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_BINARY_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid sign in external </span><span class="Special">\&quot;</span><span class="Constant"><a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a></span><span class="Special">\&quot;</span><span class="Constant"> value&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; value.dscale = (uint16) <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(buf, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint16));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((value.dscale &amp; <a href="#L233" title="utils/adt/numeric.c:233">NUMERIC_DSCALE_MASK</a>) != value.dscale)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_BINARY_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid scale in external </span><span class="Special">\&quot;</span><span class="Constant"><a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a></span><span class="Special">\&quot;</span><span class="Constant"> value&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; len; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> d = <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(buf, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (d &lt; <span class="Constant">0</span> || d &gt;= <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_BINARY_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid digit in external </span><span class="Special">\&quot;</span><span class="Constant"><a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a></span><span class="Special">\&quot;</span><span class="Constant"> value&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; value.digits[i] = d;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the given dscale would hide <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> digits, truncate those digits away.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We could alternatively throw an error, but that would take a bunch of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * extra code (about as much as <a href="#L11855" title="utils/adt/numeric.c:11855">trunc_var</a> involves), and it might cause<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * client compatibility issues.&nbsp; Be careful not to apply <a href="#L11855" title="utils/adt/numeric.c:11855">trunc_var</a> to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * special <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, as it could do the wrong thing; we don't need it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * anyway, since <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a> will ignore all but the sign field.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * After doing that, be sure to check the typmod restriction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (value.sign == <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; value.sign == <a href="#L166" title="utils/adt/numeric.c:166">NUMERIC_NEG</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L11855" title="utils/adt/numeric.c:11855">trunc_var</a>(&amp;value, value.dscale);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L7907" title="utils/adt/numeric.c:7907">apply_typmod</a>(&amp;value, typmod, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res = <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;value);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L7992" title="utils/adt/numeric.c:7992">apply_typmod_special</a> wants us to make the Numeric first */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; res = <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;value);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L7992" title="utils/adt/numeric.c:7992">apply_typmod_special</a>(res, typmod, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;value);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_NUMERIC(res);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1154" title="utils/adt/numeric.c:1154">numeric_send</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> to binary format<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1154">&#x200c;</a><span class="linkable">numeric_send</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num = PG_GETARG_NUMERIC(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; x;<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L7451" title="utils/adt/numeric.c:7451">init_var_from_num</a>(num, &amp;x);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L326" title="libpq/pqformat.c:326">pq_begintypsend</a>(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pq_sendint16(&amp;buf, x.ndigits);<br/></li>
<li>&nbsp; &nbsp; pq_sendint16(&amp;buf, x.weight);<br/></li>
<li>&nbsp; &nbsp; pq_sendint16(&amp;buf, x.sign);<br/></li>
<li>&nbsp; &nbsp; pq_sendint16(&amp;buf, x.dscale);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; x.ndigits; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pq_sendint16(&amp;buf, x.digits[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BYTEA_P(<a href="../../libpq/pqformat.c.html#L346" title="libpq/pqformat.c:346">pq_endtypsend</a>(&amp;buf));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1187" title="utils/adt/numeric.c:1187">numeric_support</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Planner support function for the <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a>() length coercion function.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Flatten calls that solely represent increases in allowable precision.<br/></li>
<li></span><span class="Comment"> * Scale changes mutate every datum, so they are unoptimizable.&nbsp; Some <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>,<br/></li>
<li></span><span class="Comment"> * e.g. 1E-1001, can only fit into an unconstrained <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a>, so a change from<br/></li>
<li></span><span class="Comment"> * an unconstrained <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> to <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> constrained <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> is also unoptimizable.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1187">&#x200c;</a><span class="linkable">numeric_support</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *rawreq = (Node *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *ret = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(rawreq, SupportRequestSimplify))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SupportRequestSimplify *req = (SupportRequestSimplify *) rawreq;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FuncExpr&nbsp;&nbsp; *expr = req-&gt;fcall;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *typmod;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(list_length(expr-&gt;args) &gt;= <span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typmod = (Node *) lsecond(expr-&gt;args);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(typmod, Const) &amp;&amp; !((Const *) typmod)-&gt;constisnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *source = (Node *) linitial(expr-&gt;args);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; old_typmod = <a href="../../nodes/nodeFuncs.c.html#L298" title="nodes/nodeFuncs.c:298">exprTypmod</a>(source);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; new_typmod = DatumGetInt32(((Const *) typmod)-&gt;constvalue);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; old_scale = <a href="#L933" title="utils/adt/numeric.c:933">numeric_typmod_scale</a>(old_typmod);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; new_scale = <a href="#L933" title="utils/adt/numeric.c:933">numeric_typmod_scale</a>(new_typmod);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; old_precision = <a href="#L918" title="utils/adt/numeric.c:918">numeric_typmod_precision</a>(old_typmod);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; new_precision = <a href="#L918" title="utils/adt/numeric.c:918">numeric_typmod_precision</a>(new_typmod);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If new_typmod is invalid, the destination is unconstrained;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that's always OK.&nbsp; If old_typmod is valid, the source is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * constrained, and we're OK if the scale is unchanged and the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * precision is not decreasing.&nbsp; See further notes in function<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * header comment.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L907" title="utils/adt/numeric.c:907">is_valid_numeric_typmod</a>(new_typmod) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L907" title="utils/adt/numeric.c:907">is_valid_numeric_typmod</a>(old_typmod) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; new_scale == old_scale &amp;&amp; new_precision &gt;= old_precision))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret = <a href="../../nodes/nodeFuncs.c.html#L684" title="nodes/nodeFuncs.c:684">relabel_to_typmod</a>(source, new_typmod);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(ret);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; This is a special function called by the Postgres database system<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> a value is stored in a tuple's attribute. The precision and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; scale of the attribute have to be applied on the value.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1237">&#x200c;</a><span class="linkable">numeric</span>&nbsp; &nbsp; &nbsp; &nbsp; (PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num = PG_GETARG_NUMERIC(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; typmod = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; new;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; precision;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scale;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ddigits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxdigits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dscale;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; var;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Handle NaN and infinities: if <a href="#L7992" title="utils/adt/numeric.c:7992">apply_typmod_special</a> doesn't complain,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * just return a copy of the input.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(num))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L7992" title="utils/adt/numeric.c:7992">apply_typmod_special</a>(num, typmod, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="#L7763" title="utils/adt/numeric.c:7763">duplicate_numeric</a>(num));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the value isn't a valid type modifier, simply return a copy of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * input value<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L907" title="utils/adt/numeric.c:907">is_valid_numeric_typmod</a>(typmod))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="#L7763" title="utils/adt/numeric.c:7763">duplicate_numeric</a>(num));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get the precision and scale out of the typmod value<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; precision = <a href="#L918" title="utils/adt/numeric.c:918">numeric_typmod_precision</a>(typmod);<br/></li>
<li>&nbsp; &nbsp; scale = <a href="#L933" title="utils/adt/numeric.c:933">numeric_typmod_scale</a>(typmod);<br/></li>
<li>&nbsp; &nbsp; maxdigits = precision - scale;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The target display scale is non-negative */<br/></li>
<li></span>&nbsp; &nbsp; dscale = Max(scale, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the number is certainly in bounds and due to the target scale no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rounding could be necessary, just make a copy of the input and modify<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * its scale fields, unless the larger scale forces us to abandon the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * short representation.&nbsp; (Note we assume the existing dscale is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * honest...)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ddigits = (<a href="#L246" title="utils/adt/numeric.c:246">NUMERIC_WEIGHT</a>(num) + <span class="Constant">1</span>) * <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ddigits &lt;= maxdigits &amp;&amp; scale &gt;= <a href="#L242" title="utils/adt/numeric.c:242">NUMERIC_DSCALE</a>(num)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; (<a href="#L490" title="utils/adt/numeric.c:490">NUMERIC_CAN_BE_SHORT</a>(dscale, <a href="#L246" title="utils/adt/numeric.c:246">NUMERIC_WEIGHT</a>(num))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || !<a href="#L171" title="utils/adt/numeric.c:171">NUMERIC_IS_SHORT</a>(num)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; new = <a href="#L7763" title="utils/adt/numeric.c:7763">duplicate_numeric</a>(num);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L171" title="utils/adt/numeric.c:171">NUMERIC_IS_SHORT</a>(num))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new-&gt;choice.n_short.n_header =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (num-&gt;choice.n_short.n_header &amp; ~<a href="#L214" title="utils/adt/numeric.c:214">NUMERIC_SHORT_DSCALE_MASK</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | (dscale &lt;&lt; <a href="#L215" title="utils/adt/numeric.c:215">NUMERIC_SHORT_DSCALE_SHIFT</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new-&gt;choice.n_long.n_sign_dscale = <a href="#L236" title="utils/adt/numeric.c:236">NUMERIC_SIGN</a>(new) |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((uint16) dscale &amp; <a href="#L233" title="utils/adt/numeric.c:233">NUMERIC_DSCALE_MASK</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(new);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We really need to fiddle with things - unpack the number into a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * variable and let <a href="#L7907" title="utils/adt/numeric.c:7907">apply_typmod</a>() do it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;var);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L7420" title="utils/adt/numeric.c:7420">set_var_from_num</a>(num, &amp;var);<br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L7907" title="utils/adt/numeric.c:7907">apply_typmod</a>(&amp;var, typmod, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; new = <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;var);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;var);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_NUMERIC(new);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1315">&#x200c;</a><span class="linkable">numerictypmodin</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *ta = PG_GETARG_ARRAYTYPE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp;&nbsp; *tl;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; typmod;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tl = <a href="arrayutils.c.html#L233" title="utils/adt/arrayutils.c:233">ArrayGetIntegerTypmods</a>(ta, &amp;n);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (n == <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tl[<span class="Constant">0</span>] &lt; <span class="Constant">1</span> || tl[<span class="Constant">0</span>] &gt; NUMERIC_MAX_PRECISION)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;NUMERIC precision </span><span class="Special">%d</span><span class="Constant"> must be between 1 and </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tl[<span class="Constant">0</span>], NUMERIC_MAX_PRECISION)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tl[<span class="Constant">1</span>] &lt; NUMERIC_MIN_SCALE || tl[<span class="Constant">1</span>] &gt; NUMERIC_MAX_SCALE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;NUMERIC scale </span><span class="Special">%d</span><span class="Constant"> must be between </span><span class="Special">%d</span><span class="Constant"> and </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tl[<span class="Constant">1</span>], NUMERIC_MIN_SCALE, NUMERIC_MAX_SCALE)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typmod = <a href="#L898" title="utils/adt/numeric.c:898">make_numeric_typmod</a>(tl[<span class="Constant">0</span>], tl[<span class="Constant">1</span>]);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (n == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tl[<span class="Constant">0</span>] &lt; <span class="Constant">1</span> || tl[<span class="Constant">0</span>] &gt; NUMERIC_MAX_PRECISION)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;NUMERIC precision </span><span class="Special">%d</span><span class="Constant"> must be between 1 and </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tl[<span class="Constant">0</span>], NUMERIC_MAX_PRECISION)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* scale defaults to zero */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; typmod = <a href="#L898" title="utils/adt/numeric.c:898">make_numeric_typmod</a>(tl[<span class="Constant">0</span>], <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid NUMERIC type modifier&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typmod = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(typmod);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1360">&#x200c;</a><span class="linkable">numerictypmodout</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; typmod = PG_GETARG_INT32(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *res = (<span class="Type">char</span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Constant">64</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L907" title="utils/adt/numeric.c:907">is_valid_numeric_typmod</a>(typmod))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(res, <span class="Constant">64</span>, <span class="Constant">&quot;(</span><span class="Special">%d</span><span class="Constant">,</span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L918" title="utils/adt/numeric.c:918">numeric_typmod_precision</a>(typmod),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L933" title="utils/adt/numeric.c:933">numeric_typmod_scale</a>(typmod));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *res = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CSTRING(res);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Sign manipulation, rounding and the like<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L1384">&#x200c;</a><span class="linkable">numeric_abs</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num = PG_GETARG_NUMERIC(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Do it the easy way directly on the packed format<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; res = <a href="#L7763" title="utils/adt/numeric.c:7763">duplicate_numeric</a>(num);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L171" title="utils/adt/numeric.c:171">NUMERIC_IS_SHORT</a>(num))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res-&gt;choice.n_short.n_header =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num-&gt;choice.n_short.n_header &amp; ~<a href="#L213" title="utils/adt/numeric.c:213">NUMERIC_SHORT_SIGN_MASK</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(num))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This changes -Inf to Inf, and doesn't affect NaN */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; res-&gt;choice.n_short.n_header =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num-&gt;choice.n_short.n_header &amp; ~<a href="#L200" title="utils/adt/numeric.c:200">NUMERIC_INF_SIGN_MASK</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; res-&gt;choice.n_long.n_sign_dscale = <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a> | <a href="#L242" title="utils/adt/numeric.c:242">NUMERIC_DSCALE</a>(num);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_NUMERIC(res);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1411">&#x200c;</a><span class="linkable">numeric_uminus</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num = PG_GETARG_NUMERIC(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Do it the easy way directly on the packed format<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; res = <a href="#L7763" title="utils/adt/numeric.c:7763">duplicate_numeric</a>(num);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(num))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Flip the sign, if it's Inf or -Inf */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L203" title="utils/adt/numeric.c:203">NUMERIC_IS_NAN</a>(num))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res-&gt;choice.n_short.n_header =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num-&gt;choice.n_short.n_header ^ <a href="#L200" title="utils/adt/numeric.c:200">NUMERIC_INF_SIGN_MASK</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The packed format is known to be totally zero digit trimmed always. So<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * once we've eliminated specials, we can identify a zero by the fact that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there are no digits at all. Do nothing to a zero.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L488" title="utils/adt/numeric.c:488">NUMERIC_NDIGITS</a>(num) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Else, flip the sign */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L171" title="utils/adt/numeric.c:171">NUMERIC_IS_SHORT</a>(num))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res-&gt;choice.n_short.n_header =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num-&gt;choice.n_short.n_header ^ <a href="#L213" title="utils/adt/numeric.c:213">NUMERIC_SHORT_SIGN_MASK</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L236" title="utils/adt/numeric.c:236">NUMERIC_SIGN</a>(num) == <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res-&gt;choice.n_long.n_sign_dscale =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L166" title="utils/adt/numeric.c:166">NUMERIC_NEG</a> | <a href="#L242" title="utils/adt/numeric.c:242">NUMERIC_DSCALE</a>(num);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res-&gt;choice.n_long.n_sign_dscale =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a> | <a href="#L242" title="utils/adt/numeric.c:242">NUMERIC_DSCALE</a>(num);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_NUMERIC(res);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1453">&#x200c;</a><span class="linkable">numeric_uplus</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num = PG_GETARG_NUMERIC(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="#L7763" title="utils/adt/numeric.c:7763">duplicate_numeric</a>(num));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1469" title="utils/adt/numeric.c:1469">numeric_sign_internal</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns -1 if the argument is less than 0, 0 if the argument is <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a><br/></li>
<li></span><span class="Comment"> * to 0, and 1 if the argument is greater than zero.&nbsp; Caller must have<br/></li>
<li></span><span class="Comment"> * taken care of the NaN case, but we can handle infinities here.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1469">&#x200c;</a></span><span class="linkable">numeric_sign_internal</span>(Numeric num)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(num))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!<a href="#L203" title="utils/adt/numeric.c:203">NUMERIC_IS_NAN</a>(num));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must be Inf or -Inf */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L204" title="utils/adt/numeric.c:204">NUMERIC_IS_PINF</a>(num))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The packed format is known to be totally zero digit trimmed always. So<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * once we've eliminated specials, we can identify a zero by the fact that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there are no digits at all.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L488" title="utils/adt/numeric.c:488">NUMERIC_NDIGITS</a>(num) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L236" title="utils/adt/numeric.c:236">NUMERIC_SIGN</a>(num) == <a href="#L166" title="utils/adt/numeric.c:166">NUMERIC_NEG</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1501" title="utils/adt/numeric.c:1501">numeric_sign</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * returns -1 if the argument is less than 0, 0 if the argument is <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a><br/></li>
<li></span><span class="Comment"> * to 0, and 1 if the argument is greater than zero.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1501">&#x200c;</a><span class="linkable">numeric_sign</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num = PG_GETARG_NUMERIC(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Handle NaN (infinities can be handled normally)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L203" title="utils/adt/numeric.c:203">NUMERIC_IS_NAN</a>(num))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L449" title="utils/adt/numeric.c:449">const_nan</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (<a href="#L1469" title="utils/adt/numeric.c:1469">numeric_sign_internal</a>(num))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">0</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L415" title="utils/adt/numeric.c:415">const_zero</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">1</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L419" title="utils/adt/numeric.c:419">const_one</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> -<span class="Constant">1</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L422" title="utils/adt/numeric.c:422">const_minus_one</a>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (Datum) <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1534" title="utils/adt/numeric.c:1534">numeric_round</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Round a value to have 'scale' digits after the decimal point.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; We allow negative 'scale', implying rounding <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the decimal<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; point --- Oracle interprets rounding that way.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1534">&#x200c;</a><span class="linkable">numeric_round</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num = PG_GETARG_NUMERIC(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; scale = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; arg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Handle NaN and infinities<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(num))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="#L7763" title="utils/adt/numeric.c:7763">duplicate_numeric</a>(num));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Limit the scale value to avoid possible overflow in calculations<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; scale = Max(scale, -NUMERIC_MAX_RESULT_SCALE);<br/></li>
<li>&nbsp; &nbsp; scale = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(scale, NUMERIC_MAX_RESULT_SCALE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Unpack the argument and round it at the proper digit position<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;arg);<br/></li>
<li>&nbsp; &nbsp; <a href="#L7420" title="utils/adt/numeric.c:7420">set_var_from_num</a>(num, &amp;arg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L11749" title="utils/adt/numeric.c:11749">round_var</a>(&amp;arg, scale);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We don't allow negative output dscale */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (scale &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; arg.dscale = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Return the rounded result<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; res = <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;arg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;arg);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_NUMERIC(res);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1583" title="utils/adt/numeric.c:1583">numeric_trunc</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Truncate a value to have 'scale' digits after the decimal point.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; We allow negative 'scale', implying a truncation <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the decimal<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; point --- Oracle interprets truncation that way.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1583">&#x200c;</a><span class="linkable">numeric_trunc</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num = PG_GETARG_NUMERIC(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; scale = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; arg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Handle NaN and infinities<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(num))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="#L7763" title="utils/adt/numeric.c:7763">duplicate_numeric</a>(num));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Limit the scale value to avoid possible overflow in calculations<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; scale = Max(scale, -NUMERIC_MAX_RESULT_SCALE);<br/></li>
<li>&nbsp; &nbsp; scale = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(scale, NUMERIC_MAX_RESULT_SCALE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Unpack the argument and truncate it at the proper digit position<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;arg);<br/></li>
<li>&nbsp; &nbsp; <a href="#L7420" title="utils/adt/numeric.c:7420">set_var_from_num</a>(num, &amp;arg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L11855" title="utils/adt/numeric.c:11855">trunc_var</a>(&amp;arg, scale);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We don't allow negative output dscale */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (scale &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; arg.dscale = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Return the truncated result<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; res = <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;arg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;arg);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_NUMERIC(res);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1630" title="utils/adt/numeric.c:1630">numeric_ceil</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Return the smallest integer greater than or <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to the argument<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1630">&#x200c;</a><span class="linkable">numeric_ceil</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num = PG_GETARG_NUMERIC(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Handle NaN and infinities<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(num))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="#L7763" title="utils/adt/numeric.c:7763">duplicate_numeric</a>(num));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L7451" title="utils/adt/numeric.c:7451">init_var_from_num</a>(num, &amp;result);<br/></li>
<li>&nbsp; &nbsp; <a href="#L9945" title="utils/adt/numeric.c:9945">ceil_var</a>(&amp;result, &amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;result);<br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_NUMERIC(res);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1658" title="utils/adt/numeric.c:1658">numeric_floor</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Return the largest integer <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to or less than the argument<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1658">&#x200c;</a><span class="linkable">numeric_floor</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num = PG_GETARG_NUMERIC(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Handle NaN and infinities<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(num))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="#L7763" title="utils/adt/numeric.c:7763">duplicate_numeric</a>(num));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L7451" title="utils/adt/numeric.c:7451">init_var_from_num</a>(num, &amp;result);<br/></li>
<li>&nbsp; &nbsp; <a href="#L9969" title="utils/adt/numeric.c:9969">floor_var</a>(&amp;result, &amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;result);<br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_NUMERIC(res);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1686" title="utils/adt/numeric.c:1686">generate_series_numeric</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Generate series of <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1686">&#x200c;</a><span class="linkable">generate_series_numeric</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1692" title="utils/adt/numeric.c:1692">generate_series_step_numeric</a>(fcinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1692">&#x200c;</a><span class="linkable">generate_series_step_numeric</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L323" title="utils/adt/numeric.c:323">generate_series_numeric_fctx</a> *fctx;<br/></li>
<li>&nbsp; &nbsp; FuncCallContext *funcctx;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (SRF_IS_FIRSTCALL())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; start_num = PG_GETARG_NUMERIC(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; stop_num = PG_GETARG_NUMERIC(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; steploc = <a href="#L419" title="utils/adt/numeric.c:419">const_one</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reject NaN and infinities in start and stop <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(start_num))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L203" title="utils/adt/numeric.c:203">NUMERIC_IS_NAN</a>(start_num))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;start value cannot be NaN&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;start value cannot be infinity&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(stop_num))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L203" title="utils/adt/numeric.c:203">NUMERIC_IS_NAN</a>(stop_num))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;stop value cannot be NaN&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;stop value cannot be infinity&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* see if we were given an explicit step size */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PG_NARGS() == <span class="Constant">3</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; step_num = PG_GETARG_NUMERIC(<span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(step_num))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L203" title="utils/adt/numeric.c:203">NUMERIC_IS_NAN</a>(step_num))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;step size cannot be NaN&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;step size cannot be infinity&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7451" title="utils/adt/numeric.c:7451">init_var_from_num</a>(step_num, &amp;steploc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L8373" title="utils/adt/numeric.c:8373">cmp_var</a>(&amp;steploc, &amp;<a href="#L415" title="utils/adt/numeric.c:415">const_zero</a>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;step size cannot <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> zero&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* create a function context for cross-call persistence */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; funcctx = SRF_FIRSTCALL_INIT();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Switch to memory context appropriate for multiple function calls.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(funcctx-&gt;multi_call_memory_ctx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* allocate memory for user context */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; fctx = (<a href="#L323" title="utils/adt/numeric.c:323">generate_series_numeric_fctx</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L323" title="utils/adt/numeric.c:323">generate_series_numeric_fctx</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Use fctx to keep state from call to call. Seed current with the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * original start value. We must copy the start_num and stop_num<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> rather than pointing to them, since we may have detoasted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * them in the per-call context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;fctx-&gt;current);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;fctx-&gt;stop);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;fctx-&gt;step);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7420" title="utils/adt/numeric.c:7420">set_var_from_num</a>(start_num, &amp;fctx-&gt;current);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7420" title="utils/adt/numeric.c:7420">set_var_from_num</a>(stop_num, &amp;fctx-&gt;stop);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7468" title="utils/adt/numeric.c:7468">set_var_from_var</a>(&amp;steploc, &amp;fctx-&gt;step);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; funcctx-&gt;user_fctx = fctx;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* stuff done on every call of the function */<br/></li>
<li></span>&nbsp; &nbsp; funcctx = SRF_PERCALL_SETUP();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get the saved state and use current state as the result of this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * iteration.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; fctx = funcctx-&gt;user_fctx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((fctx-&gt;step.sign == <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L8373" title="utils/adt/numeric.c:8373">cmp_var</a>(&amp;fctx-&gt;current, &amp;fctx-&gt;stop) &lt;= <span class="Constant">0</span>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (fctx-&gt;step.sign == <a href="#L166" title="utils/adt/numeric.c:166">NUMERIC_NEG</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L8373" title="utils/adt/numeric.c:8373">cmp_var</a>(&amp;fctx-&gt;current, &amp;fctx-&gt;stop) &gt;= <span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;fctx-&gt;current);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* switch to memory context appropriate for iteration calculation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(funcctx-&gt;multi_call_memory_ctx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* increment current in preparation for <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> iteration */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8431" title="utils/adt/numeric.c:8431">add_var</a>(&amp;fctx-&gt;current, &amp;fctx-&gt;step, &amp;fctx-&gt;current);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* do when there is more left to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; SRF_RETURN_NEXT(funcctx, NumericGetDatum(result));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* do when there is no more left */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; SRF_RETURN_DONE(funcctx);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Implements the <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> version of the width_bucket() function<br/></li>
<li></span><span class="Comment"> * defined by SQL2003. See also <a href="float.c.html#L3989" title="utils/adt/float.c:3989">width_bucket_float8</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'bound1' and 'bound2' are the <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> and <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bounds of the<br/></li>
<li></span><span class="Comment"> * histogram's <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, respectively. 'count' is the number of buckets<br/></li>
<li></span><span class="Comment"> * in the histogram. width_bucket() returns an integer indicating the<br/></li>
<li></span><span class="Comment"> * bucket number that 'operand' belongs to in an equiwidth histogram<br/></li>
<li></span><span class="Comment"> * with the specified characteristics. An operand smaller than the<br/></li>
<li></span><span class="Comment"> * <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound is assigned to bucket 0. An operand greater than the<br/></li>
<li></span><span class="Comment"> * <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound is assigned to an additional bucket (with number<br/></li>
<li></span><span class="Comment"> * count+1). We don't allow &quot;NaN&quot; for <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> arguments.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1829">&#x200c;</a><span class="linkable">width_bucket_numeric</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; operand = PG_GETARG_NUMERIC(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; bound1 = PG_GETARG_NUMERIC(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; bound2 = PG_GETARG_NUMERIC(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; count = PG_GETARG_INT32(<span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; count_var;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; result_var;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (count &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_ARGUMENT_FOR_WIDTH_BUCKET_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;count must be greater than zero&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(operand) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(bound1) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(bound2))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L203" title="utils/adt/numeric.c:203">NUMERIC_IS_NAN</a>(operand) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L203" title="utils/adt/numeric.c:203">NUMERIC_IS_NAN</a>(bound1) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L203" title="utils/adt/numeric.c:203">NUMERIC_IS_NAN</a>(bound2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_ARGUMENT_FOR_WIDTH_BUCKET_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;operand, <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound, and <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound cannot be NaN&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We allow &quot;operand&quot; to be infinite; <a href="#L2505" title="utils/adt/numeric.c:2505">cmp_numerics</a> will cope */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L206" title="utils/adt/numeric.c:206">NUMERIC_IS_INF</a>(bound1) || <a href="#L206" title="utils/adt/numeric.c:206">NUMERIC_IS_INF</a>(bound2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_ARGUMENT_FOR_WIDTH_BUCKET_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> and <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bounds must be finite&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;result_var);<br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;count_var);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Convert 'count' to a <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a>, for ease of use later */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L8104" title="utils/adt/numeric.c:8104">int64_to_numericvar</a>((int64) count, &amp;count_var);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (<a href="#L2505" title="utils/adt/numeric.c:2505">cmp_numerics</a>(bound1, bound2))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">0</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_ARGUMENT_FOR_WIDTH_BUCKET_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound cannot <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* bound1 &lt; bound2 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> -<span class="Constant">1</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2505" title="utils/adt/numeric.c:2505">cmp_numerics</a>(operand, bound1) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7468" title="utils/adt/numeric.c:7468">set_var_from_var</a>(&amp;<a href="#L415" title="utils/adt/numeric.c:415">const_zero</a>, &amp;result_var);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L2505" title="utils/adt/numeric.c:2505">cmp_numerics</a>(operand, bound2) &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8431" title="utils/adt/numeric.c:8431">add_var</a>(&amp;count_var, &amp;<a href="#L419" title="utils/adt/numeric.c:419">const_one</a>, &amp;result_var);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1917" title="utils/adt/numeric.c:1917">compute_bucket</a>(operand, bound1, bound2, &amp;count_var, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;result_var);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* bound1 &gt; bound2 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">1</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2505" title="utils/adt/numeric.c:2505">cmp_numerics</a>(operand, bound1) &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7468" title="utils/adt/numeric.c:7468">set_var_from_var</a>(&amp;<a href="#L415" title="utils/adt/numeric.c:415">const_zero</a>, &amp;result_var);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L2505" title="utils/adt/numeric.c:2505">cmp_numerics</a>(operand, bound2) &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8431" title="utils/adt/numeric.c:8431">add_var</a>(&amp;count_var, &amp;<a href="#L419" title="utils/adt/numeric.c:419">const_one</a>, &amp;result_var);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1917" title="utils/adt/numeric.c:1917">compute_bucket</a>(operand, bound1, bound2, &amp;count_var, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;result_var);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if result exceeds the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of a legal int4, we ereport here */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L4460" title="utils/adt/numeric.c:4460">numericvar_to_int32</a>(&amp;result_var, &amp;result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;integer out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;count_var);<br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;result_var);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * 'operand' is inside the bucket <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, so determine the correct<br/></li>
<li></span><span class="Comment"> * bucket for it to go. The calculations performed by this function<br/></li>
<li></span><span class="Comment"> * are derived directly from the SQL2003 spec. Note however that we<br/></li>
<li></span><span class="Comment"> * multiply by count <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> dividing, to avoid unnecessary roundoff error.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1917">&#x200c;</a></span><span class="linkable">compute_bucket</span>(Numeric operand, Numeric bound1, Numeric bound2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *count_var, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> reversed_bounds,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *result_var)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; bound1_var;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; bound2_var;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; operand_var;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L7451" title="utils/adt/numeric.c:7451">init_var_from_num</a>(bound1, &amp;bound1_var);<br/></li>
<li>&nbsp; &nbsp; <a href="#L7451" title="utils/adt/numeric.c:7451">init_var_from_num</a>(bound2, &amp;bound2_var);<br/></li>
<li>&nbsp; &nbsp; <a href="#L7451" title="utils/adt/numeric.c:7451">init_var_from_num</a>(operand, &amp;operand_var);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!reversed_bounds)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8548" title="utils/adt/numeric.c:8548">sub_var</a>(&amp;operand_var, &amp;bound1_var, &amp;operand_var);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8548" title="utils/adt/numeric.c:8548">sub_var</a>(&amp;bound2_var, &amp;bound1_var, &amp;bound2_var);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8548" title="utils/adt/numeric.c:8548">sub_var</a>(&amp;bound1_var, &amp;operand_var, &amp;operand_var);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8548" title="utils/adt/numeric.c:8548">sub_var</a>(&amp;bound1_var, &amp;bound2_var, &amp;bound2_var);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L8669" title="utils/adt/numeric.c:8669">mul_var</a>(&amp;operand_var, count_var, &amp;operand_var,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; operand_var.dscale + count_var-&gt;dscale);<br/></li>
<li>&nbsp; &nbsp; <a href="#L8877" title="utils/adt/numeric.c:8877">div_var</a>(&amp;operand_var, &amp;bound2_var, result_var,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L9777" title="utils/adt/numeric.c:9777">select_div_scale</a>(&amp;operand_var, &amp;bound2_var), <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Roundoff in the division could give us a quotient exactly <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &quot;count&quot;, which is too large.&nbsp; Clamp so that we do not emit a result<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * larger than &quot;count&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L8373" title="utils/adt/numeric.c:8373">cmp_var</a>(result_var, count_var) &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7468" title="utils/adt/numeric.c:7468">set_var_from_var</a>(count_var, result_var);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8431" title="utils/adt/numeric.c:8431">add_var</a>(result_var, &amp;<a href="#L419" title="utils/adt/numeric.c:419">const_one</a>, result_var);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L9969" title="utils/adt/numeric.c:9969">floor_var</a>(result_var, result_var);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;bound1_var);<br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;bound2_var);<br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;operand_var);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Comparison <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: btree indexes need these routines not to leak memory; therefore,<br/></li>
<li></span><span class="Comment"> * be careful to free working copies of toasted datums.&nbsp; Most places don't<br/></li>
<li></span><span class="Comment"> * need to be so careful.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Sort support:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We implement the sortsupport strategy routine in order to get the benefit of<br/></li>
<li></span><span class="Comment"> * abbreviation. The ordinary <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> comparison can be quite slow as a result<br/></li>
<li></span><span class="Comment"> * of <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>/<a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a> cycles (due to detoasting packed <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for alignment);<br/></li>
<li></span><span class="Comment"> * while this could be worked on itself, the abbreviation strategy gives more<br/></li>
<li></span><span class="Comment"> * speedup in many common cases.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Two different representations are used for the abbreviated form, one in<br/></li>
<li></span><span class="Comment"> * int32 and one in int64, whichever fits into a by-value Datum.&nbsp; In both cases<br/></li>
<li></span><span class="Comment"> * the representation is negated relative to the original value, because we use<br/></li>
<li></span><span class="Comment"> * the largest negative value for NaN, which sorts higher than other <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>. We<br/></li>
<li></span><span class="Comment"> * convert the absolute value of the <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> to a 31-<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> or 63-<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> positive<br/></li>
<li></span><span class="Comment"> * value, and then negate it if the original number was positive.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We abort the abbreviation process if the abbreviation cardinality is below<br/></li>
<li></span><span class="Comment"> * 0.01% of the row count (1 per 10k non-null rows).&nbsp; The actual break-even<br/></li>
<li></span><span class="Comment"> * point is somewhat below that, perhaps 1 per 30k (at 1 per 100k there's a<br/></li>
<li></span><span class="Comment"> * very small penalty), but we don't want to build up too many abbreviated<br/></li>
<li></span><span class="Comment"> * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> first testing for abort, so we take the slightly pessimistic<br/></li>
<li></span><span class="Comment"> * number.&nbsp; We make no attempt to estimate the cardinality of the real <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>,<br/></li>
<li></span><span class="Comment"> * since it plays no part in the cost model here (if the abbreviation is <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>,<br/></li>
<li></span><span class="Comment"> * the cost of comparing <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> and unequal underlying <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> is comparable).<br/></li>
<li></span><span class="Comment"> * We discontinue even checking for abort (saving us the hashing overhead) if<br/></li>
<li></span><span class="Comment"> * the estimated cardinality gets to 100k; that would be enough to support many<br/></li>
<li></span><span class="Comment"> * billions of rows while doing no worse than breaking even.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Sort support strategy routine.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2005">&#x200c;</a><span class="linkable">numeric_sortsupport</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SortSupport ssup = (SortSupport) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ssup-&gt;comparator = <a href="#L2181" title="utils/adt/numeric.c:2181">numeric_fast_cmp</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ssup-&gt;abbreviate)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L337" title="utils/adt/numeric.c:337">NumericSortSupport</a> *nss;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldcontext = MemoryContextSwitchTo(ssup-&gt;ssup_cxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nss = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L337" title="utils/adt/numeric.c:337">NumericSortSupport</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a> a buffer for handling unaligned packed <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in addition to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the support struct<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nss-&gt;buf = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(VARATT_SHORT_MAX + VARHDRSZ + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nss-&gt;input_count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nss-&gt;estimating = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../lib/hyperloglog.c.html#L66" title="lib/hyperloglog.c:66">initHyperLogLog</a>(&amp;nss-&gt;abbr_card, <span class="Constant">10</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ssup-&gt;ssup_extra = nss;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ssup-&gt;abbrev_full_comparator = ssup-&gt;comparator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ssup-&gt;comparator = <a href="#L2203" title="utils/adt/numeric.c:2203">numeric_cmp_abbrev</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ssup-&gt;abbrev_converter = <a href="#L2046" title="utils/adt/numeric.c:2046">numeric_abbrev_convert</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ssup-&gt;abbrev_abort = <a href="#L2108" title="utils/adt/numeric.c:2108">numeric_abbrev_abort</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VOID();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Abbreviate a <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> datum, handling NaNs and detoasting<br/></li>
<li></span><span class="Comment"> * (must not leak memory!)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Datum<br/></li>
<li><a id="L2046">&#x200c;</a><span class="linkable">numeric_abbrev_convert</span>(Datum original_datum, SortSupport ssup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L337" title="utils/adt/numeric.c:337">NumericSortSupport</a> *nss = ssup-&gt;ssup_extra;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *original_varatt = PG_DETOAST_DATUM_PACKED(original_datum);<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; value;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nss-&gt;input_count += <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is to handle packed datums without needing a <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>/<a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a> cycle;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we keep and reuse a buffer large enough to handle <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> short datum.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (VARATT_IS_SHORT(original_varatt))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *buf = nss-&gt;buf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; sz = VARSIZE_SHORT(original_varatt) - VARHDRSZ_SHORT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(sz &lt;= VARATT_SHORT_MAX - VARHDRSZ_SHORT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SET_VARSIZE(buf, VARHDRSZ + sz);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(VARDATA(buf), VARDATA_SHORT(original_varatt), sz);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; value = (Numeric) buf;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; value = (Numeric) original_varatt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(value))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L204" title="utils/adt/numeric.c:204">NUMERIC_IS_PINF</a>(value))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L399" title="utils/adt/numeric.c:399">NUMERIC_ABBREV_PINF</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L205" title="utils/adt/numeric.c:205">NUMERIC_IS_NINF</a>(value))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L400" title="utils/adt/numeric.c:400">NUMERIC_ABBREV_NINF</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L398" title="utils/adt/numeric.c:398">NUMERIC_ABBREV_NAN</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; var;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7451" title="utils/adt/numeric.c:7451">init_var_from_num</a>(value, &amp;var);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L2265" title="utils/adt/numeric.c:2265">numeric_abbrev_convert_var</a>(&amp;var, nss);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* should happen only for external/compressed toasts */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((Pointer) original_varatt != DatumGetPointer(original_datum))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(original_varatt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Consider whether to abort abbreviation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We pay no attention to the cardinality of the non-abbreviated data. There is<br/></li>
<li></span><span class="Comment"> * no reason to do so: unlike text, we have no fast check for <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, so<br/></li>
<li></span><span class="Comment"> * we pay the full overhead whenever the abbreviations are <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> regardless of<br/></li>
<li></span><span class="Comment"> * whether the underlying <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are also <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2108">&#x200c;</a></span><span class="linkable">numeric_abbrev_abort</span>(<span class="Type">int</span> memtupcount, SortSupport ssup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L337" title="utils/adt/numeric.c:337">NumericSortSupport</a> *nss = ssup-&gt;ssup_extra;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; abbr_card;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (memtupcount &lt; <span class="Constant">10000</span> || nss-&gt;input_count &lt; <span class="Constant">10000</span> || !nss-&gt;estimating)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; abbr_card = <a href="../../lib/hyperloglog.c.html#L186" title="lib/hyperloglog.c:186">estimateHyperLogLog</a>(&amp;nss-&gt;abbr_card);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we have &gt;100k distinct <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, then even if we were sorting many<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * billion rows we'd likely still break even, and the penalty of undoing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that many rows of abbrevs would probably not be worth it. Stop even<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * counting at that point.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (abbr_card &gt; <span class="Constant">100000.0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li><span class="PreProc">#ifdef TRACE_SORT<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../sort/tuplesort.c.html#L124" title="utils/sort/tuplesort.c:124">trace_sort</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;numeric_abbrev: estimation ends at cardinality </span><span class="Special">%f</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot; after &quot;</span> INT64_FORMAT <span class="Constant">&quot; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> (</span><span class="Special">%d</span><span class="Constant"> rows)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; abbr_card, nss-&gt;input_count, memtupcount);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nss-&gt;estimating = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Target minimum cardinality is 1 per ~10k of non-null inputs.&nbsp; (The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * break even point is somewhere between one per 100k rows, where<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * abbreviation has a very slight penalty, and 1 per 10k where it wins by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a measurable percentage.)&nbsp; We use the relatively pessimistic 10k<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * threshold, and add a 0.5 row fudge factor, because it allows us to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * abort earlier on genuinely pathological data where we've had exactly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * one abbreviated value in the first 10k (non-null) rows.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (abbr_card &lt; nss-&gt;input_count / <span class="Constant">10000.0</span> + <span class="Constant">0.5</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li><span class="PreProc">#ifdef TRACE_SORT<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../sort/tuplesort.c.html#L124" title="utils/sort/tuplesort.c:124">trace_sort</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;numeric_abbrev: aborting abbreviation at cardinality </span><span class="Special">%f</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot; below threshold </span><span class="Special">%f</span><span class="Constant"> after &quot;</span> INT64_FORMAT <span class="Constant">&quot; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> (</span><span class="Special">%d</span><span class="Constant"> rows)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; abbr_card, nss-&gt;input_count / <span class="Constant">10000.0</span> + <span class="Constant">0.5</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nss-&gt;input_count, memtupcount);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef TRACE_SORT<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../sort/tuplesort.c.html#L124" title="utils/sort/tuplesort.c:124">trace_sort</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;numeric_abbrev: cardinality </span><span class="Special">%f</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot; after &quot;</span> INT64_FORMAT <span class="Constant">&quot; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> (</span><span class="Special">%d</span><span class="Constant"> rows)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; abbr_card, nss-&gt;input_count, memtupcount);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Non-fmgr interface to the comparison routine to allow sortsupport to elide<br/></li>
<li></span><span class="Comment"> * the fmgr call.&nbsp; The saving here is small given how slow <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> comparisons<br/></li>
<li></span><span class="Comment"> * are, but it is a required part of the sort support API when abbreviations<br/></li>
<li></span><span class="Comment"> * are performed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Two <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>/<a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a> cycles could be saved here by using persistent buffers for<br/></li>
<li></span><span class="Comment"> * aligning short-varlena inputs, but this has not so far been considered to<br/></li>
<li></span><span class="Comment"> * be worth the effort.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L2181">&#x200c;</a></span><span class="linkable">numeric_fast_cmp</span>(Datum x, Datum y, SortSupport ssup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; nx = DatumGetNumeric(x);<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; ny = DatumGetNumeric(y);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L2505" title="utils/adt/numeric.c:2505">cmp_numerics</a>(nx, ny);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((Pointer) nx != DatumGetPointer(x))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(nx);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((Pointer) ny != DatumGetPointer(y))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(ny);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compare abbreviations of <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>. (Abbreviations may be <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> where the true<br/></li>
<li></span><span class="Comment"> * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> differ, but if the abbreviations differ, they must reflect the<br/></li>
<li></span><span class="Comment"> * ordering of the true <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L2203">&#x200c;</a></span><span class="linkable">numeric_cmp_abbrev</span>(Datum x, Datum y, SortSupport ssup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a> WELL: this is intentionally backwards, because the abbreviation is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * negated relative to the original value, to handle NaN/infinity cases.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L397" title="utils/adt/numeric.c:397">DatumGetNumericAbbrev</a>(x) &lt; <a href="#L397" title="utils/adt/numeric.c:397">DatumGetNumericAbbrev</a>(y))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L397" title="utils/adt/numeric.c:397">DatumGetNumericAbbrev</a>(x) &gt; <a href="#L397" title="utils/adt/numeric.c:397">DatumGetNumericAbbrev</a>(y))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Abbreviate a <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> according to the available <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> size.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The 31-<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> value is constructed as:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; 0 + 7bits digit weight + 24 bits digit value<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * where the digit weight is in single decimal digits, not digit words, and<br/></li>
<li></span><span class="Comment"> * stored in excess-44 representation[1]. The 24-<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> digit value is the 7 most<br/></li>
<li></span><span class="Comment"> * significant decimal digits of the value converted to binary. Values whose<br/></li>
<li></span><span class="Comment"> * <a href="tsrank.c.html#L24" title="utils/adt/tsrank.c:24">weights</a> would fall outside the representable <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> are rounded off to zero<br/></li>
<li></span><span class="Comment"> * (which is also used to represent actual zeros) or to 0x7FFFFFFF (which<br/></li>
<li></span><span class="Comment"> * otherwise cannot occur). Abbreviation therefore fails to gain <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> advantage<br/></li>
<li></span><span class="Comment"> * where <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are outside the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> 10^-44 to 10^83, which is not considered<br/></li>
<li></span><span class="Comment"> * to be a serious limitation, or when <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are of the same magnitude and<br/></li>
<li></span><span class="Comment"> * <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> in the first 7 decimal digits, which is considered to be an<br/></li>
<li></span><span class="Comment"> * unavoidable limitation given the available bits. (Stealing three more bits<br/></li>
<li></span><span class="Comment"> * to <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> another digit would narrow the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of representable <a href="tsrank.c.html#L24" title="utils/adt/tsrank.c:24">weights</a> by<br/></li>
<li></span><span class="Comment"> * a factor of 8, which starts to look like a real limiting factor.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * (The value 44 for the excess is essentially arbitrary)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The 63-<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> value is constructed as:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; 0 + 7bits weight + 4 x 14-<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> packed digit words<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The weight in this case is again stored in excess-44, but this time it is<br/></li>
<li></span><span class="Comment"> * the original weight in digit words (i.e. powers of 10000). The first four<br/></li>
<li></span><span class="Comment"> * digit words of the value (if present; trailing zeros are assumed as needed)<br/></li>
<li></span><span class="Comment"> * are packed into 14 bits each to form the rest of the value. Again,<br/></li>
<li></span><span class="Comment"> * out-of-<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are rounded off to 0 or 0x7FFFFFFFFFFFFFFF. The<br/></li>
<li></span><span class="Comment"> * representable <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> in this case is 10^-176 to 10^332, which is considered<br/></li>
<li></span><span class="Comment"> * to be good enough for all practical purposes, and comparison of 4 words<br/></li>
<li></span><span class="Comment"> * means that at least 13 decimal digits are compared, which is considered to<br/></li>
<li></span><span class="Comment"> * be a reasonable compromise between effectiveness and efficiency in computing<br/></li>
<li></span><span class="Comment"> * the abbreviation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * (The value 44 for the excess is even more arbitrary here, it was chosen just<br/></li>
<li></span><span class="Comment"> * to match the value used in the 31-<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> case)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * [1] - Excess-k representation means that the value is offset by adding 'k'<br/></li>
<li></span><span class="Comment"> * and then treated as unsigned, so the smallest representable value is stored<br/></li>
<li></span><span class="Comment"> * with all bits zero. This allows simple comparisons to work on the composite<br/></li>
<li></span><span class="Comment"> * value.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#if <a href="#L394" title="utils/adt/numeric.c:394">NUMERIC_ABBREV_BITS</a> == </span><span class="Constant">64<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> Datum<br/></li>
<li><a id="L2265">&#x200c;</a><span class="linkable">numeric_abbrev_convert_var</span>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var, <a href="#L337" title="utils/adt/numeric.c:337">NumericSortSupport</a> *nss)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndigits = var-&gt;ndigits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; weight = var-&gt;weight;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ndigits == <span class="Constant">0</span> || weight &lt; -<span class="Constant">44</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (weight &gt; <span class="Constant">83</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = PG_INT64_MAX;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = ((int64) (weight + <span class="Constant">44</span>) &lt;&lt; <span class="Constant">56</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (ndigits)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result |= ((int64) var-&gt;digits[<span class="Constant">3</span>]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALLTHROUGH */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">3</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result |= ((int64) var-&gt;digits[<span class="Constant">2</span>]) &lt;&lt; <span class="Constant">14</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALLTHROUGH */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">2</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result |= ((int64) var-&gt;digits[<span class="Constant">1</span>]) &lt;&lt; <span class="Constant">28</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALLTHROUGH */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">1</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result |= ((int64) var-&gt;digits[<span class="Constant">0</span>]) &lt;&lt; <span class="Constant">42</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* the abbrev is negated relative to the original */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;sign == <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = -result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nss-&gt;estimating)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; tmp = ((uint32) result<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ^ (uint32) ((uint64) result &gt;&gt; <span class="Constant">32</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../lib/hyperloglog.c.html#L167" title="lib/hyperloglog.c:167">addHyperLogLog</a>(&amp;nss-&gt;abbr_card, DatumGetUInt32(hash_uint32(tmp)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L396" title="utils/adt/numeric.c:396">NumericAbbrevGetDatum</a>(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L394" title="utils/adt/numeric.c:394">NUMERIC_ABBREV_BITS</a> == 64 */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#if <a href="#L394" title="utils/adt/numeric.c:394">NUMERIC_ABBREV_BITS</a> == </span><span class="Constant">32<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> Datum<br/></li>
<li><a id="L2320">&#x200c;</a><span class="linkable">numeric_abbrev_convert_var</span>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var, <a href="#L337" title="utils/adt/numeric.c:337">NumericSortSupport</a> *nss)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndigits = var-&gt;ndigits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; weight = var-&gt;weight;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ndigits == <span class="Constant">0</span> || weight &lt; -<span class="Constant">11</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (weight &gt; <span class="Constant">20</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = PG_INT32_MAX;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> nxt1 = (ndigits &gt; <span class="Constant">1</span>) ? var-&gt;digits[<span class="Constant">1</span>] : <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; weight = (weight + <span class="Constant">11</span>) * <span class="Constant">4</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = var-&gt;digits[<span class="Constant">0</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * &quot;result&quot; <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> has 1 to 4 nonzero decimal digits. We pack in more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * digits to make 7 in total (largest we can fit in 24 bits)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result &gt; <span class="Constant">999</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* already have 4 digits, add 3 more */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = (result * <span class="Constant">1000</span>) + (nxt1 / <span class="Constant">10</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; weight += <span class="Constant">3</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (result &gt; <span class="Constant">99</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* already have 3 digits, add 4 more */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = (result * <span class="Constant">10000</span>) + nxt1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; weight += <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (result &gt; <span class="Constant">9</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> nxt2 = (ndigits &gt; <span class="Constant">2</span>) ? var-&gt;digits[<span class="Constant">2</span>] : <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* already have 2 digits, add 5 more */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = (result * <span class="Constant">100000</span>) + (nxt1 * <span class="Constant">10</span>) + (nxt2 / <span class="Constant">1000</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; weight += <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> nxt2 = (ndigits &gt; <span class="Constant">2</span>) ? var-&gt;digits[<span class="Constant">2</span>] : <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* already have 1 digit, add 6 more */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = (result * <span class="Constant">1000000</span>) + (nxt1 * <span class="Constant">100</span>) + (nxt2 / <span class="Constant">100</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = result | (weight &lt;&lt; <span class="Constant">24</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* the abbrev is negated relative to the original */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;sign == <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = -result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nss-&gt;estimating)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; tmp = (uint32) result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../lib/hyperloglog.c.html#L167" title="lib/hyperloglog.c:167">addHyperLogLog</a>(&amp;nss-&gt;abbr_card, DatumGetUInt32(hash_uint32(tmp)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L396" title="utils/adt/numeric.c:396">NumericAbbrevGetDatum</a>(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L394" title="utils/adt/numeric.c:394">NUMERIC_ABBREV_BITS</a> == 32 */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Ordinary (non-sortsupport) comparisons follow.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L2399">&#x200c;</a><span class="linkable">numeric_cmp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num1 = PG_GETARG_NUMERIC(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num2 = PG_GETARG_NUMERIC(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L2505" title="utils/adt/numeric.c:2505">cmp_numerics</a>(num1, num2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(num1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(num2, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2415">&#x200c;</a><span class="linkable">numeric_eq</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num1 = PG_GETARG_NUMERIC(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num2 = PG_GETARG_NUMERIC(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L2505" title="utils/adt/numeric.c:2505">cmp_numerics</a>(num1, num2) == <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(num1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(num2, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2430">&#x200c;</a><span class="linkable">numeric_ne</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num1 = PG_GETARG_NUMERIC(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num2 = PG_GETARG_NUMERIC(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L2505" title="utils/adt/numeric.c:2505">cmp_numerics</a>(num1, num2) != <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(num1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(num2, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2445">&#x200c;</a><span class="linkable">numeric_gt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num1 = PG_GETARG_NUMERIC(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num2 = PG_GETARG_NUMERIC(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L2505" title="utils/adt/numeric.c:2505">cmp_numerics</a>(num1, num2) &gt; <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(num1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(num2, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2460">&#x200c;</a><span class="linkable">numeric_ge</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num1 = PG_GETARG_NUMERIC(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num2 = PG_GETARG_NUMERIC(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L2505" title="utils/adt/numeric.c:2505">cmp_numerics</a>(num1, num2) &gt;= <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(num1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(num2, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2475">&#x200c;</a><span class="linkable">numeric_lt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num1 = PG_GETARG_NUMERIC(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num2 = PG_GETARG_NUMERIC(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L2505" title="utils/adt/numeric.c:2505">cmp_numerics</a>(num1, num2) &lt; <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(num1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(num2, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2490">&#x200c;</a><span class="linkable">numeric_le</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num1 = PG_GETARG_NUMERIC(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num2 = PG_GETARG_NUMERIC(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L2505" title="utils/adt/numeric.c:2505">cmp_numerics</a>(num1, num2) &lt;= <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(num1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(num2, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L2505">&#x200c;</a></span><span class="linkable">cmp_numerics</span>(Numeric num1, Numeric num2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We consider all NANs to be <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> and larger than <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> non-NAN (including<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Infinity).&nbsp; This is somewhat arbitrary; the important thing is to have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a consistent sort order.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(num1))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L203" title="utils/adt/numeric.c:203">NUMERIC_IS_NAN</a>(num1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L203" title="utils/adt/numeric.c:203">NUMERIC_IS_NAN</a>(num2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* NAN = NAN */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* NAN &gt; non-NAN */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L204" title="utils/adt/numeric.c:204">NUMERIC_IS_PINF</a>(num1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L203" title="utils/adt/numeric.c:203">NUMERIC_IS_NAN</a>(num2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = -<span class="Constant">1</span>;&nbsp; &nbsp; <span class="Comment">/* PINF &lt; NAN */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L204" title="utils/adt/numeric.c:204">NUMERIC_IS_PINF</a>(num2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* PINF = PINF */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* PINF &gt; anything else */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* num1 must be NINF */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L205" title="utils/adt/numeric.c:205">NUMERIC_IS_NINF</a>(num2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* NINF = NINF */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = -<span class="Constant">1</span>;&nbsp; &nbsp; <span class="Comment">/* NINF &lt; anything else */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(num2))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L205" title="utils/adt/numeric.c:205">NUMERIC_IS_NINF</a>(num2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* normal &gt; NINF */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = -<span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* normal &lt; NAN or PINF */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L8388" title="utils/adt/numeric.c:8388">cmp_var_common</a>(<a href="#L486" title="utils/adt/numeric.c:486">NUMERIC_DIGITS</a>(num1), <a href="#L488" title="utils/adt/numeric.c:488">NUMERIC_NDIGITS</a>(num1),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L246" title="utils/adt/numeric.c:246">NUMERIC_WEIGHT</a>(num1), <a href="#L236" title="utils/adt/numeric.c:236">NUMERIC_SIGN</a>(num1),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L486" title="utils/adt/numeric.c:486">NUMERIC_DIGITS</a>(num2), <a href="#L488" title="utils/adt/numeric.c:488">NUMERIC_NDIGITS</a>(num2),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L246" title="utils/adt/numeric.c:246">NUMERIC_WEIGHT</a>(num2), <a href="#L236" title="utils/adt/numeric.c:236">NUMERIC_SIGN</a>(num2));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * in_range support function for <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2562">&#x200c;</a><span class="linkable">in_range_numeric_numeric</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; val = PG_GETARG_NUMERIC(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; base = PG_GETARG_NUMERIC(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; offset = PG_GETARG_NUMERIC(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; sub = PG_GETARG_BOOL(<span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; less = PG_GETARG_BOOL(<span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reject negative (including -Inf) or NaN offset.&nbsp; Negative is per spec,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and NaN is because appropriate semantics for that seem non-obvious.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L203" title="utils/adt/numeric.c:203">NUMERIC_IS_NAN</a>(offset) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L205" title="utils/adt/numeric.c:205">NUMERIC_IS_NINF</a>(offset) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L236" title="utils/adt/numeric.c:236">NUMERIC_SIGN</a>(offset) == <a href="#L166" title="utils/adt/numeric.c:166">NUMERIC_NEG</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid preceding or following size in window function&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Deal with cases where val and/or base is NaN, following the rule that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NaN sorts after non-NaN (cf <a href="#L2505" title="utils/adt/numeric.c:2505">cmp_numerics</a>).&nbsp; The offset cannot affect<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the conclusion.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L203" title="utils/adt/numeric.c:203">NUMERIC_IS_NAN</a>(val))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L203" title="utils/adt/numeric.c:203">NUMERIC_IS_NAN</a>(base))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* NAN = NAN */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = !less;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* NAN &gt; non-NAN */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L203" title="utils/adt/numeric.c:203">NUMERIC_IS_NAN</a>(base))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = less;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* non-NAN &lt; NAN */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Deal with infinite offset (necessarily +Inf, at this point).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(offset))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L204" title="utils/adt/numeric.c:204">NUMERIC_IS_PINF</a>(offset));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sub ? <a href="#L204" title="utils/adt/numeric.c:204">NUMERIC_IS_PINF</a>(base) : <a href="#L205" title="utils/adt/numeric.c:205">NUMERIC_IS_NINF</a>(base))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * base +/- offset would produce NaN, so return true for <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> val<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (see <a href="float.c.html#L1020" title="utils/adt/float.c:1020">in_range_float8_float8</a>() for reasoning).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (sub)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* base - offset must be -inf */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (less)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L205" title="utils/adt/numeric.c:205">NUMERIC_IS_NINF</a>(val);&nbsp; &nbsp; <span class="Comment">/* only -inf is &lt;= sum */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;&nbsp; &nbsp; <span class="Comment">/* <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> val is &gt;= sum */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* base + offset must be +inf */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (less)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;&nbsp; &nbsp; <span class="Comment">/* <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> val is &lt;= sum */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L204" title="utils/adt/numeric.c:204">NUMERIC_IS_PINF</a>(val);&nbsp; &nbsp; <span class="Comment">/* only +inf is &gt;= sum */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Deal with cases where val and/or base is infinite.&nbsp; The offset, being<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> known finite, cannot affect the conclusion.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(val))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L204" title="utils/adt/numeric.c:204">NUMERIC_IS_PINF</a>(val))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L204" title="utils/adt/numeric.c:204">NUMERIC_IS_PINF</a>(base))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;&nbsp; &nbsp; <span class="Comment">/* PINF = PINF */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = !less; <span class="Comment">/* PINF &gt; <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other non-NAN */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* val must be NINF */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L205" title="utils/adt/numeric.c:205">NUMERIC_IS_NINF</a>(base))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;&nbsp; &nbsp; <span class="Comment">/* NINF = NINF */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = less;&nbsp; &nbsp; <span class="Comment">/* NINF &lt; anything else */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(base))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L205" title="utils/adt/numeric.c:205">NUMERIC_IS_NINF</a>(base))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = !less;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* normal &gt; NINF */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = less;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* normal &lt; PINF */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise go ahead and compute base +/- offset.&nbsp; While it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * possible for this to overflow the <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> format, it's unlikely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * enough that we don't take measures to prevent it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; valv;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; basev;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; offsetv;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; sum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7451" title="utils/adt/numeric.c:7451">init_var_from_num</a>(val, &amp;valv);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7451" title="utils/adt/numeric.c:7451">init_var_from_num</a>(base, &amp;basev);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7451" title="utils/adt/numeric.c:7451">init_var_from_num</a>(offset, &amp;offsetv);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;sum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sub)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8548" title="utils/adt/numeric.c:8548">sub_var</a>(&amp;basev, &amp;offsetv, &amp;sum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8431" title="utils/adt/numeric.c:8431">add_var</a>(&amp;basev, &amp;offsetv, &amp;sum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (less)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = (<a href="#L8373" title="utils/adt/numeric.c:8373">cmp_var</a>(&amp;valv, &amp;sum) &lt;= <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = (<a href="#L8373" title="utils/adt/numeric.c:8373">cmp_var</a>(&amp;valv, &amp;sum) &gt;= <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;sum);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(val, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(base, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(offset, <span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2697">&#x200c;</a><span class="linkable">hash_numeric</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; key = PG_GETARG_NUMERIC(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; digit_hash;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; weight;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; start_offset;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end_offset;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash_len;<br/></li>
<li>&nbsp; &nbsp; <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> *digits;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If it's NaN or infinity, don't try to <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> the rest of the fields */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(key))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_UINT32(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; weight = <a href="#L246" title="utils/adt/numeric.c:246">NUMERIC_WEIGHT</a>(key);<br/></li>
<li>&nbsp; &nbsp; start_offset = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; end_offset = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Omit <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> leading or trailing zeros from the input to the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>. The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> implementation *should* guarantee that leading and trailing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * zeros are suppressed, but we're paranoid. Note that we measure the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * starting and ending offsets in units of NumericDigits, not bytes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; digits = <a href="#L486" title="utils/adt/numeric.c:486">NUMERIC_DIGITS</a>(key);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L488" title="utils/adt/numeric.c:488">NUMERIC_NDIGITS</a>(key); i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (digits[i] != (<a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a>) <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; start_offset++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The weight is effectively the # of digits <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the decimal point,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so decrement it for each leading zero we <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; weight--;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there are no non-zero digits, then the value of the number is zero,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * regardless of <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other fields.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L488" title="utils/adt/numeric.c:488">NUMERIC_NDIGITS</a>(key) == start_offset)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_UINT32(-<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <a href="#L488" title="utils/adt/numeric.c:488">NUMERIC_NDIGITS</a>(key) - <span class="Constant">1</span>; i &gt;= <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (digits[i] != (<a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a>) <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; end_offset++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we get here, there should be at least one non-zero digit */<br/></li>
<li></span>&nbsp; &nbsp; Assert(start_offset + end_offset &lt; <a href="#L488" title="utils/adt/numeric.c:488">NUMERIC_NDIGITS</a>(key));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that we don't <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> on the Numeric's scale, since two numerics can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> but have different scales. We also don't <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sign, although we could: since a sign difference implies inequality,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this shouldn't affect correctness.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; hash_len = <a href="#L488" title="utils/adt/numeric.c:488">NUMERIC_NDIGITS</a>(key) - start_offset - end_offset;<br/></li>
<li>&nbsp; &nbsp; digit_hash = hash_any((<span class="Type">unsigned</span> <span class="Type">char</span> *) (<a href="#L486" title="utils/adt/numeric.c:486">NUMERIC_DIGITS</a>(key) + start_offset),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash_len * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mix in the weight, via XOR */<br/></li>
<li></span>&nbsp; &nbsp; result = digit_hash ^ weight;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_DATUM(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns 64-<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> value by hashing a value to a 64-<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> value, with a seed.<br/></li>
<li></span><span class="Comment"> * Otherwise, similar to <a href="#L2697" title="utils/adt/numeric.c:2697">hash_numeric</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2777">&#x200c;</a><span class="linkable">hash_numeric_extended</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; key = PG_GETARG_NUMERIC(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; seed = PG_GETARG_INT64(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; digit_hash;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; weight;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; start_offset;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end_offset;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash_len;<br/></li>
<li>&nbsp; &nbsp; <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> *digits;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If it's NaN or infinity, don't try to <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> the rest of the fields */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(key))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_UINT64(seed);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; weight = <a href="#L246" title="utils/adt/numeric.c:246">NUMERIC_WEIGHT</a>(key);<br/></li>
<li>&nbsp; &nbsp; start_offset = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; end_offset = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; digits = <a href="#L486" title="utils/adt/numeric.c:486">NUMERIC_DIGITS</a>(key);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L488" title="utils/adt/numeric.c:488">NUMERIC_NDIGITS</a>(key); i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (digits[i] != (<a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a>) <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; start_offset++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; weight--;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L488" title="utils/adt/numeric.c:488">NUMERIC_NDIGITS</a>(key) == start_offset)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_UINT64(seed - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <a href="#L488" title="utils/adt/numeric.c:488">NUMERIC_NDIGITS</a>(key) - <span class="Constant">1</span>; i &gt;= <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (digits[i] != (<a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a>) <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; end_offset++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(start_offset + end_offset &lt; <a href="#L488" title="utils/adt/numeric.c:488">NUMERIC_NDIGITS</a>(key));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; hash_len = <a href="#L488" title="utils/adt/numeric.c:488">NUMERIC_NDIGITS</a>(key) - start_offset - end_offset;<br/></li>
<li>&nbsp; &nbsp; digit_hash = hash_any_extended((<span class="Type">unsigned</span> <span class="Type">char</span> *) (<a href="#L486" title="utils/adt/numeric.c:486">NUMERIC_DIGITS</a>(key)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; + start_offset),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hash_len * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; seed);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = UInt64GetDatum(DatumGetUInt64(digit_hash) ^ weight);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_DATUM(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Basic arithmetic <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2848" title="utils/adt/numeric.c:2848">numeric_add</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Add two numerics<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2848">&#x200c;</a><span class="linkable">numeric_add</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num1 = PG_GETARG_NUMERIC(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num2 = PG_GETARG_NUMERIC(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="#L2867" title="utils/adt/numeric.c:2867">numeric_add_opt_error</a>(num1, num2, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_NUMERIC(res);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2867" title="utils/adt/numeric.c:2867">numeric_add_opt_error</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Internal version of <a href="#L2848" title="utils/adt/numeric.c:2848">numeric_add</a>().&nbsp; If &quot;*have_error&quot; flag is provided,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; on error it's set to true, NULL returned.&nbsp; This is helpful when caller<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; need to handle errors by itself.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Numeric<br/></li>
<li><a id="L2867">&#x200c;</a><span class="linkable">numeric_add_opt_error</span>(Numeric num1, Numeric num2, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *have_error)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; arg1;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; arg2;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Handle NaN and infinities<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(num1) || <a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(num2))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L203" title="utils/adt/numeric.c:203">NUMERIC_IS_NAN</a>(num1) || <a href="#L203" title="utils/adt/numeric.c:203">NUMERIC_IS_NAN</a>(num2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L449" title="utils/adt/numeric.c:449">const_nan</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L204" title="utils/adt/numeric.c:204">NUMERIC_IS_PINF</a>(num1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L205" title="utils/adt/numeric.c:205">NUMERIC_IS_NINF</a>(num2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L449" title="utils/adt/numeric.c:449">const_nan</a>); <span class="Comment">/* Inf + -Inf */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L452" title="utils/adt/numeric.c:452">const_pinf</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L205" title="utils/adt/numeric.c:205">NUMERIC_IS_NINF</a>(num1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L204" title="utils/adt/numeric.c:204">NUMERIC_IS_PINF</a>(num2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L449" title="utils/adt/numeric.c:449">const_nan</a>); <span class="Comment">/* -Inf + Inf */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L455" title="utils/adt/numeric.c:455">const_ninf</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* by here, num1 must be finite, so num2 is not */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L204" title="utils/adt/numeric.c:204">NUMERIC_IS_PINF</a>(num2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L452" title="utils/adt/numeric.c:452">const_pinf</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L205" title="utils/adt/numeric.c:205">NUMERIC_IS_NINF</a>(num2));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L455" title="utils/adt/numeric.c:455">const_ninf</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Unpack the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, let <a href="#L8431" title="utils/adt/numeric.c:8431">add_var</a>() compute the result and return it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L7451" title="utils/adt/numeric.c:7451">init_var_from_num</a>(num1, &amp;arg1);<br/></li>
<li>&nbsp; &nbsp; <a href="#L7451" title="utils/adt/numeric.c:7451">init_var_from_num</a>(num2, &amp;arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;result);<br/></li>
<li>&nbsp; &nbsp; <a href="#L8431" title="utils/adt/numeric.c:8431">add_var</a>(&amp;arg1, &amp;arg2, &amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="#L7782" title="utils/adt/numeric.c:7782">make_result_opt_error</a>(&amp;result, have_error);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2925" title="utils/adt/numeric.c:2925">numeric_sub</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Subtract one <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> from another<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2925">&#x200c;</a><span class="linkable">numeric_sub</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num1 = PG_GETARG_NUMERIC(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num2 = PG_GETARG_NUMERIC(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="#L2945" title="utils/adt/numeric.c:2945">numeric_sub_opt_error</a>(num1, num2, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_NUMERIC(res);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2945" title="utils/adt/numeric.c:2945">numeric_sub_opt_error</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Internal version of <a href="#L2925" title="utils/adt/numeric.c:2925">numeric_sub</a>().&nbsp; If &quot;*have_error&quot; flag is provided,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; on error it's set to true, NULL returned.&nbsp; This is helpful when caller<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; need to handle errors by itself.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Numeric<br/></li>
<li><a id="L2945">&#x200c;</a><span class="linkable">numeric_sub_opt_error</span>(Numeric num1, Numeric num2, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *have_error)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; arg1;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; arg2;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Handle NaN and infinities<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(num1) || <a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(num2))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L203" title="utils/adt/numeric.c:203">NUMERIC_IS_NAN</a>(num1) || <a href="#L203" title="utils/adt/numeric.c:203">NUMERIC_IS_NAN</a>(num2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L449" title="utils/adt/numeric.c:449">const_nan</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L204" title="utils/adt/numeric.c:204">NUMERIC_IS_PINF</a>(num1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L204" title="utils/adt/numeric.c:204">NUMERIC_IS_PINF</a>(num2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L449" title="utils/adt/numeric.c:449">const_nan</a>); <span class="Comment">/* Inf - Inf */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L452" title="utils/adt/numeric.c:452">const_pinf</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L205" title="utils/adt/numeric.c:205">NUMERIC_IS_NINF</a>(num1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L205" title="utils/adt/numeric.c:205">NUMERIC_IS_NINF</a>(num2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L449" title="utils/adt/numeric.c:449">const_nan</a>); <span class="Comment">/* -Inf - -Inf */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L455" title="utils/adt/numeric.c:455">const_ninf</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* by here, num1 must be finite, so num2 is not */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L204" title="utils/adt/numeric.c:204">NUMERIC_IS_PINF</a>(num2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L455" title="utils/adt/numeric.c:455">const_ninf</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L205" title="utils/adt/numeric.c:205">NUMERIC_IS_NINF</a>(num2));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L452" title="utils/adt/numeric.c:452">const_pinf</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Unpack the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, let <a href="#L8548" title="utils/adt/numeric.c:8548">sub_var</a>() compute the result and return it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L7451" title="utils/adt/numeric.c:7451">init_var_from_num</a>(num1, &amp;arg1);<br/></li>
<li>&nbsp; &nbsp; <a href="#L7451" title="utils/adt/numeric.c:7451">init_var_from_num</a>(num2, &amp;arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;result);<br/></li>
<li>&nbsp; &nbsp; <a href="#L8548" title="utils/adt/numeric.c:8548">sub_var</a>(&amp;arg1, &amp;arg2, &amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="#L7782" title="utils/adt/numeric.c:7782">make_result_opt_error</a>(&amp;result, have_error);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3003" title="utils/adt/numeric.c:3003">numeric_mul</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Calculate the product of two numerics<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3003">&#x200c;</a><span class="linkable">numeric_mul</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num1 = PG_GETARG_NUMERIC(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num2 = PG_GETARG_NUMERIC(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="#L3023" title="utils/adt/numeric.c:3023">numeric_mul_opt_error</a>(num1, num2, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_NUMERIC(res);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3023" title="utils/adt/numeric.c:3023">numeric_mul_opt_error</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Internal version of <a href="#L3003" title="utils/adt/numeric.c:3003">numeric_mul</a>().&nbsp; If &quot;*have_error&quot; flag is provided,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; on error it's set to true, NULL returned.&nbsp; This is helpful when caller<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; need to handle errors by itself.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Numeric<br/></li>
<li><a id="L3023">&#x200c;</a><span class="linkable">numeric_mul_opt_error</span>(Numeric num1, Numeric num2, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *have_error)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; arg1;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; arg2;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Handle NaN and infinities<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(num1) || <a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(num2))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L203" title="utils/adt/numeric.c:203">NUMERIC_IS_NAN</a>(num1) || <a href="#L203" title="utils/adt/numeric.c:203">NUMERIC_IS_NAN</a>(num2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L449" title="utils/adt/numeric.c:449">const_nan</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L204" title="utils/adt/numeric.c:204">NUMERIC_IS_PINF</a>(num1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (<a href="#L1469" title="utils/adt/numeric.c:1469">numeric_sign_internal</a>(num2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">0</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L449" title="utils/adt/numeric.c:449">const_nan</a>); <span class="Comment">/* Inf * 0 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">1</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L452" title="utils/adt/numeric.c:452">const_pinf</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> -<span class="Constant">1</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L455" title="utils/adt/numeric.c:455">const_ninf</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L205" title="utils/adt/numeric.c:205">NUMERIC_IS_NINF</a>(num1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (<a href="#L1469" title="utils/adt/numeric.c:1469">numeric_sign_internal</a>(num2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">0</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L449" title="utils/adt/numeric.c:449">const_nan</a>); <span class="Comment">/* -Inf * 0 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">1</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L455" title="utils/adt/numeric.c:455">const_ninf</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> -<span class="Constant">1</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L452" title="utils/adt/numeric.c:452">const_pinf</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* by here, num1 must be finite, so num2 is not */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L204" title="utils/adt/numeric.c:204">NUMERIC_IS_PINF</a>(num2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (<a href="#L1469" title="utils/adt/numeric.c:1469">numeric_sign_internal</a>(num1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">0</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L449" title="utils/adt/numeric.c:449">const_nan</a>); <span class="Comment">/* 0 * Inf */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">1</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L452" title="utils/adt/numeric.c:452">const_pinf</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> -<span class="Constant">1</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L455" title="utils/adt/numeric.c:455">const_ninf</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L205" title="utils/adt/numeric.c:205">NUMERIC_IS_NINF</a>(num2));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (<a href="#L1469" title="utils/adt/numeric.c:1469">numeric_sign_internal</a>(num1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">0</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L449" title="utils/adt/numeric.c:449">const_nan</a>); <span class="Comment">/* 0 * -Inf */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">1</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L455" title="utils/adt/numeric.c:455">const_ninf</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> -<span class="Constant">1</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L452" title="utils/adt/numeric.c:452">const_pinf</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Unpack the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, let <a href="#L8669" title="utils/adt/numeric.c:8669">mul_var</a>() compute the result and return it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Unlike <a href="#L8431" title="utils/adt/numeric.c:8431">add_var</a>() and <a href="#L8548" title="utils/adt/numeric.c:8548">sub_var</a>(), <a href="#L8669" title="utils/adt/numeric.c:8669">mul_var</a>() will round its result. In the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * case of <a href="#L3003" title="utils/adt/numeric.c:3003">numeric_mul</a>(), which is invoked for the * operator on numerics,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we request exact representation for the product (rscale = sum(dscale of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * arg1, dscale of arg2)).&nbsp; If the exact result has more digits after the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * decimal point than can be stored in a <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a>, we round it.&nbsp; Rounding<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * after computing the exact result ensures that the final result is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * correctly rounded (rounding in <a href="#L8669" title="utils/adt/numeric.c:8669">mul_var</a>() using a truncated product<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * would not guarantee this).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L7451" title="utils/adt/numeric.c:7451">init_var_from_num</a>(num1, &amp;arg1);<br/></li>
<li>&nbsp; &nbsp; <a href="#L7451" title="utils/adt/numeric.c:7451">init_var_from_num</a>(num2, &amp;arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;result);<br/></li>
<li>&nbsp; &nbsp; <a href="#L8669" title="utils/adt/numeric.c:8669">mul_var</a>(&amp;arg1, &amp;arg2, &amp;result, arg1.dscale + arg2.dscale);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result.dscale &gt; <a href="#L234" title="utils/adt/numeric.c:234">NUMERIC_DSCALE_MAX</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L11749" title="utils/adt/numeric.c:11749">round_var</a>(&amp;result, <a href="#L234" title="utils/adt/numeric.c:234">NUMERIC_DSCALE_MAX</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="#L7782" title="utils/adt/numeric.c:7782">make_result_opt_error</a>(&amp;result, have_error);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3124" title="utils/adt/numeric.c:3124">numeric_div</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Divide one <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> into another<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3124">&#x200c;</a><span class="linkable">numeric_div</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num1 = PG_GETARG_NUMERIC(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num2 = PG_GETARG_NUMERIC(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="#L3144" title="utils/adt/numeric.c:3144">numeric_div_opt_error</a>(num1, num2, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_NUMERIC(res);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3144" title="utils/adt/numeric.c:3144">numeric_div_opt_error</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Internal version of <a href="#L3124" title="utils/adt/numeric.c:3124">numeric_div</a>().&nbsp; If &quot;*have_error&quot; flag is provided,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; on error it's set to true, NULL returned.&nbsp; This is helpful when caller<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; need to handle errors by itself.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Numeric<br/></li>
<li><a id="L3144">&#x200c;</a><span class="linkable">numeric_div_opt_error</span>(Numeric num1, Numeric num2, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *have_error)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; arg1;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; arg2;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rscale;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (have_error)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *have_error = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Handle NaN and infinities<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(num1) || <a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(num2))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L203" title="utils/adt/numeric.c:203">NUMERIC_IS_NAN</a>(num1) || <a href="#L203" title="utils/adt/numeric.c:203">NUMERIC_IS_NAN</a>(num2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L449" title="utils/adt/numeric.c:449">const_nan</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L204" title="utils/adt/numeric.c:204">NUMERIC_IS_PINF</a>(num1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(num2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L449" title="utils/adt/numeric.c:449">const_nan</a>); <span class="Comment">/* Inf / [-]Inf */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (<a href="#L1469" title="utils/adt/numeric.c:1469">numeric_sign_internal</a>(num2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">0</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (have_error)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *have_error = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DIVISION_BY_ZERO),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;division by zero&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">1</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L452" title="utils/adt/numeric.c:452">const_pinf</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> -<span class="Constant">1</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L455" title="utils/adt/numeric.c:455">const_ninf</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L205" title="utils/adt/numeric.c:205">NUMERIC_IS_NINF</a>(num1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(num2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L449" title="utils/adt/numeric.c:449">const_nan</a>); <span class="Comment">/* -Inf / [-]Inf */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (<a href="#L1469" title="utils/adt/numeric.c:1469">numeric_sign_internal</a>(num2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">0</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (have_error)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *have_error = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DIVISION_BY_ZERO),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;division by zero&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">1</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L455" title="utils/adt/numeric.c:455">const_ninf</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> -<span class="Constant">1</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L452" title="utils/adt/numeric.c:452">const_pinf</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* by here, num1 must be finite, so num2 is not */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * POSIX would have us return zero or minus zero if num1 is zero, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * otherwise throw an underflow error.&nbsp; But the <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> type doesn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * really do underflow, so let's just return zero.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L415" title="utils/adt/numeric.c:415">const_zero</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Unpack the arguments<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L7451" title="utils/adt/numeric.c:7451">init_var_from_num</a>(num1, &amp;arg1);<br/></li>
<li>&nbsp; &nbsp; <a href="#L7451" title="utils/adt/numeric.c:7451">init_var_from_num</a>(num2, &amp;arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Select scale for division result<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rscale = <a href="#L9777" title="utils/adt/numeric.c:9777">select_div_scale</a>(&amp;arg1, &amp;arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If &quot;have_error&quot; is provided, check for division by zero here<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (have_error &amp;&amp; (arg2.ndigits == <span class="Constant">0</span> || arg2.digits[<span class="Constant">0</span>] == <span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *have_error = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Do the divide and return the result<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L8877" title="utils/adt/numeric.c:8877">div_var</a>(&amp;arg1, &amp;arg2, &amp;result, rscale, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="#L7782" title="utils/adt/numeric.c:7782">make_result_opt_error</a>(&amp;result, have_error);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3259" title="utils/adt/numeric.c:3259">numeric_div_trunc</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Divide one <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> into another, truncating the result to an integer<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3259">&#x200c;</a><span class="linkable">numeric_div_trunc</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num1 = PG_GETARG_NUMERIC(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num2 = PG_GETARG_NUMERIC(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; arg1;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; arg2;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Handle NaN and infinities<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(num1) || <a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(num2))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L203" title="utils/adt/numeric.c:203">NUMERIC_IS_NAN</a>(num1) || <a href="#L203" title="utils/adt/numeric.c:203">NUMERIC_IS_NAN</a>(num2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L449" title="utils/adt/numeric.c:449">const_nan</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L204" title="utils/adt/numeric.c:204">NUMERIC_IS_PINF</a>(num1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(num2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L449" title="utils/adt/numeric.c:449">const_nan</a>)); <span class="Comment">/* Inf / [-]Inf */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (<a href="#L1469" title="utils/adt/numeric.c:1469">numeric_sign_internal</a>(num2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">0</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DIVISION_BY_ZERO),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;division by zero&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">1</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L452" title="utils/adt/numeric.c:452">const_pinf</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> -<span class="Constant">1</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L455" title="utils/adt/numeric.c:455">const_ninf</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L205" title="utils/adt/numeric.c:205">NUMERIC_IS_NINF</a>(num1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(num2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L449" title="utils/adt/numeric.c:449">const_nan</a>)); <span class="Comment">/* -Inf / [-]Inf */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (<a href="#L1469" title="utils/adt/numeric.c:1469">numeric_sign_internal</a>(num2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">0</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DIVISION_BY_ZERO),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;division by zero&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">1</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L455" title="utils/adt/numeric.c:455">const_ninf</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> -<span class="Constant">1</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L452" title="utils/adt/numeric.c:452">const_pinf</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* by here, num1 must be finite, so num2 is not */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * POSIX would have us return zero or minus zero if num1 is zero, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * otherwise throw an underflow error.&nbsp; But the <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> type doesn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * really do underflow, so let's just return zero.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L415" title="utils/adt/numeric.c:415">const_zero</a>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Unpack the arguments<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L7451" title="utils/adt/numeric.c:7451">init_var_from_num</a>(num1, &amp;arg1);<br/></li>
<li>&nbsp; &nbsp; <a href="#L7451" title="utils/adt/numeric.c:7451">init_var_from_num</a>(num2, &amp;arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Do the divide and return the result<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L8877" title="utils/adt/numeric.c:8877">div_var</a>(&amp;arg1, &amp;arg2, &amp;result, <span class="Constant">0</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_NUMERIC(res);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3348" title="utils/adt/numeric.c:3348">numeric_mod</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Calculate the modulo of two numerics<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3348">&#x200c;</a><span class="linkable">numeric_mod</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num1 = PG_GETARG_NUMERIC(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num2 = PG_GETARG_NUMERIC(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="#L3368" title="utils/adt/numeric.c:3368">numeric_mod_opt_error</a>(num1, num2, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_NUMERIC(res);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3368" title="utils/adt/numeric.c:3368">numeric_mod_opt_error</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Internal version of <a href="#L3348" title="utils/adt/numeric.c:3348">numeric_mod</a>().&nbsp; If &quot;*have_error&quot; flag is provided,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; on error it's set to true, NULL returned.&nbsp; This is helpful when caller<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; need to handle errors by itself.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Numeric<br/></li>
<li><a id="L3368">&#x200c;</a><span class="linkable">numeric_mod_opt_error</span>(Numeric num1, Numeric num2, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *have_error)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; arg1;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; arg2;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (have_error)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *have_error = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Handle NaN and infinities.&nbsp; We follow POSIX fmod() on this, except that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * POSIX treats x-is-infinite and y-is-zero identically, raising EDOM and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * returning NaN.&nbsp; We choose to throw error only for y-is-zero.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(num1) || <a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(num2))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L203" title="utils/adt/numeric.c:203">NUMERIC_IS_NAN</a>(num1) || <a href="#L203" title="utils/adt/numeric.c:203">NUMERIC_IS_NAN</a>(num2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L449" title="utils/adt/numeric.c:449">const_nan</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L206" title="utils/adt/numeric.c:206">NUMERIC_IS_INF</a>(num1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1469" title="utils/adt/numeric.c:1469">numeric_sign_internal</a>(num2) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (have_error)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *have_error = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DIVISION_BY_ZERO),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;division by zero&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Inf % <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> nonzero = NaN */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L449" title="utils/adt/numeric.c:449">const_nan</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* num2 must be [-]Inf; result is num1 regardless of sign of num2 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L7763" title="utils/adt/numeric.c:7763">duplicate_numeric</a>(num1);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L7451" title="utils/adt/numeric.c:7451">init_var_from_num</a>(num1, &amp;arg1);<br/></li>
<li>&nbsp; &nbsp; <a href="#L7451" title="utils/adt/numeric.c:7451">init_var_from_num</a>(num2, &amp;arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If &quot;have_error&quot; is provided, check for division by zero here<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (have_error &amp;&amp; (arg2.ndigits == <span class="Constant">0</span> || arg2.digits[<span class="Constant">0</span>] == <span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *have_error = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L9846" title="utils/adt/numeric.c:9846">mod_var</a>(&amp;arg1, &amp;arg2, &amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="#L7782" title="utils/adt/numeric.c:7782">make_result_opt_error</a>(&amp;result, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3437" title="utils/adt/numeric.c:3437">numeric_inc</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Increment a number by one<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3437">&#x200c;</a><span class="linkable">numeric_inc</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num = PG_GETARG_NUMERIC(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; arg;<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Handle NaN and infinities<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(num))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="#L7763" title="utils/adt/numeric.c:7763">duplicate_numeric</a>(num));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Compute the result and return it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L7451" title="utils/adt/numeric.c:7451">init_var_from_num</a>(num, &amp;arg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L8431" title="utils/adt/numeric.c:8431">add_var</a>(&amp;arg, &amp;<a href="#L419" title="utils/adt/numeric.c:419">const_one</a>, &amp;arg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;arg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;arg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_NUMERIC(res);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3470" title="utils/adt/numeric.c:3470">numeric_smaller</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Return the smaller of two numbers<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3470">&#x200c;</a><span class="linkable">numeric_smaller</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num1 = PG_GETARG_NUMERIC(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num2 = PG_GETARG_NUMERIC(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Use <a href="#L2505" title="utils/adt/numeric.c:2505">cmp_numerics</a> so that this will agree with the comparison operators,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * particularly as regards comparisons involving NaN.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2505" title="utils/adt/numeric.c:2505">cmp_numerics</a>(num1, num2) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(num1);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(num2);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3492" title="utils/adt/numeric.c:3492">numeric_larger</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Return the larger of two numbers<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3492">&#x200c;</a><span class="linkable">numeric_larger</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num1 = PG_GETARG_NUMERIC(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num2 = PG_GETARG_NUMERIC(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Use <a href="#L2505" title="utils/adt/numeric.c:2505">cmp_numerics</a> so that this will agree with the comparison operators,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * particularly as regards comparisons involving NaN.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2505" title="utils/adt/numeric.c:2505">cmp_numerics</a>(num1, num2) &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(num1);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(num2);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Advanced math <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3521" title="utils/adt/numeric.c:3521">numeric_gcd</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Calculate the greatest common divisor of two numerics<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3521">&#x200c;</a><span class="linkable">numeric_gcd</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num1 = PG_GETARG_NUMERIC(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num2 = PG_GETARG_NUMERIC(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; arg1;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; arg2;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Handle NaN and infinities: we consider the result to be NaN in all such<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cases.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(num1) || <a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(num2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L449" title="utils/adt/numeric.c:449">const_nan</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Unpack the arguments<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L7451" title="utils/adt/numeric.c:7451">init_var_from_num</a>(num1, &amp;arg1);<br/></li>
<li>&nbsp; &nbsp; <a href="#L7451" title="utils/adt/numeric.c:7451">init_var_from_num</a>(num2, &amp;arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Find the GCD and return the result<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L9992" title="utils/adt/numeric.c:9992">gcd_var</a>(&amp;arg1, &amp;arg2, &amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_NUMERIC(res);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3564" title="utils/adt/numeric.c:3564">numeric_lcm</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Calculate the least common multiple of two numerics<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3564">&#x200c;</a><span class="linkable">numeric_lcm</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num1 = PG_GETARG_NUMERIC(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num2 = PG_GETARG_NUMERIC(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; arg1;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; arg2;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Handle NaN and infinities: we consider the result to be NaN in all such<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cases.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(num1) || <a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(num2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L449" title="utils/adt/numeric.c:449">const_nan</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Unpack the arguments<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L7451" title="utils/adt/numeric.c:7451">init_var_from_num</a>(num1, &amp;arg1);<br/></li>
<li>&nbsp; &nbsp; <a href="#L7451" title="utils/adt/numeric.c:7451">init_var_from_num</a>(num2, &amp;arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Compute the result using lcm(x, y) = abs(x / gcd(x, y) * y), returning<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * zero if either input is zero.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that the division is guaranteed to be exact, returning an integer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * result, so the LCM is an integral multiple of both x and y.&nbsp; A display<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scale of <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(x.dscale, y.dscale) would be sufficient to represent it,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but as with other <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, we choose to return a result whose<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * display scale is no smaller than either input.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (arg1.ndigits == <span class="Constant">0</span> || arg2.ndigits == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7468" title="utils/adt/numeric.c:7468">set_var_from_var</a>(&amp;<a href="#L415" title="utils/adt/numeric.c:415">const_zero</a>, &amp;result);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L9992" title="utils/adt/numeric.c:9992">gcd_var</a>(&amp;arg1, &amp;arg2, &amp;result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8877" title="utils/adt/numeric.c:8877">div_var</a>(&amp;arg1, &amp;result, &amp;result, <span class="Constant">0</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8669" title="utils/adt/numeric.c:8669">mul_var</a>(&amp;arg2, &amp;result, &amp;result, arg2.dscale);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result.sign = <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result.dscale = Max(arg1.dscale, arg2.dscale);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_NUMERIC(res);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3624" title="utils/adt/numeric.c:3624">numeric_fac</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Compute factorial<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3624">&#x200c;</a><span class="linkable">numeric_fac</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; num = PG_GETARG_INT64(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; fact;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (num &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;factorial of a negative number is undefined&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (num &lt;= <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res = <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L419" title="utils/adt/numeric.c:419">const_one</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(res);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fail immediately if the result would overflow */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (num &gt; <span class="Constant">32177</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;value overflows <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> format&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;fact);<br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L8104" title="utils/adt/numeric.c:8104">int64_to_numericvar</a>(num, &amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (num = num - <span class="Constant">1</span>; num &gt; <span class="Constant">1</span>; num--)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* this loop can take awhile, so allow it to be interrupted */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8104" title="utils/adt/numeric.c:8104">int64_to_numericvar</a>(num, &amp;fact);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8669" title="utils/adt/numeric.c:8669">mul_var</a>(&amp;result, &amp;fact, &amp;result, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;fact);<br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_NUMERIC(res);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3676" title="utils/adt/numeric.c:3676">numeric_sqrt</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Compute the square root of a <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3676">&#x200c;</a><span class="linkable">numeric_sqrt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num = PG_GETARG_NUMERIC(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; arg;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sweight;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rscale;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Handle NaN and infinities<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(num))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* error should match that in <a href="#L10062" title="utils/adt/numeric.c:10062">sqrt_var</a>() */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L205" title="utils/adt/numeric.c:205">NUMERIC_IS_NINF</a>(num))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_ARGUMENT_FOR_POWER_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot take square root of a negative number&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* For NAN or PINF, just duplicate the input */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="#L7763" title="utils/adt/numeric.c:7763">duplicate_numeric</a>(num));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Unpack the argument and determine the result scale.&nbsp; We choose a scale<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to give at least NUMERIC_MIN_SIG_DIGITS significant digits; but in <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * case not less than the input's dscale.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L7451" title="utils/adt/numeric.c:7451">init_var_from_num</a>(num, &amp;arg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Assume the input was normalized, so arg.weight is accurate.&nbsp; The result<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * then has at least sweight = floor(arg.weight * <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> / 2 + 1)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * digits <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the decimal point.&nbsp; When <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> is even, we can save<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a few cycles, since the division is exact and there is no need to round<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * towards negative infinity.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#if <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> == ((<a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> / </span><span class="Constant">2</span><span class="PreProc">) * </span><span class="Constant">2</span><span class="PreProc">)<br/></li>
<li></span>&nbsp; &nbsp; sweight = arg.weight * <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> / <span class="Constant">2</span> + <span class="Constant">1</span>;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (arg.weight &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sweight = arg.weight * <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> / <span class="Constant">2</span> + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sweight = <span class="Constant">1</span> - (<span class="Constant">1</span> - arg.weight * <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a>) / <span class="Constant">2</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; rscale = NUMERIC_MIN_SIG_DIGITS - sweight;<br/></li>
<li>&nbsp; &nbsp; rscale = Max(rscale, arg.dscale);<br/></li>
<li>&nbsp; &nbsp; rscale = Max(rscale, NUMERIC_MIN_DISPLAY_SCALE);<br/></li>
<li>&nbsp; &nbsp; rscale = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(rscale, NUMERIC_MAX_DISPLAY_SCALE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Let <a href="#L10062" title="utils/adt/numeric.c:10062">sqrt_var</a>() do the calculation and return the result.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L10062" title="utils/adt/numeric.c:10062">sqrt_var</a>(&amp;arg, &amp;result, rscale);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_NUMERIC(res);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3748" title="utils/adt/numeric.c:3748">numeric_exp</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Raise e to the power of x<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3748">&#x200c;</a><span class="linkable">numeric_exp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num = PG_GETARG_NUMERIC(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; arg;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rscale;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Handle NaN and infinities<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(num))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Per POSIX, exp(-Inf) is zero */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L205" title="utils/adt/numeric.c:205">NUMERIC_IS_NINF</a>(num))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L415" title="utils/adt/numeric.c:415">const_zero</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* For NAN or PINF, just duplicate the input */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="#L7763" title="utils/adt/numeric.c:7763">duplicate_numeric</a>(num));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Unpack the argument and determine the result scale.&nbsp; We choose a scale<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to give at least NUMERIC_MIN_SIG_DIGITS significant digits; but in <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * case not less than the input's dscale.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L7451" title="utils/adt/numeric.c:7451">init_var_from_num</a>(num, &amp;arg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* convert input to float8, ignoring overflow */<br/></li>
<li></span>&nbsp; &nbsp; val = <a href="#L8341" title="utils/adt/numeric.c:8341">numericvar_to_double_no_overflow</a>(&amp;arg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * log10(result) = num * log10(e), so this is approximately the decimal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * weight of the result:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; val *= <span class="Constant">0.434294481903252</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* limit to something that won't cause integer overflow */<br/></li>
<li></span>&nbsp; &nbsp; val = Max(val, -NUMERIC_MAX_RESULT_SCALE);<br/></li>
<li>&nbsp; &nbsp; val = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(val, NUMERIC_MAX_RESULT_SCALE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rscale = NUMERIC_MIN_SIG_DIGITS - (<span class="Type">int</span>) val;<br/></li>
<li>&nbsp; &nbsp; rscale = Max(rscale, arg.dscale);<br/></li>
<li>&nbsp; &nbsp; rscale = Max(rscale, NUMERIC_MIN_DISPLAY_SCALE);<br/></li>
<li>&nbsp; &nbsp; rscale = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(rscale, NUMERIC_MAX_DISPLAY_SCALE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Let <a href="#L10542" title="utils/adt/numeric.c:10542">exp_var</a>() do the calculation and return the result.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L10542" title="utils/adt/numeric.c:10542">exp_var</a>(&amp;arg, &amp;result, rscale);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_NUMERIC(res);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3815" title="utils/adt/numeric.c:3815">numeric_ln</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Compute the natural logarithm of x<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3815">&#x200c;</a><span class="linkable">numeric_ln</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num = PG_GETARG_NUMERIC(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; arg;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ln_dweight;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rscale;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Handle NaN and infinities<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(num))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L205" title="utils/adt/numeric.c:205">NUMERIC_IS_NINF</a>(num))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_ARGUMENT_FOR_LOG),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot take logarithm of a negative number&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* For NAN or PINF, just duplicate the input */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="#L7763" title="utils/adt/numeric.c:7763">duplicate_numeric</a>(num));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L7451" title="utils/adt/numeric.c:7451">init_var_from_num</a>(num, &amp;arg);<br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Estimated dweight of logarithm */<br/></li>
<li></span>&nbsp; &nbsp; ln_dweight = <a href="#L10671" title="utils/adt/numeric.c:10671">estimate_ln_dweight</a>(&amp;arg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rscale = NUMERIC_MIN_SIG_DIGITS - ln_dweight;<br/></li>
<li>&nbsp; &nbsp; rscale = Max(rscale, arg.dscale);<br/></li>
<li>&nbsp; &nbsp; rscale = Max(rscale, NUMERIC_MIN_DISPLAY_SCALE);<br/></li>
<li>&nbsp; &nbsp; rscale = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(rscale, NUMERIC_MAX_DISPLAY_SCALE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L10753" title="utils/adt/numeric.c:10753">ln_var</a>(&amp;arg, &amp;result, rscale);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_NUMERIC(res);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3864" title="utils/adt/numeric.c:3864">numeric_log</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Compute the logarithm of x in a given base<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3864">&#x200c;</a><span class="linkable">numeric_log</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num1 = PG_GETARG_NUMERIC(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num2 = PG_GETARG_NUMERIC(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; arg1;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; arg2;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Handle NaN and infinities<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(num1) || <a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(num2))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sign1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sign2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L203" title="utils/adt/numeric.c:203">NUMERIC_IS_NAN</a>(num1) || <a href="#L203" title="utils/adt/numeric.c:203">NUMERIC_IS_NAN</a>(num2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L449" title="utils/adt/numeric.c:449">const_nan</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fail on negative inputs including -Inf, as <a href="#L10871" title="utils/adt/numeric.c:10871">log_var</a> would */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sign1 = <a href="#L1469" title="utils/adt/numeric.c:1469">numeric_sign_internal</a>(num1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sign2 = <a href="#L1469" title="utils/adt/numeric.c:1469">numeric_sign_internal</a>(num2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sign1 &lt; <span class="Constant">0</span> || sign2 &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_ARGUMENT_FOR_LOG),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot take logarithm of a negative number&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fail on zero inputs, as <a href="#L10871" title="utils/adt/numeric.c:10871">log_var</a> would */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sign1 == <span class="Constant">0</span> || sign2 == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_ARGUMENT_FOR_LOG),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot take logarithm of zero&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L204" title="utils/adt/numeric.c:204">NUMERIC_IS_PINF</a>(num1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* log(Inf, Inf) reduces to Inf/Inf, so it's NaN */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L204" title="utils/adt/numeric.c:204">NUMERIC_IS_PINF</a>(num2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L449" title="utils/adt/numeric.c:449">const_nan</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* log(Inf, finite-positive) is zero (we don't throw underflow) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L415" title="utils/adt/numeric.c:415">const_zero</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L204" title="utils/adt/numeric.c:204">NUMERIC_IS_PINF</a>(num2));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* log(finite-positive, Inf) is Inf */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L452" title="utils/adt/numeric.c:452">const_pinf</a>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize things<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L7451" title="utils/adt/numeric.c:7451">init_var_from_num</a>(num1, &amp;arg1);<br/></li>
<li>&nbsp; &nbsp; <a href="#L7451" title="utils/adt/numeric.c:7451">init_var_from_num</a>(num2, &amp;arg2);<br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Call <a href="#L10871" title="utils/adt/numeric.c:10871">log_var</a>() to compute and return the result; note it handles scale<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * selection itself.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L10871" title="utils/adt/numeric.c:10871">log_var</a>(&amp;arg1, &amp;arg2, &amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_NUMERIC(res);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3935" title="utils/adt/numeric.c:3935">numeric_power</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Raise x to the power of y<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3935">&#x200c;</a><span class="linkable">numeric_power</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num1 = PG_GETARG_NUMERIC(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num2 = PG_GETARG_NUMERIC(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; arg1;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; arg2;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sign1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sign2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Handle NaN and infinities<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(num1) || <a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(num2))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We follow the POSIX spec for pow(3), which says that NaN ^ 0 = 1,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and 1 ^ NaN = 1, while all other cases with NaN inputs yield NaN<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (with no error).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L203" title="utils/adt/numeric.c:203">NUMERIC_IS_NAN</a>(num1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(num2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7451" title="utils/adt/numeric.c:7451">init_var_from_num</a>(num2, &amp;arg2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L8373" title="utils/adt/numeric.c:8373">cmp_var</a>(&amp;arg2, &amp;<a href="#L415" title="utils/adt/numeric.c:415">const_zero</a>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L419" title="utils/adt/numeric.c:419">const_one</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L449" title="utils/adt/numeric.c:449">const_nan</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L203" title="utils/adt/numeric.c:203">NUMERIC_IS_NAN</a>(num2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(num1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7451" title="utils/adt/numeric.c:7451">init_var_from_num</a>(num1, &amp;arg1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L8373" title="utils/adt/numeric.c:8373">cmp_var</a>(&amp;arg1, &amp;<a href="#L419" title="utils/adt/numeric.c:419">const_one</a>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L419" title="utils/adt/numeric.c:419">const_one</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L449" title="utils/adt/numeric.c:449">const_nan</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* At least one input is infinite, but error rules still apply */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sign1 = <a href="#L1469" title="utils/adt/numeric.c:1469">numeric_sign_internal</a>(num1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sign2 = <a href="#L1469" title="utils/adt/numeric.c:1469">numeric_sign_internal</a>(num2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sign1 == <span class="Constant">0</span> &amp;&amp; sign2 &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_ARGUMENT_FOR_POWER_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;zero raised to a negative power is undefined&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sign1 &lt; <span class="Constant">0</span> &amp;&amp; !<a href="#L864" title="utils/adt/numeric.c:864">numeric_is_integral</a>(num2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_ARGUMENT_FOR_POWER_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;a negative number raised to a non-integer power yields a complex result&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * POSIX gives this series of rules for pow(3) with infinite inputs:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> value of y, if x is +1, 1.0 shall be returned.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(num1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7451" title="utils/adt/numeric.c:7451">init_var_from_num</a>(num1, &amp;arg1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L8373" title="utils/adt/numeric.c:8373">cmp_var</a>(&amp;arg1, &amp;<a href="#L419" title="utils/adt/numeric.c:419">const_one</a>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L419" title="utils/adt/numeric.c:419">const_one</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> value of x, if y is [-]0, 1.0 shall be returned.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sign2 == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L419" title="utils/adt/numeric.c:419">const_one</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> odd integer value of y &gt; 0, if x is [-]0, [-]0 shall be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * returned.&nbsp; For y &gt; 0 and not an odd integer, if x is [-]0, +0 shall<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be returned.&nbsp; (Since we don't deal in minus zero, we need not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * distinguish these two cases.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sign1 == <span class="Constant">0</span> &amp;&amp; sign2 &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L415" title="utils/adt/numeric.c:415">const_zero</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If x is -1, and y is [-]Inf, 1.0 shall be returned.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For |x| &lt; 1, if y is -Inf, +Inf shall be returned.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For |x| &gt; 1, if y is -Inf, +0 shall be returned.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For |x| &lt; 1, if y is +Inf, +0 shall be returned.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For |x| &gt; 1, if y is +Inf, +Inf shall be returned.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L206" title="utils/adt/numeric.c:206">NUMERIC_IS_INF</a>(num2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; abs_x_gt_one;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(num1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; abs_x_gt_one = <span class="Constant">true</span>;&nbsp; &nbsp; <span class="Comment">/* x is either Inf or -Inf */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7451" title="utils/adt/numeric.c:7451">init_var_from_num</a>(num1, &amp;arg1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L8373" title="utils/adt/numeric.c:8373">cmp_var</a>(&amp;arg1, &amp;<a href="#L422" title="utils/adt/numeric.c:422">const_minus_one</a>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L419" title="utils/adt/numeric.c:419">const_one</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arg1.sign = <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a>;&nbsp; &nbsp; <span class="Comment">/* <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> arg1 = abs(x) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; abs_x_gt_one = (<a href="#L8373" title="utils/adt/numeric.c:8373">cmp_var</a>(&amp;arg1, &amp;<a href="#L419" title="utils/adt/numeric.c:419">const_one</a>) &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (abs_x_gt_one == (sign2 &gt; <span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L452" title="utils/adt/numeric.c:452">const_pinf</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L415" title="utils/adt/numeric.c:415">const_zero</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For y &lt; 0, if x is +Inf, +0 shall be returned.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For y &gt; 0, if x is +Inf, +Inf shall be returned.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L204" title="utils/adt/numeric.c:204">NUMERIC_IS_PINF</a>(num1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sign2 &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L452" title="utils/adt/numeric.c:452">const_pinf</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L415" title="utils/adt/numeric.c:415">const_zero</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L205" title="utils/adt/numeric.c:205">NUMERIC_IS_NINF</a>(num1));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For y an odd integer &lt; 0, if x is -Inf, -0 shall be returned.&nbsp; For<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * y &lt; 0 and not an odd integer, if x is -Inf, +0 shall be returned.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (Again, we need not distinguish these two cases.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sign2 &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L415" title="utils/adt/numeric.c:415">const_zero</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For y an odd integer &gt; 0, if x is -Inf, -Inf shall be returned. For<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * y &gt; 0 and not an odd integer, if x is -Inf, +Inf shall be returned.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7451" title="utils/adt/numeric.c:7451">init_var_from_num</a>(num2, &amp;arg2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (arg2.ndigits &gt; <span class="Constant">0</span> &amp;&amp; arg2.ndigits == arg2.weight + <span class="Constant">1</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (arg2.digits[arg2.ndigits - <span class="Constant">1</span>] &amp; <span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L455" title="utils/adt/numeric.c:455">const_ninf</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L452" title="utils/adt/numeric.c:452">const_pinf</a>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The SQL spec requires that we emit a particular SQLSTATE error code for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * certain error conditions.&nbsp; Specifically, we don't return a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * divide-by-zero error code for 0 ^ -1.&nbsp; Raising a negative number to a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * non-integer power must produce the same error code, but that case is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * handled in <a href="#L10931" title="utils/adt/numeric.c:10931">power_var</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; sign1 = <a href="#L1469" title="utils/adt/numeric.c:1469">numeric_sign_internal</a>(num1);<br/></li>
<li>&nbsp; &nbsp; sign2 = <a href="#L1469" title="utils/adt/numeric.c:1469">numeric_sign_internal</a>(num2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (sign1 == <span class="Constant">0</span> &amp;&amp; sign2 &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_ARGUMENT_FOR_POWER_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;zero raised to a negative power is undefined&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize things<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;result);<br/></li>
<li>&nbsp; &nbsp; <a href="#L7451" title="utils/adt/numeric.c:7451">init_var_from_num</a>(num1, &amp;arg1);<br/></li>
<li>&nbsp; &nbsp; <a href="#L7451" title="utils/adt/numeric.c:7451">init_var_from_num</a>(num2, &amp;arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Call <a href="#L10931" title="utils/adt/numeric.c:10931">power_var</a>() to compute and return the result; note it handles<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scale selection itself.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L10931" title="utils/adt/numeric.c:10931">power_var</a>(&amp;arg1, &amp;arg2, &amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_NUMERIC(res);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4122" title="utils/adt/numeric.c:4122">numeric_scale</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Returns the scale, i.e. the count of decimal digits in the fractional part<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4122">&#x200c;</a><span class="linkable">numeric_scale</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num = PG_GETARG_NUMERIC(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(num))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(<a href="#L242" title="utils/adt/numeric.c:242">NUMERIC_DSCALE</a>(num));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Calculate minimum scale for value.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L4136">&#x200c;</a></span><span class="linkable">get_min_scale</span>(<a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min_scale;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last_digit_pos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ordinarily, the input value will be &quot;stripped&quot; so that the last<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> is nonzero.&nbsp; But we don't want to get into an infinite<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * loop if it isn't, so explicitly <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the last nonzero digit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; last_digit_pos = var-&gt;ndigits - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (last_digit_pos &gt;= <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; var-&gt;digits[last_digit_pos] == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; last_digit_pos--;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (last_digit_pos &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* compute min_scale assuming that last ndigit has no zeroes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; min_scale = (last_digit_pos - var-&gt;weight) * <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We could get a negative result if there are no digits after the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * decimal point.&nbsp; In this case the min_scale must be zero.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (min_scale &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Reduce min_scale if trailing digit(s) in last <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * zero.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> last_digit = var-&gt;digits[last_digit_pos];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (last_digit % <span class="Constant">10</span> == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min_scale--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last_digit /= <span class="Constant">10</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min_scale = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; min_scale = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* result if input is zero */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> min_scale;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns minimum scale required to represent supplied value without loss.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4187">&#x200c;</a><span class="linkable">numeric_min_scale</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num = PG_GETARG_NUMERIC(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; arg;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min_scale;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(num))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L7451" title="utils/adt/numeric.c:7451">init_var_from_num</a>(num, &amp;arg);<br/></li>
<li>&nbsp; &nbsp; min_scale = <a href="#L4136" title="utils/adt/numeric.c:4136">get_min_scale</a>(&amp;arg);<br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;arg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(min_scale);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Reduce scale of <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> value to represent supplied value without loss.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4207">&#x200c;</a><span class="linkable">numeric_trim_scale</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num = PG_GETARG_NUMERIC(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(num))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="#L7763" title="utils/adt/numeric.c:7763">duplicate_numeric</a>(num));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L7451" title="utils/adt/numeric.c:7451">init_var_from_num</a>(num, &amp;result);<br/></li>
<li>&nbsp; &nbsp; result.dscale = <a href="#L4136" title="utils/adt/numeric.c:4136">get_min_scale</a>(&amp;result);<br/></li>
<li>&nbsp; &nbsp; res = <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;result);<br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_NUMERIC(res);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return a random <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> value in the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> [rmin, rmax].<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Numeric<br/></li>
<li><a id="L4228">&#x200c;</a><span class="linkable">random_numeric</span>(pg_prng_state *state, Numeric rmin, Numeric rmax)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; rmin_var;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; rmax_var;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="geo_spgist.c.html#L107" title="utils/adt/geo_spgist.c:107">Range</a> bounds must not be NaN/infinity */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(rmin))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L203" title="utils/adt/numeric.c:203">NUMERIC_IS_NAN</a>(rmin))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound cannot be NaN&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound cannot be infinity&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(rmax))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L203" title="utils/adt/numeric.c:203">NUMERIC_IS_NAN</a>(rmax))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound cannot be NaN&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound cannot be infinity&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Return a random value in the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> [rmin, rmax] */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L7451" title="utils/adt/numeric.c:7451">init_var_from_num</a>(rmin, &amp;rmin_var);<br/></li>
<li>&nbsp; &nbsp; <a href="#L7451" title="utils/adt/numeric.c:7451">init_var_from_num</a>(rmax, &amp;rmax_var);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L11321" title="utils/adt/numeric.c:11321">random_var</a>(state, &amp;rmin_var, &amp;rmax_var, &amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Type conversion <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li>Numeric<br/></li>
<li><a id="L4283">&#x200c;</a><span class="linkable">int64_to_numeric</span>(int64 val)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L8104" title="utils/adt/numeric.c:8104">int64_to_numericvar</a>(val, &amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert val1/(10**log10val2) to <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a>.&nbsp; This is much faster than normal<br/></li>
<li></span><span class="Comment"> * <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> division.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Numeric<br/></li>
<li><a id="L4304">&#x200c;</a><span class="linkable">int64_div_fast_to_numeric</span>(int64 val1, <span class="Type">int</span> log10val2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rscale;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; w;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; m;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* result scale */<br/></li>
<li></span>&nbsp; &nbsp; rscale = log10val2 &lt; <span class="Constant">0</span> ? <span class="Constant">0</span> : log10val2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* how much to decrease the weight by */<br/></li>
<li></span>&nbsp; &nbsp; w = log10val2 / <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* how much is left to divide by */<br/></li>
<li></span>&nbsp; &nbsp; m = log10val2 % <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (m &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; m += <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; w--;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there is anything left to divide by (10^m with 0 &lt; m &lt; <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a>),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * multiply the dividend by 10^(<a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> - m), and shift the weight by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * one more.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (m &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li><span class="PreProc">#if <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> == </span><span class="Constant">4<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">static</span> <span class="Type">const</span> <span class="Type">int</span> pow10[] = {<span class="Constant">1</span>, <span class="Constant">10</span>, <span class="Constant">100</span>, <span class="Constant">1000</span>};<br/></li>
<li><span class="PreProc">#elif <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> == </span><span class="Constant">2<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">static</span> <span class="Type">const</span> <span class="Type">int</span> pow10[] = {<span class="Constant">1</span>, <span class="Constant">10</span>};<br/></li>
<li><span class="PreProc">#elif <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> == </span><span class="Constant">1<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">static</span> <span class="Type">const</span> <span class="Type">int</span> pow10[] = {<span class="Constant">1</span>};<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span><span class="PreProc">#error unsupported <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a><br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; factor = pow10[<a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> - m];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; new_val1;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; StaticAssertDecl(lengthof(pow10) == <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a>, <span class="Constant">&quot;mismatch with <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a>&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlikely(pg_mul_s64_overflow(val1, factor, &amp;new_val1)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li><span class="PreProc">#ifdef HAVE_INT128<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* do the multiplication using 128-<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> integers */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int128&nbsp; &nbsp; &nbsp; &nbsp; tmp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp = (int128) val1 * (int128) factor;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8295" title="utils/adt/numeric.c:8295">int128_to_numericvar</a>(tmp, &amp;result);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* do the multiplication using numerics */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; tmp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;tmp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8104" title="utils/adt/numeric.c:8104">int64_to_numericvar</a>(val1, &amp;result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8104" title="utils/adt/numeric.c:8104">int64_to_numericvar</a>(factor, &amp;tmp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8669" title="utils/adt/numeric.c:8669">mul_var</a>(&amp;result, &amp;tmp, &amp;result, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;tmp);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8104" title="utils/adt/numeric.c:8104">int64_to_numericvar</a>(new_val1, &amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; w++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8104" title="utils/adt/numeric.c:8104">int64_to_numericvar</a>(val1, &amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result.weight -= w;<br/></li>
<li>&nbsp; &nbsp; result.dscale = rscale;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L4389">&#x200c;</a><span class="linkable">int4_numeric</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; val = PG_GETARG_INT32(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="#L4283" title="utils/adt/numeric.c:4283">int64_to_numeric</a>(val));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>int32<br/></li>
<li><a id="L4397">&#x200c;</a><span class="linkable">numeric_int4_opt_error</span>(Numeric num, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *have_error)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; x;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (have_error)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *have_error = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(num))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (have_error)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *have_error = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L203" title="utils/adt/numeric.c:203">NUMERIC_IS_NAN</a>(num))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot convert NaN to </span><span class="Special">%s</span><span class="Constant">&quot;</span>, <span class="Constant">&quot;integer&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot convert infinity to </span><span class="Special">%s</span><span class="Constant">&quot;</span>, <span class="Constant">&quot;integer&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Convert to variable format, then convert to int4 */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L7451" title="utils/adt/numeric.c:7451">init_var_from_num</a>(num, &amp;x);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L4460" title="utils/adt/numeric.c:4460">numericvar_to_int32</a>(&amp;x, &amp;result))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (have_error)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *have_error = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;integer out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L4447">&#x200c;</a><span class="linkable">numeric_int4</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num = PG_GETARG_NUMERIC(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(<a href="#L4397" title="utils/adt/numeric.c:4397">numeric_int4_opt_error</a>(num, <span class="Constant">NULL</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Given a <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>, convert it to an int32. If the <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a><br/></li>
<li></span><span class="Comment"> * exceeds the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of an int32, false is returned, otherwise true is returned.<br/></li>
<li></span><span class="Comment"> * The input <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> is *not* free'd.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L4460">&#x200c;</a></span><span class="linkable">numericvar_to_int32</span>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var, int32 *result)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L8029" title="utils/adt/numeric.c:8029">numericvar_to_int64</a>(var, &amp;val))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(val &lt; PG_INT32_MIN) || unlikely(val &gt; PG_INT32_MAX))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Down-convert to int4 */<br/></li>
<li></span>&nbsp; &nbsp; *result = (int32) val;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L4477">&#x200c;</a><span class="linkable">int8_numeric</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; val = PG_GETARG_INT64(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="#L4283" title="utils/adt/numeric.c:4283">int64_to_numeric</a>(val));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>int64<br/></li>
<li><a id="L4485">&#x200c;</a><span class="linkable">numeric_int8_opt_error</span>(Numeric num, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *have_error)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; x;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (have_error)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *have_error = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(num))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (have_error)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *have_error = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L203" title="utils/adt/numeric.c:203">NUMERIC_IS_NAN</a>(num))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot convert NaN to </span><span class="Special">%s</span><span class="Constant">&quot;</span>, <span class="Constant">&quot;bigint&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot convert infinity to </span><span class="Special">%s</span><span class="Constant">&quot;</span>, <span class="Constant">&quot;bigint&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Convert to variable format, then convert to int8 */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L7451" title="utils/adt/numeric.c:7451">init_var_from_num</a>(num, &amp;x);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L8029" title="utils/adt/numeric.c:8029">numericvar_to_int64</a>(&amp;x, &amp;result))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (have_error)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *have_error = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;bigint out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L4535">&#x200c;</a><span class="linkable">numeric_int8</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num = PG_GETARG_NUMERIC(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT64(<a href="#L4485" title="utils/adt/numeric.c:4485">numeric_int8_opt_error</a>(num, <span class="Constant">NULL</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L4544">&#x200c;</a><span class="linkable">int2_numeric</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; val = PG_GETARG_INT16(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="#L4283" title="utils/adt/numeric.c:4283">int64_to_numeric</a>(val));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L4553">&#x200c;</a><span class="linkable">numeric_int2</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num = PG_GETARG_NUMERIC(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; x;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(num))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L203" title="utils/adt/numeric.c:203">NUMERIC_IS_NAN</a>(num))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot convert NaN to </span><span class="Special">%s</span><span class="Constant">&quot;</span>, <span class="Constant">&quot;smallint&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot convert infinity to </span><span class="Special">%s</span><span class="Constant">&quot;</span>, <span class="Constant">&quot;smallint&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Convert to variable format and thence to int8 */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L7451" title="utils/adt/numeric.c:7451">init_var_from_num</a>(num, &amp;x);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L8029" title="utils/adt/numeric.c:8029">numericvar_to_int64</a>(&amp;x, &amp;val))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;smallint out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(val &lt; PG_INT16_MIN) || unlikely(val &gt; PG_INT16_MAX))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;smallint out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Down-convert to int2 */<br/></li>
<li></span>&nbsp; &nbsp; result = (int16) val;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT16(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L4593">&#x200c;</a><span class="linkable">float8_numeric</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; val = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; buf[<span class="Constant">DBL_DIG</span> + <span class="Constant">100</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *endptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isnan(val))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L449" title="utils/adt/numeric.c:449">const_nan</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isinf(val))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (val &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L455" title="utils/adt/numeric.c:455">const_ninf</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L452" title="utils/adt/numeric.c:452">const_pinf</a>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snprintf(buf, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(buf), <span class="Constant">&quot;</span><span class="Special">%.*g</span><span class="Constant">&quot;</span>, <span class="Constant">DBL_DIG</span>, val);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Assume we need not worry about leading/trailing spaces */<br/></li>
<li></span>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L7012" title="utils/adt/numeric.c:7012">set_var_from_str</a>(buf, buf, &amp;result, &amp;endptr, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_NUMERIC(res);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L4628">&#x200c;</a><span class="linkable">numeric_float8</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num = PG_GETARG_NUMERIC(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *tmp;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(num))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L204" title="utils/adt/numeric.c:204">NUMERIC_IS_PINF</a>(num))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(get_float8_infinity());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L205" title="utils/adt/numeric.c:205">NUMERIC_IS_NINF</a>(num))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(-get_float8_infinity());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(get_float8_nan());<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tmp = DatumGetCString(DirectFunctionCall1(<a href="#L807" title="utils/adt/numeric.c:807">numeric_out</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NumericGetDatum(num)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = DirectFunctionCall1(<a href="float.c.html#L357" title="utils/adt/float.c:357">float8in</a>, CStringGetDatum(tmp));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(tmp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_DATUM(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> to float8; if out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, return +/- HUGE_VAL<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * (<a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> helper function, not directly callable from SQL)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4661">&#x200c;</a><span class="linkable">numeric_float8_no_overflow</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num = PG_GETARG_NUMERIC(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(num))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L204" title="utils/adt/numeric.c:204">NUMERIC_IS_PINF</a>(num))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val = <span class="Constant">HUGE_VAL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L205" title="utils/adt/numeric.c:205">NUMERIC_IS_NINF</a>(num))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val = -<span class="Constant">HUGE_VAL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val = get_float8_nan();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; x;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7451" title="utils/adt/numeric.c:7451">init_var_from_num</a>(num, &amp;x);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; val = <a href="#L8341" title="utils/adt/numeric.c:8341">numericvar_to_double_no_overflow</a>(&amp;x);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(val);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L4687">&#x200c;</a><span class="linkable">float4_numeric</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; val = PG_GETARG_FLOAT4(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; buf[<span class="Constant">FLT_DIG</span> + <span class="Constant">100</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *endptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isnan(val))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L449" title="utils/adt/numeric.c:449">const_nan</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isinf(val))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (val &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L455" title="utils/adt/numeric.c:455">const_ninf</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L452" title="utils/adt/numeric.c:452">const_pinf</a>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snprintf(buf, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(buf), <span class="Constant">&quot;</span><span class="Special">%.*g</span><span class="Constant">&quot;</span>, <span class="Constant">FLT_DIG</span>, val);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Assume we need not worry about leading/trailing spaces */<br/></li>
<li></span>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L7012" title="utils/adt/numeric.c:7012">set_var_from_str</a>(buf, buf, &amp;result, &amp;endptr, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_NUMERIC(res);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L4722">&#x200c;</a><span class="linkable">numeric_float4</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num = PG_GETARG_NUMERIC(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *tmp;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(num))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L204" title="utils/adt/numeric.c:204">NUMERIC_IS_PINF</a>(num))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT4(get_float4_infinity());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L205" title="utils/adt/numeric.c:205">NUMERIC_IS_NINF</a>(num))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT4(-get_float4_infinity());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT4(get_float4_nan());<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tmp = DatumGetCString(DirectFunctionCall1(<a href="#L807" title="utils/adt/numeric.c:807">numeric_out</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NumericGetDatum(num)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = DirectFunctionCall1(<a href="float.c.html#L157" title="utils/adt/float.c:157">float4in</a>, CStringGetDatum(tmp));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(tmp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_DATUM(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L4750">&#x200c;</a><span class="linkable">numeric_pg_lsn</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; num = PG_GETARG_NUMERIC(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; x;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(num))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L203" title="utils/adt/numeric.c:203">NUMERIC_IS_NAN</a>(num))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot convert NaN to </span><span class="Special">%s</span><span class="Constant">&quot;</span>, <span class="Constant">&quot;pg_lsn&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot convert infinity to </span><span class="Special">%s</span><span class="Constant">&quot;</span>, <span class="Constant">&quot;pg_lsn&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Convert to variable format and thence to pg_lsn */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L7451" title="utils/adt/numeric.c:7451">init_var_from_num</a>(num, &amp;x);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L8151" title="utils/adt/numeric.c:8151">numericvar_to_uint64</a>(&amp;x, (uint64 *) &amp;result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;pg_lsn out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_LSN(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Aggregate <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The transition datatype for all these aggregates is declared as INTERNAL.<br/></li>
<li></span><span class="Comment"> * Actually, it's a pointer to a <a href="#L4794" title="utils/adt/numeric.c:4794">NumericAggState</a> allocated in the aggregate<br/></li>
<li></span><span class="Comment"> * context.&nbsp; The digit buffers for the NumericVars will be there too.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On platforms which support 128-<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> integers some aggregates instead use a<br/></li>
<li></span><span class="Comment"> * 128-<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> integer based transition datatype to speed up calculations.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><a id="L4794">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">NumericAggState</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; calcSumX2;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if true, calculate sumX2 */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContext agg_context;&nbsp; &nbsp; <span class="Comment">/* context we're calculating in */<br/></li>
<li></span>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; N;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* count of processed numbers */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L370" title="utils/adt/numeric.c:370">NumericSumAccum</a> sumX;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* sum of processed numbers */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L370" title="utils/adt/numeric.c:370">NumericSumAccum</a> sumX2;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* sum of squares of processed numbers */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxScale;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* maximum scale seen so far */<br/></li>
<li></span>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; maxScaleCount;&nbsp; &nbsp; <span class="Comment">/* number of <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> seen with maximum scale */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* These counts are *not* included in N!&nbsp; Use <a href="#L4809" title="utils/adt/numeric.c:4809">NA_TOTAL_COUNT</a>() as needed */<br/></li>
<li></span>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; NaNcount;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* count of NaN <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; pInfcount;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* count of +Inf <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; nInfcount;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* count of -Inf <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li><a id="L4807">&#x200c;</a></span>} <span class="linkable">NumericAggState</span>;<br/></li>
<li><br/></li>
<li><a id="L4809">&#x200c;</a><span class="PreProc">#define <span class="linkable">NA_TOTAL_COUNT</span>(na) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((na)-&gt;N + (na)-&gt;NaNcount + (na)-&gt;pInfcount + (na)-&gt;nInfcount)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Prepare state data for a <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> aggregate function that needs to compute<br/></li>
<li></span><span class="Comment"> * sum, count and optionally sum of squares of the input.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L4794" title="utils/adt/numeric.c:4794">NumericAggState</a> *<br/></li>
<li><a id="L4817">&#x200c;</a><span class="linkable">makeNumericAggState</span>(FunctionCallInfo fcinfo, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> calcSumX2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L4794" title="utils/adt/numeric.c:4794">NumericAggState</a> *state;<br/></li>
<li>&nbsp; &nbsp; MemoryContext agg_context;<br/></li>
<li>&nbsp; &nbsp; MemoryContext old_context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../executor/nodeAgg.c.html#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>(fcinfo, &amp;agg_context))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;aggregate function called in non-aggregate context&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; old_context = MemoryContextSwitchTo(agg_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = (<a href="#L4794" title="utils/adt/numeric.c:4794">NumericAggState</a> *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L4794" title="utils/adt/numeric.c:4794">NumericAggState</a>));<br/></li>
<li>&nbsp; &nbsp; state-&gt;calcSumX2 = calcSumX2;<br/></li>
<li>&nbsp; &nbsp; state-&gt;agg_context = agg_context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(old_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> state;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Like <a href="#L4817" title="utils/adt/numeric.c:4817">makeNumericAggState</a>(), but allocate the state in the current memory<br/></li>
<li></span><span class="Comment"> * context.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L4794" title="utils/adt/numeric.c:4794">NumericAggState</a> *<br/></li>
<li><a id="L4842">&#x200c;</a><span class="linkable">makeNumericAggStateCurrentContext</span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> calcSumX2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L4794" title="utils/adt/numeric.c:4794">NumericAggState</a> *state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = (<a href="#L4794" title="utils/adt/numeric.c:4794">NumericAggState</a> *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L4794" title="utils/adt/numeric.c:4794">NumericAggState</a>));<br/></li>
<li>&nbsp; &nbsp; state-&gt;calcSumX2 = calcSumX2;<br/></li>
<li>&nbsp; &nbsp; state-&gt;agg_context = <a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> state;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Accumulate a new input value for <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> aggregate <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4857">&#x200c;</a></span><span class="linkable">do_numeric_accum</span>(<a href="#L4794" title="utils/adt/numeric.c:4794">NumericAggState</a> *state, Numeric <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; X;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; X2;<br/></li>
<li>&nbsp; &nbsp; MemoryContext old_context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Count NaN/infinity inputs separately from all else */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L204" title="utils/adt/numeric.c:204">NUMERIC_IS_PINF</a>(<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;pInfcount++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L205" title="utils/adt/numeric.c:205">NUMERIC_IS_NINF</a>(<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;nInfcount++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;NaNcount++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* load processed number in short-lived context */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L7451" title="utils/adt/numeric.c:7451">init_var_from_num</a>(<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, &amp;X);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Track the highest input dscale that we've seen, to support inverse<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transitions (see <a href="#L4927" title="utils/adt/numeric.c:4927">do_numeric_discard</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (X.dscale &gt; state-&gt;maxScale)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;maxScale = X.dscale;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;maxScaleCount = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (X.dscale == state-&gt;maxScale)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;maxScaleCount++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if we need X^2, calculate that in short-lived context */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;calcSumX2)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;X2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8669" title="utils/adt/numeric.c:8669">mul_var</a>(&amp;X, &amp;X, &amp;X2, X.dscale * <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The rest of this needs to work in the aggregate context */<br/></li>
<li></span>&nbsp; &nbsp; old_context = MemoryContextSwitchTo(state-&gt;agg_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;N++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Accumulate sums */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L11974" title="utils/adt/numeric.c:11974">accum_sum_add</a>(&amp;(state-&gt;sumX), &amp;X);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;calcSumX2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L11974" title="utils/adt/numeric.c:11974">accum_sum_add</a>(&amp;(state-&gt;sumX2), &amp;X2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(old_context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Attempt to remove an input value from the aggregated state.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the value cannot be removed then the function will return false; the<br/></li>
<li></span><span class="Comment"> * possible reasons for failing are described below.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If we aggregate the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> 1.01 and 2 then the result will be 3.01.<br/></li>
<li></span><span class="Comment"> * If we are then asked to un-aggregate the 1.01 then we must fail as we<br/></li>
<li></span><span class="Comment"> * won't be able to tell what the new aggregated value's dscale should be.<br/></li>
<li></span><span class="Comment"> * We don't want to return 2.00 (dscale = 2), since the sum's dscale would<br/></li>
<li></span><span class="Comment"> * have been zero if we'd really aggregated only 2.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: alternatively, we could count the number of inputs with each possible<br/></li>
<li></span><span class="Comment"> * dscale (up to some sane limit).&nbsp; Not yet clear if it's worth the trouble.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L4927">&#x200c;</a></span><span class="linkable">do_numeric_discard</span>(<a href="#L4794" title="utils/adt/numeric.c:4794">NumericAggState</a> *state, Numeric <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; X;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; X2;<br/></li>
<li>&nbsp; &nbsp; MemoryContext old_context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Count NaN/infinity inputs separately from all else */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L204" title="utils/adt/numeric.c:204">NUMERIC_IS_PINF</a>(<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;pInfcount--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L205" title="utils/adt/numeric.c:205">NUMERIC_IS_NINF</a>(<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;nInfcount--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;NaNcount--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* load processed number in short-lived context */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L7451" title="utils/adt/numeric.c:7451">init_var_from_num</a>(<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, &amp;X);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * state-&gt;sumX's dscale is the maximum dscale of <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the inputs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Removing the last input with that dscale would require us to recompute<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the maximum dscale of the *remaining* inputs, which we cannot do unless<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * no more non-NaN inputs remain at all.&nbsp; So we report a failure instead,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and force the aggregation to be redone from scratch.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (X.dscale == state-&gt;maxScale)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;maxScaleCount &gt; <span class="Constant">1</span> || state-&gt;maxScale == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Some remaining inputs have same dscale, or dscale hasn't gotten<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * above zero anyway<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;maxScaleCount--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (state-&gt;N == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No remaining non-NaN inputs at all, so reset maxScale */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;maxScale = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;maxScaleCount = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Correct new maxScale is uncertain, must fail */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if we need X^2, calculate that in short-lived context */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;calcSumX2)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;X2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8669" title="utils/adt/numeric.c:8669">mul_var</a>(&amp;X, &amp;X, &amp;X2, X.dscale * <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The rest of this needs to work in the aggregate context */<br/></li>
<li></span>&nbsp; &nbsp; old_context = MemoryContextSwitchTo(state-&gt;agg_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;N-- &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Negate X, to subtract it from the sum */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; X.sign = (X.sign == <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a> ? <a href="#L166" title="utils/adt/numeric.c:166">NUMERIC_NEG</a> : <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L11974" title="utils/adt/numeric.c:11974">accum_sum_add</a>(&amp;(state-&gt;sumX), &amp;X);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;calcSumX2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Negate X^2. X^2 is always positive */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; X2.sign = <a href="#L166" title="utils/adt/numeric.c:166">NUMERIC_NEG</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L11974" title="utils/adt/numeric.c:11974">accum_sum_add</a>(&amp;(state-&gt;sumX2), &amp;X2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Zero the sums */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(state-&gt;N == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L11958" title="utils/adt/numeric.c:11958">accum_sum_reset</a>(&amp;state-&gt;sumX);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;calcSumX2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L11958" title="utils/adt/numeric.c:11958">accum_sum_reset</a>(&amp;state-&gt;sumX2);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(old_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Generic transition function for <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> aggregates that require sumX2.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L5020">&#x200c;</a><span class="linkable">numeric_accum</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L4794" title="utils/adt/numeric.c:4794">NumericAggState</a> *state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = PG_ARGISNULL(<span class="Constant">0</span>) ? <span class="Constant">NULL</span> : (<a href="#L4794" title="utils/adt/numeric.c:4794">NumericAggState</a> *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create the state data on the first call */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state = <a href="#L4817" title="utils/adt/numeric.c:4817">makeNumericAggState</a>(fcinfo, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!PG_ARGISNULL(<span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4857" title="utils/adt/numeric.c:4857">do_numeric_accum</a>(state, PG_GETARG_NUMERIC(<span class="Constant">1</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(state);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Generic <a href="../../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> function for <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> aggregates which require sumX2<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L5040">&#x200c;</a><span class="linkable">numeric_combine</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L4794" title="utils/adt/numeric.c:4794">NumericAggState</a> *state1;<br/></li>
<li>&nbsp; &nbsp; <a href="#L4794" title="utils/adt/numeric.c:4794">NumericAggState</a> *state2;<br/></li>
<li>&nbsp; &nbsp; MemoryContext agg_context;<br/></li>
<li>&nbsp; &nbsp; MemoryContext old_context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../executor/nodeAgg.c.html#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>(fcinfo, &amp;agg_context))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;aggregate function called in non-aggregate context&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state1 = PG_ARGISNULL(<span class="Constant">0</span>) ? <span class="Constant">NULL</span> : (<a href="#L4794" title="utils/adt/numeric.c:4794">NumericAggState</a> *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; state2 = PG_ARGISNULL(<span class="Constant">1</span>) ? <span class="Constant">NULL</span> : (<a href="#L4794" title="utils/adt/numeric.c:4794">NumericAggState</a> *) PG_GETARG_POINTER(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state2 == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_POINTER(state1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* manually copy all fields from state2 to state1 */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state1 == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; old_context = MemoryContextSwitchTo(agg_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state1 = <a href="#L4842" title="utils/adt/numeric.c:4842">makeNumericAggStateCurrentContext</a>(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state1-&gt;N = state2-&gt;N;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state1-&gt;NaNcount = state2-&gt;NaNcount;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state1-&gt;pInfcount = state2-&gt;pInfcount;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state1-&gt;nInfcount = state2-&gt;nInfcount;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state1-&gt;maxScale = state2-&gt;maxScale;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state1-&gt;maxScaleCount = state2-&gt;maxScaleCount;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L12235" title="utils/adt/numeric.c:12235">accum_sum_copy</a>(&amp;state1-&gt;sumX, &amp;state2-&gt;sumX);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L12235" title="utils/adt/numeric.c:12235">accum_sum_copy</a>(&amp;state1-&gt;sumX2, &amp;state2-&gt;sumX2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(old_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_POINTER(state1);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state1-&gt;N += state2-&gt;N;<br/></li>
<li>&nbsp; &nbsp; state1-&gt;NaNcount += state2-&gt;NaNcount;<br/></li>
<li>&nbsp; &nbsp; state1-&gt;pInfcount += state2-&gt;pInfcount;<br/></li>
<li>&nbsp; &nbsp; state1-&gt;nInfcount += state2-&gt;nInfcount;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state2-&gt;N &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * These are currently only needed for moving aggregates, but let's do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the right thing anyway...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state2-&gt;maxScale &gt; state1-&gt;maxScale)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state1-&gt;maxScale = state2-&gt;maxScale;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state1-&gt;maxScaleCount = state2-&gt;maxScaleCount;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (state2-&gt;maxScale == state1-&gt;maxScale)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state1-&gt;maxScaleCount += state2-&gt;maxScaleCount;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The rest of this needs to work in the aggregate context */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; old_context = MemoryContextSwitchTo(agg_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Accumulate sums */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L12252" title="utils/adt/numeric.c:12252">accum_sum_combine</a>(&amp;state1-&gt;sumX, &amp;state2-&gt;sumX);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L12252" title="utils/adt/numeric.c:12252">accum_sum_combine</a>(&amp;state1-&gt;sumX2, &amp;state2-&gt;sumX2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(old_context);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(state1);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Generic transition function for <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> aggregates that don't require sumX2.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L5112">&#x200c;</a><span class="linkable">numeric_avg_accum</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L4794" title="utils/adt/numeric.c:4794">NumericAggState</a> *state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = PG_ARGISNULL(<span class="Constant">0</span>) ? <span class="Constant">NULL</span> : (<a href="#L4794" title="utils/adt/numeric.c:4794">NumericAggState</a> *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create the state data on the first call */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state = <a href="#L4817" title="utils/adt/numeric.c:4817">makeNumericAggState</a>(fcinfo, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!PG_ARGISNULL(<span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4857" title="utils/adt/numeric.c:4857">do_numeric_accum</a>(state, PG_GETARG_NUMERIC(<span class="Constant">1</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(state);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Combine function for <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> aggregates which don't require sumX2<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L5132">&#x200c;</a><span class="linkable">numeric_avg_combine</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L4794" title="utils/adt/numeric.c:4794">NumericAggState</a> *state1;<br/></li>
<li>&nbsp; &nbsp; <a href="#L4794" title="utils/adt/numeric.c:4794">NumericAggState</a> *state2;<br/></li>
<li>&nbsp; &nbsp; MemoryContext agg_context;<br/></li>
<li>&nbsp; &nbsp; MemoryContext old_context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../executor/nodeAgg.c.html#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>(fcinfo, &amp;agg_context))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;aggregate function called in non-aggregate context&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state1 = PG_ARGISNULL(<span class="Constant">0</span>) ? <span class="Constant">NULL</span> : (<a href="#L4794" title="utils/adt/numeric.c:4794">NumericAggState</a> *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; state2 = PG_ARGISNULL(<span class="Constant">1</span>) ? <span class="Constant">NULL</span> : (<a href="#L4794" title="utils/adt/numeric.c:4794">NumericAggState</a> *) PG_GETARG_POINTER(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state2 == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_POINTER(state1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* manually copy all fields from state2 to state1 */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state1 == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; old_context = MemoryContextSwitchTo(agg_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state1 = <a href="#L4842" title="utils/adt/numeric.c:4842">makeNumericAggStateCurrentContext</a>(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state1-&gt;N = state2-&gt;N;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state1-&gt;NaNcount = state2-&gt;NaNcount;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state1-&gt;pInfcount = state2-&gt;pInfcount;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state1-&gt;nInfcount = state2-&gt;nInfcount;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state1-&gt;maxScale = state2-&gt;maxScale;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state1-&gt;maxScaleCount = state2-&gt;maxScaleCount;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L12235" title="utils/adt/numeric.c:12235">accum_sum_copy</a>(&amp;state1-&gt;sumX, &amp;state2-&gt;sumX);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(old_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_POINTER(state1);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state1-&gt;N += state2-&gt;N;<br/></li>
<li>&nbsp; &nbsp; state1-&gt;NaNcount += state2-&gt;NaNcount;<br/></li>
<li>&nbsp; &nbsp; state1-&gt;pInfcount += state2-&gt;pInfcount;<br/></li>
<li>&nbsp; &nbsp; state1-&gt;nInfcount += state2-&gt;nInfcount;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state2-&gt;N &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * These are currently only needed for moving aggregates, but let's do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the right thing anyway...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state2-&gt;maxScale &gt; state1-&gt;maxScale)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state1-&gt;maxScale = state2-&gt;maxScale;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state1-&gt;maxScaleCount = state2-&gt;maxScaleCount;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (state2-&gt;maxScale == state1-&gt;maxScale)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state1-&gt;maxScaleCount += state2-&gt;maxScaleCount;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The rest of this needs to work in the aggregate context */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; old_context = MemoryContextSwitchTo(agg_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Accumulate sums */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L12252" title="utils/adt/numeric.c:12252">accum_sum_combine</a>(&amp;state1-&gt;sumX, &amp;state2-&gt;sumX);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(old_context);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(state1);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5204" title="utils/adt/numeric.c:5204">numeric_avg_serialize</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Serialize <a href="#L4794" title="utils/adt/numeric.c:4794">NumericAggState</a> for <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> aggregates that don't require<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; sumX2.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L5204">&#x200c;</a><span class="linkable">numeric_avg_serialize</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L4794" title="utils/adt/numeric.c:4794">NumericAggState</a> *state;<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; tmp_var;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Ensure we disallow calling when not in aggregate context */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../executor/nodeAgg.c.html#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>(fcinfo, <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;aggregate function called in non-aggregate context&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = (<a href="#L4794" title="utils/adt/numeric.c:4794">NumericAggState</a> *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;tmp_var);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L326" title="libpq/pqformat.c:326">pq_begintypsend</a>(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* N */<br/></li>
<li></span>&nbsp; &nbsp; pq_sendint64(&amp;buf, state-&gt;N);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sumX */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L12184" title="utils/adt/numeric.c:12184">accum_sum_final</a>(&amp;state-&gt;sumX, &amp;tmp_var);<br/></li>
<li>&nbsp; &nbsp; <a href="#L7724" title="utils/adt/numeric.c:7724">numericvar_serialize</a>(&amp;buf, &amp;tmp_var);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* maxScale */<br/></li>
<li></span>&nbsp; &nbsp; pq_sendint32(&amp;buf, state-&gt;maxScale);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* maxScaleCount */<br/></li>
<li></span>&nbsp; &nbsp; pq_sendint64(&amp;buf, state-&gt;maxScaleCount);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* NaNcount */<br/></li>
<li></span>&nbsp; &nbsp; pq_sendint64(&amp;buf, state-&gt;NaNcount);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* pInfcount */<br/></li>
<li></span>&nbsp; &nbsp; pq_sendint64(&amp;buf, state-&gt;pInfcount);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* nInfcount */<br/></li>
<li></span>&nbsp; &nbsp; pq_sendint64(&amp;buf, state-&gt;nInfcount);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="../../libpq/pqformat.c.html#L346" title="libpq/pqformat.c:346">pq_endtypsend</a>(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;tmp_var);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BYTEA_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5256" title="utils/adt/numeric.c:5256">numeric_avg_deserialize</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Deserialize bytea into <a href="#L4794" title="utils/adt/numeric.c:4794">NumericAggState</a> for <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> aggregates that<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; don't require sumX2.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L5256">&#x200c;</a><span class="linkable">numeric_avg_deserialize</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *sstate;<br/></li>
<li>&nbsp; &nbsp; <a href="#L4794" title="utils/adt/numeric.c:4794">NumericAggState</a> *result;<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; tmp_var;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../executor/nodeAgg.c.html#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>(fcinfo, <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;aggregate function called in non-aggregate context&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sstate = PG_GETARG_BYTEA_PP(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;tmp_var);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize a StringInfo so that we can &quot;receive&quot; it using the standard<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../port/win32/socket.c.html#L37" title="port/win32/socket.c:37">recv</a>-function infrastructure.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; initReadOnlyStringInfo(&amp;buf, VARDATA_ANY(sstate),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VARSIZE_ANY_EXHDR(sstate));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L4842" title="utils/adt/numeric.c:4842">makeNumericAggStateCurrentContext</a>(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* N */<br/></li>
<li></span>&nbsp; &nbsp; result-&gt;N = <a href="../../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sumX */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L7740" title="utils/adt/numeric.c:7740">numericvar_deserialize</a>(&amp;buf, &amp;tmp_var);<br/></li>
<li>&nbsp; &nbsp; <a href="#L11974" title="utils/adt/numeric.c:11974">accum_sum_add</a>(&amp;(result-&gt;sumX), &amp;tmp_var);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* maxScale */<br/></li>
<li></span>&nbsp; &nbsp; result-&gt;maxScale = <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(&amp;buf, <span class="Constant">4</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* maxScaleCount */<br/></li>
<li></span>&nbsp; &nbsp; result-&gt;maxScaleCount = <a href="../../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* NaNcount */<br/></li>
<li></span>&nbsp; &nbsp; result-&gt;NaNcount = <a href="../../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* pInfcount */<br/></li>
<li></span>&nbsp; &nbsp; result-&gt;pInfcount = <a href="../../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* nInfcount */<br/></li>
<li></span>&nbsp; &nbsp; result-&gt;nInfcount = <a href="../../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L635" title="libpq/pqformat.c:635">pq_getmsgend</a>(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;tmp_var);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5314" title="utils/adt/numeric.c:5314">numeric_serialize</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Serialization function for <a href="#L4794" title="utils/adt/numeric.c:4794">NumericAggState</a> for <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> aggregates that<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; require sumX2.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L5314">&#x200c;</a><span class="linkable">numeric_serialize</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L4794" title="utils/adt/numeric.c:4794">NumericAggState</a> *state;<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; tmp_var;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Ensure we disallow calling when not in aggregate context */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../executor/nodeAgg.c.html#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>(fcinfo, <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;aggregate function called in non-aggregate context&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = (<a href="#L4794" title="utils/adt/numeric.c:4794">NumericAggState</a> *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;tmp_var);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L326" title="libpq/pqformat.c:326">pq_begintypsend</a>(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* N */<br/></li>
<li></span>&nbsp; &nbsp; pq_sendint64(&amp;buf, state-&gt;N);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sumX */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L12184" title="utils/adt/numeric.c:12184">accum_sum_final</a>(&amp;state-&gt;sumX, &amp;tmp_var);<br/></li>
<li>&nbsp; &nbsp; <a href="#L7724" title="utils/adt/numeric.c:7724">numericvar_serialize</a>(&amp;buf, &amp;tmp_var);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sumX2 */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L12184" title="utils/adt/numeric.c:12184">accum_sum_final</a>(&amp;state-&gt;sumX2, &amp;tmp_var);<br/></li>
<li>&nbsp; &nbsp; <a href="#L7724" title="utils/adt/numeric.c:7724">numericvar_serialize</a>(&amp;buf, &amp;tmp_var);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* maxScale */<br/></li>
<li></span>&nbsp; &nbsp; pq_sendint32(&amp;buf, state-&gt;maxScale);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* maxScaleCount */<br/></li>
<li></span>&nbsp; &nbsp; pq_sendint64(&amp;buf, state-&gt;maxScaleCount);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* NaNcount */<br/></li>
<li></span>&nbsp; &nbsp; pq_sendint64(&amp;buf, state-&gt;NaNcount);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* pInfcount */<br/></li>
<li></span>&nbsp; &nbsp; pq_sendint64(&amp;buf, state-&gt;pInfcount);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* nInfcount */<br/></li>
<li></span>&nbsp; &nbsp; pq_sendint64(&amp;buf, state-&gt;nInfcount);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="../../libpq/pqformat.c.html#L346" title="libpq/pqformat.c:346">pq_endtypsend</a>(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;tmp_var);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BYTEA_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5370" title="utils/adt/numeric.c:5370">numeric_deserialize</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Deserialization function for <a href="#L4794" title="utils/adt/numeric.c:4794">NumericAggState</a> for <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> aggregates that<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; require sumX2.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L5370">&#x200c;</a><span class="linkable">numeric_deserialize</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *sstate;<br/></li>
<li>&nbsp; &nbsp; <a href="#L4794" title="utils/adt/numeric.c:4794">NumericAggState</a> *result;<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; tmp_var;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../executor/nodeAgg.c.html#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>(fcinfo, <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;aggregate function called in non-aggregate context&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sstate = PG_GETARG_BYTEA_PP(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;tmp_var);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize a StringInfo so that we can &quot;receive&quot; it using the standard<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../port/win32/socket.c.html#L37" title="port/win32/socket.c:37">recv</a>-function infrastructure.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; initReadOnlyStringInfo(&amp;buf, VARDATA_ANY(sstate),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VARSIZE_ANY_EXHDR(sstate));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L4842" title="utils/adt/numeric.c:4842">makeNumericAggStateCurrentContext</a>(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* N */<br/></li>
<li></span>&nbsp; &nbsp; result-&gt;N = <a href="../../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sumX */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L7740" title="utils/adt/numeric.c:7740">numericvar_deserialize</a>(&amp;buf, &amp;tmp_var);<br/></li>
<li>&nbsp; &nbsp; <a href="#L11974" title="utils/adt/numeric.c:11974">accum_sum_add</a>(&amp;(result-&gt;sumX), &amp;tmp_var);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sumX2 */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L7740" title="utils/adt/numeric.c:7740">numericvar_deserialize</a>(&amp;buf, &amp;tmp_var);<br/></li>
<li>&nbsp; &nbsp; <a href="#L11974" title="utils/adt/numeric.c:11974">accum_sum_add</a>(&amp;(result-&gt;sumX2), &amp;tmp_var);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* maxScale */<br/></li>
<li></span>&nbsp; &nbsp; result-&gt;maxScale = <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(&amp;buf, <span class="Constant">4</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* maxScaleCount */<br/></li>
<li></span>&nbsp; &nbsp; result-&gt;maxScaleCount = <a href="../../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* NaNcount */<br/></li>
<li></span>&nbsp; &nbsp; result-&gt;NaNcount = <a href="../../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* pInfcount */<br/></li>
<li></span>&nbsp; &nbsp; result-&gt;pInfcount = <a href="../../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* nInfcount */<br/></li>
<li></span>&nbsp; &nbsp; result-&gt;nInfcount = <a href="../../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L635" title="libpq/pqformat.c:635">pq_getmsgend</a>(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;tmp_var);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Generic inverse transition function for <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> aggregates<br/></li>
<li></span><span class="Comment"> * (with or without requirement for X^2).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L5431">&#x200c;</a><span class="linkable">numeric_accum_inv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L4794" title="utils/adt/numeric.c:4794">NumericAggState</a> *state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = PG_ARGISNULL(<span class="Constant">0</span>) ? <span class="Constant">NULL</span> : (<a href="#L4794" title="utils/adt/numeric.c:4794">NumericAggState</a> *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Should not get here with no state */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L5431" title="utils/adt/numeric.c:5431">numeric_accum_inv</a> called with NULL state&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!PG_ARGISNULL(<span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we fail to perform the inverse transition, return NULL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L4927" title="utils/adt/numeric.c:4927">do_numeric_discard</a>(state, PG_GETARG_NUMERIC(<span class="Constant">1</span>)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(state);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Integer data types in general use Numeric accumulators to share code<br/></li>
<li></span><span class="Comment"> * and avoid risk of overflow.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * However for performance reasons optimized special-purpose accumulator<br/></li>
<li></span><span class="Comment"> * routines are used when possible.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On platforms with 128-<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> integer support, the 128-<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> routines will be<br/></li>
<li></span><span class="Comment"> * used when sum(X) or sum(X*X) fit into 128-<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For 16 and 32 <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> inputs, the N and sum(X) fit into 64-<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> so the 64-<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a><br/></li>
<li></span><span class="Comment"> * accumulators will be used for SUM and AVG of these data types.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef HAVE_INT128<br/></li>
<li><a id="L5467">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">Int128AggState</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; calcSumX2;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if true, calculate sumX2 */<br/></li>
<li></span>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; N;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* count of processed numbers */<br/></li>
<li></span>&nbsp; &nbsp; int128&nbsp; &nbsp; &nbsp; &nbsp; sumX;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* sum of processed numbers */<br/></li>
<li></span>&nbsp; &nbsp; int128&nbsp; &nbsp; &nbsp; &nbsp; sumX2;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* sum of squares of processed numbers */<br/></li>
<li><a id="L5473">&#x200c;</a></span>} <span class="linkable">Int128AggState</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Prepare state data for a 128-<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> aggregate function that needs to compute<br/></li>
<li></span><span class="Comment"> * sum, count and optionally sum of squares of the input.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L5467" title="utils/adt/numeric.c:5467">Int128AggState</a> *<br/></li>
<li><a id="L5480">&#x200c;</a><span class="linkable">makeInt128AggState</span>(FunctionCallInfo fcinfo, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> calcSumX2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L5467" title="utils/adt/numeric.c:5467">Int128AggState</a> *state;<br/></li>
<li>&nbsp; &nbsp; MemoryContext agg_context;<br/></li>
<li>&nbsp; &nbsp; MemoryContext old_context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../executor/nodeAgg.c.html#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>(fcinfo, &amp;agg_context))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;aggregate function called in non-aggregate context&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; old_context = MemoryContextSwitchTo(agg_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = (<a href="#L5467" title="utils/adt/numeric.c:5467">Int128AggState</a> *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L5467" title="utils/adt/numeric.c:5467">Int128AggState</a>));<br/></li>
<li>&nbsp; &nbsp; state-&gt;calcSumX2 = calcSumX2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(old_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> state;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Like <a href="#L5480" title="utils/adt/numeric.c:5480">makeInt128AggState</a>(), but allocate the state in the current memory<br/></li>
<li></span><span class="Comment"> * context.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L5467" title="utils/adt/numeric.c:5467">Int128AggState</a> *<br/></li>
<li><a id="L5504">&#x200c;</a><span class="linkable">makeInt128AggStateCurrentContext</span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> calcSumX2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L5467" title="utils/adt/numeric.c:5467">Int128AggState</a> *state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = (<a href="#L5467" title="utils/adt/numeric.c:5467">Int128AggState</a> *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L5467" title="utils/adt/numeric.c:5467">Int128AggState</a>));<br/></li>
<li>&nbsp; &nbsp; state-&gt;calcSumX2 = calcSumX2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> state;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Accumulate a new input value for 128-<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> aggregate <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L5518">&#x200c;</a></span><span class="linkable">do_int128_accum</span>(<a href="#L5467" title="utils/adt/numeric.c:5467">Int128AggState</a> *state, int128 <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;calcSumX2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;sumX2 += <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> * <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;sumX += <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;N++;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Remove an input value from the aggregated state.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L5531">&#x200c;</a></span><span class="linkable">do_int128_discard</span>(<a href="#L5467" title="utils/adt/numeric.c:5467">Int128AggState</a> *state, int128 <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;calcSumX2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;sumX2 -= <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> * <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;sumX -= <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;N--;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L5540">&#x200c;</a><span class="Type">typedef</span> <a href="#L5467" title="utils/adt/numeric.c:5467">Int128AggState</a> <span class="linkable">PolyNumAggState</span>;<br/></li>
<li><a id="L5541">&#x200c;</a><span class="PreProc">#define <span class="linkable">makePolyNumAggState</span> <a href="#L5480" title="utils/adt/numeric.c:5480">makeInt128AggState</a><br/></li>
<li><a id="L5542">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">makePolyNumAggStateCurrentContext</span> <a href="#L5504" title="utils/adt/numeric.c:5504">makeInt128AggStateCurrentContext</a><br/></li>
<li></span><span class="PreProc">#else<br/></li>
<li><a id="L5544">&#x200c;</a></span><span class="Type">typedef</span> <a href="#L4794" title="utils/adt/numeric.c:4794">NumericAggState</a> <span class="linkable">PolyNumAggState</span>;<br/></li>
<li><a id="L5545">&#x200c;</a><span class="PreProc">#define <span class="linkable">makePolyNumAggState</span> <a href="#L4817" title="utils/adt/numeric.c:4817">makeNumericAggState</a><br/></li>
<li><a id="L5546">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">makePolyNumAggStateCurrentContext</span> <a href="#L4842" title="utils/adt/numeric.c:4842">makeNumericAggStateCurrentContext</a><br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L5550">&#x200c;</a><span class="linkable">int2_accum</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L5540" title="utils/adt/numeric.c:5540">PolyNumAggState</a> *state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = PG_ARGISNULL(<span class="Constant">0</span>) ? <span class="Constant">NULL</span> : (<a href="#L5540" title="utils/adt/numeric.c:5540">PolyNumAggState</a> *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create the state data on the first call */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state = <a href="#L5541" title="utils/adt/numeric.c:5541">makePolyNumAggState</a>(fcinfo, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!PG_ARGISNULL(<span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li><span class="PreProc">#ifdef HAVE_INT128<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5518" title="utils/adt/numeric.c:5518">do_int128_accum</a>(state, (int128) PG_GETARG_INT16(<span class="Constant">1</span>));<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4857" title="utils/adt/numeric.c:4857">do_numeric_accum</a>(state, <a href="#L4283" title="utils/adt/numeric.c:4283">int64_to_numeric</a>(PG_GETARG_INT16(<span class="Constant">1</span>)));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(state);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L5573">&#x200c;</a><span class="linkable">int4_accum</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L5540" title="utils/adt/numeric.c:5540">PolyNumAggState</a> *state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = PG_ARGISNULL(<span class="Constant">0</span>) ? <span class="Constant">NULL</span> : (<a href="#L5540" title="utils/adt/numeric.c:5540">PolyNumAggState</a> *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create the state data on the first call */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state = <a href="#L5541" title="utils/adt/numeric.c:5541">makePolyNumAggState</a>(fcinfo, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!PG_ARGISNULL(<span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li><span class="PreProc">#ifdef HAVE_INT128<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5518" title="utils/adt/numeric.c:5518">do_int128_accum</a>(state, (int128) PG_GETARG_INT32(<span class="Constant">1</span>));<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4857" title="utils/adt/numeric.c:4857">do_numeric_accum</a>(state, <a href="#L4283" title="utils/adt/numeric.c:4283">int64_to_numeric</a>(PG_GETARG_INT32(<span class="Constant">1</span>)));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(state);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L5596">&#x200c;</a><span class="linkable">int8_accum</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L4794" title="utils/adt/numeric.c:4794">NumericAggState</a> *state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = PG_ARGISNULL(<span class="Constant">0</span>) ? <span class="Constant">NULL</span> : (<a href="#L4794" title="utils/adt/numeric.c:4794">NumericAggState</a> *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create the state data on the first call */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state = <a href="#L4817" title="utils/adt/numeric.c:4817">makeNumericAggState</a>(fcinfo, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!PG_ARGISNULL(<span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4857" title="utils/adt/numeric.c:4857">do_numeric_accum</a>(state, <a href="#L4283" title="utils/adt/numeric.c:4283">int64_to_numeric</a>(PG_GETARG_INT64(<span class="Constant">1</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(state);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Combine function for <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> aggregates which require sumX2<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L5616">&#x200c;</a><span class="linkable">numeric_poly_combine</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L5540" title="utils/adt/numeric.c:5540">PolyNumAggState</a> *state1;<br/></li>
<li>&nbsp; &nbsp; <a href="#L5540" title="utils/adt/numeric.c:5540">PolyNumAggState</a> *state2;<br/></li>
<li>&nbsp; &nbsp; MemoryContext agg_context;<br/></li>
<li>&nbsp; &nbsp; MemoryContext old_context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../executor/nodeAgg.c.html#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>(fcinfo, &amp;agg_context))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;aggregate function called in non-aggregate context&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state1 = PG_ARGISNULL(<span class="Constant">0</span>) ? <span class="Constant">NULL</span> : (<a href="#L5540" title="utils/adt/numeric.c:5540">PolyNumAggState</a> *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; state2 = PG_ARGISNULL(<span class="Constant">1</span>) ? <span class="Constant">NULL</span> : (<a href="#L5540" title="utils/adt/numeric.c:5540">PolyNumAggState</a> *) PG_GETARG_POINTER(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state2 == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_POINTER(state1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* manually copy all fields from state2 to state1 */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state1 == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; old_context = MemoryContextSwitchTo(agg_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state1 = <a href="#L5541" title="utils/adt/numeric.c:5541">makePolyNumAggState</a>(fcinfo, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state1-&gt;N = state2-&gt;N;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef HAVE_INT128<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; state1-&gt;sumX = state2-&gt;sumX;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state1-&gt;sumX2 = state2-&gt;sumX2;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L12235" title="utils/adt/numeric.c:12235">accum_sum_copy</a>(&amp;state1-&gt;sumX, &amp;state2-&gt;sumX);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L12235" title="utils/adt/numeric.c:12235">accum_sum_copy</a>(&amp;state1-&gt;sumX2, &amp;state2-&gt;sumX2);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(old_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_POINTER(state1);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state2-&gt;N &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state1-&gt;N += state2-&gt;N;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef HAVE_INT128<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; state1-&gt;sumX += state2-&gt;sumX;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state1-&gt;sumX2 += state2-&gt;sumX2;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The rest of this needs to work in the aggregate context */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; old_context = MemoryContextSwitchTo(agg_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Accumulate sums */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L12252" title="utils/adt/numeric.c:12252">accum_sum_combine</a>(&amp;state1-&gt;sumX, &amp;state2-&gt;sumX);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L12252" title="utils/adt/numeric.c:12252">accum_sum_combine</a>(&amp;state1-&gt;sumX2, &amp;state2-&gt;sumX2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(old_context);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(state1);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5681" title="utils/adt/numeric.c:5681">numeric_poly_serialize</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Serialize <a href="#L5540" title="utils/adt/numeric.c:5540">PolyNumAggState</a> into bytea for aggregate <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> which<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; require sumX2.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L5681">&#x200c;</a><span class="linkable">numeric_poly_serialize</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L5540" title="utils/adt/numeric.c:5540">PolyNumAggState</a> *state;<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; tmp_var;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Ensure we disallow calling when not in aggregate context */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../executor/nodeAgg.c.html#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>(fcinfo, <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;aggregate function called in non-aggregate context&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = (<a href="#L5540" title="utils/adt/numeric.c:5540">PolyNumAggState</a> *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the platform supports int128 then sumX and sumX2 will be a 128 <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * integer type. Here we'll convert that into a <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> type so that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> state is in the same format for both int128 enabled machines<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and machines which don't support that type. The logic here is that one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * day we might like to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> these over to another server for further<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * processing and we want a standard format to work with.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;tmp_var);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L326" title="libpq/pqformat.c:326">pq_begintypsend</a>(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* N */<br/></li>
<li></span>&nbsp; &nbsp; pq_sendint64(&amp;buf, state-&gt;N);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sumX */<br/></li>
<li></span><span class="PreProc">#ifdef HAVE_INT128<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L8295" title="utils/adt/numeric.c:8295">int128_to_numericvar</a>(state-&gt;sumX, &amp;tmp_var);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L12184" title="utils/adt/numeric.c:12184">accum_sum_final</a>(&amp;state-&gt;sumX, &amp;tmp_var);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L7724" title="utils/adt/numeric.c:7724">numericvar_serialize</a>(&amp;buf, &amp;tmp_var);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sumX2 */<br/></li>
<li></span><span class="PreProc">#ifdef HAVE_INT128<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L8295" title="utils/adt/numeric.c:8295">int128_to_numericvar</a>(state-&gt;sumX2, &amp;tmp_var);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L12184" title="utils/adt/numeric.c:12184">accum_sum_final</a>(&amp;state-&gt;sumX2, &amp;tmp_var);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L7724" title="utils/adt/numeric.c:7724">numericvar_serialize</a>(&amp;buf, &amp;tmp_var);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="../../libpq/pqformat.c.html#L346" title="libpq/pqformat.c:346">pq_endtypsend</a>(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;tmp_var);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BYTEA_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5739" title="utils/adt/numeric.c:5739">numeric_poly_deserialize</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Deserialize <a href="#L5540" title="utils/adt/numeric.c:5540">PolyNumAggState</a> from bytea for aggregate <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> which<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; require sumX2.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L5739">&#x200c;</a><span class="linkable">numeric_poly_deserialize</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *sstate;<br/></li>
<li>&nbsp; &nbsp; <a href="#L5540" title="utils/adt/numeric.c:5540">PolyNumAggState</a> *result;<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; tmp_var;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../executor/nodeAgg.c.html#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>(fcinfo, <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;aggregate function called in non-aggregate context&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sstate = PG_GETARG_BYTEA_PP(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;tmp_var);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize a StringInfo so that we can &quot;receive&quot; it using the standard<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../port/win32/socket.c.html#L37" title="port/win32/socket.c:37">recv</a>-function infrastructure.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; initReadOnlyStringInfo(&amp;buf, VARDATA_ANY(sstate),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VARSIZE_ANY_EXHDR(sstate));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L5542" title="utils/adt/numeric.c:5542">makePolyNumAggStateCurrentContext</a>(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* N */<br/></li>
<li></span>&nbsp; &nbsp; result-&gt;N = <a href="../../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sumX */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L7740" title="utils/adt/numeric.c:7740">numericvar_deserialize</a>(&amp;buf, &amp;tmp_var);<br/></li>
<li><span class="PreProc">#ifdef HAVE_INT128<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L8224" title="utils/adt/numeric.c:8224">numericvar_to_int128</a>(&amp;tmp_var, &amp;result-&gt;sumX);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L11974" title="utils/adt/numeric.c:11974">accum_sum_add</a>(&amp;result-&gt;sumX, &amp;tmp_var);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sumX2 */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L7740" title="utils/adt/numeric.c:7740">numericvar_deserialize</a>(&amp;buf, &amp;tmp_var);<br/></li>
<li><span class="PreProc">#ifdef HAVE_INT128<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L8224" title="utils/adt/numeric.c:8224">numericvar_to_int128</a>(&amp;tmp_var, &amp;result-&gt;sumX2);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L11974" title="utils/adt/numeric.c:11974">accum_sum_add</a>(&amp;result-&gt;sumX2, &amp;tmp_var);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L635" title="libpq/pqformat.c:635">pq_getmsgend</a>(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;tmp_var);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Transition function for int8 input when we don't need sumX2.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L5792">&#x200c;</a><span class="linkable">int8_avg_accum</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L5540" title="utils/adt/numeric.c:5540">PolyNumAggState</a> *state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = PG_ARGISNULL(<span class="Constant">0</span>) ? <span class="Constant">NULL</span> : (<a href="#L5540" title="utils/adt/numeric.c:5540">PolyNumAggState</a> *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create the state data on the first call */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state = <a href="#L5541" title="utils/adt/numeric.c:5541">makePolyNumAggState</a>(fcinfo, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!PG_ARGISNULL(<span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li><span class="PreProc">#ifdef HAVE_INT128<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5518" title="utils/adt/numeric.c:5518">do_int128_accum</a>(state, (int128) PG_GETARG_INT64(<span class="Constant">1</span>));<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4857" title="utils/adt/numeric.c:4857">do_numeric_accum</a>(state, <a href="#L4283" title="utils/adt/numeric.c:4283">int64_to_numeric</a>(PG_GETARG_INT64(<span class="Constant">1</span>)));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(state);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Combine function for <a href="#L5540" title="utils/adt/numeric.c:5540">PolyNumAggState</a> for aggregates which don't require<br/></li>
<li></span><span class="Comment"> * sumX2<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L5819">&#x200c;</a><span class="linkable">int8_avg_combine</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L5540" title="utils/adt/numeric.c:5540">PolyNumAggState</a> *state1;<br/></li>
<li>&nbsp; &nbsp; <a href="#L5540" title="utils/adt/numeric.c:5540">PolyNumAggState</a> *state2;<br/></li>
<li>&nbsp; &nbsp; MemoryContext agg_context;<br/></li>
<li>&nbsp; &nbsp; MemoryContext old_context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../executor/nodeAgg.c.html#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>(fcinfo, &amp;agg_context))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;aggregate function called in non-aggregate context&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state1 = PG_ARGISNULL(<span class="Constant">0</span>) ? <span class="Constant">NULL</span> : (<a href="#L5540" title="utils/adt/numeric.c:5540">PolyNumAggState</a> *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; state2 = PG_ARGISNULL(<span class="Constant">1</span>) ? <span class="Constant">NULL</span> : (<a href="#L5540" title="utils/adt/numeric.c:5540">PolyNumAggState</a> *) PG_GETARG_POINTER(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state2 == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_POINTER(state1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* manually copy all fields from state2 to state1 */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state1 == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; old_context = MemoryContextSwitchTo(agg_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state1 = <a href="#L5541" title="utils/adt/numeric.c:5541">makePolyNumAggState</a>(fcinfo, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state1-&gt;N = state2-&gt;N;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef HAVE_INT128<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; state1-&gt;sumX = state2-&gt;sumX;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L12235" title="utils/adt/numeric.c:12235">accum_sum_copy</a>(&amp;state1-&gt;sumX, &amp;state2-&gt;sumX);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(old_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_POINTER(state1);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state2-&gt;N &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state1-&gt;N += state2-&gt;N;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef HAVE_INT128<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; state1-&gt;sumX += state2-&gt;sumX;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The rest of this needs to work in the aggregate context */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; old_context = MemoryContextSwitchTo(agg_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Accumulate sums */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L12252" title="utils/adt/numeric.c:12252">accum_sum_combine</a>(&amp;state1-&gt;sumX, &amp;state2-&gt;sumX);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(old_context);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(state1);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5879" title="utils/adt/numeric.c:5879">int8_avg_serialize</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Serialize <a href="#L5540" title="utils/adt/numeric.c:5540">PolyNumAggState</a> into bytea using the standard<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../port/win32/socket.c.html#L37" title="port/win32/socket.c:37">recv</a>-function infrastructure.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L5879">&#x200c;</a><span class="linkable">int8_avg_serialize</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L5540" title="utils/adt/numeric.c:5540">PolyNumAggState</a> *state;<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; tmp_var;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Ensure we disallow calling when not in aggregate context */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../executor/nodeAgg.c.html#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>(fcinfo, <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;aggregate function called in non-aggregate context&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = (<a href="#L5540" title="utils/adt/numeric.c:5540">PolyNumAggState</a> *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the platform supports int128 then sumX will be a 128 integer type.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Here we'll convert that into a <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> type so that the <a href="../../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> state<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is in the same format for both int128 enabled machines and machines<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which don't support that type. The logic here is that one day we might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * like to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> these over to another server for further processing and we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * want a standard format to work with.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;tmp_var);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L326" title="libpq/pqformat.c:326">pq_begintypsend</a>(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* N */<br/></li>
<li></span>&nbsp; &nbsp; pq_sendint64(&amp;buf, state-&gt;N);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sumX */<br/></li>
<li></span><span class="PreProc">#ifdef HAVE_INT128<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L8295" title="utils/adt/numeric.c:8295">int128_to_numericvar</a>(state-&gt;sumX, &amp;tmp_var);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L12184" title="utils/adt/numeric.c:12184">accum_sum_final</a>(&amp;state-&gt;sumX, &amp;tmp_var);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L7724" title="utils/adt/numeric.c:7724">numericvar_serialize</a>(&amp;buf, &amp;tmp_var);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="../../libpq/pqformat.c.html#L346" title="libpq/pqformat.c:346">pq_endtypsend</a>(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;tmp_var);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BYTEA_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5928" title="utils/adt/numeric.c:5928">int8_avg_deserialize</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Deserialize bytea back into <a href="#L5540" title="utils/adt/numeric.c:5540">PolyNumAggState</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L5928">&#x200c;</a><span class="linkable">int8_avg_deserialize</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *sstate;<br/></li>
<li>&nbsp; &nbsp; <a href="#L5540" title="utils/adt/numeric.c:5540">PolyNumAggState</a> *result;<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; tmp_var;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../executor/nodeAgg.c.html#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>(fcinfo, <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;aggregate function called in non-aggregate context&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sstate = PG_GETARG_BYTEA_PP(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;tmp_var);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize a StringInfo so that we can &quot;receive&quot; it using the standard<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../port/win32/socket.c.html#L37" title="port/win32/socket.c:37">recv</a>-function infrastructure.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; initReadOnlyStringInfo(&amp;buf, VARDATA_ANY(sstate),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VARSIZE_ANY_EXHDR(sstate));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L5542" title="utils/adt/numeric.c:5542">makePolyNumAggStateCurrentContext</a>(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* N */<br/></li>
<li></span>&nbsp; &nbsp; result-&gt;N = <a href="../../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sumX */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L7740" title="utils/adt/numeric.c:7740">numericvar_deserialize</a>(&amp;buf, &amp;tmp_var);<br/></li>
<li><span class="PreProc">#ifdef HAVE_INT128<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L8224" title="utils/adt/numeric.c:8224">numericvar_to_int128</a>(&amp;tmp_var, &amp;result-&gt;sumX);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L11974" title="utils/adt/numeric.c:11974">accum_sum_add</a>(&amp;result-&gt;sumX, &amp;tmp_var);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L635" title="libpq/pqformat.c:635">pq_getmsgend</a>(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;tmp_var);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Inverse transition <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> to go with the above.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L5974">&#x200c;</a><span class="linkable">int2_accum_inv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L5540" title="utils/adt/numeric.c:5540">PolyNumAggState</a> *state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = PG_ARGISNULL(<span class="Constant">0</span>) ? <span class="Constant">NULL</span> : (<a href="#L5540" title="utils/adt/numeric.c:5540">PolyNumAggState</a> *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Should not get here with no state */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L5974" title="utils/adt/numeric.c:5974">int2_accum_inv</a> called with NULL state&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!PG_ARGISNULL(<span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li><span class="PreProc">#ifdef HAVE_INT128<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5531" title="utils/adt/numeric.c:5531">do_int128_discard</a>(state, (int128) PG_GETARG_INT16(<span class="Constant">1</span>));<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Should never fail, all inputs have dscale 0 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L4927" title="utils/adt/numeric.c:4927">do_numeric_discard</a>(state, <a href="#L4283" title="utils/adt/numeric.c:4283">int64_to_numeric</a>(PG_GETARG_INT16(<span class="Constant">1</span>))))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L4927" title="utils/adt/numeric.c:4927">do_numeric_discard</a> failed unexpectedly&quot;</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(state);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L5999">&#x200c;</a><span class="linkable">int4_accum_inv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L5540" title="utils/adt/numeric.c:5540">PolyNumAggState</a> *state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = PG_ARGISNULL(<span class="Constant">0</span>) ? <span class="Constant">NULL</span> : (<a href="#L5540" title="utils/adt/numeric.c:5540">PolyNumAggState</a> *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Should not get here with no state */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L5999" title="utils/adt/numeric.c:5999">int4_accum_inv</a> called with NULL state&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!PG_ARGISNULL(<span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li><span class="PreProc">#ifdef HAVE_INT128<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5531" title="utils/adt/numeric.c:5531">do_int128_discard</a>(state, (int128) PG_GETARG_INT32(<span class="Constant">1</span>));<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Should never fail, all inputs have dscale 0 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L4927" title="utils/adt/numeric.c:4927">do_numeric_discard</a>(state, <a href="#L4283" title="utils/adt/numeric.c:4283">int64_to_numeric</a>(PG_GETARG_INT32(<span class="Constant">1</span>))))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L4927" title="utils/adt/numeric.c:4927">do_numeric_discard</a> failed unexpectedly&quot;</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(state);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L6024">&#x200c;</a><span class="linkable">int8_accum_inv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L4794" title="utils/adt/numeric.c:4794">NumericAggState</a> *state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = PG_ARGISNULL(<span class="Constant">0</span>) ? <span class="Constant">NULL</span> : (<a href="#L4794" title="utils/adt/numeric.c:4794">NumericAggState</a> *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Should not get here with no state */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L6024" title="utils/adt/numeric.c:6024">int8_accum_inv</a> called with NULL state&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!PG_ARGISNULL(<span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Should never fail, all inputs have dscale 0 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L4927" title="utils/adt/numeric.c:4927">do_numeric_discard</a>(state, <a href="#L4283" title="utils/adt/numeric.c:4283">int64_to_numeric</a>(PG_GETARG_INT64(<span class="Constant">1</span>))))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L4927" title="utils/adt/numeric.c:4927">do_numeric_discard</a> failed unexpectedly&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(state);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L6045">&#x200c;</a><span class="linkable">int8_avg_accum_inv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L5540" title="utils/adt/numeric.c:5540">PolyNumAggState</a> *state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = PG_ARGISNULL(<span class="Constant">0</span>) ? <span class="Constant">NULL</span> : (<a href="#L5540" title="utils/adt/numeric.c:5540">PolyNumAggState</a> *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Should not get here with no state */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L6045" title="utils/adt/numeric.c:6045">int8_avg_accum_inv</a> called with NULL state&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!PG_ARGISNULL(<span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li><span class="PreProc">#ifdef HAVE_INT128<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5531" title="utils/adt/numeric.c:5531">do_int128_discard</a>(state, (int128) PG_GETARG_INT64(<span class="Constant">1</span>));<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Should never fail, all inputs have dscale 0 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L4927" title="utils/adt/numeric.c:4927">do_numeric_discard</a>(state, <a href="#L4283" title="utils/adt/numeric.c:4283">int64_to_numeric</a>(PG_GETARG_INT64(<span class="Constant">1</span>))))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L4927" title="utils/adt/numeric.c:4927">do_numeric_discard</a> failed unexpectedly&quot;</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(state);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L6070">&#x200c;</a><span class="linkable">numeric_poly_sum</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef HAVE_INT128<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L5540" title="utils/adt/numeric.c:5540">PolyNumAggState</a> *state;<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = PG_ARGISNULL(<span class="Constant">0</span>) ? <span class="Constant">NULL</span> : (<a href="#L5540" title="utils/adt/numeric.c:5540">PolyNumAggState</a> *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If there were no non-null inputs, return NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state == <span class="Constant">NULL</span> || state-&gt;N == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L8295" title="utils/adt/numeric.c:8295">int128_to_numericvar</a>(state-&gt;sumX, &amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_NUMERIC(res);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L6163" title="utils/adt/numeric.c:6163">numeric_sum</a>(fcinfo);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L6098">&#x200c;</a><span class="linkable">numeric_poly_avg</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef HAVE_INT128<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L5540" title="utils/adt/numeric.c:5540">PolyNumAggState</a> *state;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; countd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sumd;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = PG_ARGISNULL(<span class="Constant">0</span>) ? <span class="Constant">NULL</span> : (<a href="#L5540" title="utils/adt/numeric.c:5540">PolyNumAggState</a> *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If there were no non-null inputs, return NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state == <span class="Constant">NULL</span> || state-&gt;N == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L8295" title="utils/adt/numeric.c:8295">int128_to_numericvar</a>(state-&gt;sumX, &amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; countd = NumericGetDatum(<a href="#L4283" title="utils/adt/numeric.c:4283">int64_to_numeric</a>(state-&gt;N));<br/></li>
<li>&nbsp; &nbsp; sumd = NumericGetDatum(<a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;result));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_DATUM(DirectFunctionCall2(<a href="#L3124" title="utils/adt/numeric.c:3124">numeric_div</a>, sumd, countd));<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L6128" title="utils/adt/numeric.c:6128">numeric_avg</a>(fcinfo);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L6128">&#x200c;</a><span class="linkable">numeric_avg</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L4794" title="utils/adt/numeric.c:4794">NumericAggState</a> *state;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; N_datum;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; sumX_datum;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; sumX_var;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = PG_ARGISNULL(<span class="Constant">0</span>) ? <span class="Constant">NULL</span> : (<a href="#L4794" title="utils/adt/numeric.c:4794">NumericAggState</a> *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If there were no non-null inputs, return NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state == <span class="Constant">NULL</span> || <a href="#L4809" title="utils/adt/numeric.c:4809">NA_TOTAL_COUNT</a>(state) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;NaNcount &gt; <span class="Constant">0</span>)&nbsp; &nbsp; <span class="Comment">/* there was at least one NaN input */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L449" title="utils/adt/numeric.c:449">const_nan</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* adding plus and minus infinities gives NaN */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;pInfcount &gt; <span class="Constant">0</span> &amp;&amp; state-&gt;nInfcount &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L449" title="utils/adt/numeric.c:449">const_nan</a>));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;pInfcount &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L452" title="utils/adt/numeric.c:452">const_pinf</a>));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;nInfcount &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L455" title="utils/adt/numeric.c:455">const_ninf</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; N_datum = NumericGetDatum(<a href="#L4283" title="utils/adt/numeric.c:4283">int64_to_numeric</a>(state-&gt;N));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;sumX_var);<br/></li>
<li>&nbsp; &nbsp; <a href="#L12184" title="utils/adt/numeric.c:12184">accum_sum_final</a>(&amp;state-&gt;sumX, &amp;sumX_var);<br/></li>
<li>&nbsp; &nbsp; sumX_datum = NumericGetDatum(<a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;sumX_var));<br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;sumX_var);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_DATUM(DirectFunctionCall2(<a href="#L3124" title="utils/adt/numeric.c:3124">numeric_div</a>, sumX_datum, N_datum));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L6163">&#x200c;</a><span class="linkable">numeric_sum</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L4794" title="utils/adt/numeric.c:4794">NumericAggState</a> *state;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; sumX_var;<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = PG_ARGISNULL(<span class="Constant">0</span>) ? <span class="Constant">NULL</span> : (<a href="#L4794" title="utils/adt/numeric.c:4794">NumericAggState</a> *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If there were no non-null inputs, return NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state == <span class="Constant">NULL</span> || <a href="#L4809" title="utils/adt/numeric.c:4809">NA_TOTAL_COUNT</a>(state) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;NaNcount &gt; <span class="Constant">0</span>)&nbsp; &nbsp; <span class="Comment">/* there was at least one NaN input */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L449" title="utils/adt/numeric.c:449">const_nan</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* adding plus and minus infinities gives NaN */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;pInfcount &gt; <span class="Constant">0</span> &amp;&amp; state-&gt;nInfcount &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L449" title="utils/adt/numeric.c:449">const_nan</a>));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;pInfcount &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L452" title="utils/adt/numeric.c:452">const_pinf</a>));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;nInfcount &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L455" title="utils/adt/numeric.c:455">const_ninf</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;sumX_var);<br/></li>
<li>&nbsp; &nbsp; <a href="#L12184" title="utils/adt/numeric.c:12184">accum_sum_final</a>(&amp;state-&gt;sumX, &amp;sumX_var);<br/></li>
<li>&nbsp; &nbsp; result = <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;sumX_var);<br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;sumX_var);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_NUMERIC(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Workhorse routine for the standard deviance and variance<br/></li>
<li></span><span class="Comment"> * aggregates. 'state' is aggregate's transition state.<br/></li>
<li></span><span class="Comment"> * 'variance' specifies whether we should calculate the<br/></li>
<li></span><span class="Comment"> * variance or the standard deviation. 'sample' indicates whether the<br/></li>
<li></span><span class="Comment"> * caller is interested in the sample or the population<br/></li>
<li></span><span class="Comment"> * variance/stddev.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If appropriate variance statistic is undefined for the input,<br/></li>
<li></span><span class="Comment"> * *is_null is set to true and NULL is returned.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Numeric<br/></li>
<li><a id="L6206">&#x200c;</a><span class="linkable">numeric_stddev_internal</span>(<a href="#L4794" title="utils/adt/numeric.c:4794">NumericAggState</a> *state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> variance, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> sample,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *is_null)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; vN,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vsumX,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vsumX2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vNminus1;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; totCount;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rscale;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Sample stddev and variance are undefined when N &lt;= 1; population stddev<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is undefined when N == 0.&nbsp; Return NULL in either case (note that NaNs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and infinities count as normal inputs for this purpose).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state == <span class="Constant">NULL</span> || (totCount = <a href="#L4809" title="utils/adt/numeric.c:4809">NA_TOTAL_COUNT</a>(state)) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *is_null = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (sample &amp;&amp; totCount &lt;= <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *is_null = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *is_null = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Deal with NaN and infinity cases.&nbsp; By analogy to the behavior of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * float8 <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> infinity input produces NaN output.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;NaNcount &gt; <span class="Constant">0</span> || state-&gt;pInfcount &gt; <span class="Constant">0</span> || state-&gt;nInfcount &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L449" title="utils/adt/numeric.c:449">const_nan</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* OK, normal calculation applies */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;vN);<br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;vsumX);<br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;vsumX2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L8104" title="utils/adt/numeric.c:8104">int64_to_numericvar</a>(state-&gt;N, &amp;vN);<br/></li>
<li>&nbsp; &nbsp; <a href="#L12184" title="utils/adt/numeric.c:12184">accum_sum_final</a>(&amp;(state-&gt;sumX), &amp;vsumX);<br/></li>
<li>&nbsp; &nbsp; <a href="#L12184" title="utils/adt/numeric.c:12184">accum_sum_final</a>(&amp;(state-&gt;sumX2), &amp;vsumX2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;vNminus1);<br/></li>
<li>&nbsp; &nbsp; <a href="#L8548" title="utils/adt/numeric.c:8548">sub_var</a>(&amp;vN, &amp;<a href="#L419" title="utils/adt/numeric.c:419">const_one</a>, &amp;vNminus1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* compute rscale for <a href="#L8669" title="utils/adt/numeric.c:8669">mul_var</a> calls */<br/></li>
<li></span>&nbsp; &nbsp; rscale = vsumX.dscale * <span class="Constant">2</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L8669" title="utils/adt/numeric.c:8669">mul_var</a>(&amp;vsumX, &amp;vsumX, &amp;vsumX, rscale);&nbsp; &nbsp; <span class="Comment">/* vsumX = sumX * sumX */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L8669" title="utils/adt/numeric.c:8669">mul_var</a>(&amp;vN, &amp;vsumX2, &amp;vsumX2, rscale); <span class="Comment">/* vsumX2 = N * sumX2 */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L8548" title="utils/adt/numeric.c:8548">sub_var</a>(&amp;vsumX2, &amp;vsumX, &amp;vsumX2);&nbsp; &nbsp; <span class="Comment">/* N * sumX2 - sumX * sumX */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L8373" title="utils/adt/numeric.c:8373">cmp_var</a>(&amp;vsumX2, &amp;<a href="#L415" title="utils/adt/numeric.c:415">const_zero</a>) &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Watch out for roundoff error producing a negative numerator */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; res = <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;<a href="#L415" title="utils/adt/numeric.c:415">const_zero</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sample)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8669" title="utils/adt/numeric.c:8669">mul_var</a>(&amp;vN, &amp;vNminus1, &amp;vNminus1, <span class="Constant">0</span>);&nbsp; &nbsp; <span class="Comment">/* N * (N - 1) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8669" title="utils/adt/numeric.c:8669">mul_var</a>(&amp;vN, &amp;vN, &amp;vNminus1, <span class="Constant">0</span>);&nbsp; &nbsp; <span class="Comment">/* N * N */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rscale = <a href="#L9777" title="utils/adt/numeric.c:9777">select_div_scale</a>(&amp;vsumX2, &amp;vNminus1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8877" title="utils/adt/numeric.c:8877">div_var</a>(&amp;vsumX2, &amp;vNminus1, &amp;vsumX, rscale, <span class="Constant">true</span>);&nbsp; &nbsp; <span class="Comment">/* variance */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!variance)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L10062" title="utils/adt/numeric.c:10062">sqrt_var</a>(&amp;vsumX, &amp;vsumX, rscale);&nbsp; &nbsp; <span class="Comment">/* stddev */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res = <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(&amp;vsumX);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;vNminus1);<br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;vsumX);<br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;vsumX2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L6290">&#x200c;</a><span class="linkable">numeric_var_samp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L4794" title="utils/adt/numeric.c:4794">NumericAggState</a> *state;<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_null;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = PG_ARGISNULL(<span class="Constant">0</span>) ? <span class="Constant">NULL</span> : (<a href="#L4794" title="utils/adt/numeric.c:4794">NumericAggState</a> *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="#L6206" title="utils/adt/numeric.c:6206">numeric_stddev_internal</a>(state, <span class="Constant">true</span>, <span class="Constant">true</span>, &amp;is_null);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (is_null)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(res);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L6307">&#x200c;</a><span class="linkable">numeric_stddev_samp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L4794" title="utils/adt/numeric.c:4794">NumericAggState</a> *state;<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_null;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = PG_ARGISNULL(<span class="Constant">0</span>) ? <span class="Constant">NULL</span> : (<a href="#L4794" title="utils/adt/numeric.c:4794">NumericAggState</a> *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="#L6206" title="utils/adt/numeric.c:6206">numeric_stddev_internal</a>(state, <span class="Constant">false</span>, <span class="Constant">true</span>, &amp;is_null);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (is_null)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(res);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L6324">&#x200c;</a><span class="linkable">numeric_var_pop</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L4794" title="utils/adt/numeric.c:4794">NumericAggState</a> *state;<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_null;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = PG_ARGISNULL(<span class="Constant">0</span>) ? <span class="Constant">NULL</span> : (<a href="#L4794" title="utils/adt/numeric.c:4794">NumericAggState</a> *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="#L6206" title="utils/adt/numeric.c:6206">numeric_stddev_internal</a>(state, <span class="Constant">true</span>, <span class="Constant">false</span>, &amp;is_null);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (is_null)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(res);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L6341">&#x200c;</a><span class="linkable">numeric_stddev_pop</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L4794" title="utils/adt/numeric.c:4794">NumericAggState</a> *state;<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_null;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = PG_ARGISNULL(<span class="Constant">0</span>) ? <span class="Constant">NULL</span> : (<a href="#L4794" title="utils/adt/numeric.c:4794">NumericAggState</a> *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="#L6206" title="utils/adt/numeric.c:6206">numeric_stddev_internal</a>(state, <span class="Constant">false</span>, <span class="Constant">false</span>, &amp;is_null);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (is_null)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(res);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef HAVE_INT128<br/></li>
<li></span><span class="Type">static</span> Numeric<br/></li>
<li><a id="L6359">&#x200c;</a><span class="linkable">numeric_poly_stddev_internal</span>(<a href="#L5467" title="utils/adt/numeric.c:5467">Int128AggState</a> *state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> variance, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> sample,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *is_null)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L4794" title="utils/adt/numeric.c:4794">NumericAggState</a> numstate;<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize an empty agg state */<br/></li>
<li></span>&nbsp; &nbsp; memset(&amp;numstate, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L4794" title="utils/adt/numeric.c:4794">NumericAggState</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; tmp_var;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; numstate.N = state-&gt;N;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;tmp_var);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8295" title="utils/adt/numeric.c:8295">int128_to_numericvar</a>(state-&gt;sumX, &amp;tmp_var);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L11974" title="utils/adt/numeric.c:11974">accum_sum_add</a>(&amp;numstate.sumX, &amp;tmp_var);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8295" title="utils/adt/numeric.c:8295">int128_to_numericvar</a>(state-&gt;sumX2, &amp;tmp_var);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L11974" title="utils/adt/numeric.c:11974">accum_sum_add</a>(&amp;numstate.sumX2, &amp;tmp_var);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;tmp_var);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="#L6206" title="utils/adt/numeric.c:6206">numeric_stddev_internal</a>(&amp;numstate, variance, sample, is_null);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (numstate.sumX.ndigits &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(numstate.sumX.pos_digits);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(numstate.sumX.neg_digits);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (numstate.sumX2.ndigits &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(numstate.sumX2.pos_digits);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(numstate.sumX2.neg_digits);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L6404">&#x200c;</a><span class="linkable">numeric_poly_var_samp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef HAVE_INT128<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L5540" title="utils/adt/numeric.c:5540">PolyNumAggState</a> *state;<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_null;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = PG_ARGISNULL(<span class="Constant">0</span>) ? <span class="Constant">NULL</span> : (<a href="#L5540" title="utils/adt/numeric.c:5540">PolyNumAggState</a> *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="#L6359" title="utils/adt/numeric.c:6359">numeric_poly_stddev_internal</a>(state, <span class="Constant">true</span>, <span class="Constant">true</span>, &amp;is_null);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (is_null)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(res);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L6290" title="utils/adt/numeric.c:6290">numeric_var_samp</a>(fcinfo);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L6425">&#x200c;</a><span class="linkable">numeric_poly_stddev_samp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef HAVE_INT128<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L5540" title="utils/adt/numeric.c:5540">PolyNumAggState</a> *state;<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_null;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = PG_ARGISNULL(<span class="Constant">0</span>) ? <span class="Constant">NULL</span> : (<a href="#L5540" title="utils/adt/numeric.c:5540">PolyNumAggState</a> *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="#L6359" title="utils/adt/numeric.c:6359">numeric_poly_stddev_internal</a>(state, <span class="Constant">false</span>, <span class="Constant">true</span>, &amp;is_null);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (is_null)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(res);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L6307" title="utils/adt/numeric.c:6307">numeric_stddev_samp</a>(fcinfo);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L6446">&#x200c;</a><span class="linkable">numeric_poly_var_pop</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef HAVE_INT128<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L5540" title="utils/adt/numeric.c:5540">PolyNumAggState</a> *state;<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_null;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = PG_ARGISNULL(<span class="Constant">0</span>) ? <span class="Constant">NULL</span> : (<a href="#L5540" title="utils/adt/numeric.c:5540">PolyNumAggState</a> *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="#L6359" title="utils/adt/numeric.c:6359">numeric_poly_stddev_internal</a>(state, <span class="Constant">true</span>, <span class="Constant">false</span>, &amp;is_null);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (is_null)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(res);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L6324" title="utils/adt/numeric.c:6324">numeric_var_pop</a>(fcinfo);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L6467">&#x200c;</a><span class="linkable">numeric_poly_stddev_pop</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef HAVE_INT128<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L5540" title="utils/adt/numeric.c:5540">PolyNumAggState</a> *state;<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_null;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = PG_ARGISNULL(<span class="Constant">0</span>) ? <span class="Constant">NULL</span> : (<a href="#L5540" title="utils/adt/numeric.c:5540">PolyNumAggState</a> *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="#L6359" title="utils/adt/numeric.c:6359">numeric_poly_stddev_internal</a>(state, <span class="Constant">false</span>, <span class="Constant">false</span>, &amp;is_null);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (is_null)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(res);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L6341" title="utils/adt/numeric.c:6341">numeric_stddev_pop</a>(fcinfo);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * SUM transition <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for integer datatypes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To avoid overflow, we use accumulators wider than the input datatype.<br/></li>
<li></span><span class="Comment"> * A Numeric accumulator is needed for int8 input; for int4 and int2<br/></li>
<li></span><span class="Comment"> * inputs, we use int8 accumulators which should be sufficient for practical<br/></li>
<li></span><span class="Comment"> * purposes.&nbsp; (The latter two therefore don't really belong in this file,<br/></li>
<li></span><span class="Comment"> * but we keep them here anyway.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Because SQL defines the SUM() of no <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to be NULL, not zero,<br/></li>
<li></span><span class="Comment"> * the initial condition of the transition data value needs to be NULL. This<br/></li>
<li></span><span class="Comment"> * means we can't rely on <a href="../../executor/nodeAgg.c.html#L2158" title="executor/nodeAgg.c:2158">ExecAgg</a> to automatically insert the first non-null<br/></li>
<li></span><span class="Comment"> * data value into the transition data: it doesn't know how to do the type<br/></li>
<li></span><span class="Comment"> * conversion.&nbsp; The upshot is that these routines have to be marked non-strict<br/></li>
<li></span><span class="Comment"> * and handle substitution of the first non-null input themselves.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: these <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> are used only in plain aggregation mode.<br/></li>
<li></span><span class="Comment"> * In moving-aggregate mode, we use intX_avg_accum and intX_avg_accum_inv.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L6508">&#x200c;</a><span class="linkable">int2_sum</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PG_ARGISNULL(<span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No non-null input seen so far... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PG_ARGISNULL(<span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();&nbsp; &nbsp; <span class="Comment">/* still no non-null */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This is the first non-null input. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> = (int64) PG_GETARG_INT16(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_INT64(<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're invoked as an aggregate, we can cheat and modify our first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parameter in-place to avoid <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a> overhead. If not, we need to return<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the new value of the transition variable. (If int8 is pass-by-value,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * then of course this is useless as well as incorrect, so just ifdef it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * out.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifndef USE_FLOAT8_BYVAL&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* controls int8 too */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../executor/nodeAgg.c.html#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>(fcinfo, <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp;&nbsp; *oldsum = (int64 *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Leave the running sum unchanged in the new input is null */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!PG_ARGISNULL(<span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *oldsum = *oldsum + (int64) PG_GETARG_INT16(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_POINTER(oldsum);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; oldsum = PG_GETARG_INT64(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Leave sum unchanged if new input is null. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PG_ARGISNULL(<span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_INT64(oldsum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK to do the addition. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> = oldsum + (int64) PG_GETARG_INT16(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_INT64(<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L6557">&#x200c;</a><span class="linkable">int4_sum</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PG_ARGISNULL(<span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No non-null input seen so far... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PG_ARGISNULL(<span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();&nbsp; &nbsp; <span class="Comment">/* still no non-null */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This is the first non-null input. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> = (int64) PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_INT64(<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're invoked as an aggregate, we can cheat and modify our first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parameter in-place to avoid <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a> overhead. If not, we need to return<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the new value of the transition variable. (If int8 is pass-by-value,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * then of course this is useless as well as incorrect, so just ifdef it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * out.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifndef USE_FLOAT8_BYVAL&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* controls int8 too */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../executor/nodeAgg.c.html#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>(fcinfo, <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp;&nbsp; *oldsum = (int64 *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Leave the running sum unchanged in the new input is null */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!PG_ARGISNULL(<span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *oldsum = *oldsum + (int64) PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_POINTER(oldsum);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; oldsum = PG_GETARG_INT64(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Leave sum unchanged if new input is null. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PG_ARGISNULL(<span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_INT64(oldsum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK to do the addition. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> = oldsum + (int64) PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_INT64(<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Note: this function is obsolete, it's no longer used for SUM(int8).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L6609">&#x200c;</a><span class="linkable">int8_sum</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; oldsum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PG_ARGISNULL(<span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No non-null input seen so far... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PG_ARGISNULL(<span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();&nbsp; &nbsp; <span class="Comment">/* still no non-null */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This is the first non-null input. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="#L4283" title="utils/adt/numeric.c:4283">int64_to_numeric</a>(PG_GETARG_INT64(<span class="Constant">1</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that we cannot special-case the aggregate case here, as we do for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L6508" title="utils/adt/numeric.c:6508">int2_sum</a> and <a href="#L6557" title="utils/adt/numeric.c:6557">int4_sum</a>: <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> is of variable size, so we cannot modify<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * our first parameter in-place.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; oldsum = PG_GETARG_NUMERIC(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Leave sum unchanged if new input is null. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PG_ARGISNULL(<span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(oldsum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* OK to do the addition. */<br/></li>
<li></span>&nbsp; &nbsp; PG_RETURN_DATUM(DirectFunctionCall2(<a href="#L2848" title="utils/adt/numeric.c:2848">numeric_add</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NumericGetDatum(oldsum),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NumericGetDatum(<a href="#L4283" title="utils/adt/numeric.c:4283">int64_to_numeric</a>(PG_GETARG_INT64(<span class="Constant">1</span>)))));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Routines for avg(int2) and avg(int4).&nbsp; The transition datatype<br/></li>
<li></span><span class="Comment"> * is a two-<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> int8 array, holding count and sum.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * These <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> are also used for sum(int2) and sum(int4) when<br/></li>
<li></span><span class="Comment"> * operating in moving-aggregate mode, since for correct inverse transitions<br/></li>
<li></span><span class="Comment"> * we need to count the inputs.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><a id="L6650">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">Int8TransTypeData</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; count;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; sum;<br/></li>
<li><a id="L6654">&#x200c;</a>} <span class="linkable">Int8TransTypeData</span>;<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L6657">&#x200c;</a><span class="linkable">int2_avg_accum</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *transarray;<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> = PG_GETARG_INT16(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L6650" title="utils/adt/numeric.c:6650">Int8TransTypeData</a> *transdata;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're invoked as an aggregate, we can cheat and modify our first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parameter in-place to reduce <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a> overhead. Otherwise we need to make<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a copy of it <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> scribbling on it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../executor/nodeAgg.c.html#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>(fcinfo, <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; transarray = PG_GETARG_ARRAYTYPE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; transarray = PG_GETARG_ARRAYTYPE_P_COPY(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ARR_HASNULL(transarray) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ARR_SIZE(transarray) != ARR_OVERHEAD_NONULLS(<span class="Constant">1</span>) + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L6650" title="utils/adt/numeric.c:6650">Int8TransTypeData</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;expected 2-<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> int8 array&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; transdata = (<a href="#L6650" title="utils/adt/numeric.c:6650">Int8TransTypeData</a> *) ARR_DATA_PTR(transarray);<br/></li>
<li>&nbsp; &nbsp; transdata-&gt;count++;<br/></li>
<li>&nbsp; &nbsp; transdata-&gt;sum += <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_ARRAYTYPE_P(transarray);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L6685">&#x200c;</a><span class="linkable">int4_avg_accum</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *transarray;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L6650" title="utils/adt/numeric.c:6650">Int8TransTypeData</a> *transdata;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're invoked as an aggregate, we can cheat and modify our first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parameter in-place to reduce <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a> overhead. Otherwise we need to make<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a copy of it <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> scribbling on it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../executor/nodeAgg.c.html#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>(fcinfo, <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; transarray = PG_GETARG_ARRAYTYPE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; transarray = PG_GETARG_ARRAYTYPE_P_COPY(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ARR_HASNULL(transarray) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ARR_SIZE(transarray) != ARR_OVERHEAD_NONULLS(<span class="Constant">1</span>) + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L6650" title="utils/adt/numeric.c:6650">Int8TransTypeData</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;expected 2-<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> int8 array&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; transdata = (<a href="#L6650" title="utils/adt/numeric.c:6650">Int8TransTypeData</a> *) ARR_DATA_PTR(transarray);<br/></li>
<li>&nbsp; &nbsp; transdata-&gt;count++;<br/></li>
<li>&nbsp; &nbsp; transdata-&gt;sum += <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_ARRAYTYPE_P(transarray);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L6713">&#x200c;</a><span class="linkable">int4_avg_combine</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *transarray1;<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *transarray2;<br/></li>
<li>&nbsp; &nbsp; <a href="#L6650" title="utils/adt/numeric.c:6650">Int8TransTypeData</a> *state1;<br/></li>
<li>&nbsp; &nbsp; <a href="#L6650" title="utils/adt/numeric.c:6650">Int8TransTypeData</a> *state2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../executor/nodeAgg.c.html#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>(fcinfo, <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;aggregate function called in non-aggregate context&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; transarray1 = PG_GETARG_ARRAYTYPE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; transarray2 = PG_GETARG_ARRAYTYPE_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ARR_HASNULL(transarray1) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ARR_SIZE(transarray1) != ARR_OVERHEAD_NONULLS(<span class="Constant">1</span>) + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L6650" title="utils/adt/numeric.c:6650">Int8TransTypeData</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;expected 2-<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> int8 array&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ARR_HASNULL(transarray2) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ARR_SIZE(transarray2) != ARR_OVERHEAD_NONULLS(<span class="Constant">1</span>) + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L6650" title="utils/adt/numeric.c:6650">Int8TransTypeData</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;expected 2-<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> int8 array&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state1 = (<a href="#L6650" title="utils/adt/numeric.c:6650">Int8TransTypeData</a> *) ARR_DATA_PTR(transarray1);<br/></li>
<li>&nbsp; &nbsp; state2 = (<a href="#L6650" title="utils/adt/numeric.c:6650">Int8TransTypeData</a> *) ARR_DATA_PTR(transarray2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state1-&gt;count += state2-&gt;count;<br/></li>
<li>&nbsp; &nbsp; state1-&gt;sum += state2-&gt;sum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_ARRAYTYPE_P(transarray1);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L6744">&#x200c;</a><span class="linkable">int2_avg_accum_inv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *transarray;<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> = PG_GETARG_INT16(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L6650" title="utils/adt/numeric.c:6650">Int8TransTypeData</a> *transdata;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're invoked as an aggregate, we can cheat and modify our first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parameter in-place to reduce <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a> overhead. Otherwise we need to make<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a copy of it <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> scribbling on it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../executor/nodeAgg.c.html#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>(fcinfo, <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; transarray = PG_GETARG_ARRAYTYPE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; transarray = PG_GETARG_ARRAYTYPE_P_COPY(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ARR_HASNULL(transarray) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ARR_SIZE(transarray) != ARR_OVERHEAD_NONULLS(<span class="Constant">1</span>) + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L6650" title="utils/adt/numeric.c:6650">Int8TransTypeData</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;expected 2-<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> int8 array&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; transdata = (<a href="#L6650" title="utils/adt/numeric.c:6650">Int8TransTypeData</a> *) ARR_DATA_PTR(transarray);<br/></li>
<li>&nbsp; &nbsp; transdata-&gt;count--;<br/></li>
<li>&nbsp; &nbsp; transdata-&gt;sum -= <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_ARRAYTYPE_P(transarray);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L6772">&#x200c;</a><span class="linkable">int4_avg_accum_inv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *transarray;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L6650" title="utils/adt/numeric.c:6650">Int8TransTypeData</a> *transdata;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're invoked as an aggregate, we can cheat and modify our first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parameter in-place to reduce <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a> overhead. Otherwise we need to make<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a copy of it <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> scribbling on it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../executor/nodeAgg.c.html#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>(fcinfo, <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; transarray = PG_GETARG_ARRAYTYPE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; transarray = PG_GETARG_ARRAYTYPE_P_COPY(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ARR_HASNULL(transarray) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ARR_SIZE(transarray) != ARR_OVERHEAD_NONULLS(<span class="Constant">1</span>) + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L6650" title="utils/adt/numeric.c:6650">Int8TransTypeData</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;expected 2-<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> int8 array&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; transdata = (<a href="#L6650" title="utils/adt/numeric.c:6650">Int8TransTypeData</a> *) ARR_DATA_PTR(transarray);<br/></li>
<li>&nbsp; &nbsp; transdata-&gt;count--;<br/></li>
<li>&nbsp; &nbsp; transdata-&gt;sum -= <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_ARRAYTYPE_P(transarray);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L6800">&#x200c;</a><span class="linkable">int8_avg</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *transarray = PG_GETARG_ARRAYTYPE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L6650" title="utils/adt/numeric.c:6650">Int8TransTypeData</a> *transdata;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; countd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sumd;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ARR_HASNULL(transarray) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ARR_SIZE(transarray) != ARR_OVERHEAD_NONULLS(<span class="Constant">1</span>) + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L6650" title="utils/adt/numeric.c:6650">Int8TransTypeData</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;expected 2-<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> int8 array&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; transdata = (<a href="#L6650" title="utils/adt/numeric.c:6650">Int8TransTypeData</a> *) ARR_DATA_PTR(transarray);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* SQL defines AVG of no <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to be NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (transdata-&gt;count == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; countd = NumericGetDatum(<a href="#L4283" title="utils/adt/numeric.c:4283">int64_to_numeric</a>(transdata-&gt;count));<br/></li>
<li>&nbsp; &nbsp; sumd = NumericGetDatum(<a href="#L4283" title="utils/adt/numeric.c:4283">int64_to_numeric</a>(transdata-&gt;sum));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_DATUM(DirectFunctionCall2(<a href="#L3124" title="utils/adt/numeric.c:3124">numeric_div</a>, sumd, countd));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * SUM(int2) and SUM(int4) both return int8, so we can use this<br/></li>
<li></span><span class="Comment"> * final function for both.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L6827">&#x200c;</a><span class="linkable">int2int4_sum</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *transarray = PG_GETARG_ARRAYTYPE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L6650" title="utils/adt/numeric.c:6650">Int8TransTypeData</a> *transdata;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ARR_HASNULL(transarray) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ARR_SIZE(transarray) != ARR_OVERHEAD_NONULLS(<span class="Constant">1</span>) + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L6650" title="utils/adt/numeric.c:6650">Int8TransTypeData</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;expected 2-<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> int8 array&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; transdata = (<a href="#L6650" title="utils/adt/numeric.c:6650">Int8TransTypeData</a> *) ARR_DATA_PTR(transarray);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* SQL defines SUM of no <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to be NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (transdata-&gt;count == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_DATUM(Int64GetDatumFast(transdata-&gt;sum));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Debug support<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef NUMERIC_DEBUG<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L472" title="utils/adt/numeric.c:472">dump_numeric</a>() - Dump a value in the db storage format for debugging<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L6858">&#x200c;</a></span><span class="linkable">dump_numeric</span>(<span class="Type">const</span> <span class="Type">char</span> *str, Numeric num)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> *digits = <a href="#L486" title="utils/adt/numeric.c:486">NUMERIC_DIGITS</a>(num);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndigits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ndigits = <a href="#L488" title="utils/adt/numeric.c:488">NUMERIC_NDIGITS</a>(num);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; printf(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">: NUMERIC w=</span><span class="Special">%d</span><span class="Constant"> d=</span><span class="Special">%d</span><span class="Constant"> &quot;</span>, str,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L246" title="utils/adt/numeric.c:246">NUMERIC_WEIGHT</a>(num), <a href="#L242" title="utils/adt/numeric.c:242">NUMERIC_DSCALE</a>(num));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (<a href="#L236" title="utils/adt/numeric.c:236">NUMERIC_SIGN</a>(num))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(<span class="Constant">&quot;POS&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L166" title="utils/adt/numeric.c:166">NUMERIC_NEG</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(<span class="Constant">&quot;NEG&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L197" title="utils/adt/numeric.c:197">NUMERIC_NAN</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(<span class="Constant">&quot;NaN&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L198" title="utils/adt/numeric.c:198">NUMERIC_PINF</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(<span class="Constant">&quot;Infinity&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L199" title="utils/adt/numeric.c:199">NUMERIC_NINF</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(<span class="Constant">&quot;-Infinity&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(<span class="Constant">&quot;SIGN=0x</span><span class="Special">%x</span><span class="Constant">&quot;</span>, <a href="#L236" title="utils/adt/numeric.c:236">NUMERIC_SIGN</a>(num));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; ndigits; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; printf(<span class="Constant">&quot; </span><span class="Special">%0*d</span><span class="Constant">&quot;</span>, <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a>, digits[i]);<br/></li>
<li>&nbsp; &nbsp; printf(<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L473" title="utils/adt/numeric.c:473">dump_var</a>() - Dump a value in the variable format for debugging<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L6900">&#x200c;</a></span><span class="linkable">dump_var</span>(<span class="Type">const</span> <span class="Type">char</span> *str, <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; printf(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">: VAR w=</span><span class="Special">%d</span><span class="Constant"> d=</span><span class="Special">%d</span><span class="Constant"> &quot;</span>, str, var-&gt;weight, var-&gt;dscale);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (var-&gt;sign)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(<span class="Constant">&quot;POS&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L166" title="utils/adt/numeric.c:166">NUMERIC_NEG</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(<span class="Constant">&quot;NEG&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L197" title="utils/adt/numeric.c:197">NUMERIC_NAN</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(<span class="Constant">&quot;NaN&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L198" title="utils/adt/numeric.c:198">NUMERIC_PINF</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(<span class="Constant">&quot;Infinity&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L199" title="utils/adt/numeric.c:199">NUMERIC_NINF</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(<span class="Constant">&quot;-Infinity&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(<span class="Constant">&quot;SIGN=0x</span><span class="Special">%x</span><span class="Constant">&quot;</span>, var-&gt;sign);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; var-&gt;ndigits; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; printf(<span class="Constant">&quot; </span><span class="Special">%0*d</span><span class="Constant">&quot;</span>, <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a>, var-&gt;digits[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; printf(<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* NUMERIC_DEBUG */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Local <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> follow<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In general, these do not support &quot;special&quot; (NaN or infinity) inputs;<br/></li>
<li></span><span class="Comment"> * callers should handle those possibilities first.<br/></li>
<li></span><span class="Comment"> * (There are one or two exceptions, noted in their header comments.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6953" title="utils/adt/numeric.c:6953">alloc_var</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Allocate a digit buffer of ndigits digits (plus a spare digit for rounding)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L6953">&#x200c;</a></span><span class="linkable">alloc_var</span>(<a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var, <span class="Type">int</span> ndigits)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L478" title="utils/adt/numeric.c:478">digitbuf_free</a>(var-&gt;buf);<br/></li>
<li>&nbsp; &nbsp; var-&gt;buf = <a href="#L476" title="utils/adt/numeric.c:476">digitbuf_alloc</a>(ndigits + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; var-&gt;buf[<span class="Constant">0</span>] = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* spare digit for rounding */<br/></li>
<li></span>&nbsp; &nbsp; var-&gt;digits = var-&gt;buf + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; var-&gt;ndigits = ndigits;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Return the digit buffer of a variable to the free pool<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L6969">&#x200c;</a></span><span class="linkable">free_var</span>(<a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L478" title="utils/adt/numeric.c:478">digitbuf_free</a>(var-&gt;buf);<br/></li>
<li>&nbsp; &nbsp; var-&gt;buf = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; var-&gt;digits = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; var-&gt;sign = <a href="#L197" title="utils/adt/numeric.c:197">NUMERIC_NAN</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6985" title="utils/adt/numeric.c:6985">zero_var</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Set a variable to ZERO.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Note: its dscale is not touched.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L6985">&#x200c;</a></span><span class="linkable">zero_var</span>(<a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L478" title="utils/adt/numeric.c:478">digitbuf_free</a>(var-&gt;buf);<br/></li>
<li>&nbsp; &nbsp; var-&gt;buf = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; var-&gt;digits = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; var-&gt;ndigits = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; var-&gt;weight = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* by convention; doesn't really matter */<br/></li>
<li></span>&nbsp; &nbsp; var-&gt;sign = <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a>;&nbsp; &nbsp; <span class="Comment">/* anything but NAN... */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L7012" title="utils/adt/numeric.c:7012">set_var_from_str</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Parse a string and put the number into a variable<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function does not handle leading or trailing spaces.&nbsp; It returns<br/></li>
<li></span><span class="Comment"> * the end+1 position parsed into *endptr, so that caller can check for<br/></li>
<li></span><span class="Comment"> * trailing spaces/garbage if deemed necessary.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * cp is the place to actually start parsing; str is what to use in error<br/></li>
<li></span><span class="Comment"> * reports.&nbsp; (Typically cp would be the same except advanced over spaces.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true on success, false on failure (if escontext points to an<br/></li>
<li></span><span class="Comment"> * ErrorSaveContext; otherwise errors are thrown).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L7012">&#x200c;</a></span><span class="linkable">set_var_from_str</span>(<span class="Type">const</span> <span class="Type">char</span> *str, <span class="Type">const</span> <span class="Type">char</span> *cp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *dest, <span class="Type">const</span> <span class="Type">char</span> **endptr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Node *escontext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; have_dp = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> *decdigits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sign = <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dweight = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ddigits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dscale = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; weight;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndigits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offset;<br/></li>
<li>&nbsp; &nbsp; <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> *digits;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We first <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> the string to extract decimal digits and determine the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * correct decimal weight.&nbsp; Then convert to <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> representation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (*cp)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'+'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sign = <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cp++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'-'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sign = <a href="#L166" title="utils/adt/numeric.c:166">NUMERIC_NEG</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cp++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*cp == <span class="Constant">'.'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; have_dp = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cp++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!isdigit((<span class="Type">unsigned</span> <span class="Type">char</span>) *cp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> invalid_syntax;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; decdigits = (<span class="Type">unsigned</span> <span class="Type">char</span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(strlen(cp) + <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> * <span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* leading padding for digit alignment later */<br/></li>
<li></span>&nbsp; &nbsp; memset(decdigits, <span class="Constant">0</span>, <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a>);<br/></li>
<li>&nbsp; &nbsp; i = <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (*cp)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isdigit((<span class="Type">unsigned</span> <span class="Type">char</span>) *cp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; decdigits[i++] = *cp++ - <span class="Constant">'0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!have_dp)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dweight++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dscale++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*cp == <span class="Constant">'.'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (have_dp)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> invalid_syntax;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; have_dp = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cp++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* decimal point must not be followed by underscore */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*cp == <span class="Constant">'<a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> invalid_syntax;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*cp == <span class="Constant">'<a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* underscore must be followed by more digits */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cp++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!isdigit((<span class="Type">unsigned</span> <span class="Type">char</span>) *cp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> invalid_syntax;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ddigits = i - <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* trailing padding for digit alignment later */<br/></li>
<li></span>&nbsp; &nbsp; memset(decdigits + i, <span class="Constant">0</span>, <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Handle exponent, if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (*cp == <span class="Constant">'e'</span> || *cp == <span class="Constant">'E'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; exponent = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; neg = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * At this point, dweight and dscale can't be more than about<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * INT_MAX/2 due to the MaxAllocSize limit on string length, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * constraining the exponent similarly should be enough to prevent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * integer overflow in this function.&nbsp; If the value is too large to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fit in storage format, <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>() will complain about it later;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for consistency use the same ereport <a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>/text as <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* exponent sign */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; cp++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*cp == <span class="Constant">'+'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cp++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*cp == <span class="Constant">'-'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; neg = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cp++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* exponent digits */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!isdigit((<span class="Type">unsigned</span> <span class="Type">char</span>) *cp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> invalid_syntax;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (*cp)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isdigit((<span class="Type">unsigned</span> <span class="Type">char</span>) *cp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exponent = exponent * <span class="Constant">10</span> + (*cp++ - <span class="Constant">'0'</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (exponent &gt; PG_INT32_MAX / <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> out_of_range;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*cp == <span class="Constant">'<a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* underscore must be followed by more digits */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cp++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!isdigit((<span class="Type">unsigned</span> <span class="Type">char</span>) *cp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> invalid_syntax;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (neg)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exponent = -exponent;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dweight += (<span class="Type">int</span>) exponent;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dscale -= (<span class="Type">int</span>) exponent;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dscale &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dscale = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Okay, convert pure-decimal representation to base <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>.&nbsp; First we need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to determine the converted weight and ndigits.&nbsp; offset is the number of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * decimal zeroes to insert <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the first given digit to have a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * correctly aligned first <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> digit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (dweight &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; weight = (dweight + <span class="Constant">1</span> + <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> - <span class="Constant">1</span>) / <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; weight = -((-dweight - <span class="Constant">1</span>) / <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; offset = (weight + <span class="Constant">1</span>) * <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> - (dweight + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; ndigits = (ddigits + offset + <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> - <span class="Constant">1</span>) / <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6953" title="utils/adt/numeric.c:6953">alloc_var</a>(dest, ndigits);<br/></li>
<li>&nbsp; &nbsp; dest-&gt;sign = sign;<br/></li>
<li>&nbsp; &nbsp; dest-&gt;weight = weight;<br/></li>
<li>&nbsp; &nbsp; dest-&gt;dscale = dscale;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; i = <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> - offset;<br/></li>
<li>&nbsp; &nbsp; digits = dest-&gt;digits;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (ndigits-- &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li><span class="PreProc">#if <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> == </span><span class="Constant">4<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *digits++ = ((decdigits[i] * <span class="Constant">10</span> + decdigits[i + <span class="Constant">1</span>]) * <span class="Constant">10</span> +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; decdigits[i + <span class="Constant">2</span>]) * <span class="Constant">10</span> + decdigits[i + <span class="Constant">3</span>];<br/></li>
<li><span class="PreProc">#elif <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> == </span><span class="Constant">2<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *digits++ = decdigits[i] * <span class="Constant">10</span> + decdigits[i + <span class="Constant">1</span>];<br/></li>
<li><span class="PreProc">#elif <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> == </span><span class="Constant">1<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *digits++ = decdigits[i];<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span><span class="PreProc">#error unsupported <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a><br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; i += <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(decdigits);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Strip <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> leading/trailing zeroes, and normalize weight if zero */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L11917" title="utils/adt/numeric.c:11917">strip_var</a>(dest);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Return end+1 position for caller */<br/></li>
<li></span>&nbsp; &nbsp; *endptr = cp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li><span class="Statement">out_of_range</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; ereturn(escontext, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;value overflows <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> format&quot;</span>)));<br/></li>
<li><br/></li>
<li><span class="Statement">invalid_syntax</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; ereturn(escontext, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid input syntax for type </span><span class="Special">%s</span><span class="Constant">: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;<a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a>&quot;</span>, str)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> value of a single hex digit.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">int<br/></li>
<li><a id="L7215">&#x200c;</a></span><span class="linkable">xdigit_value</span>(<span class="Type">char</span> dig)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> dig &gt;= <span class="Constant">'0'</span> &amp;&amp; dig &lt;= <span class="Constant">'9'</span> ? dig - <span class="Constant">'0'</span> :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dig &gt;= <span class="Constant">'a'</span> &amp;&amp; dig &lt;= <span class="Constant">'f'</span> ? dig - <span class="Constant">'a'</span> + <span class="Constant">10</span> :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dig &gt;= <span class="Constant">'A'</span> &amp;&amp; dig &lt;= <span class="Constant">'F'</span> ? dig - <span class="Constant">'A'</span> + <span class="Constant">10</span> : -<span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L7242" title="utils/adt/numeric.c:7242">set_var_from_non_decimal_integer_str</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Parse a string containing a non-decimal integer<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function does not handle leading or trailing spaces.&nbsp; It returns<br/></li>
<li></span><span class="Comment"> * the end+1 position parsed into *endptr, so that caller can check for<br/></li>
<li></span><span class="Comment"> * trailing spaces/garbage if deemed necessary.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * cp is the place to actually start parsing; str is what to use in error<br/></li>
<li></span><span class="Comment"> * reports.&nbsp; The number's sign and base prefix indicator (e.g., &quot;0x&quot;) are<br/></li>
<li></span><span class="Comment"> * assumed to have already been parsed, so cp should point to the number's<br/></li>
<li></span><span class="Comment"> * first digit in the base specified.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * base is expected to be 2, 8 or 16.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true on success, false on failure (if escontext points to an<br/></li>
<li></span><span class="Comment"> * ErrorSaveContext; otherwise errors are thrown).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L7242">&#x200c;</a></span><span class="linkable">set_var_from_non_decimal_integer_str</span>(<span class="Type">const</span> <span class="Type">char</span> *str, <span class="Type">const</span> <span class="Type">char</span> *cp, <span class="Type">int</span> sign,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> base, <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *dest,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> **endptr, Node *escontext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *firstdigit = cp;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; tmp;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; mul;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; tmp_var;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;tmp_var);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6985" title="utils/adt/numeric.c:6985">zero_var</a>(dest);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Process input digits in groups that fit in int64.&nbsp; Here &quot;tmp&quot; is the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * value of the digits in the group, and &quot;mul&quot; is base^n, where n is the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * number of digits in the group.&nbsp; Thus tmp &lt; mul, and we must start a new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * group when mul * base threatens to overflow PG_INT64_MAX.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tmp = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; mul = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (base == <span class="Constant">16</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (*cp)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isxdigit((<span class="Type">unsigned</span> <span class="Type">char</span>) *cp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (mul &gt; PG_INT64_MAX / <span class="Constant">16</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Add the contribution from this group of digits */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8104" title="utils/adt/numeric.c:8104">int64_to_numericvar</a>(mul, &amp;tmp_var);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8669" title="utils/adt/numeric.c:8669">mul_var</a>(dest, &amp;tmp_var, dest, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8104" title="utils/adt/numeric.c:8104">int64_to_numericvar</a>(tmp, &amp;tmp_var);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8431" title="utils/adt/numeric.c:8431">add_var</a>(dest, &amp;tmp_var, dest);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Result will overflow if weight overflows int16 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dest-&gt;weight &gt; <span class="Constant">SHRT_MAX</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> out_of_range;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Begin a new group */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mul = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp = tmp * <span class="Constant">16</span> + <a href="#L7215" title="utils/adt/numeric.c:7215">xdigit_value</a>(*cp++);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mul = mul * <span class="Constant">16</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*cp == <span class="Constant">'<a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Underscore must be followed by more digits */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cp++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!isxdigit((<span class="Type">unsigned</span> <span class="Type">char</span>) *cp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> invalid_syntax;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (base == <span class="Constant">8</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (*cp)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*cp &gt;= <span class="Constant">'0'</span> &amp;&amp; *cp &lt;= <span class="Constant">'7'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (mul &gt; PG_INT64_MAX / <span class="Constant">8</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Add the contribution from this group of digits */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8104" title="utils/adt/numeric.c:8104">int64_to_numericvar</a>(mul, &amp;tmp_var);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8669" title="utils/adt/numeric.c:8669">mul_var</a>(dest, &amp;tmp_var, dest, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8104" title="utils/adt/numeric.c:8104">int64_to_numericvar</a>(tmp, &amp;tmp_var);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8431" title="utils/adt/numeric.c:8431">add_var</a>(dest, &amp;tmp_var, dest);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Result will overflow if weight overflows int16 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dest-&gt;weight &gt; <span class="Constant">SHRT_MAX</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> out_of_range;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Begin a new group */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mul = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp = tmp * <span class="Constant">8</span> + (*cp++ - <span class="Constant">'0'</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mul = mul * <span class="Constant">8</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*cp == <span class="Constant">'<a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Underscore must be followed by more digits */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cp++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*cp &lt; <span class="Constant">'0'</span> || *cp &gt; <span class="Constant">'7'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> invalid_syntax;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (base == <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (*cp)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*cp &gt;= <span class="Constant">'0'</span> &amp;&amp; *cp &lt;= <span class="Constant">'1'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (mul &gt; PG_INT64_MAX / <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Add the contribution from this group of digits */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8104" title="utils/adt/numeric.c:8104">int64_to_numericvar</a>(mul, &amp;tmp_var);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8669" title="utils/adt/numeric.c:8669">mul_var</a>(dest, &amp;tmp_var, dest, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8104" title="utils/adt/numeric.c:8104">int64_to_numericvar</a>(tmp, &amp;tmp_var);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8431" title="utils/adt/numeric.c:8431">add_var</a>(dest, &amp;tmp_var, dest);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Result will overflow if weight overflows int16 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dest-&gt;weight &gt; <span class="Constant">SHRT_MAX</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> out_of_range;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Begin a new group */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mul = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp = tmp * <span class="Constant">2</span> + (*cp++ - <span class="Constant">'0'</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mul = mul * <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*cp == <span class="Constant">'<a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Underscore must be followed by more digits */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cp++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*cp &lt; <span class="Constant">'0'</span> || *cp &gt; <span class="Constant">'1'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> invalid_syntax;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Should never happen; treat as invalid input */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> invalid_syntax;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check that we got at least one digit */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(cp == firstdigit))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> invalid_syntax;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Add the contribution from the final group of digits */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L8104" title="utils/adt/numeric.c:8104">int64_to_numericvar</a>(mul, &amp;tmp_var);<br/></li>
<li>&nbsp; &nbsp; <a href="#L8669" title="utils/adt/numeric.c:8669">mul_var</a>(dest, &amp;tmp_var, dest, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L8104" title="utils/adt/numeric.c:8104">int64_to_numericvar</a>(tmp, &amp;tmp_var);<br/></li>
<li>&nbsp; &nbsp; <a href="#L8431" title="utils/adt/numeric.c:8431">add_var</a>(dest, &amp;tmp_var, dest);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dest-&gt;weight &gt; <span class="Constant">SHRT_MAX</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> out_of_range;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dest-&gt;sign = sign;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;tmp_var);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Return end+1 position for caller */<br/></li>
<li></span>&nbsp; &nbsp; *endptr = cp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li><span class="Statement">out_of_range</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; ereturn(escontext, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;value overflows <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> format&quot;</span>)));<br/></li>
<li><br/></li>
<li><span class="Statement">invalid_syntax</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; ereturn(escontext, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid input syntax for type </span><span class="Special">%s</span><span class="Constant">: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;<a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a>&quot;</span>, str)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L7420" title="utils/adt/numeric.c:7420">set_var_from_num</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Convert the packed db format into a variable<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L7420">&#x200c;</a></span><span class="linkable">set_var_from_num</span>(Numeric num, <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *dest)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndigits;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ndigits = <a href="#L488" title="utils/adt/numeric.c:488">NUMERIC_NDIGITS</a>(num);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6953" title="utils/adt/numeric.c:6953">alloc_var</a>(dest, ndigits);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dest-&gt;weight = <a href="#L246" title="utils/adt/numeric.c:246">NUMERIC_WEIGHT</a>(num);<br/></li>
<li>&nbsp; &nbsp; dest-&gt;sign = <a href="#L236" title="utils/adt/numeric.c:236">NUMERIC_SIGN</a>(num);<br/></li>
<li>&nbsp; &nbsp; dest-&gt;dscale = <a href="#L242" title="utils/adt/numeric.c:242">NUMERIC_DSCALE</a>(num);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memcpy(dest-&gt;digits, <a href="#L486" title="utils/adt/numeric.c:486">NUMERIC_DIGITS</a>(num), ndigits * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L7451" title="utils/adt/numeric.c:7451">init_var_from_num</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Initialize a variable from packed db format. The digits array is not<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; copied, which saves some cycles when the resulting var is not modified.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Also, there's no need to call <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(), as long as you don't assign <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; other value to it (with set_var_* <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, or by using the var as the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; destination of a function like <a href="#L8431" title="utils/adt/numeric.c:8431">add_var</a>())<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; CAUTION: Do not modify the digits buffer of a var initialized with this<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; function, e.g by calling <a href="#L11749" title="utils/adt/numeric.c:11749">round_var</a>() or <a href="#L11855" title="utils/adt/numeric.c:11855">trunc_var</a>(), as the changes will<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; propagate to the original Numeric! It's OK to use it as the destination<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; argument of one of the calculational <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, though.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L7451">&#x200c;</a></span><span class="linkable">init_var_from_num</span>(Numeric num, <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *dest)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dest-&gt;ndigits = <a href="#L488" title="utils/adt/numeric.c:488">NUMERIC_NDIGITS</a>(num);<br/></li>
<li>&nbsp; &nbsp; dest-&gt;weight = <a href="#L246" title="utils/adt/numeric.c:246">NUMERIC_WEIGHT</a>(num);<br/></li>
<li>&nbsp; &nbsp; dest-&gt;sign = <a href="#L236" title="utils/adt/numeric.c:236">NUMERIC_SIGN</a>(num);<br/></li>
<li>&nbsp; &nbsp; dest-&gt;dscale = <a href="#L242" title="utils/adt/numeric.c:242">NUMERIC_DSCALE</a>(num);<br/></li>
<li>&nbsp; &nbsp; dest-&gt;digits = <a href="#L486" title="utils/adt/numeric.c:486">NUMERIC_DIGITS</a>(num);<br/></li>
<li>&nbsp; &nbsp; dest-&gt;buf = <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* digits array is not <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L7468" title="utils/adt/numeric.c:7468">set_var_from_var</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Copy one variable into another<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L7468">&#x200c;</a></span><span class="linkable">set_var_from_var</span>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *value, <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *dest)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> *newbuf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; newbuf = <a href="#L476" title="utils/adt/numeric.c:476">digitbuf_alloc</a>(value-&gt;ndigits + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; newbuf[<span class="Constant">0</span>] = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* spare digit for rounding */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (value-&gt;ndigits &gt; <span class="Constant">0</span>)&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* else value-&gt;digits might be null */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(newbuf + <span class="Constant">1</span>, value-&gt;digits,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; value-&gt;ndigits * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L478" title="utils/adt/numeric.c:478">digitbuf_free</a>(dest-&gt;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memmove(dest, value, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>));<br/></li>
<li>&nbsp; &nbsp; dest-&gt;buf = newbuf;<br/></li>
<li>&nbsp; &nbsp; dest-&gt;digits = newbuf + <span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L7494" title="utils/adt/numeric.c:7494">get_str_from_var</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Convert a var to text representation (guts of <a href="#L807" title="utils/adt/numeric.c:807">numeric_out</a>).<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; The var is displayed to the number of digits indicated by its dscale.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Returns a <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d string.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L7494">&#x200c;</a><span class="linkable">get_str_from_var</span>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dscale;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *str;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *cp;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *endcp;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d;<br/></li>
<li>&nbsp; &nbsp; <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> dig;<br/></li>
<li><br/></li>
<li><span class="PreProc">#if <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> &gt; </span><span class="Constant">1<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> d1;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; dscale = var-&gt;dscale;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate space for the result.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * i is set to the # of decimal digits <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> decimal point. dscale is the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * # of decimal digits we will <a href="../../nodes/print.c.html#L36" title="nodes/print.c:36">print</a> after decimal point. We may generate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as many as <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a>-1 excess digits at the end, and in addition we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need room for sign, decimal point, null terminator.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; i = (var-&gt;weight + <span class="Constant">1</span>) * <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (i &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; str = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(i + dscale + <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> + <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; cp = str;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Output a dash for negative <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;sign == <a href="#L166" title="utils/adt/numeric.c:166">NUMERIC_NEG</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *cp++ = <span class="Constant">'-'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Output all digits <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the decimal point<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;weight &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; d = var-&gt;weight + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *cp++ = <span class="Constant">'0'</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (d = <span class="Constant">0</span>; d &lt;= var-&gt;weight; d++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dig = (d &lt; var-&gt;ndigits) ? var-&gt;digits[d] : <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* In the first digit, suppress extra leading decimal zeroes */<br/></li>
<li></span><span class="PreProc">#if <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> == </span><span class="Constant">4<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; putit = (d &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d1 = dig / <span class="Constant">1000</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dig -= d1 * <span class="Constant">1000</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; putit |= (d1 &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (putit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *cp++ = d1 + <span class="Constant">'0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d1 = dig / <span class="Constant">100</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dig -= d1 * <span class="Constant">100</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; putit |= (d1 &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (putit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *cp++ = d1 + <span class="Constant">'0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d1 = dig / <span class="Constant">10</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dig -= d1 * <span class="Constant">10</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; putit |= (d1 &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (putit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *cp++ = d1 + <span class="Constant">'0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *cp++ = dig + <span class="Constant">'0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#elif <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> == </span><span class="Constant">2<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d1 = dig / <span class="Constant">10</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dig -= d1 * <span class="Constant">10</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (d1 &gt; <span class="Constant">0</span> || d &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *cp++ = d1 + <span class="Constant">'0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *cp++ = dig + <span class="Constant">'0'</span>;<br/></li>
<li><span class="PreProc">#elif <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> == </span><span class="Constant">1<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *cp++ = dig + <span class="Constant">'0'</span>;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span><span class="PreProc">#error unsupported <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a><br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If requested, output a decimal point and all the digits that follow it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We initially put out a multiple of <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> digits, then truncate if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (dscale &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *cp++ = <span class="Constant">'.'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; endcp = cp + dscale;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; dscale; d++, i += <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dig = (d &gt;= <span class="Constant">0</span> &amp;&amp; d &lt; var-&gt;ndigits) ? var-&gt;digits[d] : <span class="Constant">0</span>;<br/></li>
<li><span class="PreProc">#if <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> == </span><span class="Constant">4<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d1 = dig / <span class="Constant">1000</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dig -= d1 * <span class="Constant">1000</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *cp++ = d1 + <span class="Constant">'0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d1 = dig / <span class="Constant">100</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dig -= d1 * <span class="Constant">100</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *cp++ = d1 + <span class="Constant">'0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d1 = dig / <span class="Constant">10</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dig -= d1 * <span class="Constant">10</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *cp++ = d1 + <span class="Constant">'0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *cp++ = dig + <span class="Constant">'0'</span>;<br/></li>
<li><span class="PreProc">#elif <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> == </span><span class="Constant">2<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d1 = dig / <span class="Constant">10</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dig -= d1 * <span class="Constant">10</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *cp++ = d1 + <span class="Constant">'0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *cp++ = dig + <span class="Constant">'0'</span>;<br/></li>
<li><span class="PreProc">#elif <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> == </span><span class="Constant">1<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *cp++ = dig + <span class="Constant">'0'</span>;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span><span class="PreProc">#error unsupported <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a><br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cp = endcp;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * terminate the string and return it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; *cp = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> str;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L7647" title="utils/adt/numeric.c:7647">get_str_from_var_sci</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Convert a var to a normalised scientific notation text representation.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; This function does the heavy lifting for <a href="#L983" title="utils/adt/numeric.c:983">numeric_out_sci</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; This notation has the general form a * 10^b, where a is known as the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &quot;significand&quot; and b is known as the &quot;exponent&quot;.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Because we can't do superscript in ASCII (and because we want to copy<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; printf's behaviour) we display the exponent using E notation, with a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; minimum of two exponent digits.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; For example, the value 1234 could be output as 1.2e+03.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; We assume that the exponent can fit into an int32.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; rscale is the number of decimal digits desired after the decimal point in<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; the output, negative <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> will be treated as meaning zero.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Returns a <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d string.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L7647">&#x200c;</a><span class="linkable">get_str_from_var_sci</span>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var, <span class="Type">int</span> rscale)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; exponent;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; tmp_var;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *str;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *sig_out;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rscale &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rscale = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine the exponent of this number in normalised form.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is the exponent required to represent the number with only one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * significant digit <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the decimal place.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;ndigits &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; exponent = (var-&gt;weight + <span class="Constant">1</span>) * <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Compensate for leading decimal zeroes in the first <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> digit by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * decrementing the exponent.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; exponent -= <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> - (<span class="Type">int</span>) log10(var-&gt;digits[<span class="Constant">0</span>]);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If var has no digits, then it must be zero.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Zero doesn't technically have a meaningful exponent in normalised<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * notation, but we just display the exponent as zero for consistency<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of output.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; exponent = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Divide var by 10^exponent to get the significand, rounding to rscale<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * decimal digits in the process.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;tmp_var);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L11296" title="utils/adt/numeric.c:11296">power_ten_int</a>(exponent, &amp;tmp_var);<br/></li>
<li>&nbsp; &nbsp; <a href="#L8877" title="utils/adt/numeric.c:8877">div_var</a>(var, &amp;tmp_var, &amp;tmp_var, rscale, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; sig_out = <a href="#L7494" title="utils/adt/numeric.c:7494">get_str_from_var</a>(&amp;tmp_var);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;tmp_var);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate space for the result.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In addition to the significand, we need room for the exponent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * decoration (&quot;e&quot;), the sign of the exponent, up to 10 digits for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exponent itself, and of course the null terminator.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; len = strlen(sig_out) + <span class="Constant">13</span>;<br/></li>
<li>&nbsp; &nbsp; str = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(len);<br/></li>
<li>&nbsp; &nbsp; snprintf(str, len, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">e</span><span class="Special">%+03d</span><span class="Constant">&quot;</span>, sig_out, exponent);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(sig_out);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> str;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L7724" title="utils/adt/numeric.c:7724">numericvar_serialize</a> - serialize <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> to binary format<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * At variable level, no checks are performed on the weight or dscale, allowing<br/></li>
<li></span><span class="Comment"> * us to pass around intermediate <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> with higher precision than supported<br/></li>
<li></span><span class="Comment"> * by the <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> type.&nbsp; Note: this is incompatible with <a href="#L1154" title="utils/adt/numeric.c:1154">numeric_send</a>/<a href="../../port/win32/socket.c.html#L37" title="port/win32/socket.c:37">recv</a>(),<br/></li>
<li></span><span class="Comment"> * which use 16-<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> integers for these fields.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L7724">&#x200c;</a></span><span class="linkable">numericvar_serialize</span>(StringInfo buf, <span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pq_sendint32(buf, var-&gt;ndigits);<br/></li>
<li>&nbsp; &nbsp; pq_sendint32(buf, var-&gt;weight);<br/></li>
<li>&nbsp; &nbsp; pq_sendint32(buf, var-&gt;sign);<br/></li>
<li>&nbsp; &nbsp; pq_sendint32(buf, var-&gt;dscale);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; var-&gt;ndigits; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pq_sendint16(buf, var-&gt;digits[i]);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L7740" title="utils/adt/numeric.c:7740">numericvar_deserialize</a> - deserialize binary format to <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L7740">&#x200c;</a></span><span class="linkable">numericvar_deserialize</span>(StringInfo buf, <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len = <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(buf, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int32));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6953" title="utils/adt/numeric.c:6953">alloc_var</a>(var, len);&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* sets var-&gt;ndigits */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; var-&gt;weight = <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(buf, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int32));<br/></li>
<li>&nbsp; &nbsp; var-&gt;sign = <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(buf, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int32));<br/></li>
<li>&nbsp; &nbsp; var-&gt;dscale = <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(buf, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int32));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; len; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; var-&gt;digits[i] = <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(buf, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int16));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L7763" title="utils/adt/numeric.c:7763">duplicate_numeric</a>() - copy a packed-format Numeric<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This will handle NaN and Infinity cases.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Numeric<br/></li>
<li><a id="L7763">&#x200c;</a><span class="linkable">duplicate_numeric</span>(Numeric num)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = (Numeric) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(VARSIZE(num));<br/></li>
<li>&nbsp; &nbsp; memcpy(res, num, VARSIZE(num));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L7782" title="utils/adt/numeric.c:7782">make_result_opt_error</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Create the packed db <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> format in <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>()'d memory from<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; a variable.&nbsp; This will handle NaN and Infinity cases.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; If &quot;have_error&quot; isn't NULL, on overflow *have_error is set to true and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; NULL is returned.&nbsp; This is helpful when caller needs to handle errors.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Numeric<br/></li>
<li><a id="L7782">&#x200c;</a><span class="linkable">make_result_opt_error</span>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *have_error)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> *digits = var-&gt;digits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; weight = var-&gt;weight;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sign = var-&gt;sign;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (have_error)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *have_error = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((sign &amp; <a href="#L164" title="utils/adt/numeric.c:164">NUMERIC_SIGN_MASK</a>) == <a href="#L168" title="utils/adt/numeric.c:168">NUMERIC_SPECIAL</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Verify valid special value.&nbsp; This could be just an Assert, perhaps,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but it seems worthwhile to expend a few cycles to ensure that we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * never write <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> nonzero reserved bits to disk.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!(sign == <a href="#L197" title="utils/adt/numeric.c:197">NUMERIC_NAN</a> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sign == <a href="#L198" title="utils/adt/numeric.c:198">NUMERIC_PINF</a> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sign == <a href="#L199" title="utils/adt/numeric.c:199">NUMERIC_NINF</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> sign value 0x</span><span class="Special">%x</span><span class="Constant">&quot;</span>, sign);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = (Numeric) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<a href="#L175" title="utils/adt/numeric.c:175">NUMERIC_HDRSZ_SHORT</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SET_VARSIZE(result, <a href="#L175" title="utils/adt/numeric.c:175">NUMERIC_HDRSZ_SHORT</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;choice.n_header = sign;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the header <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> is all we need */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L472" title="utils/adt/numeric.c:472">dump_numeric</a>(<span class="Constant">&quot;<a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>()&quot;</span>, result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; n = var-&gt;ndigits;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* truncate leading zeroes */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (n &gt; <span class="Constant">0</span> &amp;&amp; *digits == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; digits++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; weight--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; n--;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* truncate trailing zeroes */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (n &gt; <span class="Constant">0</span> &amp;&amp; digits[n - <span class="Constant">1</span>] == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; n--;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If zero result, force to weight=0 and positive sign */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (n == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; weight = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sign = <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Build the result */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L490" title="utils/adt/numeric.c:490">NUMERIC_CAN_BE_SHORT</a>(var-&gt;dscale, weight))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len = <a href="#L175" title="utils/adt/numeric.c:175">NUMERIC_HDRSZ_SHORT</a> + n * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = (Numeric) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SET_VARSIZE(result, len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;choice.n_short.n_header =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (sign == <a href="#L166" title="utils/adt/numeric.c:166">NUMERIC_NEG</a> ? (<a href="#L167" title="utils/adt/numeric.c:167">NUMERIC_SHORT</a> | <a href="#L213" title="utils/adt/numeric.c:213">NUMERIC_SHORT_SIGN_MASK</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; : <a href="#L167" title="utils/adt/numeric.c:167">NUMERIC_SHORT</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | (var-&gt;dscale &lt;&lt; <a href="#L215" title="utils/adt/numeric.c:215">NUMERIC_SHORT_DSCALE_SHIFT</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | (weight &lt; <span class="Constant">0</span> ? <a href="#L218" title="utils/adt/numeric.c:218">NUMERIC_SHORT_WEIGHT_SIGN_MASK</a> : <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | (weight &amp; <a href="#L219" title="utils/adt/numeric.c:219">NUMERIC_SHORT_WEIGHT_MASK</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len = <a href="#L174" title="utils/adt/numeric.c:174">NUMERIC_HDRSZ</a> + n * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = (Numeric) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SET_VARSIZE(result, len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;choice.n_long.n_sign_dscale =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sign | (var-&gt;dscale &amp; <a href="#L233" title="utils/adt/numeric.c:233">NUMERIC_DSCALE_MASK</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;choice.n_long.n_weight = weight;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L488" title="utils/adt/numeric.c:488">NUMERIC_NDIGITS</a>(result) == n);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (n &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(<a href="#L486" title="utils/adt/numeric.c:486">NUMERIC_DIGITS</a>(result), digits, n * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for overflow of int16 fields */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L246" title="utils/adt/numeric.c:246">NUMERIC_WEIGHT</a>(result) != weight ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L242" title="utils/adt/numeric.c:242">NUMERIC_DSCALE</a>(result) != var-&gt;dscale)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (have_error)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *have_error = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;value overflows <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> format&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L472" title="utils/adt/numeric.c:472">dump_numeric</a>(<span class="Constant">&quot;<a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>()&quot;</span>, result);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="../../optimizer/plan/createplan.c.html#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; An interface to <a href="#L7782" title="utils/adt/numeric.c:7782">make_result_opt_error</a>() without &quot;have_error&quot; argument.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Numeric<br/></li>
<li><a id="L7891">&#x200c;</a><span class="linkable">make_result</span>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L7782" title="utils/adt/numeric.c:7782">make_result_opt_error</a>(var, <span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L7907" title="utils/adt/numeric.c:7907">apply_typmod</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Do bounds checking and rounding according to the specified typmod.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Note that this is only applied to normal finite <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true on success, false on failure (if escontext points to an<br/></li>
<li></span><span class="Comment"> * ErrorSaveContext; otherwise errors are thrown).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L7907">&#x200c;</a></span><span class="linkable">apply_typmod</span>(<a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var, int32 typmod, Node *escontext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; precision;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scale;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxdigits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ddigits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Do nothing if we have an invalid typmod */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L907" title="utils/adt/numeric.c:907">is_valid_numeric_typmod</a>(typmod))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; precision = <a href="#L918" title="utils/adt/numeric.c:918">numeric_typmod_precision</a>(typmod);<br/></li>
<li>&nbsp; &nbsp; scale = <a href="#L933" title="utils/adt/numeric.c:933">numeric_typmod_scale</a>(typmod);<br/></li>
<li>&nbsp; &nbsp; maxdigits = precision - scale;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Round to target scale (and set var-&gt;dscale) */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L11749" title="utils/adt/numeric.c:11749">round_var</a>(var, scale);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* but don't allow var-&gt;dscale to be negative */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;dscale &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; var-&gt;dscale = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check for overflow - note we can't do this <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> rounding, because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rounding could raise the weight.&nbsp; Also note that the var's weight could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be inflated by leading zeroes, which will be stripped <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> storage<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but perhaps might not have been yet. In <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case, we must recognize a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * true zero, whose weight doesn't mean anything.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ddigits = (var-&gt;weight + <span class="Constant">1</span>) * <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ddigits &gt; maxdigits)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Determine true weight; and check for all-zero result */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; var-&gt;ndigits; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> dig = var-&gt;digits[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dig)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Adjust for <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> high-order decimal zero digits */<br/></li>
<li></span><span class="PreProc">#if <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> == </span><span class="Constant">4<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dig &lt; <span class="Constant">10</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ddigits -= <span class="Constant">3</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (dig &lt; <span class="Constant">100</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ddigits -= <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (dig &lt; <span class="Constant">1000</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ddigits -= <span class="Constant">1</span>;<br/></li>
<li><span class="PreProc">#elif <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> == </span><span class="Constant">2<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dig &lt; <span class="Constant">10</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ddigits -= <span class="Constant">1</span>;<br/></li>
<li><span class="PreProc">#elif <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> == </span><span class="Constant">1<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no adjustment */<br/></li>
<li></span><span class="PreProc">#else<br/></li>
<li></span><span class="PreProc">#error unsupported <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a><br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ddigits &gt; maxdigits)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;<a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> field overflow&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;A field with precision </span><span class="Special">%d</span><span class="Constant">, scale </span><span class="Special">%d</span><span class="Constant"> must round to an absolute value less than </span><span class="Special">%s%d</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; precision, scale,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Display 10^0 as 1 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; maxdigits ? <span class="Constant">&quot;10^&quot;</span> : <span class="Constant">&quot;&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; maxdigits ? maxdigits : <span class="Constant">1<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; )));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ddigits -= <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L7992" title="utils/adt/numeric.c:7992">apply_typmod_special</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Do bounds checking according to the specified typmod, for an Inf or NaN.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; For convenience of most callers, the value is presented in packed form.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true on success, false on failure (if escontext points to an<br/></li>
<li></span><span class="Comment"> * ErrorSaveContext; otherwise errors are thrown).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L7992">&#x200c;</a></span><span class="linkable">apply_typmod_special</span>(Numeric num, int32 typmod, Node *escontext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; precision;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scale;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L172" title="utils/adt/numeric.c:172">NUMERIC_IS_SPECIAL</a>(num));&nbsp; &nbsp; <span class="Comment">/* caller error if not */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NaN is allowed regardless of the typmod; that's rather dubious perhaps,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but it's a longstanding behavior.&nbsp; Inf is rejected if we have <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * typmod restriction, since an infinity shouldn't be claimed to fit in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> finite number of digits.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L203" title="utils/adt/numeric.c:203">NUMERIC_IS_NAN</a>(num))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Do nothing if we have a default typmod (-1) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L907" title="utils/adt/numeric.c:907">is_valid_numeric_typmod</a>(typmod))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; precision = <a href="#L918" title="utils/adt/numeric.c:918">numeric_typmod_precision</a>(typmod);<br/></li>
<li>&nbsp; &nbsp; scale = <a href="#L933" title="utils/adt/numeric.c:933">numeric_typmod_scale</a>(typmod);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereturn(escontext, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;<a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> field overflow&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;A field with precision </span><span class="Special">%d</span><span class="Constant">, scale </span><span class="Special">%d</span><span class="Constant"> cannot hold an infinite value.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; precision, scale)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> to int8, rounding if needed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If overflow, return false (no error is raised).&nbsp; Return true if okay.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L8029">&#x200c;</a></span><span class="linkable">numericvar_to_int64</span>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var, int64 *result)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> *digits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndigits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; weight;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; neg;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; rounded;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Round to nearest integer */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;rounded);<br/></li>
<li>&nbsp; &nbsp; <a href="#L7468" title="utils/adt/numeric.c:7468">set_var_from_var</a>(var, &amp;rounded);<br/></li>
<li>&nbsp; &nbsp; <a href="#L11749" title="utils/adt/numeric.c:11749">round_var</a>(&amp;rounded, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for zero input */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L11917" title="utils/adt/numeric.c:11917">strip_var</a>(&amp;rounded);<br/></li>
<li>&nbsp; &nbsp; ndigits = rounded.ndigits;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ndigits == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *result = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;rounded);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For input like 10000000000, we must treat stripped digits as real. So<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the loop assumes there are weight+1 digits <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the decimal point.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; weight = rounded.weight;<br/></li>
<li>&nbsp; &nbsp; Assert(weight &gt;= <span class="Constant">0</span> &amp;&amp; ndigits &lt;= weight + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Construct the result. To avoid issues with converting a value<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * corresponding to INT64_MIN (which can't be represented as a positive 64<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> two's complement integer), accumulate value as a negative number.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; digits = rounded.digits;<br/></li>
<li>&nbsp; &nbsp; neg = (rounded.sign == <a href="#L166" title="utils/adt/numeric.c:166">NUMERIC_NEG</a>);<br/></li>
<li>&nbsp; &nbsp; val = -digits[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt;= weight; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlikely(pg_mul_s64_overflow(val, <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>, &amp;val)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;rounded);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &lt; ndigits)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlikely(pg_sub_s64_overflow(val, digits[i], &amp;val)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;rounded);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;rounded);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!neg)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlikely(val == PG_INT64_MIN))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; val = -val;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; *result = val;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert int8 value to <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L8104">&#x200c;</a></span><span class="linkable">int64_to_numericvar</span>(int64 val, <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; uval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newuval;<br/></li>
<li>&nbsp; &nbsp; <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> *ptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndigits;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* int64 can require at most 19 decimal digits; add one for safety */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L6953" title="utils/adt/numeric.c:6953">alloc_var</a>(var, <span class="Constant">20</span> / <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (val &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; var-&gt;sign = <a href="#L166" title="utils/adt/numeric.c:166">NUMERIC_NEG</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uval = -val;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; var-&gt;sign = <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uval = val;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; var-&gt;dscale = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (val == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; var-&gt;ndigits = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; var-&gt;weight = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; ptr = var-&gt;digits + var-&gt;ndigits;<br/></li>
<li>&nbsp; &nbsp; ndigits = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ndigits++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newuval = uval / <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *ptr = uval - newuval * <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uval = newuval;<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (uval);<br/></li>
<li>&nbsp; &nbsp; var-&gt;digits = ptr;<br/></li>
<li>&nbsp; &nbsp; var-&gt;ndigits = ndigits;<br/></li>
<li>&nbsp; &nbsp; var-&gt;weight = ndigits - <span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> to uint64, rounding if needed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If overflow, return false (no error is raised).&nbsp; Return true if okay.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L8151">&#x200c;</a></span><span class="linkable">numericvar_to_uint64</span>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var, uint64 *result)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> *digits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndigits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; weight;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; rounded;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Round to nearest integer */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;rounded);<br/></li>
<li>&nbsp; &nbsp; <a href="#L7468" title="utils/adt/numeric.c:7468">set_var_from_var</a>(var, &amp;rounded);<br/></li>
<li>&nbsp; &nbsp; <a href="#L11749" title="utils/adt/numeric.c:11749">round_var</a>(&amp;rounded, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for zero input */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L11917" title="utils/adt/numeric.c:11917">strip_var</a>(&amp;rounded);<br/></li>
<li>&nbsp; &nbsp; ndigits = rounded.ndigits;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ndigits == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *result = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;rounded);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for negative input */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rounded.sign == <a href="#L166" title="utils/adt/numeric.c:166">NUMERIC_NEG</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;rounded);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For input like 10000000000, we must treat stripped digits as real. So<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the loop assumes there are weight+1 digits <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the decimal point.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; weight = rounded.weight;<br/></li>
<li>&nbsp; &nbsp; Assert(weight &gt;= <span class="Constant">0</span> &amp;&amp; ndigits &lt;= weight + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Construct the result */<br/></li>
<li></span>&nbsp; &nbsp; digits = rounded.digits;<br/></li>
<li>&nbsp; &nbsp; val = digits[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt;= weight; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlikely(pg_mul_u64_overflow(val, <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>, &amp;val)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;rounded);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &lt; ndigits)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlikely(pg_add_u64_overflow(val, digits[i], &amp;val)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;rounded);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;rounded);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *result = val;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef HAVE_INT128<br/></li>
<li></span><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> to int128, rounding if needed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If overflow, return false (no error is raised).&nbsp; Return true if okay.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L8224">&#x200c;</a></span><span class="linkable">numericvar_to_int128</span>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var, int128 *result)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> *digits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndigits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; weight;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; int128&nbsp; &nbsp; &nbsp; &nbsp; val,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldval;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; neg;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; rounded;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Round to nearest integer */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;rounded);<br/></li>
<li>&nbsp; &nbsp; <a href="#L7468" title="utils/adt/numeric.c:7468">set_var_from_var</a>(var, &amp;rounded);<br/></li>
<li>&nbsp; &nbsp; <a href="#L11749" title="utils/adt/numeric.c:11749">round_var</a>(&amp;rounded, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for zero input */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L11917" title="utils/adt/numeric.c:11917">strip_var</a>(&amp;rounded);<br/></li>
<li>&nbsp; &nbsp; ndigits = rounded.ndigits;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ndigits == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *result = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;rounded);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For input like 10000000000, we must treat stripped digits as real. So<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the loop assumes there are weight+1 digits <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the decimal point.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; weight = rounded.weight;<br/></li>
<li>&nbsp; &nbsp; Assert(weight &gt;= <span class="Constant">0</span> &amp;&amp; ndigits &lt;= weight + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Construct the result */<br/></li>
<li></span>&nbsp; &nbsp; digits = rounded.digits;<br/></li>
<li>&nbsp; &nbsp; neg = (rounded.sign == <a href="#L166" title="utils/adt/numeric.c:166">NUMERIC_NEG</a>);<br/></li>
<li>&nbsp; &nbsp; val = digits[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt;= weight; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldval = val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; val *= <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &lt; ndigits)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val += digits[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The overflow check is a <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> tricky because we want to <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * INT128_MIN, which will overflow the positive accumulator.&nbsp; We can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * detect this case easily though because INT128_MIN is the only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * nonzero value for which -val == val (on a two's complement machine,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * anyway).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((val / <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>) != oldval)&nbsp; &nbsp; <span class="Comment">/* possible overflow? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!neg || (-val) != val || val == <span class="Constant">0</span> || oldval &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;rounded);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;rounded);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *result = neg ? -val : val;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert 128 <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> integer to <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L8295">&#x200c;</a></span><span class="linkable">int128_to_numericvar</span>(int128 val, <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint128&nbsp; &nbsp; &nbsp; &nbsp; uval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newuval;<br/></li>
<li>&nbsp; &nbsp; <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> *ptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndigits;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* int128 can require at most 39 decimal digits; add one for safety */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L6953" title="utils/adt/numeric.c:6953">alloc_var</a>(var, <span class="Constant">40</span> / <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (val &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; var-&gt;sign = <a href="#L166" title="utils/adt/numeric.c:166">NUMERIC_NEG</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uval = -val;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; var-&gt;sign = <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uval = val;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; var-&gt;dscale = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (val == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; var-&gt;ndigits = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; var-&gt;weight = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; ptr = var-&gt;digits + var-&gt;ndigits;<br/></li>
<li>&nbsp; &nbsp; ndigits = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ndigits++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newuval = uval / <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *ptr = uval - newuval * <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uval = newuval;<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (uval);<br/></li>
<li>&nbsp; &nbsp; var-&gt;digits = ptr;<br/></li>
<li>&nbsp; &nbsp; var-&gt;ndigits = ndigits;<br/></li>
<li>&nbsp; &nbsp; var-&gt;weight = ndigits - <span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert a <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> to float8; if out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, return +/- HUGE_VAL<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">double<br/></li>
<li><a id="L8341">&#x200c;</a></span><span class="linkable">numericvar_to_double_no_overflow</span>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *tmp;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *endptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tmp = <a href="#L7494" title="utils/adt/numeric.c:7494">get_str_from_var</a>(var);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* unlike <a href="float.c.html#L357" title="utils/adt/float.c:357">float8in</a>, we ignore ERANGE from strtod */<br/></li>
<li></span>&nbsp; &nbsp; val = strtod(tmp, &amp;endptr);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*endptr != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* shouldn't happen ... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid input syntax for type </span><span class="Special">%s</span><span class="Constant">: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;double precision&quot;</span>, tmp)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(tmp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> val;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L8373" title="utils/adt/numeric.c:8373">cmp_var</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Compare two <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> on variable level.&nbsp; We assume zeroes have been<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; truncated to no digits.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L8373">&#x200c;</a></span><span class="linkable">cmp_var</span>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var1, <span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L8388" title="utils/adt/numeric.c:8388">cmp_var_common</a>(var1-&gt;digits, var1-&gt;ndigits,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var1-&gt;weight, var1-&gt;sign,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var2-&gt;digits, var2-&gt;ndigits,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var2-&gt;weight, var2-&gt;sign);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L8388" title="utils/adt/numeric.c:8388">cmp_var_common</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Main routine of <a href="#L8373" title="utils/adt/numeric.c:8373">cmp_var</a>(). This function can be used by both<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> and Numeric.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L8388">&#x200c;</a></span><span class="linkable">cmp_var_common</span>(<span class="Type">const</span> <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> *var1digits, <span class="Type">int</span> var1ndigits,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> var1weight, <span class="Type">int</span> var1sign,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> *var2digits, <span class="Type">int</span> var2ndigits,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> var2weight, <span class="Type">int</span> var2sign)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (var1ndigits == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var2ndigits == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var2sign == <a href="#L166" title="utils/adt/numeric.c:166">NUMERIC_NEG</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (var2ndigits == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var1sign == <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (var1sign == <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var2sign == <a href="#L166" title="utils/adt/numeric.c:166">NUMERIC_NEG</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L11518" title="utils/adt/numeric.c:11518">cmp_abs_common</a>(var1digits, var1ndigits, var1weight,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var2digits, var2ndigits, var2weight);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (var2sign == <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L11518" title="utils/adt/numeric.c:11518">cmp_abs_common</a>(var2digits, var2ndigits, var2weight,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var1digits, var1ndigits, var1weight);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L8431" title="utils/adt/numeric.c:8431">add_var</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Full version of add functionality on variable level (handling signs).<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; result might point to one of the operands too without danger.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L8431">&#x200c;</a></span><span class="linkable">add_var</span>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var1, <span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var2, <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *result)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Decide on the signs of the two variables what to do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (var1-&gt;sign == <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var2-&gt;sign == <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Both are positive result = +(ABS(var1) + ABS(var2))<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L11582" title="utils/adt/numeric.c:11582">add_abs</a>(var1, var2, result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result-&gt;sign = <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * var1 is positive, var2 is negative Must <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> absolute <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (<a href="#L11504" title="utils/adt/numeric.c:11504">cmp_abs</a>(var1, var2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">0</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ABS(var1) == ABS(var2)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * result = ZERO<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6985" title="utils/adt/numeric.c:6985">zero_var</a>(result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result-&gt;dscale = Max(var1-&gt;dscale, var2-&gt;dscale);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">1</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ABS(var1) &gt; ABS(var2)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * result = +(ABS(var1) - ABS(var2))<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L11667" title="utils/adt/numeric.c:11667">sub_abs</a>(var1, var2, result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result-&gt;sign = <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> -<span class="Constant">1</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ABS(var1) &lt; ABS(var2)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * result = -(ABS(var2) - ABS(var1))<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L11667" title="utils/adt/numeric.c:11667">sub_abs</a>(var2, var1, result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result-&gt;sign = <a href="#L166" title="utils/adt/numeric.c:166">NUMERIC_NEG</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var2-&gt;sign == <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * var1 is negative, var2 is positive<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Must <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> absolute <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (<a href="#L11504" title="utils/adt/numeric.c:11504">cmp_abs</a>(var1, var2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">0</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ABS(var1) == ABS(var2)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * result = ZERO<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6985" title="utils/adt/numeric.c:6985">zero_var</a>(result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result-&gt;dscale = Max(var1-&gt;dscale, var2-&gt;dscale);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">1</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ABS(var1) &gt; ABS(var2)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * result = -(ABS(var1) - ABS(var2))<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L11667" title="utils/adt/numeric.c:11667">sub_abs</a>(var1, var2, result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result-&gt;sign = <a href="#L166" title="utils/adt/numeric.c:166">NUMERIC_NEG</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> -<span class="Constant">1</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ABS(var1) &lt; ABS(var2)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * result = +(ABS(var2) - ABS(var1))<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L11667" title="utils/adt/numeric.c:11667">sub_abs</a>(var2, var1, result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result-&gt;sign = <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Both are negative<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * result = -(ABS(var1) + ABS(var2))<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L11582" title="utils/adt/numeric.c:11582">add_abs</a>(var1, var2, result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result-&gt;sign = <a href="#L166" title="utils/adt/numeric.c:166">NUMERIC_NEG</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L8548" title="utils/adt/numeric.c:8548">sub_var</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Full version of sub functionality on variable level (handling signs).<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; result might point to one of the operands too without danger.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L8548">&#x200c;</a></span><span class="linkable">sub_var</span>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var1, <span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var2, <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *result)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Decide on the signs of the two variables what to do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (var1-&gt;sign == <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var2-&gt;sign == <a href="#L166" title="utils/adt/numeric.c:166">NUMERIC_NEG</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * var1 is positive, var2 is negative<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * result = +(ABS(var1) + ABS(var2))<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L11582" title="utils/adt/numeric.c:11582">add_abs</a>(var1, var2, result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result-&gt;sign = <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Both are positive<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Must <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> absolute <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (<a href="#L11504" title="utils/adt/numeric.c:11504">cmp_abs</a>(var1, var2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">0</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ABS(var1) == ABS(var2)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * result = ZERO<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6985" title="utils/adt/numeric.c:6985">zero_var</a>(result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result-&gt;dscale = Max(var1-&gt;dscale, var2-&gt;dscale);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">1</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ABS(var1) &gt; ABS(var2)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * result = +(ABS(var1) - ABS(var2))<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L11667" title="utils/adt/numeric.c:11667">sub_abs</a>(var1, var2, result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result-&gt;sign = <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> -<span class="Constant">1</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ABS(var1) &lt; ABS(var2)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * result = -(ABS(var2) - ABS(var1))<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L11667" title="utils/adt/numeric.c:11667">sub_abs</a>(var2, var1, result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result-&gt;sign = <a href="#L166" title="utils/adt/numeric.c:166">NUMERIC_NEG</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var2-&gt;sign == <a href="#L166" title="utils/adt/numeric.c:166">NUMERIC_NEG</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Both are negative<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Must <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> absolute <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (<a href="#L11504" title="utils/adt/numeric.c:11504">cmp_abs</a>(var1, var2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">0</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ABS(var1) == ABS(var2)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * result = ZERO<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6985" title="utils/adt/numeric.c:6985">zero_var</a>(result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result-&gt;dscale = Max(var1-&gt;dscale, var2-&gt;dscale);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">1</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ABS(var1) &gt; ABS(var2)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * result = -(ABS(var1) - ABS(var2))<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L11667" title="utils/adt/numeric.c:11667">sub_abs</a>(var1, var2, result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result-&gt;sign = <a href="#L166" title="utils/adt/numeric.c:166">NUMERIC_NEG</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> -<span class="Constant">1</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ABS(var1) &lt; ABS(var2)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * result = +(ABS(var2) - ABS(var1))<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L11667" title="utils/adt/numeric.c:11667">sub_abs</a>(var2, var1, result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result-&gt;sign = <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * var1 is negative, var2 is positive<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * result = -(ABS(var1) + ABS(var2))<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L11582" title="utils/adt/numeric.c:11582">add_abs</a>(var1, var2, result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result-&gt;sign = <a href="#L166" title="utils/adt/numeric.c:166">NUMERIC_NEG</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L8669" title="utils/adt/numeric.c:8669">mul_var</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Multiplication on variable level. Product of var1 * var2 is stored<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; in result.&nbsp; Result is rounded to no more than rscale fractional digits.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L8669">&#x200c;</a></span><span class="linkable">mul_var</span>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var1, <span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var2, <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> rscale)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res_ndigits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res_sign;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res_weight;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxdigits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *dig;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; carry;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxdig;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newdig;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var1ndigits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var2ndigits;<br/></li>
<li>&nbsp; &nbsp; <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> *var1digits;<br/></li>
<li>&nbsp; &nbsp; <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> *var2digits;<br/></li>
<li>&nbsp; &nbsp; <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> *res_digits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Arrange for var1 to be the shorter of the two numbers.&nbsp; This improves<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * performance because the inner multiplication loop is much simpler than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the outer loop, so it's better to have a smaller number of iterations<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of the outer loop.&nbsp; This also reduces the number of times that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * accumulator array needs to be normalized.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (var1-&gt;ndigits &gt; var2-&gt;ndigits)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *tmp = var1;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; var1 = var2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; var2 = tmp;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* copy these <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> into local <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> for speed in inner loop */<br/></li>
<li></span>&nbsp; &nbsp; var1ndigits = var1-&gt;ndigits;<br/></li>
<li>&nbsp; &nbsp; var2ndigits = var2-&gt;ndigits;<br/></li>
<li>&nbsp; &nbsp; var1digits = var1-&gt;digits;<br/></li>
<li>&nbsp; &nbsp; var2digits = var2-&gt;digits;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (var1ndigits == <span class="Constant">0</span> || var2ndigits == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* one or both inputs is zero; so is result */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6985" title="utils/adt/numeric.c:6985">zero_var</a>(result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;dscale = rscale;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Determine result sign and (maximum possible) weight */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (var1-&gt;sign == var2-&gt;sign)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res_sign = <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; res_sign = <a href="#L166" title="utils/adt/numeric.c:166">NUMERIC_NEG</a>;<br/></li>
<li>&nbsp; &nbsp; res_weight = var1-&gt;weight + var2-&gt;weight + <span class="Constant">2</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine the number of result digits to compute.&nbsp; If the exact result<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * would have more than rscale fractional digits, truncate the computation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with <a href="#L98" title="utils/adt/numeric.c:98">MUL_GUARD_DIGITS</a> guard digits, i.e., ignore input digits that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * would only contribute to the right of that.&nbsp; (This will give the exact<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rounded-to-rscale answer unless carries out of the ignored positions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * would have propagated through more than <a href="#L98" title="utils/adt/numeric.c:98">MUL_GUARD_DIGITS</a> digits.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: an exact computation could not produce more than var1ndigits +<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * var2ndigits digits, but we allocate one extra output digit in case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rscale-driven rounding produces a carry out of the highest exact digit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; res_ndigits = var1ndigits + var2ndigits + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; maxdigits = res_weight + <span class="Constant">1</span> + (rscale + <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> - <span class="Constant">1</span>) / <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L98" title="utils/adt/numeric.c:98">MUL_GUARD_DIGITS</a>;<br/></li>
<li>&nbsp; &nbsp; res_ndigits = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(res_ndigits, maxdigits);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (res_ndigits &lt; <span class="Constant">3</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* All input digits will be ignored; so result is zero */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6985" title="utils/adt/numeric.c:6985">zero_var</a>(result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;dscale = rscale;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We do the arithmetic in an array &quot;dig[]&quot; of signed int's.&nbsp; Since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * INT_MAX is noticeably larger than <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>*<a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>, this gives us headroom<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to avoid normalizing carries immediately.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * maxdig tracks the maximum possible value of <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> dig[] entry; when this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * threatens to exceed INT_MAX, we take the time to propagate carries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Furthermore, we need to ensure that overflow doesn't occur during the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * carry propagation passes either.&nbsp; The carry <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> could be as much as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * INT_MAX/<a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>, so really we must normalize when digits threaten to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exceed INT_MAX - INT_MAX/<a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * To avoid overflow in maxdig itself, it actually represents the max<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * possible value divided by <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>-1, ie, at the top of the loop it is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * known that no dig[] entry exceeds maxdig * (<a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>-1).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; dig = (<span class="Type">int</span> *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(res_ndigits * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; maxdig = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The least significant digits of var1 should be ignored if they don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * contribute directly to the first res_ndigits digits of the result that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we are computing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Digit i1 of var1 and digit i2 of var2 are multiplied and added to digit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * i1+i2+2 of the accumulator array, so we need only consider digits of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * var1 for which i1 &lt;= res_ndigits - 3.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i1 = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(var1ndigits - <span class="Constant">1</span>, res_ndigits - <span class="Constant">3</span>); i1 &gt;= <span class="Constant">0</span>; i1--)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> var1digit = var1digits[i1];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var1digit == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Time to normalize? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; maxdig += var1digit;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (maxdig &gt; (<span class="Constant">INT_MAX</span> - <span class="Constant">INT_MAX</span> / <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>) / (<a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> - <span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Yes, do it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; carry = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = res_ndigits - <span class="Constant">1</span>; i &gt;= <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newdig = dig[i] + carry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newdig &gt;= <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; carry = newdig / <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newdig -= carry * <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; carry = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dig[i] = newdig;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(carry == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reset maxdig to indicate new worst-case */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxdig = <span class="Constant">1</span> + var1digit;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Add the appropriate multiple of var2 into the accumulator.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * As above, digits of var2 can be ignored if they don't contribute,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so we only include digits for which i1+i2+2 &lt; res_ndigits.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This inner loop is the performance bottleneck for multiplication,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so we want to keep it simple enough so that it can be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * auto-vectorized.&nbsp; Accordingly, process the digits left-to-right<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * even though schoolbook multiplication would suggest right-to-left.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since we aren't propagating carries in this loop, the order does<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not matter.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i2limit = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(var2ndigits, res_ndigits - i1 - <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *dig_i1_2 = &amp;dig[i1 + <span class="Constant">2</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i2 = <span class="Constant">0</span>; i2 &lt; i2limit; i2++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dig_i1_2[i2] += var1digit * var2digits[i2];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now we do a final carry propagation pass to normalize the result, which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we <a href="../../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> with storing the result digits into the output. Note that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this is still done at full precision w/guard digits.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L6953" title="utils/adt/numeric.c:6953">alloc_var</a>(result, res_ndigits);<br/></li>
<li>&nbsp; &nbsp; res_digits = result-&gt;digits;<br/></li>
<li>&nbsp; &nbsp; carry = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = res_ndigits - <span class="Constant">1</span>; i &gt;= <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newdig = dig[i] + carry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newdig &gt;= <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; carry = newdig / <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newdig -= carry * <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; carry = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res_digits[i] = newdig;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; Assert(carry == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(dig);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Finally, round the result to the requested precision.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; result-&gt;weight = res_weight;<br/></li>
<li>&nbsp; &nbsp; result-&gt;sign = res_sign;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Round to target rscale (and set result-&gt;dscale) */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L11749" title="utils/adt/numeric.c:11749">round_var</a>(result, rscale);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Strip leading and trailing zeroes */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L11917" title="utils/adt/numeric.c:11917">strip_var</a>(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L8877" title="utils/adt/numeric.c:8877">div_var</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Division on variable level. Quotient of var1 / var2 is stored in result.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; The quotient is figured to exactly rscale fractional digits.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; If round is true, it is rounded at the rscale'th digit; if false, it<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; is truncated (towards zero) at that digit.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L8877">&#x200c;</a></span><span class="linkable">div_var</span>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var1, <span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var2, <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> rscale, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> round)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; div_ndigits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res_ndigits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res_sign;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res_weight;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; carry;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; borrow;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; divisor1;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; divisor2;<br/></li>
<li>&nbsp; &nbsp; <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> *dividend;<br/></li>
<li>&nbsp; &nbsp; <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> *divisor;<br/></li>
<li>&nbsp; &nbsp; <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> *res_digits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* copy these <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> into local <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> for speed in inner loop */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var1ndigits = var1-&gt;ndigits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var2ndigits = var2-&gt;ndigits;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First of all division by zero check; we must not be handed an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unnormalized divisor.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (var2ndigits == <span class="Constant">0</span> || var2-&gt;digits[<span class="Constant">0</span>] == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DIVISION_BY_ZERO),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;division by zero&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the divisor has just one or two digits, delegate to <a href="#L9549" title="utils/adt/numeric.c:9549">div_var_int</a>(),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which uses fast short division.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Similarly, on platforms with 128-<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> integer support, delegate to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L9665" title="utils/adt/numeric.c:9665">div_var_int64</a>() for divisors with three or four digits.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (var2ndigits &lt;= <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idivisor;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idivisor_weight;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; idivisor = var2-&gt;digits[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; idivisor_weight = var2-&gt;weight;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var2ndigits == <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idivisor = idivisor * <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> + var2-&gt;digits[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idivisor_weight--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var2-&gt;sign == <a href="#L166" title="utils/adt/numeric.c:166">NUMERIC_NEG</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idivisor = -idivisor;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L9549" title="utils/adt/numeric.c:9549">div_var_int</a>(var1, idivisor, idivisor_weight, result, rscale, round);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#ifdef HAVE_INT128<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (var2ndigits &lt;= <span class="Constant">4</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; idivisor;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idivisor_weight;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; idivisor = var2-&gt;digits[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; idivisor_weight = var2-&gt;weight;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt; var2ndigits; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idivisor = idivisor * <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> + var2-&gt;digits[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idivisor_weight--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var2-&gt;sign == <a href="#L166" title="utils/adt/numeric.c:166">NUMERIC_NEG</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idivisor = -idivisor;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L9665" title="utils/adt/numeric.c:9665">div_var_int64</a>(var1, idivisor, idivisor_weight, result, rscale, round);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Otherwise, perform full long division.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Result zero check */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (var1ndigits == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6985" title="utils/adt/numeric.c:6985">zero_var</a>(result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;dscale = rscale;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine the result sign, weight and number of digits to calculate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The weight figured here is correct if the emitted quotient has no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * leading zero digits; otherwise <a href="#L11917" title="utils/adt/numeric.c:11917">strip_var</a>() will fix things up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (var1-&gt;sign == var2-&gt;sign)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res_sign = <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; res_sign = <a href="#L166" title="utils/adt/numeric.c:166">NUMERIC_NEG</a>;<br/></li>
<li>&nbsp; &nbsp; res_weight = var1-&gt;weight - var2-&gt;weight;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The number of accurate result digits we need to produce: */<br/></li>
<li></span>&nbsp; &nbsp; res_ndigits = res_weight + <span class="Constant">1</span> + (rscale + <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> - <span class="Constant">1</span>) / <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ... but always at least 1 */<br/></li>
<li></span>&nbsp; &nbsp; res_ndigits = Max(res_ndigits, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If rounding needed, figure one more digit to ensure correct result */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (round)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res_ndigits++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The working dividend normally requires res_ndigits + var2ndigits<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * digits, but make it at least var1ndigits so we can load all of var1<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * into it.&nbsp; (There will be an additional digit dividend[0] in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * dividend space, but for consistency with Knuth's notation we don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * count that in div_ndigits.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; div_ndigits = res_ndigits + var2ndigits;<br/></li>
<li>&nbsp; &nbsp; div_ndigits = Max(div_ndigits, var1ndigits);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need a workspace with room for the working dividend (div_ndigits+1<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * digits) plus room for the possibly-normalized divisor (var2ndigits<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * digits).&nbsp; It is convenient also to have a zero at divisor[0] with the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * actual divisor data in divisor[1 .. var2ndigits].&nbsp; Transferring the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * digits into the workspace also allows us to realloc the result (which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might be the same as either input var) <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we begin the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> loop.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that we use <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a> to ensure that divisor[0], dividend[0], and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> additional dividend positions beyond var1ndigits, start out 0.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; dividend = (<a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>((div_ndigits + var2ndigits + <span class="Constant">2</span>) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a>));<br/></li>
<li>&nbsp; &nbsp; divisor = dividend + (div_ndigits + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; memcpy(dividend + <span class="Constant">1</span>, var1-&gt;digits, var1ndigits * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a>));<br/></li>
<li>&nbsp; &nbsp; memcpy(divisor + <span class="Constant">1</span>, var2-&gt;digits, var2ndigits * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now we can realloc the result to hold the generated quotient digits.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L6953" title="utils/adt/numeric.c:6953">alloc_var</a>(result, res_ndigits);<br/></li>
<li>&nbsp; &nbsp; res_digits = result-&gt;digits;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The full multiple-place algorithm is taken from Knuth volume 2,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Algorithm 4.3.1D.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need the first divisor digit to be &gt;= <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>/2.&nbsp; If it isn't, make it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so by scaling up both the divisor and dividend by the factor &quot;d&quot;.&nbsp; (The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reason for allocating dividend[0] above is to leave room for possible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * carry here.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (divisor[<span class="Constant">1</span>] &lt; <a href="#L96" title="utils/adt/numeric.c:96">HALF_NBASE</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d = <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> / (divisor[<span class="Constant">1</span>] + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; carry = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = var2ndigits; i &gt; <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; carry += divisor[i] * d;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; divisor[i] = carry % <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; carry = carry / <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(carry == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; carry = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* at this point only var1ndigits of dividend can be nonzero */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = var1ndigits; i &gt;= <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; carry += dividend[i] * d;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dividend[i] = carry % <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; carry = carry / <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(carry == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(divisor[<span class="Constant">1</span>] &gt;= <a href="#L96" title="utils/adt/numeric.c:96">HALF_NBASE</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* First 2 divisor digits are used repeatedly in <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> loop */<br/></li>
<li></span>&nbsp; &nbsp; divisor1 = divisor[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; divisor2 = divisor[<span class="Constant">2</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Begin the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> loop.&nbsp; Each iteration of this loop produces the j'th<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * quotient digit by dividing dividend[j .. j + var2ndigits] by the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * divisor; this is essentially the same as the common manual procedure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for long division.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (j = <span class="Constant">0</span>; j &lt; res_ndigits; j++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Estimate quotient digit from the first two dividend digits */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; next2digits = dividend[j] * <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> + dividend[j + <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qhat;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If next2digits are 0, then quotient digit must be 0 and there's no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * need to adjust the working dividend.&nbsp; It's worth testing here to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fall out ASAP when processing trailing zeroes in a dividend.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (next2digits == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res_digits[j] = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dividend[j] == divisor1)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qhat = <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qhat = next2digits / divisor1;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Adjust quotient digit if it's too large.&nbsp; Knuth proves that after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this step, the quotient digit will be either correct or just one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * too large.&nbsp; (Note: it's OK to use dividend[j+2] here because we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * know the divisor length is at least 2.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (divisor2 * qhat &gt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (next2digits - qhat * divisor1) * <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> + dividend[j + <span class="Constant">2</span>])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qhat--;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* As above, need do nothing more when quotient digit is 0 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (qhat &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> *dividend_j = &amp;dividend[j];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Multiply the divisor by qhat, and subtract that from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * working dividend.&nbsp; The multiplication and subtraction are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * folded together here, noting that qhat &lt;= <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> (since it might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be one too large), and so the intermediate result &quot;tmp_result&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is in the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> [-<a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>^2, <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> - 1], and &quot;borrow&quot; is in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> [0, <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; borrow = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = var2ndigits; i &gt;= <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp_result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp_result = dividend_j[i] - borrow - divisor[i] * qhat;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; borrow = (<a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> - <span class="Constant">1</span> - tmp_result) / <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dividend_j[i] = tmp_result + borrow * <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we got a borrow out of the top dividend digit, then indeed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * qhat was one too large.&nbsp; Fix it, and add back the divisor to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * correct the working dividend.&nbsp; (Knuth proves that this will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * occur only about 3/<a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> of the time; hence, it's a good idea<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to test this code with small <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> to be sure this section gets<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * exercised.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (borrow)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qhat--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; carry = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = var2ndigits; i &gt;= <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; carry += dividend_j[i] + divisor[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (carry &gt;= <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dividend_j[i] = carry - <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; carry = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dividend_j[i] = carry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; carry = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* A carry should occur here to cancel the borrow above */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(carry == <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* And we're done with this quotient digit */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; res_digits[j] = qhat;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(dividend);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Finally, round or truncate the result to the requested precision.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; result-&gt;weight = res_weight;<br/></li>
<li>&nbsp; &nbsp; result-&gt;sign = res_sign;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Round or truncate to target rscale (and set result-&gt;dscale) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (round)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L11749" title="utils/adt/numeric.c:11749">round_var</a>(result, rscale);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L11855" title="utils/adt/numeric.c:11855">trunc_var</a>(result, rscale);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Strip leading and trailing zeroes */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L11917" title="utils/adt/numeric.c:11917">strip_var</a>(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L9185" title="utils/adt/numeric.c:9185">div_var_fast</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; This has the same API as <a href="#L8877" title="utils/adt/numeric.c:8877">div_var</a>, but is implemented using the division<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; algorithm from the &quot;FM&quot; library, rather than Knuth's schoolbook-division<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; approach.&nbsp; This is significantly faster but can produce inaccurate<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; results, because it sometimes has to propagate rounding to the left,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; and so we can never be entirely sure that we know the requested digits<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; exactly.&nbsp; We compute <a href="#L99" title="utils/adt/numeric.c:99">DIV_GUARD_DIGITS</a> extra digits, but there is<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; no certainty that that's enough.&nbsp; We use this only in the transcendental<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; function calculation routines, where everything is approximate anyway.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Although we provide a &quot;round&quot; argument for consistency with <a href="#L8877" title="utils/adt/numeric.c:8877">div_var</a>,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; it is unwise to use this function with round=false.&nbsp; In truncation mode<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; it is possible to get a result with no significant digits, for example<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; with rscale=0 we might compute 0.99999... and truncate that to 0 when<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; the correct answer is 1.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L9185">&#x200c;</a></span><span class="linkable">div_var_fast</span>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var1, <span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *result, <span class="Type">int</span> rscale, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> round)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; div_ndigits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; load_ndigits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res_sign;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res_weight;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *div;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qdigit;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; carry;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxdiv;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newdig;<br/></li>
<li>&nbsp; &nbsp; <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> *res_digits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; fdividend,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fdivisor,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fdivisorinverse,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fquotient;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qi;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* copy these <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> into local <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> for speed in inner loop */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var1ndigits = var1-&gt;ndigits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var2ndigits = var2-&gt;ndigits;<br/></li>
<li>&nbsp; &nbsp; <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> *var1digits = var1-&gt;digits;<br/></li>
<li>&nbsp; &nbsp; <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> *var2digits = var2-&gt;digits;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First of all division by zero check; we must not be handed an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unnormalized divisor.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (var2ndigits == <span class="Constant">0</span> || var2digits[<span class="Constant">0</span>] == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DIVISION_BY_ZERO),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;division by zero&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the divisor has just one or two digits, delegate to <a href="#L9549" title="utils/adt/numeric.c:9549">div_var_int</a>(),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which uses fast short division.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Similarly, on platforms with 128-<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> integer support, delegate to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L9665" title="utils/adt/numeric.c:9665">div_var_int64</a>() for divisors with three or four digits.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (var2ndigits &lt;= <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idivisor;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idivisor_weight;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; idivisor = var2-&gt;digits[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; idivisor_weight = var2-&gt;weight;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var2ndigits == <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idivisor = idivisor * <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> + var2-&gt;digits[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idivisor_weight--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var2-&gt;sign == <a href="#L166" title="utils/adt/numeric.c:166">NUMERIC_NEG</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idivisor = -idivisor;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L9549" title="utils/adt/numeric.c:9549">div_var_int</a>(var1, idivisor, idivisor_weight, result, rscale, round);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#ifdef HAVE_INT128<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (var2ndigits &lt;= <span class="Constant">4</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; idivisor;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idivisor_weight;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; idivisor = var2-&gt;digits[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; idivisor_weight = var2-&gt;weight;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt; var2ndigits; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idivisor = idivisor * <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> + var2-&gt;digits[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idivisor_weight--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var2-&gt;sign == <a href="#L166" title="utils/adt/numeric.c:166">NUMERIC_NEG</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idivisor = -idivisor;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L9665" title="utils/adt/numeric.c:9665">div_var_int64</a>(var1, idivisor, idivisor_weight, result, rscale, round);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Otherwise, perform full long division.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Result zero check */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (var1ndigits == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6985" title="utils/adt/numeric.c:6985">zero_var</a>(result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;dscale = rscale;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine the result sign, weight and number of digits to calculate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (var1-&gt;sign == var2-&gt;sign)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res_sign = <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; res_sign = <a href="#L166" title="utils/adt/numeric.c:166">NUMERIC_NEG</a>;<br/></li>
<li>&nbsp; &nbsp; res_weight = var1-&gt;weight - var2-&gt;weight + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The number of accurate result digits we need to produce: */<br/></li>
<li></span>&nbsp; &nbsp; div_ndigits = res_weight + <span class="Constant">1</span> + (rscale + <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> - <span class="Constant">1</span>) / <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Add guard digits for roundoff error */<br/></li>
<li></span>&nbsp; &nbsp; div_ndigits += <a href="#L99" title="utils/adt/numeric.c:99">DIV_GUARD_DIGITS</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (div_ndigits &lt; <a href="#L99" title="utils/adt/numeric.c:99">DIV_GUARD_DIGITS</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; div_ndigits = <a href="#L99" title="utils/adt/numeric.c:99">DIV_GUARD_DIGITS</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We do the arithmetic in an array &quot;div[]&quot; of signed int's.&nbsp; Since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * INT_MAX is noticeably larger than <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>*<a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>, this gives us headroom<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to avoid normalizing carries immediately.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We start with div[] containing one zero digit followed by the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * dividend's digits (plus appended zeroes to reach the desired precision<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * including guard digits).&nbsp; Each step of the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> loop computes an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (approximate) quotient digit and stores it into div[], removing one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * position of dividend space.&nbsp; A final pass of carry propagation takes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * care of <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> mistaken quotient digits.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that div[] doesn't necessarily contain all of the digits from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * dividend --- the desired precision plus guard digits might be less than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the dividend's precision.&nbsp; This happens, for example, in the square<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * root algorithm, where we typically divide a 2N-digit number by an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * N-digit number, and only require a result with N digits of precision.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; div = (<span class="Type">int</span> *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>((div_ndigits + <span class="Constant">1</span>) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; load_ndigits = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(div_ndigits, var1ndigits);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; load_ndigits; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; div[i + <span class="Constant">1</span>] = var1digits[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We estimate each quotient digit using floating-point arithmetic, taking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the first four digits of the (current) dividend and divisor.&nbsp; This must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be float to avoid overflow.&nbsp; The quotient digits will generally be off<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * by no more than one from the exact answer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; fdivisor = (<span class="Type">double</span>) var2digits[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt; <span class="Constant">4</span>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fdivisor *= <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &lt; var2ndigits)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fdivisor += (<span class="Type">double</span>) var2digits[i];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; fdivisorinverse = <span class="Constant">1.0</span> / fdivisor;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * maxdiv tracks the maximum possible absolute value of <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> div[] entry;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * when this threatens to exceed INT_MAX, we take the time to propagate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * carries.&nbsp; Furthermore, we need to ensure that overflow doesn't occur<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * during the carry propagation passes either.&nbsp; The carry <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> may have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * an absolute value as high as INT_MAX/<a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> + 1, so really we must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * normalize when digits threaten to exceed INT_MAX - INT_MAX/<a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> - 1.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * To avoid overflow in maxdiv itself, it represents the max absolute<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * value divided by <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>-1, ie, at the top of the loop it is known that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * no div[] entry has an absolute value exceeding maxdiv * (<a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>-1).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Actually, though, that holds good only for div[] entries after div[qi];<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the adjustment done at the bottom of the loop may cause div[qi + 1] to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exceed the maxdiv limit, so that div[qi] in the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> iteration is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * beyond the limit.&nbsp; This does not cause problems, as explained below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; maxdiv = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Outer loop computes <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> quotient digit, which will go into div[qi]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (qi = <span class="Constant">0</span>; qi &lt; div_ndigits; qi++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Approximate the current dividend value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; fdividend = (<span class="Type">double</span>) div[qi];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt; <span class="Constant">4</span>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fdividend *= <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (qi + i &lt;= div_ndigits)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fdividend += (<span class="Type">double</span>) div[qi + i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Compute the (approximate) quotient digit */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; fquotient = fdividend * fdivisorinverse;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qdigit = (fquotient &gt;= <span class="Constant">0.0</span>) ? ((<span class="Type">int</span>) fquotient) :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (((<span class="Type">int</span>) fquotient) - <span class="Constant">1</span>);&nbsp; &nbsp; <span class="Comment">/* truncate towards -infinity */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (qdigit != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Do we need to normalize <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxdiv += abs(qdigit);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (maxdiv &gt; (<span class="Constant">INT_MAX</span> - <span class="Constant">INT_MAX</span> / <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> - <span class="Constant">1</span>) / (<a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> - <span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Yes, do it.&nbsp; Note that if var2ndigits is much smaller than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * div_ndigits, we can save a significant amount of effort<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * here by noting that we only need to normalise those div[]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entries touched where prior iterations subtracted multiples<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of the divisor.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; carry = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(qi + var2ndigits - <span class="Constant">2</span>, div_ndigits); i &gt; qi; i--)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newdig = div[i] + carry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newdig &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; carry = -((-newdig - <span class="Constant">1</span>) / <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>) - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newdig -= carry * <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (newdig &gt;= <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; carry = newdig / <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newdig -= carry * <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; carry = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; div[i] = newdig;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newdig = div[qi] + carry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; div[qi] = newdig;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * All the div[] digits except possibly div[qi] are <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> 0..<a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>-1.&nbsp; We do not need to consider div[qi] in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the maxdiv value anymore, so we can reset maxdiv to 1.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxdiv = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Recompute the quotient digit since new info may have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * propagated into the top four dividend digits<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fdividend = (<span class="Type">double</span>) div[qi];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt; <span class="Constant">4</span>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fdividend *= <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (qi + i &lt;= div_ndigits)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fdividend += (<span class="Type">double</span>) div[qi + i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Compute the (approximate) quotient digit */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fquotient = fdividend * fdivisorinverse;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qdigit = (fquotient &gt;= <span class="Constant">0.0</span>) ? ((<span class="Type">int</span>) fquotient) :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (((<span class="Type">int</span>) fquotient) - <span class="Constant">1</span>);&nbsp; &nbsp; <span class="Comment">/* truncate towards -infinity */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxdiv += abs(qdigit);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Subtract off the appropriate multiple of the divisor.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The digits beyond div[qi] cannot overflow, because we know they<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will fall within the maxdiv limit.&nbsp; As for div[qi] itself, note<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that qdigit is approximately trunc(div[qi] / vardigits[0]),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * which would make the new value simply div[qi] mod vardigits[0].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-order terms in qdigit can change this result by not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * more than about twice INT_MAX/<a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>, so overflow is impossible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This inner loop is the performance bottleneck for division, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * code it in the same way as the inner loop of <a href="#L8669" title="utils/adt/numeric.c:8669">mul_var</a>() so that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it can be auto-vectorized.&nbsp; We cast qdigit to <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> multiplying to allow the compiler to generate more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * efficient code (using 16-<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> multiplication), which is safe<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * since we know that the quotient digit is off by at most one, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there is no overflow risk.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (qdigit != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; istop = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(var2ndigits, div_ndigits - qi + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *div_qi = &amp;div[qi];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; istop; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; div_qi[i] -= ((<a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a>) qdigit) * var2digits[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The dividend digit we are about to replace might still be nonzero.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Fold it into the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> digit position.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There is no risk of overflow here, although proving that requires<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * some care.&nbsp; Much as with the argument for div[qi] not overflowing,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if we consider the first two terms in the numerator and denominator<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of qdigit, we can see that the final value of div[qi + 1] will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * approximately a remainder mod (vardigits[0]*<a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> + vardigits[1]).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Accounting for the <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-order terms is a <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> complicated but ends<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * up adding not much more than INT_MAX/<a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> to the possible <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Thus, div[qi + 1] cannot overflow here, and in its role as div[qi]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> loop iteration, it can't be large enough to cause<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * overflow in the carry propagation step (if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>), either.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * But having said that: div[qi] can be more than INT_MAX/<a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>, as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * noted above, which means that the product div[qi] * <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> *can*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * overflow.&nbsp; When that happens, adding it to div[qi + 1] will always<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cause a canceling overflow so that the end result is correct.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * could avoid the intermediate overflow by doing the multiplication<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and addition in int64 arithmetic, but so far there appears no need.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; div[qi + <span class="Constant">1</span>] += div[qi] * <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; div[qi] = qdigit;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Approximate and store the last quotient digit (div[div_ndigits])<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; fdividend = (<span class="Type">double</span>) div[qi];<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt; <span class="Constant">4</span>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fdividend *= <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>;<br/></li>
<li>&nbsp; &nbsp; fquotient = fdividend * fdivisorinverse;<br/></li>
<li>&nbsp; &nbsp; qdigit = (fquotient &gt;= <span class="Constant">0.0</span>) ? ((<span class="Type">int</span>) fquotient) :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (((<span class="Type">int</span>) fquotient) - <span class="Constant">1</span>);&nbsp; &nbsp; <span class="Comment">/* truncate towards -infinity */<br/></li>
<li></span>&nbsp; &nbsp; div[qi] = qdigit;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Because the quotient digits might be off by one, some of them might be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * -1 or <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> at this point.&nbsp; The represented value is correct in a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * mathematical sense, but it doesn't look right.&nbsp; We do a final carry<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * propagation pass to normalize the digits, which we <a href="../../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> with storing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the result digits into the output.&nbsp; Note that this is still done at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * full precision w/guard digits.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L6953" title="utils/adt/numeric.c:6953">alloc_var</a>(result, div_ndigits + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; res_digits = result-&gt;digits;<br/></li>
<li>&nbsp; &nbsp; carry = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = div_ndigits; i &gt;= <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newdig = div[i] + carry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newdig &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; carry = -((-newdig - <span class="Constant">1</span>) / <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>) - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newdig -= carry * <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (newdig &gt;= <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; carry = newdig / <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newdig -= carry * <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; carry = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res_digits[i] = newdig;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; Assert(carry == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(div);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Finally, round the result to the requested precision.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; result-&gt;weight = res_weight;<br/></li>
<li>&nbsp; &nbsp; result-&gt;sign = res_sign;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Round to target rscale (and set result-&gt;dscale) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (round)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L11749" title="utils/adt/numeric.c:11749">round_var</a>(result, rscale);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L11855" title="utils/adt/numeric.c:11855">trunc_var</a>(result, rscale);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Strip leading and trailing zeroes */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L11917" title="utils/adt/numeric.c:11917">strip_var</a>(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L9549" title="utils/adt/numeric.c:9549">div_var_int</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Divide a <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> variable by a 32-<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> integer with the specified weight.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; The quotient var / (ival * <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>^ival_weight) is stored in result.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L9549">&#x200c;</a></span><span class="linkable">div_var_int</span>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var, <span class="Type">int</span> ival, <span class="Type">int</span> ival_weight,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *result, <span class="Type">int</span> rscale, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> round)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> *var_digits = var-&gt;digits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var_ndigits = var-&gt;ndigits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res_sign;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res_weight;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res_ndigits;<br/></li>
<li>&nbsp; &nbsp; <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> *res_buf;<br/></li>
<li>&nbsp; &nbsp; <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> *res_digits;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; divisor;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Guard against division by zero */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ival == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DIVISION_BY_ZERO),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;division by zero&quot;</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Result zero check */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (var_ndigits == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6985" title="utils/adt/numeric.c:6985">zero_var</a>(result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;dscale = rscale;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine the result sign, weight and number of digits to calculate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The weight figured here is correct if the emitted quotient has no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * leading zero digits; otherwise <a href="#L11917" title="utils/adt/numeric.c:11917">strip_var</a>() will fix things up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;sign == <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res_sign = ival &gt; <span class="Constant">0</span> ? <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a> : <a href="#L166" title="utils/adt/numeric.c:166">NUMERIC_NEG</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; res_sign = ival &gt; <span class="Constant">0</span> ? <a href="#L166" title="utils/adt/numeric.c:166">NUMERIC_NEG</a> : <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a>;<br/></li>
<li>&nbsp; &nbsp; res_weight = var-&gt;weight - ival_weight;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The number of accurate result digits we need to produce: */<br/></li>
<li></span>&nbsp; &nbsp; res_ndigits = res_weight + <span class="Constant">1</span> + (rscale + <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> - <span class="Constant">1</span>) / <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ... but always at least 1 */<br/></li>
<li></span>&nbsp; &nbsp; res_ndigits = Max(res_ndigits, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If rounding needed, figure one more digit to ensure correct result */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (round)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res_ndigits++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res_buf = <a href="#L476" title="utils/adt/numeric.c:476">digitbuf_alloc</a>(res_ndigits + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; res_buf[<span class="Constant">0</span>] = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* spare digit for later rounding */<br/></li>
<li></span>&nbsp; &nbsp; res_digits = res_buf + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now compute the quotient digits.&nbsp; This is the short division algorithm<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * described in Knuth volume 2, section 4.3.1 exercise 16, except that we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allow the divisor to exceed the <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> base.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In this algorithm, the carry from one digit to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> is at most<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * divisor - 1.&nbsp; Therefore, while processing the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> digit, carry may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * become as large as divisor * <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> - 1, and so it requires a 64-<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * integer if this exceeds UINT_MAX.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; divisor = abs(ival);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (divisor &lt;= <span class="Constant">UINT_MAX</span> / <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* carry cannot overflow 32 bits */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; carry = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; res_ndigits; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; carry = carry * <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> + (i &lt; var_ndigits ? var_digits[i] : <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res_digits[i] = (<a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a>) (carry / divisor);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; carry = carry % divisor;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* carry may exceed 32 bits */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; carry = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; res_ndigits; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; carry = carry * <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> + (i &lt; var_ndigits ? var_digits[i] : <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res_digits[i] = (<a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a>) (carry / divisor);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; carry = carry % divisor;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Store the quotient in result */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L478" title="utils/adt/numeric.c:478">digitbuf_free</a>(result-&gt;buf);<br/></li>
<li>&nbsp; &nbsp; result-&gt;ndigits = res_ndigits;<br/></li>
<li>&nbsp; &nbsp; result-&gt;buf = res_buf;<br/></li>
<li>&nbsp; &nbsp; result-&gt;digits = res_digits;<br/></li>
<li>&nbsp; &nbsp; result-&gt;weight = res_weight;<br/></li>
<li>&nbsp; &nbsp; result-&gt;sign = res_sign;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Round or truncate to target rscale (and set result-&gt;dscale) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (round)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L11749" title="utils/adt/numeric.c:11749">round_var</a>(result, rscale);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L11855" title="utils/adt/numeric.c:11855">trunc_var</a>(result, rscale);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Strip leading/trailing zeroes */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L11917" title="utils/adt/numeric.c:11917">strip_var</a>(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef HAVE_INT128<br/></li>
<li></span><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L9665" title="utils/adt/numeric.c:9665">div_var_int64</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Divide a <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> variable by a 64-<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> integer with the specified weight.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; The quotient var / (ival * <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>^ival_weight) is stored in result.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; This duplicates the logic in <a href="#L9549" title="utils/adt/numeric.c:9549">div_var_int</a>(), so <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> changes made there<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; should be made here too.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L9665">&#x200c;</a></span><span class="linkable">div_var_int64</span>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var, int64 ival, <span class="Type">int</span> ival_weight,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *result, <span class="Type">int</span> rscale, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> round)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> *var_digits = var-&gt;digits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var_ndigits = var-&gt;ndigits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res_sign;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res_weight;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res_ndigits;<br/></li>
<li>&nbsp; &nbsp; <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> *res_buf;<br/></li>
<li>&nbsp; &nbsp; <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> *res_digits;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; divisor;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Guard against division by zero */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ival == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DIVISION_BY_ZERO),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;division by zero&quot;</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Result zero check */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (var_ndigits == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6985" title="utils/adt/numeric.c:6985">zero_var</a>(result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;dscale = rscale;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine the result sign, weight and number of digits to calculate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The weight figured here is correct if the emitted quotient has no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * leading zero digits; otherwise <a href="#L11917" title="utils/adt/numeric.c:11917">strip_var</a>() will fix things up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;sign == <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res_sign = ival &gt; <span class="Constant">0</span> ? <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a> : <a href="#L166" title="utils/adt/numeric.c:166">NUMERIC_NEG</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; res_sign = ival &gt; <span class="Constant">0</span> ? <a href="#L166" title="utils/adt/numeric.c:166">NUMERIC_NEG</a> : <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a>;<br/></li>
<li>&nbsp; &nbsp; res_weight = var-&gt;weight - ival_weight;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The number of accurate result digits we need to produce: */<br/></li>
<li></span>&nbsp; &nbsp; res_ndigits = res_weight + <span class="Constant">1</span> + (rscale + <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> - <span class="Constant">1</span>) / <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ... but always at least 1 */<br/></li>
<li></span>&nbsp; &nbsp; res_ndigits = Max(res_ndigits, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If rounding needed, figure one more digit to ensure correct result */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (round)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res_ndigits++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res_buf = <a href="#L476" title="utils/adt/numeric.c:476">digitbuf_alloc</a>(res_ndigits + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; res_buf[<span class="Constant">0</span>] = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* spare digit for later rounding */<br/></li>
<li></span>&nbsp; &nbsp; res_digits = res_buf + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now compute the quotient digits.&nbsp; This is the short division algorithm<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * described in Knuth volume 2, section 4.3.1 exercise 16, except that we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allow the divisor to exceed the <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> base.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In this algorithm, the carry from one digit to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> is at most<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * divisor - 1.&nbsp; Therefore, while processing the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> digit, carry may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * become as large as divisor * <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> - 1, and so it requires a 128-<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * integer if this exceeds PG_UINT64_MAX.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; divisor = i64abs(ival);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (divisor &lt;= PG_UINT64_MAX / <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* carry cannot overflow 64 bits */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; carry = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; res_ndigits; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; carry = carry * <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> + (i &lt; var_ndigits ? var_digits[i] : <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res_digits[i] = (<a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a>) (carry / divisor);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; carry = carry % divisor;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* carry may exceed 64 bits */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; uint128&nbsp; &nbsp; &nbsp; &nbsp; carry = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; res_ndigits; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; carry = carry * <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> + (i &lt; var_ndigits ? var_digits[i] : <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res_digits[i] = (<a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a>) (carry / divisor);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; carry = carry % divisor;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Store the quotient in result */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L478" title="utils/adt/numeric.c:478">digitbuf_free</a>(result-&gt;buf);<br/></li>
<li>&nbsp; &nbsp; result-&gt;ndigits = res_ndigits;<br/></li>
<li>&nbsp; &nbsp; result-&gt;buf = res_buf;<br/></li>
<li>&nbsp; &nbsp; result-&gt;digits = res_digits;<br/></li>
<li>&nbsp; &nbsp; result-&gt;weight = res_weight;<br/></li>
<li>&nbsp; &nbsp; result-&gt;sign = res_sign;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Round or truncate to target rscale (and set result-&gt;dscale) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (round)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L11749" title="utils/adt/numeric.c:11749">round_var</a>(result, rscale);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L11855" title="utils/adt/numeric.c:11855">trunc_var</a>(result, rscale);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Strip leading/trailing zeroes */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L11917" title="utils/adt/numeric.c:11917">strip_var</a>(result);<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Default scale selection for division<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the appropriate result scale for the division result.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L9777">&#x200c;</a></span><span class="linkable">select_div_scale</span>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var1, <span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; weight1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; weight2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qweight,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> firstdigit1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; firstdigit2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rscale;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The result scale of a division isn't specified in <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> SQL standard. For<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * PostgreSQL we <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> a result scale that will give at least<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NUMERIC_MIN_SIG_DIGITS significant digits, so that <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> gives a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * result no less accurate than float8; but use a scale not less than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * either input's display scale.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get the actual (normalized) weight and first digit of each input */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; weight1 = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to use if var1 is zero */<br/></li>
<li></span>&nbsp; &nbsp; firstdigit1 = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; var1-&gt;ndigits; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; firstdigit1 = var1-&gt;digits[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (firstdigit1 != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; weight1 = var1-&gt;weight - i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; weight2 = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to use if var2 is zero */<br/></li>
<li></span>&nbsp; &nbsp; firstdigit2 = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; var2-&gt;ndigits; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; firstdigit2 = var2-&gt;digits[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (firstdigit2 != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; weight2 = var2-&gt;weight - i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Estimate weight of quotient.&nbsp; If the two first digits are <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can't be sure, but assume that var1 is less than var2.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; qweight = weight1 - weight2;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (firstdigit1 &lt;= firstdigit2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qweight--;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Select result scale */<br/></li>
<li></span>&nbsp; &nbsp; rscale = NUMERIC_MIN_SIG_DIGITS - qweight * <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a>;<br/></li>
<li>&nbsp; &nbsp; rscale = Max(rscale, var1-&gt;dscale);<br/></li>
<li>&nbsp; &nbsp; rscale = Max(rscale, var2-&gt;dscale);<br/></li>
<li>&nbsp; &nbsp; rscale = Max(rscale, NUMERIC_MIN_DISPLAY_SCALE);<br/></li>
<li>&nbsp; &nbsp; rscale = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(rscale, NUMERIC_MAX_DISPLAY_SCALE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> rscale;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L9846" title="utils/adt/numeric.c:9846">mod_var</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Calculate the modulo of two numerics at variable level<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L9846">&#x200c;</a></span><span class="linkable">mod_var</span>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var1, <span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var2, <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *result)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; tmp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;tmp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ---------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We do this using the equation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; mod(x,y) = x - trunc(x/y)*y<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L8877" title="utils/adt/numeric.c:8877">div_var</a> can be persuaded to give us trunc(x/y) directly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L8877" title="utils/adt/numeric.c:8877">div_var</a>(var1, var2, &amp;tmp, <span class="Constant">0</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L8669" title="utils/adt/numeric.c:8669">mul_var</a>(var2, &amp;tmp, &amp;tmp, var2-&gt;dscale);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L8548" title="utils/adt/numeric.c:8548">sub_var</a>(var1, &amp;tmp, result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;tmp);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L9875" title="utils/adt/numeric.c:9875">div_mod_var</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Calculate the truncated integer quotient and <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> remainder of two<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> variables.&nbsp; The remainder is precise to var2's dscale.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L9875">&#x200c;</a></span><span class="linkable">div_mod_var</span>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var1, <span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *quot, <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *rem)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; q;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; r;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;q);<br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;r);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Use <a href="#L9185" title="utils/adt/numeric.c:9185">div_var_fast</a>() to get an initial estimate for the integer quotient.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This might be inaccurate (per the warning in <a href="#L9185" title="utils/adt/numeric.c:9185">div_var_fast</a>'s comments),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but we can correct it below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L9185" title="utils/adt/numeric.c:9185">div_var_fast</a>(var1, var2, &amp;q, <span class="Constant">0</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Compute initial estimate of remainder using the quotient estimate. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L8669" title="utils/adt/numeric.c:8669">mul_var</a>(var2, &amp;q, &amp;r, var2-&gt;dscale);<br/></li>
<li>&nbsp; &nbsp; <a href="#L8548" title="utils/adt/numeric.c:8548">sub_var</a>(var1, &amp;r, &amp;r);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Adjust the results if necessary --- the remainder should have the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sign as var1, and its absolute value should be less than the absolute<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * value of var2.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (r.ndigits != <span class="Constant">0</span> &amp;&amp; r.sign != var1-&gt;sign)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The absolute value of the quotient is too large */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var1-&gt;sign == var2-&gt;sign)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8548" title="utils/adt/numeric.c:8548">sub_var</a>(&amp;q, &amp;<a href="#L419" title="utils/adt/numeric.c:419">const_one</a>, &amp;q);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8431" title="utils/adt/numeric.c:8431">add_var</a>(&amp;r, var2, &amp;r);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8431" title="utils/adt/numeric.c:8431">add_var</a>(&amp;q, &amp;<a href="#L419" title="utils/adt/numeric.c:419">const_one</a>, &amp;q);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8548" title="utils/adt/numeric.c:8548">sub_var</a>(&amp;r, var2, &amp;r);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="#L11504" title="utils/adt/numeric.c:11504">cmp_abs</a>(&amp;r, var2) &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The absolute value of the quotient is too small */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var1-&gt;sign == var2-&gt;sign)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8431" title="utils/adt/numeric.c:8431">add_var</a>(&amp;q, &amp;<a href="#L419" title="utils/adt/numeric.c:419">const_one</a>, &amp;q);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8548" title="utils/adt/numeric.c:8548">sub_var</a>(&amp;r, var2, &amp;r);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8548" title="utils/adt/numeric.c:8548">sub_var</a>(&amp;q, &amp;<a href="#L419" title="utils/adt/numeric.c:419">const_one</a>, &amp;q);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8431" title="utils/adt/numeric.c:8431">add_var</a>(&amp;r, var2, &amp;r);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L7468" title="utils/adt/numeric.c:7468">set_var_from_var</a>(&amp;q, quot);<br/></li>
<li>&nbsp; &nbsp; <a href="#L7468" title="utils/adt/numeric.c:7468">set_var_from_var</a>(&amp;r, rem);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;q);<br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;r);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L9945" title="utils/adt/numeric.c:9945">ceil_var</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Return the smallest integer greater than or <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to the argument<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; on variable level<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L9945">&#x200c;</a></span><span class="linkable">ceil_var</span>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var, <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *result)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; tmp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;tmp);<br/></li>
<li>&nbsp; &nbsp; <a href="#L7468" title="utils/adt/numeric.c:7468">set_var_from_var</a>(var, &amp;tmp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L11855" title="utils/adt/numeric.c:11855">trunc_var</a>(&amp;tmp, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;sign == <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a> &amp;&amp; <a href="#L8373" title="utils/adt/numeric.c:8373">cmp_var</a>(var, &amp;tmp) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8431" title="utils/adt/numeric.c:8431">add_var</a>(&amp;tmp, &amp;<a href="#L419" title="utils/adt/numeric.c:419">const_one</a>, &amp;tmp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L7468" title="utils/adt/numeric.c:7468">set_var_from_var</a>(&amp;tmp, result);<br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;tmp);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L9969" title="utils/adt/numeric.c:9969">floor_var</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Return the largest integer <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to or less than the argument<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; on variable level<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L9969">&#x200c;</a></span><span class="linkable">floor_var</span>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var, <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *result)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; tmp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;tmp);<br/></li>
<li>&nbsp; &nbsp; <a href="#L7468" title="utils/adt/numeric.c:7468">set_var_from_var</a>(var, &amp;tmp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L11855" title="utils/adt/numeric.c:11855">trunc_var</a>(&amp;tmp, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;sign == <a href="#L166" title="utils/adt/numeric.c:166">NUMERIC_NEG</a> &amp;&amp; <a href="#L8373" title="utils/adt/numeric.c:8373">cmp_var</a>(var, &amp;tmp) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8548" title="utils/adt/numeric.c:8548">sub_var</a>(&amp;tmp, &amp;<a href="#L419" title="utils/adt/numeric.c:419">const_one</a>, &amp;tmp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L7468" title="utils/adt/numeric.c:7468">set_var_from_var</a>(&amp;tmp, result);<br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;tmp);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L9992" title="utils/adt/numeric.c:9992">gcd_var</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Calculate the greatest common divisor of two numerics at variable level<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L9992">&#x200c;</a></span><span class="linkable">gcd_var</span>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var1, <span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var2, <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *result)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res_dscale;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; tmp_arg;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; mod;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res_dscale = Max(var1-&gt;dscale, var2-&gt;dscale);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Arrange for var1 to be the number with the greater absolute value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This would happen automatically in the loop below, but avoids an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * expensive modulo operation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = <a href="#L11504" title="utils/adt/numeric.c:11504">cmp_abs</a>(var1, var2);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *tmp = var1;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; var1 = var2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; var2 = tmp;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also avoid the taking the modulo if the inputs have the same absolute<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * value, or if the smaller input is zero.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> == <span class="Constant">0</span> || var2-&gt;ndigits == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7468" title="utils/adt/numeric.c:7468">set_var_from_var</a>(var1, result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;sign = <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;dscale = res_dscale;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;tmp_arg);<br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;mod);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Use the Euclidean algorithm to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the GCD */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L7468" title="utils/adt/numeric.c:7468">set_var_from_var</a>(var1, &amp;tmp_arg);<br/></li>
<li>&nbsp; &nbsp; <a href="#L7468" title="utils/adt/numeric.c:7468">set_var_from_var</a>(var2, result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* this loop can take a while, so allow it to be interrupted */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L9846" title="utils/adt/numeric.c:9846">mod_var</a>(&amp;tmp_arg, result, &amp;mod);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (mod.ndigits == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7468" title="utils/adt/numeric.c:7468">set_var_from_var</a>(result, &amp;tmp_arg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7468" title="utils/adt/numeric.c:7468">set_var_from_var</a>(&amp;mod, result);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; result-&gt;sign = <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a>;<br/></li>
<li>&nbsp; &nbsp; result-&gt;dscale = res_dscale;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;tmp_arg);<br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;mod);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L10062" title="utils/adt/numeric.c:10062">sqrt_var</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Compute the square root of x using the Karatsuba Square Root algorithm.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: we allow rscale &lt; 0 here, implying rounding <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the decimal<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; point.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L10062">&#x200c;</a></span><span class="linkable">sqrt_var</span>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *arg, <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *result, <span class="Type">int</span> rscale)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stat;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res_weight;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res_ndigits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; src_ndigits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; step;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndigits[<span class="Constant">32</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blen;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; arg_int64;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; src_idx;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; s_int64;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; r_int64;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; s_var;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; r_var;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; a0_var;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; a1_var;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; q_var;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; u_var;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; stat = <a href="#L8373" title="utils/adt/numeric.c:8373">cmp_var</a>(arg, &amp;<a href="#L415" title="utils/adt/numeric.c:415">const_zero</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (stat == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6985" title="utils/adt/numeric.c:6985">zero_var</a>(result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;dscale = rscale;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * SQL2003 defines sqrt() in terms of power, so we need to emit the right<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * SQLSTATE error code if the operand is negative.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stat &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_ARGUMENT_FOR_POWER_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot take square root of a negative number&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;s_var);<br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;r_var);<br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;a0_var);<br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;a1_var);<br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;q_var);<br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;u_var);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The result weight is half the input weight, rounded towards minus<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * infinity --- res_weight = floor(arg-&gt;weight / 2).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (arg-&gt;weight &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res_weight = arg-&gt;weight / <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; res_weight = -((-arg-&gt;weight - <span class="Constant">1</span>) / <span class="Constant">2</span> + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Number of <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> digits to compute.&nbsp; To ensure correct rounding, compute<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * at least 1 extra decimal digit.&nbsp; We explicitly allow rscale to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * negative here, but must always compute at least 1 <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> digit.&nbsp; Thus<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * res_ndigits = res_weight + 1 + ceil((rscale + 1) / <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a>) or 1.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rscale + <span class="Constant">1</span> &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res_ndigits = res_weight + <span class="Constant">1</span> + (rscale + <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a>) / <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; res_ndigits = res_weight + <span class="Constant">1</span> - (-rscale - <span class="Constant">1</span>) / <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a>;<br/></li>
<li>&nbsp; &nbsp; res_ndigits = Max(res_ndigits, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Number of source <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> digits logically required to produce a result<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with this precision --- every digit <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the decimal point, plus 2<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for each result digit after the decimal point (or minus 2 for each<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * result digit we round <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the decimal point).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; src_ndigits = arg-&gt;weight + <span class="Constant">1</span> + (res_ndigits - res_weight - <span class="Constant">1</span>) * <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; src_ndigits = Max(src_ndigits, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * From this point on, we treat the input and the result as integers and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * compute the integer square root and remainder using the Karatsuba<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Square Root algorithm, which may be written recursively as follows:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; SqrtRem(n = <a href="../../catalog/heap.c.html#L170" title="catalog/heap.c:170">a3</a>*b^3 + <a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>*b^2 + <a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>*b + a0):<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; [ for some base b, and coefficients a0,<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>,<a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>,<a href="../../catalog/heap.c.html#L170" title="catalog/heap.c:170">a3</a> chosen so that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 &lt;= a0,<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>,<a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a> &lt; b and <a href="../../catalog/heap.c.html#L170" title="catalog/heap.c:170">a3</a> &gt;= b/4 ]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; Let (s,r) = SqrtRem(<a href="../../catalog/heap.c.html#L170" title="catalog/heap.c:170">a3</a>*b + <a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; Let (q,u) = DivRem(r*b + <a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>, 2*s)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; Let s = s*b + q<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; Let r = u*b + a0 - q^2<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; If r &lt; 0 Then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Let r = r + s<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Let s = s - 1<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Let r = r + s<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; Return (s,r)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * See &quot;Karatsuba Square Root&quot;, Paul Zimmermann, INRIA Research Report<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * RR-3805, November 1999.&nbsp; At the time of writing this was available<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on the net at &lt;https://hal.inria.fr/inria-00072854&gt;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The way to read the assumption &quot;n = <a href="../../catalog/heap.c.html#L170" title="catalog/heap.c:170">a3</a>*b^3 + <a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>*b^2 + <a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>*b + a0&quot; is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &quot;choose a base b such that n requires at least four base-b digits to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * express; then those digits are <a href="../../catalog/heap.c.html#L170" title="catalog/heap.c:170">a3</a>,<a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>,<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>,a0, with <a href="../../catalog/heap.c.html#L170" title="catalog/heap.c:170">a3</a> possibly larger<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * than b&quot;.&nbsp; For optimal performance, b should have approximately a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * quarter the number of digits in the input, so that the outer square<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * root computes roughly twice as many digits as the inner one.&nbsp; For<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * simplicity, we choose b = <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>^blen, an integer power of <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We implement the algorithm iteratively rather than recursively, to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allow the working variables to be reused.&nbsp; With this approach, each<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * digit of the input is read precisely once --- src_idx tracks the number<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of input digits used so far.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The array ndigits[] holds the number of <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> digits of the input that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will have been used at the end of each iteration, which roughly doubles<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * each time.&nbsp; Note that the array elements are stored in reverse order,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so if the final iteration requires src_ndigits = 37 input digits, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * array will contain [37,19,11,7,5,3], and we would start by computing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the square root of the 3 most significant <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> digits.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In each iteration, we choose blen to be the largest integer for which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the input number has <a href="../../catalog/heap.c.html#L170" title="catalog/heap.c:170">a3</a> &gt;= b/4, when written in the form above.&nbsp; In<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * general, this means blen = src_ndigits / 4 (truncated), but if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * src_ndigits is a multiple of 4, that might lead to the coefficient <a href="../../catalog/heap.c.html#L170" title="catalog/heap.c:170">a3</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * being less than b/4 (if the first input digit is less than <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>/4), in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which case we choose blen = src_ndigits / 4 - 1.&nbsp; The number of digits<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in the inner square root is then src_ndigits - 2*blen.&nbsp; So, for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * example, if we have src_ndigits = 26 initially, the array ndigits[]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will be either [26,14,8,4] or [26,14,8,6,4], depending on the size of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the first input digit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Additionally, we can put an <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound on the number of steps required<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as follows --- suppose that the number of source digits is an n-<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * number in the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> [2^(n-1), 2^n-1], then blen will be in the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * [2^(n-3)-1, 2^(n-2)-1] and the number of digits in the inner square<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * root will be in the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> [2^(n-2), 2^(n-1)+1].&nbsp; In the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> step, blen<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will be in the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> [2^(n-4)-1, 2^(n-3)] and the number of digits in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> inner square root will be in the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> [2^(n-3), 2^(n-2)+1].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This pattern repeats, and in the worst case the array ndigits[] will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * contain [2^n-1, 2^(n-1)+1, 2^(n-2)+1, ... 9, 5, 3], and the computation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will require n steps.&nbsp; Therefore, since all digit array sizes are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * signed 32-<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> integers, the number of steps required is guaranteed to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be less than 32.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; step = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((ndigits[step] = src_ndigits) &gt; <span class="Constant">4</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Choose b so that <a href="../../catalog/heap.c.html#L170" title="catalog/heap.c:170">a3</a> &gt;= b/4, as described above */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; blen = src_ndigits / <span class="Constant">4</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (blen * <span class="Constant">4</span> == src_ndigits &amp;&amp; arg-&gt;digits[<span class="Constant">0</span>] &lt; <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> / <span class="Constant">4</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blen--;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Number of digits in the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> step (inner square root) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; src_ndigits -= <span class="Constant">2</span> * blen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; step++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First iteration (innermost square root and remainder):<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Here src_ndigits &lt;= 4, and the input fits in an int64.&nbsp; Its square root<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * has at most 9 decimal digits, so estimate it using double precision<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * arithmetic, which will in fact almost certainly return the correct<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * result with no further correction required.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; arg_int64 = arg-&gt;digits[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (src_idx = <span class="Constant">1</span>; src_idx &lt; src_ndigits; src_idx++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; arg_int64 *= <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (src_idx &lt; arg-&gt;ndigits)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arg_int64 += arg-&gt;digits[src_idx];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; s_int64 = (int64) sqrt((<span class="Type">double</span>) arg_int64);<br/></li>
<li>&nbsp; &nbsp; r_int64 = arg_int64 - s_int64 * s_int64;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Use Newton's method to correct the result, if necessary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This uses integer division with truncation to compute the truncated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * integer square root by iterating using the formula x -&gt; (x + n/x) / 2.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is known to converge to isqrt(n), unless n+1 is a perfect square.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If n+1 is a perfect square, the sequence will oscillate between the two<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> isqrt(n) and isqrt(n)+1, so we can be assured of convergence by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * checking the remainder.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (r_int64 &lt; <span class="Constant">0</span> || r_int64 &gt; <span class="Constant">2</span> * s_int64)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s_int64 = (s_int64 + arg_int64 / s_int64) / <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; r_int64 = arg_int64 - s_int64 * s_int64;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Iterations with src_ndigits &lt;= 8:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> 1 or 2 iterations compute larger (outer) square roots with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * src_ndigits &lt;= 8, so the result still fits in an int64 (even though the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * input no longer does) and we can continue to compute using int64<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * variables to avoid more expensive <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> computations.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It is fairly easy to see that there is no risk of the intermediate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> below overflowing 64-<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> integers.&nbsp; In the worst case, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * previous iteration will have computed a 3-digit square root (of a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 6-digit input less than <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>^6 / 4), so at the start of this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * iteration, s will be less than <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>^3 / 2 = 10^12 / 2, and r will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * less than 10^12.&nbsp; In this case, blen will be 1, so numer will be less<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * than 10^17, and denom will be less than 10^12 (and hence u will also be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * less than 10^12).&nbsp; Finally, since q^2 = u*b + a0 - r, we can also be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sure that q^2 &lt; 10^17.&nbsp; Therefore all these quantities fit comfortably<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in 64-<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> integers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; step--;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (step &gt;= <span class="Constant">0</span> &amp;&amp; (src_ndigits = ndigits[step]) &lt;= <span class="Constant">8</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a0;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; numer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; denom;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; q;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; u;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; blen = (src_ndigits - src_idx) / <span class="Constant">2</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Extract <a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a> and a0, and compute b */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; a0 = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; b = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; blen; i++, src_idx++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b *= <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a> *= <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (src_idx &lt; arg-&gt;ndigits)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a> += arg-&gt;digits[src_idx];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; blen; i++, src_idx++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a0 *= <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (src_idx &lt; arg-&gt;ndigits)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a0 += arg-&gt;digits[src_idx];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Compute (q,u) = DivRem(r*b + <a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>, 2*s) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; numer = r_int64 * b + <a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; denom = <span class="Constant">2</span> * s_int64;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; q = numer / denom;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; u = numer - q * denom;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Compute s = s*b + q and r = u*b + a0 - q^2 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; s_int64 = s_int64 * b + q;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; r_int64 = u * b + a0 - q * q;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (r_int64 &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* s is too large by 1; set r += s, s--, r += s */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r_int64 += s_int64;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s_int64--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r_int64 += s_int64;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(src_idx == src_ndigits); <span class="Comment">/* All input digits consumed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; step--;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * On platforms with 128-<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> integer support, we can further delay the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need to use <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> variables.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef HAVE_INT128<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (step &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int128&nbsp; &nbsp; &nbsp; &nbsp; s_int128;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int128&nbsp; &nbsp; &nbsp; &nbsp; r_int128;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s_int128 = s_int64;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; r_int128 = r_int64;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Iterations with src_ndigits &lt;= 16:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The result fits in an int128 (even though the input doesn't) so we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * use int128 variables to avoid more expensive <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> computations.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (step &gt;= <span class="Constant">0</span> &amp;&amp; (src_ndigits = ndigits[step]) &lt;= <span class="Constant">16</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; b;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; a0;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int128&nbsp; &nbsp; &nbsp; &nbsp; numer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int128&nbsp; &nbsp; &nbsp; &nbsp; denom;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int128&nbsp; &nbsp; &nbsp; &nbsp; q;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int128&nbsp; &nbsp; &nbsp; &nbsp; u;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blen = (src_ndigits - src_idx) / <span class="Constant">2</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Extract <a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a> and a0, and compute b */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a0 = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; blen; i++, src_idx++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b *= <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a> *= <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (src_idx &lt; arg-&gt;ndigits)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a> += arg-&gt;digits[src_idx];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; blen; i++, src_idx++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a0 *= <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (src_idx &lt; arg-&gt;ndigits)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a0 += arg-&gt;digits[src_idx];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Compute (q,u) = DivRem(r*b + <a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>, 2*s) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numer = r_int128 * b + <a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; denom = <span class="Constant">2</span> * s_int128;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; q = numer / denom;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; u = numer - q * denom;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Compute s = s*b + q and r = u*b + a0 - q^2 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s_int128 = s_int128 * b + q;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r_int128 = u * b + a0 - q * q;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (r_int128 &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* s is too large by 1; set r += s, s--, r += s */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r_int128 += s_int128;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s_int128--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r_int128 += s_int128;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(src_idx == src_ndigits); <span class="Comment">/* All input digits consumed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; step--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * All remaining iterations require <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> variables.&nbsp; Convert the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * integer <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> and continue.&nbsp; Note that in the final<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * iteration we don't need the remainder, so we can save a few cycles<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there by not fully computing it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8295" title="utils/adt/numeric.c:8295">int128_to_numericvar</a>(s_int128, &amp;s_var);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (step &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8295" title="utils/adt/numeric.c:8295">int128_to_numericvar</a>(r_int128, &amp;r_var);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8104" title="utils/adt/numeric.c:8104">int64_to_numericvar</a>(s_int64, &amp;s_var);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* step &lt; 0, so we certainly don't need r */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#else</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* !HAVE_INT128 */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L8104" title="utils/adt/numeric.c:8104">int64_to_numericvar</a>(s_int64, &amp;s_var);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (step &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8104" title="utils/adt/numeric.c:8104">int64_to_numericvar</a>(r_int64, &amp;r_var);<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* HAVE_INT128 */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The remaining iterations with src_ndigits &gt; 8 (or 16, if have int128)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * use <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> variables.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (step &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp_len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; src_ndigits = ndigits[step];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; blen = (src_ndigits - src_idx) / <span class="Constant">2</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Extract <a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a> and a0 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (src_idx &lt; arg-&gt;ndigits)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp_len = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(blen, arg-&gt;ndigits - src_idx);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6953" title="utils/adt/numeric.c:6953">alloc_var</a>(&amp;a1_var, tmp_len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(a1_var.digits, arg-&gt;digits + src_idx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tmp_len * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a1_var.weight = blen - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a1_var.sign = <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a1_var.dscale = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L11917" title="utils/adt/numeric.c:11917">strip_var</a>(&amp;a1_var);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6985" title="utils/adt/numeric.c:6985">zero_var</a>(&amp;a1_var);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a1_var.dscale = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; src_idx += blen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (src_idx &lt; arg-&gt;ndigits)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp_len = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(blen, arg-&gt;ndigits - src_idx);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6953" title="utils/adt/numeric.c:6953">alloc_var</a>(&amp;a0_var, tmp_len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(a0_var.digits, arg-&gt;digits + src_idx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tmp_len * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a0_var.weight = blen - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a0_var.sign = <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a0_var.dscale = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L11917" title="utils/adt/numeric.c:11917">strip_var</a>(&amp;a0_var);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6985" title="utils/adt/numeric.c:6985">zero_var</a>(&amp;a0_var);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a0_var.dscale = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; src_idx += blen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Compute (q,u) = DivRem(r*b + <a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>, 2*s) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7468" title="utils/adt/numeric.c:7468">set_var_from_var</a>(&amp;r_var, &amp;q_var);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; q_var.weight += blen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8431" title="utils/adt/numeric.c:8431">add_var</a>(&amp;q_var, &amp;a1_var, &amp;q_var);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8431" title="utils/adt/numeric.c:8431">add_var</a>(&amp;s_var, &amp;s_var, &amp;u_var);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L9875" title="utils/adt/numeric.c:9875">div_mod_var</a>(&amp;q_var, &amp;u_var, &amp;q_var, &amp;u_var);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Compute s = s*b + q */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; s_var.weight += blen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8431" title="utils/adt/numeric.c:8431">add_var</a>(&amp;s_var, &amp;q_var, &amp;s_var);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Compute r = u*b + a0 - q^2.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In the final iteration, we don't actually need r; we just need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * know whether it is negative, so that we know whether to adjust s.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * So instead of the final subtraction we can just <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; u_var.weight += blen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8431" title="utils/adt/numeric.c:8431">add_var</a>(&amp;u_var, &amp;a0_var, &amp;u_var);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8669" title="utils/adt/numeric.c:8669">mul_var</a>(&amp;q_var, &amp;q_var, &amp;q_var, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (step &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Need r for later iterations */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8548" title="utils/adt/numeric.c:8548">sub_var</a>(&amp;u_var, &amp;q_var, &amp;r_var);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (r_var.sign == <a href="#L166" title="utils/adt/numeric.c:166">NUMERIC_NEG</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* s is too large by 1; set r += s, s--, r += s */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8431" title="utils/adt/numeric.c:8431">add_var</a>(&amp;r_var, &amp;s_var, &amp;r_var);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8548" title="utils/adt/numeric.c:8548">sub_var</a>(&amp;s_var, &amp;<a href="#L419" title="utils/adt/numeric.c:419">const_one</a>, &amp;s_var);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8431" title="utils/adt/numeric.c:8431">add_var</a>(&amp;r_var, &amp;s_var, &amp;r_var);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Don't need r anymore, except to test if s is too large by 1 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L8373" title="utils/adt/numeric.c:8373">cmp_var</a>(&amp;u_var, &amp;q_var) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8548" title="utils/adt/numeric.c:8548">sub_var</a>(&amp;s_var, &amp;<a href="#L419" title="utils/adt/numeric.c:419">const_one</a>, &amp;s_var);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(src_idx == src_ndigits); <span class="Comment">/* All input digits consumed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; step--;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Construct the final result, rounding it to the requested precision.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L7468" title="utils/adt/numeric.c:7468">set_var_from_var</a>(&amp;s_var, result);<br/></li>
<li>&nbsp; &nbsp; result-&gt;weight = res_weight;<br/></li>
<li>&nbsp; &nbsp; result-&gt;sign = <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Round to target rscale (and set result-&gt;dscale) */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L11749" title="utils/adt/numeric.c:11749">round_var</a>(result, rscale);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Strip leading and trailing zeroes */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L11917" title="utils/adt/numeric.c:11917">strip_var</a>(result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;s_var);<br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;r_var);<br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;a0_var);<br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;a1_var);<br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;q_var);<br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;u_var);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L10542" title="utils/adt/numeric.c:10542">exp_var</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Raise e to the power of x, computed to rscale fractional digits<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L10542">&#x200c;</a></span><span class="linkable">exp_var</span>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *arg, <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *result, <span class="Type">int</span> rscale)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; x;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; elem;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ni;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dweight;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndiv2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sig_digits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; local_rscale;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;x);<br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;elem);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L7468" title="utils/adt/numeric.c:7468">set_var_from_var</a>(arg, &amp;x);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Estimate the dweight of the result using floating point arithmetic, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that we can choose an appropriate local rscale for the calculation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; val = <a href="#L8341" title="utils/adt/numeric.c:8341">numericvar_to_double_no_overflow</a>(&amp;x);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Guard against overflow/underflow */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* If you change this limit, see also <a href="#L10931" title="utils/adt/numeric.c:10931">power_var</a>()'s limit */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fabs(val) &gt;= NUMERIC_MAX_RESULT_SCALE * <span class="Constant">3</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (val &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;value overflows <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> format&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6985" title="utils/adt/numeric.c:6985">zero_var</a>(result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;dscale = rscale;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* decimal weight = log10(e^x) = x * log10(e) */<br/></li>
<li></span>&nbsp; &nbsp; dweight = (<span class="Type">int</span>) (val * <span class="Constant">0.434294481903252</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reduce x to the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> -0.01 &lt;= x &lt;= 0.01 (approximately) by dividing by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 2^ndiv2, to improve the convergence rate of the Taylor series.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that the overflow check above ensures that fabs(x) &lt; 6000, which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * means that ndiv2 &lt;= 20 here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fabs(val) &gt; <span class="Constant">0.01</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ndiv2 = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; val /= <span class="Constant">2</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (fabs(val) &gt; <span class="Constant">0.01</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndiv2++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val /= <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; local_rscale = x.dscale + ndiv2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L9549" title="utils/adt/numeric.c:9549">div_var_int</a>(&amp;x, <span class="Constant">1</span> &lt;&lt; ndiv2, <span class="Constant">0</span>, &amp;x, local_rscale, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ndiv2 = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set the scale for the Taylor series expansion.&nbsp; The final result has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (dweight + rscale + 1) significant digits.&nbsp; In addition, we have to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * raise the Taylor series result to the power 2^ndiv2, which introduces<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * an error of up to around log10(2^ndiv2) digits, so work with this many<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * extra digits of precision (plus a few more for good measure).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; sig_digits = <span class="Constant">1</span> + dweight + rscale + (<span class="Type">int</span>) (ndiv2 * <span class="Constant">0.301029995663981</span>);<br/></li>
<li>&nbsp; &nbsp; sig_digits = Max(sig_digits, <span class="Constant">0</span>) + <span class="Constant">8</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; local_rscale = sig_digits - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Use the Taylor series<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exp(x) = 1 + x + x^2/2! + x^3/3! + ...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Given the limited <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of x, this should converge reasonably quickly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We run the series until the terms fall below the local_rscale limit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L8431" title="utils/adt/numeric.c:8431">add_var</a>(&amp;<a href="#L419" title="utils/adt/numeric.c:419">const_one</a>, &amp;x, result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L8669" title="utils/adt/numeric.c:8669">mul_var</a>(&amp;x, &amp;x, &amp;elem, local_rscale);<br/></li>
<li>&nbsp; &nbsp; ni = <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L9549" title="utils/adt/numeric.c:9549">div_var_int</a>(&amp;elem, ni, <span class="Constant">0</span>, &amp;elem, local_rscale, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (elem.ndigits != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8431" title="utils/adt/numeric.c:8431">add_var</a>(result, &amp;elem, result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8669" title="utils/adt/numeric.c:8669">mul_var</a>(&amp;elem, &amp;x, &amp;elem, local_rscale);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ni++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L9549" title="utils/adt/numeric.c:9549">div_var_int</a>(&amp;elem, ni, <span class="Constant">0</span>, &amp;elem, local_rscale, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Compensate for the argument <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> reduction.&nbsp; Since the weight of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * result doubles with each multiplication, we can reduce the local rscale<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as we proceed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (ndiv2-- &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; local_rscale = sig_digits - result-&gt;weight * <span class="Constant">2</span> * <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; local_rscale = Max(local_rscale, NUMERIC_MIN_DISPLAY_SCALE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8669" title="utils/adt/numeric.c:8669">mul_var</a>(result, result, result, local_rscale);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Round to requested rscale */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L11749" title="utils/adt/numeric.c:11749">round_var</a>(result, rscale);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;x);<br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;elem);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Estimate the dweight of the most significant decimal digit of the natural<br/></li>
<li></span><span class="Comment"> * logarithm of a number.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Essentially, we're approximating log10(abs(ln(var))).&nbsp; This is used to<br/></li>
<li></span><span class="Comment"> * determine the appropriate rscale when computing natural logarithms.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: many callers call this <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-checking the input.&nbsp; Therefore,<br/></li>
<li></span><span class="Comment"> * we must be robust against <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> that are invalid to apply ln() to.<br/></li>
<li></span><span class="Comment"> * We don't wish to throw an error here, so just return zero in such cases.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L10671">&#x200c;</a></span><span class="linkable">estimate_ln_dweight</span>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ln_dweight;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Caller should fail on ln(negative), but for the moment return zero */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;sign != <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L8373" title="utils/adt/numeric.c:8373">cmp_var</a>(var, &amp;<a href="#L436" title="utils/adt/numeric.c:436">const_zero_point_nine</a>) &gt;= <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8373" title="utils/adt/numeric.c:8373">cmp_var</a>(var, &amp;<a href="#L446" title="utils/adt/numeric.c:446">const_one_point_one</a>) &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * 0.9 &lt;= var &lt;= 1.1<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ln(var) has a negative weight (possibly very large).&nbsp; To get a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reasonably accurate result, estimate it using ln(1+x) ~= x.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; x;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;x);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8548" title="utils/adt/numeric.c:8548">sub_var</a>(var, &amp;<a href="#L419" title="utils/adt/numeric.c:419">const_one</a>, &amp;x);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (x.ndigits &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Use weight of most significant decimal digit of x */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ln_dweight = x.weight * <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> + (<span class="Type">int</span>) log10(x.digits[<span class="Constant">0</span>]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* x = 0.&nbsp; Since ln(1) = 0 exactly, we don't need extra digits */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ln_dweight = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;x);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Estimate the logarithm using the first couple of digits from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * input number.&nbsp; This will give an accurate result whenever the input<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is not too close to 1.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;ndigits &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; digits;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dweight;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L10753" title="utils/adt/numeric.c:10753">ln_var</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; digits = var-&gt;digits[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dweight = var-&gt;weight * <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;ndigits &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; digits = digits * <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> + var-&gt;digits[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dweight -= <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have var ~= digits * 10^dweight<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so ln(var) ~= ln(digits) + dweight * ln(10)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L10753" title="utils/adt/numeric.c:10753">ln_var</a> = log((<span class="Type">double</span>) digits) + dweight * <span class="Constant">2.302585092994046</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ln_dweight = (<span class="Type">int</span>) log10(fabs(<a href="#L10753" title="utils/adt/numeric.c:10753">ln_var</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Caller should fail on ln(0), but for the moment return zero */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ln_dweight = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ln_dweight;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L10753" title="utils/adt/numeric.c:10753">ln_var</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Compute the natural log of x<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L10753">&#x200c;</a></span><span class="linkable">ln_var</span>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *arg, <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *result, <span class="Type">int</span> rscale)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; x;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; xx;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ni;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; elem;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; fact;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nsqrt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; local_rscale;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = <a href="#L8373" title="utils/adt/numeric.c:8373">cmp_var</a>(arg, &amp;<a href="#L415" title="utils/adt/numeric.c:415">const_zero</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_ARGUMENT_FOR_LOG),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot take logarithm of zero&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_ARGUMENT_FOR_LOG),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot take logarithm of a negative number&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;x);<br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;xx);<br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;elem);<br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;fact);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L7468" title="utils/adt/numeric.c:7468">set_var_from_var</a>(arg, &amp;x);<br/></li>
<li>&nbsp; &nbsp; <a href="#L7468" title="utils/adt/numeric.c:7468">set_var_from_var</a>(&amp;<a href="#L426" title="utils/adt/numeric.c:426">const_two</a>, &amp;fact);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reduce input into <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> 0.9 &lt; x &lt; 1.1 with repeated sqrt() operations.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The final logarithm will have up to around rscale+6 significant digits.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Each sqrt() will roughly halve the weight of x, so adjust the local<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rscale as we work so that we keep this many significant digits at each<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * step (plus a few more for good measure).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that we allow local_rscale &lt; 0 during this input reduction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * process, which implies rounding <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the decimal point.&nbsp; <a href="#L10062" title="utils/adt/numeric.c:10062">sqrt_var</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * explicitly supports this, and it significantly reduces the work<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * required to reduce very large inputs to the required <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.&nbsp; Once the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * input reduction is complete, x.weight will be 0 and its display scale<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will be non-negative again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; nsqrt = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="#L8373" title="utils/adt/numeric.c:8373">cmp_var</a>(&amp;x, &amp;<a href="#L436" title="utils/adt/numeric.c:436">const_zero_point_nine</a>) &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; local_rscale = rscale - x.weight * <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> / <span class="Constant">2</span> + <span class="Constant">8</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L10062" title="utils/adt/numeric.c:10062">sqrt_var</a>(&amp;x, &amp;x, local_rscale);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8669" title="utils/adt/numeric.c:8669">mul_var</a>(&amp;fact, &amp;<a href="#L426" title="utils/adt/numeric.c:426">const_two</a>, &amp;fact, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nsqrt++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="#L8373" title="utils/adt/numeric.c:8373">cmp_var</a>(&amp;x, &amp;<a href="#L446" title="utils/adt/numeric.c:446">const_one_point_one</a>) &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; local_rscale = rscale - x.weight * <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> / <span class="Constant">2</span> + <span class="Constant">8</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L10062" title="utils/adt/numeric.c:10062">sqrt_var</a>(&amp;x, &amp;x, local_rscale);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8669" title="utils/adt/numeric.c:8669">mul_var</a>(&amp;fact, &amp;<a href="#L426" title="utils/adt/numeric.c:426">const_two</a>, &amp;fact, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nsqrt++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We use the Taylor series for 0.5 * ln((1+z)/(1-z)),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * z + z^3/3 + z^5/5 + ...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * where z = (x-1)/(x+1) is in the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> (approximately) -0.053 .. 0.048<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * due to the above <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-reduction of x.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The convergence of this is not as fast as one would like, but is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tolerable given that z is small.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The Taylor series result will be multiplied by 2^(nsqrt+1), which has a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * decimal weight of (nsqrt+1) * log10(2), so work with this many extra<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * digits of precision (plus a few more for good measure).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; local_rscale = rscale + (<span class="Type">int</span>) ((nsqrt + <span class="Constant">1</span>) * <span class="Constant">0.301029995663981</span>) + <span class="Constant">8</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L8548" title="utils/adt/numeric.c:8548">sub_var</a>(&amp;x, &amp;<a href="#L419" title="utils/adt/numeric.c:419">const_one</a>, result);<br/></li>
<li>&nbsp; &nbsp; <a href="#L8431" title="utils/adt/numeric.c:8431">add_var</a>(&amp;x, &amp;<a href="#L419" title="utils/adt/numeric.c:419">const_one</a>, &amp;elem);<br/></li>
<li>&nbsp; &nbsp; <a href="#L9185" title="utils/adt/numeric.c:9185">div_var_fast</a>(result, &amp;elem, result, local_rscale, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L7468" title="utils/adt/numeric.c:7468">set_var_from_var</a>(result, &amp;xx);<br/></li>
<li>&nbsp; &nbsp; <a href="#L8669" title="utils/adt/numeric.c:8669">mul_var</a>(result, result, &amp;x, local_rscale);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ni = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ni += <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8669" title="utils/adt/numeric.c:8669">mul_var</a>(&amp;xx, &amp;x, &amp;xx, local_rscale);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L9549" title="utils/adt/numeric.c:9549">div_var_int</a>(&amp;xx, ni, <span class="Constant">0</span>, &amp;elem, local_rscale, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (elem.ndigits == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8431" title="utils/adt/numeric.c:8431">add_var</a>(result, &amp;elem, result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (elem.weight &lt; (result-&gt;weight - local_rscale * <span class="Constant">2</span> / <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Compensate for argument <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> reduction, round to requested rscale */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L8669" title="utils/adt/numeric.c:8669">mul_var</a>(result, &amp;fact, result, rscale);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;x);<br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;xx);<br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;elem);<br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;fact);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L10871" title="utils/adt/numeric.c:10871">log_var</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Compute the logarithm of num in a given base.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Note: this routine chooses dscale of the result.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L10871">&#x200c;</a></span><span class="linkable">log_var</span>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *base, <span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *num, <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *result)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; ln_base;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; ln_num;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ln_base_dweight;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ln_num_dweight;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result_dweight;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rscale;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ln_base_rscale;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ln_num_rscale;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;ln_base);<br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;ln_num);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Estimated dweights of ln(base), ln(num) and the final result */<br/></li>
<li></span>&nbsp; &nbsp; ln_base_dweight = <a href="#L10671" title="utils/adt/numeric.c:10671">estimate_ln_dweight</a>(base);<br/></li>
<li>&nbsp; &nbsp; ln_num_dweight = <a href="#L10671" title="utils/adt/numeric.c:10671">estimate_ln_dweight</a>(num);<br/></li>
<li>&nbsp; &nbsp; result_dweight = ln_num_dweight - ln_base_dweight;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Select the scale of the result so that it will have at least<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NUMERIC_MIN_SIG_DIGITS significant digits and is not less than either<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * input's display scale.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rscale = NUMERIC_MIN_SIG_DIGITS - result_dweight;<br/></li>
<li>&nbsp; &nbsp; rscale = Max(rscale, base-&gt;dscale);<br/></li>
<li>&nbsp; &nbsp; rscale = Max(rscale, num-&gt;dscale);<br/></li>
<li>&nbsp; &nbsp; rscale = Max(rscale, NUMERIC_MIN_DISPLAY_SCALE);<br/></li>
<li>&nbsp; &nbsp; rscale = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(rscale, NUMERIC_MAX_DISPLAY_SCALE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set the scales for ln(base) and ln(num) so that they each have more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * significant digits than the final result.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ln_base_rscale = rscale + result_dweight - ln_base_dweight + <span class="Constant">8</span>;<br/></li>
<li>&nbsp; &nbsp; ln_base_rscale = Max(ln_base_rscale, NUMERIC_MIN_DISPLAY_SCALE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ln_num_rscale = rscale + result_dweight - ln_num_dweight + <span class="Constant">8</span>;<br/></li>
<li>&nbsp; &nbsp; ln_num_rscale = Max(ln_num_rscale, NUMERIC_MIN_DISPLAY_SCALE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Form natural logarithms */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L10753" title="utils/adt/numeric.c:10753">ln_var</a>(base, &amp;ln_base, ln_base_rscale);<br/></li>
<li>&nbsp; &nbsp; <a href="#L10753" title="utils/adt/numeric.c:10753">ln_var</a>(num, &amp;ln_num, ln_num_rscale);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Divide and round to the required scale */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L9185" title="utils/adt/numeric.c:9185">div_var_fast</a>(&amp;ln_num, &amp;ln_base, result, rscale, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;ln_num);<br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;ln_base);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L10931" title="utils/adt/numeric.c:10931">power_var</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Raise base to the power of exp<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Note: this routine chooses dscale of the result.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L10931">&#x200c;</a></span><span class="linkable">power_var</span>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *base, <span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *exp, <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *result)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res_sign;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; abs_base;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; ln_base;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; ln_num;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ln_dweight;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rscale;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sig_digits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; local_rscale;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If exp can be represented as an integer, use <a href="#L11092" title="utils/adt/numeric.c:11092">power_var_int</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (exp-&gt;ndigits == <span class="Constant">0</span> || exp-&gt;ndigits &lt;= exp-&gt;weight + <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* exact integer, but does it fit in int? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; expval64;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L8029" title="utils/adt/numeric.c:8029">numericvar_to_int64</a>(exp, &amp;expval64))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (expval64 &gt;= PG_INT32_MIN &amp;&amp; expval64 &lt;= PG_INT32_MAX)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Okay, use <a href="#L11092" title="utils/adt/numeric.c:11092">power_var_int</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L11092" title="utils/adt/numeric.c:11092">power_var_int</a>(base, (<span class="Type">int</span>) expval64, exp-&gt;dscale, result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This avoids log(0) for cases of 0 raised to a non-integer.&nbsp; 0 ^ 0 is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * handled by <a href="#L11092" title="utils/adt/numeric.c:11092">power_var_int</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L8373" title="utils/adt/numeric.c:8373">cmp_var</a>(base, &amp;<a href="#L415" title="utils/adt/numeric.c:415">const_zero</a>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7468" title="utils/adt/numeric.c:7468">set_var_from_var</a>(&amp;<a href="#L415" title="utils/adt/numeric.c:415">const_zero</a>, result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;dscale = NUMERIC_MIN_SIG_DIGITS;&nbsp; &nbsp; <span class="Comment">/* no need to round */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;abs_base);<br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;ln_base);<br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;ln_num);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If base is negative, insist that exp be an integer.&nbsp; The result is then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * positive if exp is even and negative if exp is odd.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (base-&gt;sign == <a href="#L166" title="utils/adt/numeric.c:166">NUMERIC_NEG</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check that exp is an integer.&nbsp; This error code is defined by the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * SQL standard, and matches other errors in <a href="#L3935" title="utils/adt/numeric.c:3935">numeric_power</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (exp-&gt;ndigits &gt; <span class="Constant">0</span> &amp;&amp; exp-&gt;ndigits &gt; exp-&gt;weight + <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_ARGUMENT_FOR_POWER_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;a negative number raised to a non-integer power yields a complex result&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Test if exp is odd or even */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (exp-&gt;ndigits &gt; <span class="Constant">0</span> &amp;&amp; exp-&gt;ndigits == exp-&gt;weight + <span class="Constant">1</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (exp-&gt;digits[exp-&gt;ndigits - <span class="Constant">1</span>] &amp; <span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res_sign = <a href="#L166" title="utils/adt/numeric.c:166">NUMERIC_NEG</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res_sign = <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Then work with abs(base) below */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7468" title="utils/adt/numeric.c:7468">set_var_from_var</a>(base, &amp;abs_base);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; abs_base.sign = <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; base = &amp;abs_base;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; res_sign = <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Decide on the scale for the ln() calculation.&nbsp; For this we need an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * estimate of the weight of the result, which we obtain by doing an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * initial low-precision calculation of exp * ln(base).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We want result = e ^ (exp * ln(base))<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so result dweight = log10(result) = exp * ln(base) * log10(e)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We also perform a crude overflow test here so that we can exit early if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the full-precision result is sure to overflow, and to guard against<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * integer overflow when determining the scale for the real calculation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L10542" title="utils/adt/numeric.c:10542">exp_var</a>() supports inputs up to NUMERIC_MAX_RESULT_SCALE * 3, so the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * result will overflow if exp * ln(base) &gt;= NUMERIC_MAX_RESULT_SCALE * 3.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> here are only approximations, we apply a small fuzz<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * factor to this overflow test and let <a href="#L10542" title="utils/adt/numeric.c:10542">exp_var</a>() determine the exact<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * overflow threshold so that it is consistent for all inputs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ln_dweight = <a href="#L10671" title="utils/adt/numeric.c:10671">estimate_ln_dweight</a>(base);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set the scale for the low-precision calculation, computing ln(base) to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * around 8 significant digits.&nbsp; Note that ln_dweight may be as small as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * -SHRT_MAX, so the scale may exceed NUMERIC_MAX_DISPLAY_SCALE here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; local_rscale = <span class="Constant">8</span> - ln_dweight;<br/></li>
<li>&nbsp; &nbsp; local_rscale = Max(local_rscale, NUMERIC_MIN_DISPLAY_SCALE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L10753" title="utils/adt/numeric.c:10753">ln_var</a>(base, &amp;ln_base, local_rscale);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L8669" title="utils/adt/numeric.c:8669">mul_var</a>(&amp;ln_base, exp, &amp;ln_num, local_rscale);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; val = <a href="#L8341" title="utils/adt/numeric.c:8341">numericvar_to_double_no_overflow</a>(&amp;ln_num);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* initial overflow/underflow test with fuzz factor */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fabs(val) &gt; NUMERIC_MAX_RESULT_SCALE * <span class="Constant">3.01</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (val &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;value overflows <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> format&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6985" title="utils/adt/numeric.c:6985">zero_var</a>(result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;dscale = NUMERIC_MAX_DISPLAY_SCALE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; val *= <span class="Constant">0.434294481903252</span>;&nbsp; &nbsp; <span class="Comment">/* approximate decimal result weight */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* choose the result scale */<br/></li>
<li></span>&nbsp; &nbsp; rscale = NUMERIC_MIN_SIG_DIGITS - (<span class="Type">int</span>) val;<br/></li>
<li>&nbsp; &nbsp; rscale = Max(rscale, base-&gt;dscale);<br/></li>
<li>&nbsp; &nbsp; rscale = Max(rscale, exp-&gt;dscale);<br/></li>
<li>&nbsp; &nbsp; rscale = Max(rscale, NUMERIC_MIN_DISPLAY_SCALE);<br/></li>
<li>&nbsp; &nbsp; rscale = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(rscale, NUMERIC_MAX_DISPLAY_SCALE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* significant digits required in the result */<br/></li>
<li></span>&nbsp; &nbsp; sig_digits = rscale + (<span class="Type">int</span>) val;<br/></li>
<li>&nbsp; &nbsp; sig_digits = Max(sig_digits, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set the scale for the real exp * ln(base) calculation */<br/></li>
<li></span>&nbsp; &nbsp; local_rscale = sig_digits - ln_dweight + <span class="Constant">8</span>;<br/></li>
<li>&nbsp; &nbsp; local_rscale = Max(local_rscale, NUMERIC_MIN_DISPLAY_SCALE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* and do the real calculation */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="#L10753" title="utils/adt/numeric.c:10753">ln_var</a>(base, &amp;ln_base, local_rscale);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L8669" title="utils/adt/numeric.c:8669">mul_var</a>(&amp;ln_base, exp, &amp;ln_num, local_rscale);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L10542" title="utils/adt/numeric.c:10542">exp_var</a>(&amp;ln_num, result, rscale);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (res_sign == <a href="#L166" title="utils/adt/numeric.c:166">NUMERIC_NEG</a> &amp;&amp; result-&gt;ndigits &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;sign = <a href="#L166" title="utils/adt/numeric.c:166">NUMERIC_NEG</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;ln_num);<br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;ln_base);<br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;abs_base);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L11092" title="utils/adt/numeric.c:11092">power_var_int</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Raise base to the power of exp, where exp is an integer.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Note: this routine chooses dscale of the result.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L11092">&#x200c;</a></span><span class="linkable">power_var_int</span>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *base, <span class="Type">int</span> exp, <span class="Type">int</span> exp_dscale,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *result)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; f;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rscale;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sig_digits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> mask;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; neg;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; base_prod;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; local_rscale;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Choose the result scale.&nbsp; For this we need an estimate of the decimal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * weight of the result, which we obtain by approximating using double<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * precision arithmetic.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We also perform crude overflow/underflow tests here so that we can exit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * early if the result is sure to overflow/underflow, and to guard against<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * integer overflow when choosing the result scale.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (base-&gt;ndigits != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Choose f (double) and p (int) such that base ~= f * 10^p.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Then log10(result) = log10(base^exp) ~= exp * (log10(f) + p).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; f = base-&gt;digits[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; p = base-&gt;weight * <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt; base-&gt;ndigits &amp;&amp; i * <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> &lt; <span class="Constant">16</span>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; f = f * <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> + base-&gt;digits[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p -= <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; f = exp * (log10(f) + p);&nbsp; &nbsp; <span class="Comment">/* approximate decimal result weight */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; f = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* result is 0 or 1 (weight 0), or error */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* overflow/underflow tests with fuzz factors */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (f &gt; (<span class="Constant">SHRT_MAX</span> + <span class="Constant">1</span>) * <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;value overflows <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> format&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (f + <span class="Constant">1</span> &lt; -NUMERIC_MAX_DISPLAY_SCALE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6985" title="utils/adt/numeric.c:6985">zero_var</a>(result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;dscale = NUMERIC_MAX_DISPLAY_SCALE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Choose the result scale in the same way as <a href="#L10931" title="utils/adt/numeric.c:10931">power_var</a>(), so it has at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * least NUMERIC_MIN_SIG_DIGITS significant digits and is not less than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * either input's display scale.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rscale = NUMERIC_MIN_SIG_DIGITS - (<span class="Type">int</span>) f;<br/></li>
<li>&nbsp; &nbsp; rscale = Max(rscale, base-&gt;dscale);<br/></li>
<li>&nbsp; &nbsp; rscale = Max(rscale, exp_dscale);<br/></li>
<li>&nbsp; &nbsp; rscale = Max(rscale, NUMERIC_MIN_DISPLAY_SCALE);<br/></li>
<li>&nbsp; &nbsp; rscale = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(rscale, NUMERIC_MAX_DISPLAY_SCALE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Handle some common special cases, as well as corner cases */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (exp)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">0</span>:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * While 0 ^ 0 can be either 1 or indeterminate (error), we treat<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it as 1 because most programming languages do this. SQL:2003<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * also requires a return value of 1.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * https://en.wikipedia.org/wiki/Exponentiation#Zero_to_the_zero_power<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7468" title="utils/adt/numeric.c:7468">set_var_from_var</a>(&amp;<a href="#L419" title="utils/adt/numeric.c:419">const_one</a>, result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result-&gt;dscale = rscale;&nbsp; &nbsp; <span class="Comment">/* no need to round */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">1</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7468" title="utils/adt/numeric.c:7468">set_var_from_var</a>(base, result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L11749" title="utils/adt/numeric.c:11749">round_var</a>(result, rscale);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> -<span class="Constant">1</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8877" title="utils/adt/numeric.c:8877">div_var</a>(&amp;<a href="#L419" title="utils/adt/numeric.c:419">const_one</a>, base, result, rscale, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">2</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8669" title="utils/adt/numeric.c:8669">mul_var</a>(base, base, result, rscale);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Handle the special case where the base is zero */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (base-&gt;ndigits == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (exp &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DIVISION_BY_ZERO),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;division by zero&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6985" title="utils/adt/numeric.c:6985">zero_var</a>(result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;dscale = rscale;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The general case repeatedly multiplies base according to the <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pattern of exp.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The local rscale used for each multiplication is varied to keep a fixed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * number of significant digits, sufficient to give the required result<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scale.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Approximate number of significant digits in the result.&nbsp; Note that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * underflow test above, together with the choice of rscale, ensures that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this approximation is necessarily &gt; 0.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; sig_digits = <span class="Constant">1</span> + rscale + (<span class="Type">int</span>) f;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The multiplications to produce the result may introduce an error of up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to around log10(abs(exp)) digits, so work with this many extra digits<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of precision (plus a few more for good measure).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; sig_digits += (<span class="Type">int</span>) log(fabs((<span class="Type">double</span>) exp)) + <span class="Constant">8</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now we can proceed with the multiplications.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; neg = (exp &lt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; mask = abs(exp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;base_prod);<br/></li>
<li>&nbsp; &nbsp; <a href="#L7468" title="utils/adt/numeric.c:7468">set_var_from_var</a>(base, &amp;base_prod);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (mask &amp; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7468" title="utils/adt/numeric.c:7468">set_var_from_var</a>(base, result);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7468" title="utils/adt/numeric.c:7468">set_var_from_var</a>(&amp;<a href="#L419" title="utils/adt/numeric.c:419">const_one</a>, result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((mask &gt;&gt;= <span class="Constant">1</span>) &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Do the multiplications using rscales large enough to hold the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * results to the required number of significant digits, but don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * waste time by exceeding the scales of the numbers themselves.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; local_rscale = sig_digits - <span class="Constant">2</span> * base_prod.weight * <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; local_rscale = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(local_rscale, <span class="Constant">2</span> * base_prod.dscale);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; local_rscale = Max(local_rscale, NUMERIC_MIN_DISPLAY_SCALE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8669" title="utils/adt/numeric.c:8669">mul_var</a>(&amp;base_prod, &amp;base_prod, &amp;base_prod, local_rscale);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (mask &amp; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; local_rscale = sig_digits -<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (base_prod.weight + result-&gt;weight) * <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; local_rscale = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(local_rscale,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; base_prod.dscale + result-&gt;dscale);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; local_rscale = Max(local_rscale, NUMERIC_MIN_DISPLAY_SCALE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8669" title="utils/adt/numeric.c:8669">mul_var</a>(&amp;base_prod, result, result, local_rscale);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When abs(base) &gt; 1, the number of digits to the left of the decimal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * point in base_prod doubles at each iteration, so if exp is large we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * could easily spend large amounts of time and memory space doing the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * multiplications.&nbsp; But once the weight exceeds what will fit in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * int16, the final result is guaranteed to overflow (or underflow, if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * exp &lt; 0), so we can give up <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> wasting too many cycles.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (base_prod.weight &gt; <span class="Constant">SHRT_MAX</span> || result-&gt;weight &gt; <span class="Constant">SHRT_MAX</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* overflow, unless neg, in which case result should be 0 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!neg)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;value overflows <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> format&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6985" title="utils/adt/numeric.c:6985">zero_var</a>(result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; neg = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;base_prod);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Compensate for input sign, and round to requested rscale */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (neg)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L9185" title="utils/adt/numeric.c:9185">div_var_fast</a>(&amp;<a href="#L419" title="utils/adt/numeric.c:419">const_one</a>, result, result, rscale, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L11749" title="utils/adt/numeric.c:11749">round_var</a>(result, rscale);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L11296" title="utils/adt/numeric.c:11296">power_ten_int</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Raise ten to the power of exp, where exp is an integer.&nbsp; Note that unlike<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L11092" title="utils/adt/numeric.c:11092">power_var_int</a>(), this does no overflow/underflow checking or rounding.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L11296">&#x200c;</a></span><span class="linkable">power_ten_int</span>(<span class="Type">int</span> exp, <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *result)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Construct the result directly, starting from 10^0 = 1 */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L7468" title="utils/adt/numeric.c:7468">set_var_from_var</a>(&amp;<a href="#L419" title="utils/adt/numeric.c:419">const_one</a>, result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Scale needed to represent the result exactly */<br/></li>
<li></span>&nbsp; &nbsp; result-&gt;dscale = exp &lt; <span class="Constant">0</span> ? -exp : <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Base-<a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> weight of result and remaining exponent */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (exp &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;weight = exp / <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;weight = (exp + <span class="Constant">1</span>) / <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; exp -= result-&gt;weight * <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Final adjustment of the result's single <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> digit */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (exp-- &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;digits[<span class="Constant">0</span>] *= <span class="Constant">10</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L11321" title="utils/adt/numeric.c:11321">random_var</a>() - return a random value in the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> [rmin, rmax].<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L11321">&#x200c;</a></span><span class="linkable">random_var</span>(pg_prng_state *state, <span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *rmin,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *rmax, <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *result)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rscale;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; rlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res_ndigits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pow10;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; rlen64;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rlen64_ndigits;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rscale = Max(rmin-&gt;dscale, rmax-&gt;dscale);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Compute rlen = rmax - rmin and check the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> bounds */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;rlen);<br/></li>
<li>&nbsp; &nbsp; <a href="#L8548" title="utils/adt/numeric.c:8548">sub_var</a>(rmax, rmin, &amp;rlen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rlen.sign == <a href="#L166" title="utils/adt/numeric.c:166">NUMERIC_NEG</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound must be less than or <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound&quot;</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Special case for an empty <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rlen.ndigits == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7468" title="utils/adt/numeric.c:7468">set_var_from_var</a>(rmin, result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;dscale = rscale;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;rlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Otherwise, <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> a random value in the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> [0, rlen = rmax - rmin],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and shift it to the required <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> by adding rmin.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Required result digits */<br/></li>
<li></span>&nbsp; &nbsp; res_ndigits = rlen.weight + <span class="Constant">1</span> + (rscale + <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> - <span class="Constant">1</span>) / <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * To get the required rscale, the final result digit must be a multiple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of pow10 = 10^n, where n = (-rscale) mod <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; n = ((rscale + <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> - <span class="Constant">1</span>) / <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a>) * <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> - rscale;<br/></li>
<li>&nbsp; &nbsp; pow10 = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; n; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pow10 *= <span class="Constant">10</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * To choose a random value uniformly from the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> [0, rlen], we choose<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from the slightly larger <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> [0, rlen2], where rlen2 is formed from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rlen by copying the first 4 <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> digits, and setting all remaining<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * decimal digits to &quot;9&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Without loss of generality, we can ignore the weight of rlen2 and treat<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it as a pure integer for the purposes of this discussion.&nbsp; The process<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * above gives rlen2 + 1 = rlen64 * 10^N, for some integer N, where rlen64<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is a 64-<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> integer formed from the first 4 <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> digits copied from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rlen.&nbsp; Since this trivially factors into smaller pieces that fit in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 64-<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> integers, the task of choosing a random value uniformly from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rlen2 + 1 possible <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in [0, rlen2] is much simpler.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the random value selected is too large, it is rejected, and we try<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * again until we get a result &lt;= rlen, ensuring that the overall result<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is uniform (no particular value is <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> more likely than <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since rlen64 holds 4 <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> digits from rlen, it contains at least<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> * 3 + 1 decimal digits (i.e., at least 13 decimal digits,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * when <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> is 4). Therefore the probability of needing to reject<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the value chosen and retry is less than 1e-13.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rlen64 = (uint64) rlen.digits[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; rlen64_ndigits = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (rlen64_ndigits &lt; res_ndigits &amp;&amp; rlen64_ndigits &lt; <span class="Constant">4</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rlen64 *= <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rlen64_ndigits &lt; rlen.ndigits)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rlen64 += rlen.digits[rlen64_ndigits];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rlen64_ndigits++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Loop until we get a result &lt;= rlen */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> *res_digits;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; rand;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; whole_ndigits;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6953" title="utils/adt/numeric.c:6953">alloc_var</a>(result, res_ndigits);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;sign = <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;weight = rlen.weight;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;dscale = rscale;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res_digits = result-&gt;digits;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Set the first rlen64_ndigits using a random value in [0, rlen64].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this is the whole result, and rscale is not a multiple of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> (pow10 from above is not 1), then we need this to be a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * multiple of pow10.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rlen64_ndigits == res_ndigits &amp;&amp; pow10 != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rand = pg_prng_uint64_range(state, <span class="Constant">0</span>, rlen64 / pow10) * pow10;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rand = pg_prng_uint64_range(state, <span class="Constant">0</span>, rlen64);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = rlen64_ndigits - <span class="Constant">1</span>; i &gt;= <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res_digits[i] = (<a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a>) (rand % <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rand = rand / <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Set the remaining digits to random <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> [0, <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * noting that the last digit needs to be a multiple of pow10.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; whole_ndigits = res_ndigits;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pow10 != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; whole_ndigits--;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set whole digits in groups of 4 for best performance */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; i = rlen64_ndigits;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (i &lt; whole_ndigits - <span class="Constant">3</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rand = pg_prng_uint64_range(state, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (uint64) <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> * <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> * <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> * <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res_digits[i++] = (<a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a>) (rand % <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rand = rand / <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res_digits[i++] = (<a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a>) (rand % <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rand = rand / <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res_digits[i++] = (<a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a>) (rand % <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rand = rand / <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res_digits[i++] = (<a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a>) rand;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Remaining whole digits */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (i &lt; whole_ndigits)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rand = pg_prng_uint64_range(state, <span class="Constant">0</span>, <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res_digits[i++] = (<a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a>) rand;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Final partial digit (multiple of pow10) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &lt; res_ndigits)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rand = pg_prng_uint64_range(state, <span class="Constant">0</span>, <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> / pow10 - <span class="Constant">1</span>) * pow10;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res_digits[i] = (<a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a>) rand;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Remove leading/trailing zeroes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L11917" title="utils/adt/numeric.c:11917">strip_var</a>(result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If result &gt; rlen, try again */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (<a href="#L8373" title="utils/adt/numeric.c:8373">cmp_var</a>(result, &amp;rlen) &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Offset the result to the required <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L8431" title="utils/adt/numeric.c:8431">add_var</a>(result, rmin, result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;rlen);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Following are the lowest level <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> that operate unsigned<br/></li>
<li></span><span class="Comment"> * on the variable level<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment"> * <a href="#L11504" title="utils/adt/numeric.c:11504">cmp_abs</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Compare the absolute <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of var1 and var2<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Returns:&nbsp; &nbsp; -1 for ABS(var1) &lt; ABS(var2)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0&nbsp; for ABS(var1) == ABS(var2)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1&nbsp; for ABS(var1) &gt; ABS(var2)<br/></li>
<li></span><span class="Comment"> * ----------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L11504">&#x200c;</a></span><span class="linkable">cmp_abs</span>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var1, <span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L11518" title="utils/adt/numeric.c:11518">cmp_abs_common</a>(var1-&gt;digits, var1-&gt;ndigits, var1-&gt;weight,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var2-&gt;digits, var2-&gt;ndigits, var2-&gt;weight);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment"> * <a href="#L11518" title="utils/adt/numeric.c:11518">cmp_abs_common</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Main routine of <a href="#L11504" title="utils/adt/numeric.c:11504">cmp_abs</a>(). This function can be used by both<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> and Numeric.<br/></li>
<li></span><span class="Comment"> * ----------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L11518">&#x200c;</a></span><span class="linkable">cmp_abs_common</span>(<span class="Type">const</span> <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> *var1digits, <span class="Type">int</span> var1ndigits, <span class="Type">int</span> var1weight,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> *var2digits, <span class="Type">int</span> var2ndigits, <span class="Type">int</span> var2weight)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i1 = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i2 = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> digits <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the first common digit */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (var1weight &gt; var2weight &amp;&amp; i1 &lt; var1ndigits)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var1digits[i1++] != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; var1weight--;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (var2weight &gt; var1weight &amp;&amp; i2 &lt; var2ndigits)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var2digits[i2++] != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; var2weight--;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* At this point, either w1 == w2 or we've run out of digits */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (var1weight == var2weight)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (i1 &lt; var1ndigits &amp;&amp; i2 &lt; var2ndigits)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stat = var1digits[i1++] - var2digits[i2++];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (stat)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (stat &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * At this point, we've run out of digits on one side or the other; so <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * remaining nonzero digits imply that side is larger<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (i1 &lt; var1ndigits)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var1digits[i1++] != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (i2 &lt; var2ndigits)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var2digits[i2++] != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L11582" title="utils/adt/numeric.c:11582">add_abs</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Add the absolute <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of two variables into result.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; result might point to one of the operands without danger.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L11582">&#x200c;</a></span><span class="linkable">add_abs</span>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var1, <span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var2, <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *result)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> *res_buf;<br/></li>
<li>&nbsp; &nbsp; <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> *res_digits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res_ndigits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res_weight;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res_rscale,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rscale1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rscale2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res_dscale;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; carry = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* copy these <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> into local <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> for speed in inner loop */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var1ndigits = var1-&gt;ndigits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var2ndigits = var2-&gt;ndigits;<br/></li>
<li>&nbsp; &nbsp; <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> *var1digits = var1-&gt;digits;<br/></li>
<li>&nbsp; &nbsp; <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> *var2digits = var2-&gt;digits;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res_weight = Max(var1-&gt;weight, var2-&gt;weight) + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res_dscale = Max(var1-&gt;dscale, var2-&gt;dscale);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Note: here we are figuring rscale in base-<a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> digits */<br/></li>
<li></span>&nbsp; &nbsp; rscale1 = var1-&gt;ndigits - var1-&gt;weight - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; rscale2 = var2-&gt;ndigits - var2-&gt;weight - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; res_rscale = Max(rscale1, rscale2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res_ndigits = res_rscale + res_weight + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (res_ndigits &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res_ndigits = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res_buf = <a href="#L476" title="utils/adt/numeric.c:476">digitbuf_alloc</a>(res_ndigits + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; res_buf[<span class="Constant">0</span>] = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* spare digit for later rounding */<br/></li>
<li></span>&nbsp; &nbsp; res_digits = res_buf + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; i1 = res_rscale + var1-&gt;weight + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; i2 = res_rscale + var2-&gt;weight + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = res_ndigits - <span class="Constant">1</span>; i &gt;= <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i1--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i2--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i1 &gt;= <span class="Constant">0</span> &amp;&amp; i1 &lt; var1ndigits)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; carry += var1digits[i1];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i2 &gt;= <span class="Constant">0</span> &amp;&amp; i2 &lt; var2ndigits)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; carry += var2digits[i2];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (carry &gt;= <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res_digits[i] = carry - <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; carry = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res_digits[i] = carry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; carry = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(carry == <span class="Constant">0</span>);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* else we failed to allow for carry out */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="#L478" title="utils/adt/numeric.c:478">digitbuf_free</a>(result-&gt;buf);<br/></li>
<li>&nbsp; &nbsp; result-&gt;ndigits = res_ndigits;<br/></li>
<li>&nbsp; &nbsp; result-&gt;buf = res_buf;<br/></li>
<li>&nbsp; &nbsp; result-&gt;digits = res_digits;<br/></li>
<li>&nbsp; &nbsp; result-&gt;weight = res_weight;<br/></li>
<li>&nbsp; &nbsp; result-&gt;dscale = res_dscale;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Remove leading/trailing zeroes */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L11917" title="utils/adt/numeric.c:11917">strip_var</a>(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L11667" title="utils/adt/numeric.c:11667">sub_abs</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Subtract the absolute value of var2 from the absolute value of var1<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; and store in result. result might point to one of the operands<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; without danger.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; ABS(var1) MUST BE GREATER OR EQUAL ABS(var2) !!!<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L11667">&#x200c;</a></span><span class="linkable">sub_abs</span>(<span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var1, <span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var2, <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *result)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> *res_buf;<br/></li>
<li>&nbsp; &nbsp; <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> *res_digits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res_ndigits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res_weight;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res_rscale,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rscale1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rscale2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res_dscale;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; borrow = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* copy these <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> into local <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> for speed in inner loop */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var1ndigits = var1-&gt;ndigits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var2ndigits = var2-&gt;ndigits;<br/></li>
<li>&nbsp; &nbsp; <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> *var1digits = var1-&gt;digits;<br/></li>
<li>&nbsp; &nbsp; <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> *var2digits = var2-&gt;digits;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res_weight = var1-&gt;weight;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res_dscale = Max(var1-&gt;dscale, var2-&gt;dscale);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Note: here we are figuring rscale in base-<a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> digits */<br/></li>
<li></span>&nbsp; &nbsp; rscale1 = var1-&gt;ndigits - var1-&gt;weight - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; rscale2 = var2-&gt;ndigits - var2-&gt;weight - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; res_rscale = Max(rscale1, rscale2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res_ndigits = res_rscale + res_weight + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (res_ndigits &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res_ndigits = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res_buf = <a href="#L476" title="utils/adt/numeric.c:476">digitbuf_alloc</a>(res_ndigits + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; res_buf[<span class="Constant">0</span>] = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* spare digit for later rounding */<br/></li>
<li></span>&nbsp; &nbsp; res_digits = res_buf + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; i1 = res_rscale + var1-&gt;weight + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; i2 = res_rscale + var2-&gt;weight + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = res_ndigits - <span class="Constant">1</span>; i &gt;= <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i1--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i2--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i1 &gt;= <span class="Constant">0</span> &amp;&amp; i1 &lt; var1ndigits)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; borrow += var1digits[i1];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i2 &gt;= <span class="Constant">0</span> &amp;&amp; i2 &lt; var2ndigits)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; borrow -= var2digits[i2];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (borrow &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res_digits[i] = borrow + <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; borrow = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res_digits[i] = borrow;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; borrow = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(borrow == <span class="Constant">0</span>);&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* else caller gave us var1 &lt; var2 */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="#L478" title="utils/adt/numeric.c:478">digitbuf_free</a>(result-&gt;buf);<br/></li>
<li>&nbsp; &nbsp; result-&gt;ndigits = res_ndigits;<br/></li>
<li>&nbsp; &nbsp; result-&gt;buf = res_buf;<br/></li>
<li>&nbsp; &nbsp; result-&gt;digits = res_digits;<br/></li>
<li>&nbsp; &nbsp; result-&gt;weight = res_weight;<br/></li>
<li>&nbsp; &nbsp; result-&gt;dscale = res_dscale;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Remove leading/trailing zeroes */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L11917" title="utils/adt/numeric.c:11917">strip_var</a>(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L11749" title="utils/adt/numeric.c:11749">round_var</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Round the value of a variable to no more than rscale decimal digits<br/></li>
<li></span><span class="Comment"> * after the decimal point.&nbsp; <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: we allow rscale &lt; 0 here, implying<br/></li>
<li></span><span class="Comment"> * rounding <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the decimal point.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L11749">&#x200c;</a></span><span class="linkable">round_var</span>(<a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var, <span class="Type">int</span> rscale)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> *digits = var-&gt;digits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; di;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndigits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; carry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; var-&gt;dscale = rscale;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* decimal digits wanted */<br/></li>
<li></span>&nbsp; &nbsp; di = (var-&gt;weight + <span class="Constant">1</span>) * <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> + rscale;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If di = 0, the value loses all digits, but could round up to 1 if its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * first extra digit is &gt;= 5.&nbsp; If di &lt; 0 the result must be 0.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (di &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; var-&gt;ndigits = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; var-&gt;weight = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; var-&gt;sign = <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> digits wanted */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ndigits = (di + <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> - <span class="Constant">1</span>) / <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* 0, or number of decimal digits to keep in last <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> digit */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; di %= <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ndigits &lt; var-&gt;ndigits ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (ndigits == var-&gt;ndigits &amp;&amp; di &gt; <span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;ndigits = ndigits;<br/></li>
<li><br/></li>
<li><span class="PreProc">#if <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> == </span><span class="Constant">1<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* di must be zero */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; carry = (digits[ndigits] &gt;= <a href="#L96" title="utils/adt/numeric.c:96">HALF_NBASE</a>) ? <span class="Constant">1</span> : <span class="Constant">0</span>;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (di == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; carry = (digits[ndigits] &gt;= <a href="#L96" title="utils/adt/numeric.c:96">HALF_NBASE</a>) ? <span class="Constant">1</span> : <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must round within last <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> digit */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; extra,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pow10;<br/></li>
<li><br/></li>
<li><span class="PreProc">#if <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> == </span><span class="Constant">4<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pow10 = <a href="#L459" title="utils/adt/numeric.c:459">round_powers</a>[di];<br/></li>
<li><span class="PreProc">#elif <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> == </span><span class="Constant">2<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pow10 = <span class="Constant">10</span>;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span><span class="PreProc">#error unsupported <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a><br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; extra = digits[--ndigits] % pow10;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; digits[ndigits] -= extra;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; carry = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (extra &gt;= pow10 / <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pow10 += digits[ndigits];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pow10 &gt;= <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pow10 -= <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; carry = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; digits[ndigits] = pow10;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Propagate carry if needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (carry)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; carry += digits[--ndigits];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (carry &gt;= <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; digits[ndigits] = carry - <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; carry = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; digits[ndigits] = carry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; carry = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ndigits &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(ndigits == -<span class="Constant">1</span>);&nbsp; &nbsp; <span class="Comment">/* better not have added &gt; 1 digit */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(var-&gt;digits &gt; var-&gt;buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;digits--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;ndigits++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;weight++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L11855" title="utils/adt/numeric.c:11855">trunc_var</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Truncate (towards zero) the value of a variable at rscale decimal digits<br/></li>
<li></span><span class="Comment"> * after the decimal point.&nbsp; <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: we allow rscale &lt; 0 here, implying<br/></li>
<li></span><span class="Comment"> * truncation <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the decimal point.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L11855">&#x200c;</a></span><span class="linkable">trunc_var</span>(<a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var, <span class="Type">int</span> rscale)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; di;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndigits;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; var-&gt;dscale = rscale;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* decimal digits wanted */<br/></li>
<li></span>&nbsp; &nbsp; di = (var-&gt;weight + <span class="Constant">1</span>) * <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> + rscale;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If di &lt;= 0, the value loses all digits.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (di &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; var-&gt;ndigits = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; var-&gt;weight = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; var-&gt;sign = <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> digits wanted */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ndigits = (di + <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> - <span class="Constant">1</span>) / <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ndigits &lt;= var-&gt;ndigits)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;ndigits = ndigits;<br/></li>
<li><br/></li>
<li><span class="PreProc">#if <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> == </span><span class="Constant">1<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no within-digit stuff to worry about */<br/></li>
<li></span><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* 0, or number of decimal digits to keep in last <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> digit */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; di %= <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (di &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must truncate within last <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> digit */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> *digits = var-&gt;digits;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; extra,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pow10;<br/></li>
<li><br/></li>
<li><span class="PreProc">#if <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> == </span><span class="Constant">4<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pow10 = <a href="#L459" title="utils/adt/numeric.c:459">round_powers</a>[di];<br/></li>
<li><span class="PreProc">#elif <a href="#L97" title="utils/adt/numeric.c:97">DEC_DIGITS</a> == </span><span class="Constant">2<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pow10 = <span class="Constant">10</span>;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span><span class="PreProc">#error unsupported <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a><br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; extra = digits[--ndigits] % pow10;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; digits[ndigits] -= extra;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L11917" title="utils/adt/numeric.c:11917">strip_var</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Strip <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> leading and trailing zeroes from a <a href="#L1237" title="utils/adt/numeric.c:1237">numeric</a> variable<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L11917">&#x200c;</a></span><span class="linkable">strip_var</span>(<a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *var)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> *digits = var-&gt;digits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndigits = var-&gt;ndigits;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Strip leading zeroes */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (ndigits &gt; <span class="Constant">0</span> &amp;&amp; *digits == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; digits++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; var-&gt;weight--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ndigits--;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Strip trailing zeroes */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (ndigits &gt; <span class="Constant">0</span> &amp;&amp; digits[ndigits - <span class="Constant">1</span>] == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ndigits--;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If it's zero, normalize the sign and weight */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ndigits == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; var-&gt;sign = <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; var-&gt;weight = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; var-&gt;digits = digits;<br/></li>
<li>&nbsp; &nbsp; var-&gt;ndigits = ndigits;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Fast sum accumulator <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Reset the accumulator's value to zero.&nbsp; The buffers to hold the digits<br/></li>
<li></span><span class="Comment"> * are not free'd.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L11958">&#x200c;</a></span><span class="linkable">accum_sum_reset</span>(<a href="#L370" title="utils/adt/numeric.c:370">NumericSumAccum</a> *accum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; accum-&gt;dscale = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; accum-&gt;ndigits; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; accum-&gt;pos_digits[i] = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; accum-&gt;neg_digits[i] = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Accumulate a new value.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L11974">&#x200c;</a></span><span class="linkable">accum_sum_add</span>(<a href="#L370" title="utils/adt/numeric.c:370">NumericSumAccum</a> *accum, <span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *val)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp;&nbsp; *accum_digits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val_i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val_ndigits;<br/></li>
<li>&nbsp; &nbsp; <a href="#L101" title="utils/adt/numeric.c:101">NumericDigit</a> *val_digits;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we have accumulated too many <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> since the last carry<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * propagation, do it <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, to avoid overflowing.&nbsp; (We could allow more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * than <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> - 1, if we reserved two extra digits, rather than one, for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * carry propagation.&nbsp; But even with <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> - 1, this needs to be done so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * seldom, that the performance difference is negligible.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (accum-&gt;num_uncarried == <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a> - <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L12022" title="utils/adt/numeric.c:12022">accum_sum_carry</a>(accum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Adjust the weight or scale of the old value, so that it can accommodate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the new value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L12095" title="utils/adt/numeric.c:12095">accum_sum_rescale</a>(accum, val);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (val-&gt;sign == <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; accum_digits = accum-&gt;pos_digits;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; accum_digits = accum-&gt;neg_digits;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* copy these <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> into local <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> for speed in loop */<br/></li>
<li></span>&nbsp; &nbsp; val_ndigits = val-&gt;ndigits;<br/></li>
<li>&nbsp; &nbsp; val_digits = val-&gt;digits;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; i = accum-&gt;weight - val-&gt;weight;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (val_i = <span class="Constant">0</span>; val_i &lt; val_ndigits; val_i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; accum_digits[i] += (int32) val_digits[val_i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; accum-&gt;num_uncarried++;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Propagate carries.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L12022">&#x200c;</a></span><span class="linkable">accum_sum_carry</span>(<a href="#L370" title="utils/adt/numeric.c:370">NumericSumAccum</a> *accum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndigits;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp;&nbsp; *dig;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; carry;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; newdig = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If no new <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> have been added since last carry propagation, nothing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to do.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (accum-&gt;num_uncarried == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We maintain that the weight of the accumulator is always one larger<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * than needed to hold the current value, <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> carrying, to make sure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there is enough space for the possible extra digit when carry is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * propagated.&nbsp; We cannot expand the buffer here, unless we require<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * callers of <a href="#L12184" title="utils/adt/numeric.c:12184">accum_sum_final</a>() to switch to the right memory context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(accum-&gt;pos_digits[<span class="Constant">0</span>] == <span class="Constant">0</span> &amp;&amp; accum-&gt;neg_digits[<span class="Constant">0</span>] == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ndigits = accum-&gt;ndigits;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Propagate carry in the positive sum */<br/></li>
<li></span>&nbsp; &nbsp; dig = accum-&gt;pos_digits;<br/></li>
<li>&nbsp; &nbsp; carry = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = ndigits - <span class="Constant">1</span>; i &gt;= <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newdig = dig[i] + carry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newdig &gt;= <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; carry = newdig / <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newdig -= carry * <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; carry = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dig[i] = newdig;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Did we use up the digit reserved for carry propagation? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (newdig &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; accum-&gt;have_carry_space = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And the same for the negative sum */<br/></li>
<li></span>&nbsp; &nbsp; dig = accum-&gt;neg_digits;<br/></li>
<li>&nbsp; &nbsp; carry = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = ndigits - <span class="Constant">1</span>; i &gt;= <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newdig = dig[i] + carry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newdig &gt;= <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; carry = newdig / <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newdig -= carry * <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; carry = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dig[i] = newdig;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newdig &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; accum-&gt;have_carry_space = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; accum-&gt;num_uncarried = <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Re-scale accumulator to accommodate new value.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the new value has more digits than the current digit buffers in the<br/></li>
<li></span><span class="Comment"> * accumulator, enlarge the buffers.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L12095">&#x200c;</a></span><span class="linkable">accum_sum_rescale</span>(<a href="#L370" title="utils/adt/numeric.c:370">NumericSumAccum</a> *accum, <span class="Type">const</span> <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *val)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_weight = accum-&gt;weight;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_ndigits = accum-&gt;ndigits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; accum_ndigits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; accum_weight;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; accum_rscale;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val_rscale;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; accum_weight = old_weight;<br/></li>
<li>&nbsp; &nbsp; accum_ndigits = old_ndigits;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Does the new value have a larger weight? If so, enlarge the buffers,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and shift the existing value to the new weight, by adding leading<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * zeros.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We enforce that the accumulator always has a weight one larger than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * needed for the inputs, so that we have space for an extra digit at the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * final carry-propagation phase, if necessary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (val-&gt;weight &gt;= accum_weight)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; accum_weight = val-&gt;weight + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; accum_ndigits = accum_ndigits + (accum_weight - old_weight);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Even though the new value is small, we might've used up the space<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reserved for the carry digit in the last call to <a href="#L12022" title="utils/adt/numeric.c:12022">accum_sum_carry</a>().&nbsp; If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so, enlarge to make room for another one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!accum-&gt;have_carry_space)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; accum_weight++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; accum_ndigits++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Is the new value wider on the right side? */<br/></li>
<li></span>&nbsp; &nbsp; accum_rscale = accum_ndigits - accum_weight - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; val_rscale = val-&gt;ndigits - val-&gt;weight - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (val_rscale &gt; accum_rscale)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; accum_ndigits = accum_ndigits + (val_rscale - accum_rscale);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (accum_ndigits != old_ndigits ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; accum_weight != old_weight)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp;&nbsp; *new_pos_digits;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp;&nbsp; *new_neg_digits;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; weightdiff;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; weightdiff = accum_weight - old_weight;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; new_pos_digits = <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(accum_ndigits * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int32));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; new_neg_digits = <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(accum_ndigits * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int32));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (accum-&gt;pos_digits)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;new_pos_digits[weightdiff], accum-&gt;pos_digits,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; old_ndigits * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int32));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(accum-&gt;pos_digits);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;new_neg_digits[weightdiff], accum-&gt;neg_digits,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; old_ndigits * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int32));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(accum-&gt;neg_digits);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; accum-&gt;pos_digits = new_pos_digits;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; accum-&gt;neg_digits = new_neg_digits;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; accum-&gt;weight = accum_weight;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; accum-&gt;ndigits = accum_ndigits;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(accum-&gt;pos_digits[<span class="Constant">0</span>] == <span class="Constant">0</span> &amp;&amp; accum-&gt;neg_digits[<span class="Constant">0</span>] == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; accum-&gt;have_carry_space = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (val-&gt;dscale &gt; accum-&gt;dscale)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; accum-&gt;dscale = val-&gt;dscale;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the current value of the accumulator.&nbsp; This perform final carry<br/></li>
<li></span><span class="Comment"> * propagation, and adds together the positive and negative sums.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Unlike all the other routines, the caller is not required to switch to<br/></li>
<li></span><span class="Comment"> * the memory context that holds the accumulator.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L12184">&#x200c;</a></span><span class="linkable">accum_sum_final</span>(<a href="#L370" title="utils/adt/numeric.c:370">NumericSumAccum</a> *accum, <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a> *result)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; pos_var;<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; neg_var;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (accum-&gt;ndigits == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7468" title="utils/adt/numeric.c:7468">set_var_from_var</a>(&amp;<a href="#L415" title="utils/adt/numeric.c:415">const_zero</a>, result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Perform final carry */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L12022" title="utils/adt/numeric.c:12022">accum_sum_carry</a>(accum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create NumericVars representing the positive and negative sums */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;pos_var);<br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;neg_var);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pos_var.ndigits = neg_var.ndigits = accum-&gt;ndigits;<br/></li>
<li>&nbsp; &nbsp; pos_var.weight = neg_var.weight = accum-&gt;weight;<br/></li>
<li>&nbsp; &nbsp; pos_var.dscale = neg_var.dscale = accum-&gt;dscale;<br/></li>
<li>&nbsp; &nbsp; pos_var.sign = <a href="#L165" title="utils/adt/numeric.c:165">NUMERIC_POS</a>;<br/></li>
<li>&nbsp; &nbsp; neg_var.sign = <a href="#L166" title="utils/adt/numeric.c:166">NUMERIC_NEG</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pos_var.buf = pos_var.digits = <a href="#L476" title="utils/adt/numeric.c:476">digitbuf_alloc</a>(accum-&gt;ndigits);<br/></li>
<li>&nbsp; &nbsp; neg_var.buf = neg_var.digits = <a href="#L476" title="utils/adt/numeric.c:476">digitbuf_alloc</a>(accum-&gt;ndigits);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; accum-&gt;ndigits; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(accum-&gt;pos_digits[i] &lt; <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pos_var.digits[i] = (int16) accum-&gt;pos_digits[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(accum-&gt;neg_digits[i] &lt; <a href="#L95" title="utils/adt/numeric.c:95">NBASE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; neg_var.digits[i] = (int16) accum-&gt;neg_digits[i];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And add them together */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L8431" title="utils/adt/numeric.c:8431">add_var</a>(&amp;pos_var, &amp;neg_var, result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Remove leading/trailing zeroes */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L11917" title="utils/adt/numeric.c:11917">strip_var</a>(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Copy an accumulator's state.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'dst' is assumed to be uninitialized beforehand.&nbsp; No attempt is made at<br/></li>
<li></span><span class="Comment"> * freeing old <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L12235">&#x200c;</a></span><span class="linkable">accum_sum_copy</span>(<a href="#L370" title="utils/adt/numeric.c:370">NumericSumAccum</a> *dst, <a href="#L370" title="utils/adt/numeric.c:370">NumericSumAccum</a> *src)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dst-&gt;pos_digits = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(src-&gt;ndigits * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int32));<br/></li>
<li>&nbsp; &nbsp; dst-&gt;neg_digits = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(src-&gt;ndigits * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int32));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memcpy(dst-&gt;pos_digits, src-&gt;pos_digits, src-&gt;ndigits * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int32));<br/></li>
<li>&nbsp; &nbsp; memcpy(dst-&gt;neg_digits, src-&gt;neg_digits, src-&gt;ndigits * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int32));<br/></li>
<li>&nbsp; &nbsp; dst-&gt;num_uncarried = src-&gt;num_uncarried;<br/></li>
<li>&nbsp; &nbsp; dst-&gt;ndigits = src-&gt;ndigits;<br/></li>
<li>&nbsp; &nbsp; dst-&gt;weight = src-&gt;weight;<br/></li>
<li>&nbsp; &nbsp; dst-&gt;dscale = src-&gt;dscale;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Add the current value of 'accum2' into 'accum'.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L12252">&#x200c;</a></span><span class="linkable">accum_sum_combine</span>(<a href="#L370" title="utils/adt/numeric.c:370">NumericSumAccum</a> *accum, <a href="#L370" title="utils/adt/numeric.c:370">NumericSumAccum</a> *accum2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="utils/adt/numeric.c:303">NumericVar</a>&nbsp; &nbsp; tmp_var;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L484" title="utils/adt/numeric.c:484">init_var</a>(&amp;tmp_var);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L12184" title="utils/adt/numeric.c:12184">accum_sum_final</a>(accum2, &amp;tmp_var);<br/></li>
<li>&nbsp; &nbsp; <a href="#L11974" title="utils/adt/numeric.c:11974">accum_sum_add</a>(accum, &amp;tmp_var);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6969" title="utils/adt/numeric.c:6969">free_var</a>(&amp;tmp_var);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
