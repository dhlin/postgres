<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/adt/array_typanalyze.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/adt/array_typanalyze.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L65">array_extra_data</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L57">ArrayAnalyzeExtraData</a></li>
<li><a href="#L81">DECountItem</a></li>
<li><a href="#L74">TrackItem</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L98">array_typanalyze</a></li>
<li><a href="#L216">compute_array_stats</a></li>
<li><a href="#L780">countitem_compare_count</a></li>
<li><a href="#L740">element_compare</a></li>
<li><a href="#L710">element_hash</a></li>
<li><a href="#L725">element_match</a></li>
<li><a href="#L681">prune_element_hashtable</a></li>
<li><a href="#L768">trackitem_compare_element</a></li>
<li><a href="#L756">trackitem_compare_frequencies_desc</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L33">ARRAY_WIDTH_THRESHOLD</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L98" title="utils/adt/array_typanalyze.c:98">array_typanalyze</a>.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Functions for gathering statistics from array columns<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/adt/<a href="#L98" title="utils/adt/array_typanalyze.c:98">array_typanalyze</a>.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/detoast.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/<a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/array.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/datum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgrprotos.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/typcache.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * To avoid consuming too much memory, IO and CPU load during analysis, and/or<br/></li>
<li></span><span class="Comment"> * too much space in the resulting pg_statistic rows, we ignore arrays that<br/></li>
<li></span><span class="Comment"> * are wider than <a href="#L33" title="utils/adt/array_typanalyze.c:33">ARRAY_WIDTH_THRESHOLD</a> (after detoasting!).&nbsp; Note that this<br/></li>
<li></span><span class="Comment"> * number is considerably more than the similar <a href="../../statistics/extended_stats.c.html#L58" title="statistics/extended_stats.c:58">WIDTH_THRESHOLD</a> limit used<br/></li>
<li></span><span class="Comment"> * in <a href="../../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a>.c's standard typanalyze code.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L33">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ARRAY_WIDTH_THRESHOLD</span> </span><span class="Constant">0x10000<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Extra data for <a href="#L216" title="utils/adt/array_typanalyze.c:216">compute_array_stats</a> function */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Information about array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type_id;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type's OID */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eq_opr;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* default equality operator's OID */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; coll_id;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* collation to use */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; typbyval;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* physical properties of <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type */<br/></li>
<li></span>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; typlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; typalign;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Lookup data for <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type's comparison and <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> (these are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in the type's typcache entry, which we expect to remain valid over the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lifespan of the ANALYZE run)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; FmgrInfo&nbsp;&nbsp; *<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a>;<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp;&nbsp; *<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Saved state from <a href="../../commands/analyze.c.html#L1840" title="commands/analyze.c:1840">std_typanalyze</a>() */<br/></li>
<li></span>&nbsp; &nbsp; AnalyzeAttrComputeStatsFunc std_compute_stats;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *std_extra_data;<br/></li>
<li><a id="L57">&#x200c;</a>} <span class="linkable">ArrayAnalyzeExtraData</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * While <a href="#L216" title="utils/adt/array_typanalyze.c:216">compute_array_stats</a> is running, we keep a pointer to the extra data<br/></li>
<li></span><span class="Comment"> * here for use by assorted subroutines.&nbsp; <a href="#L216" title="utils/adt/array_typanalyze.c:216">compute_array_stats</a> doesn't<br/></li>
<li></span><span class="Comment"> * currently need to be re-entrant, so avoiding this is not worth the extra<br/></li>
<li></span><span class="Comment"> * notational cruft that would be needed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L65">&#x200c;</a></span><span class="Type">static</span> <a href="#L57" title="utils/adt/array_typanalyze.c:57">ArrayAnalyzeExtraData</a> *<span class="linkable">array_extra_data</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* A <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table entry for the Lossy Counting algorithm */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; key;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This is 'e' from the LC algorithm. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; frequency;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This is 'f'. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; delta;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* And this is 'delta'. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last_container; <span class="Comment">/* For de-duplication of array elements. */<br/></li>
<li><a id="L74">&#x200c;</a></span>} <span class="linkable">TrackItem</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* A <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table entry for distinct-elements counts */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Count of distinct elements in an array */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; frequency;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Number of arrays seen with this count */<br/></li>
<li><a id="L81">&#x200c;</a></span>} <span class="linkable">DECountItem</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L216" title="utils/adt/array_typanalyze.c:216">compute_array_stats</a>(VacAttrStats *stats,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AnalyzeAttrFetchFunc fetchfunc, <span class="Type">int</span> samplerows, <span class="Type">double</span> totalrows);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L681" title="utils/adt/array_typanalyze.c:681">prune_element_hashtable</a>(<a href="../hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *elements_tab, <span class="Type">int</span> b_current);<br/></li>
<li><span class="Type">static</span> uint32 <a href="#L710" title="utils/adt/array_typanalyze.c:710">element_hash</a>(<span class="Type">const</span> <span class="Type">void</span> *key, Size keysize);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L725" title="utils/adt/array_typanalyze.c:725">element_match</a>(<span class="Type">const</span> <span class="Type">void</span> *key1, <span class="Type">const</span> <span class="Type">void</span> *key2, Size keysize);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="array_selfuncs.c.html#L1165" title="utils/adt/array_selfuncs.c:1165">element_compare</a>(<span class="Type">const</span> <span class="Type">void</span> *key1, <span class="Type">const</span> <span class="Type">void</span> *key2);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L756" title="utils/adt/array_typanalyze.c:756">trackitem_compare_frequencies_desc</a>(<span class="Type">const</span> <span class="Type">void</span> *e1, <span class="Type">const</span> <span class="Type">void</span> *e2, <span class="Type">void</span> *arg);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L768" title="utils/adt/array_typanalyze.c:768">trackitem_compare_element</a>(<span class="Type">const</span> <span class="Type">void</span> *e1, <span class="Type">const</span> <span class="Type">void</span> *e2, <span class="Type">void</span> *arg);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L780" title="utils/adt/array_typanalyze.c:780">countitem_compare_count</a>(<span class="Type">const</span> <span class="Type">void</span> *e1, <span class="Type">const</span> <span class="Type">void</span> *e2, <span class="Type">void</span> *arg);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L98" title="utils/adt/array_typanalyze.c:98">array_typanalyze</a> -- typanalyze function for array columns<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L98">&#x200c;</a><span class="linkable">array_typanalyze</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; VacAttrStats *stats = (VacAttrStats *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; element_typeid;<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typentry;<br/></li>
<li>&nbsp; &nbsp; <a href="#L57" title="utils/adt/array_typanalyze.c:57">ArrayAnalyzeExtraData</a> *extra_data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Call the standard typanalyze function.&nbsp; It may fail to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> needed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operators, in which case we also can't do anything, so just fail.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../commands/analyze.c.html#L1840" title="commands/analyze.c:1840">std_typanalyze</a>(stats))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check attribute data type is a varlena array (or a domain over one).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; element_typeid = <a href="../cache/lsyscache.c.html#L2832" title="utils/cache/lsyscache.c:2832">get_base_element_type</a>(stats-&gt;attrtypid);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(element_typeid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L98" title="utils/adt/array_typanalyze.c:98">array_typanalyze</a> was invoked for non-array type </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; stats-&gt;attrtypid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Gather information about the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type.&nbsp; If we fail to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * something, return leaving the state from <a href="../../commands/analyze.c.html#L1840" title="commands/analyze.c:1840">std_typanalyze</a>() in place.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; typentry = <a href="../cache/typcache.c.html#L346" title="utils/cache/typcache.c:346">lookup_type_cache</a>(element_typeid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TYPECACHE_EQ_OPR |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TYPECACHE_CMP_PROC_FINFO |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TYPECACHE_HASH_PROC_FINFO);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(typentry-&gt;eq_opr) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !OidIsValid(typentry-&gt;cmp_proc_finfo.fn_oid) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !OidIsValid(typentry-&gt;hash_proc_finfo.fn_oid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Store our findings for use by <a href="#L216" title="utils/adt/array_typanalyze.c:216">compute_array_stats</a>() */<br/></li>
<li></span>&nbsp; &nbsp; extra_data = (<a href="#L57" title="utils/adt/array_typanalyze.c:57">ArrayAnalyzeExtraData</a> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L57" title="utils/adt/array_typanalyze.c:57">ArrayAnalyzeExtraData</a>));<br/></li>
<li>&nbsp; &nbsp; extra_data-&gt;type_id = typentry-&gt;type_id;<br/></li>
<li>&nbsp; &nbsp; extra_data-&gt;eq_opr = typentry-&gt;eq_opr;<br/></li>
<li>&nbsp; &nbsp; extra_data-&gt;coll_id = stats-&gt;attrcollid;&nbsp; &nbsp; <span class="Comment">/* collation we should use */<br/></li>
<li></span>&nbsp; &nbsp; extra_data-&gt;typbyval = typentry-&gt;typbyval;<br/></li>
<li>&nbsp; &nbsp; extra_data-&gt;typlen = typentry-&gt;typlen;<br/></li>
<li>&nbsp; &nbsp; extra_data-&gt;typalign = typentry-&gt;typalign;<br/></li>
<li>&nbsp; &nbsp; extra_data-&gt;<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = &amp;typentry-&gt;cmp_proc_finfo;<br/></li>
<li>&nbsp; &nbsp; extra_data-&gt;<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> = &amp;typentry-&gt;hash_proc_finfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Save old compute_stats and extra_data for scalar statistics ... */<br/></li>
<li></span>&nbsp; &nbsp; extra_data-&gt;std_compute_stats = stats-&gt;compute_stats;<br/></li>
<li>&nbsp; &nbsp; extra_data-&gt;std_extra_data = stats-&gt;extra_data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ... and replace with our info */<br/></li>
<li></span>&nbsp; &nbsp; stats-&gt;compute_stats = <a href="#L216" title="utils/adt/array_typanalyze.c:216">compute_array_stats</a>;<br/></li>
<li>&nbsp; &nbsp; stats-&gt;extra_data = extra_data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note we leave stats-&gt;minrows set as <a href="../../commands/analyze.c.html#L1840" title="commands/analyze.c:1840">std_typanalyze</a> set it.&nbsp; Should it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be increased for array analysis purposes?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L216" title="utils/adt/array_typanalyze.c:216">compute_array_stats</a>() -- compute statistics for an array column<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function computes statistics useful for determining selectivity of<br/></li>
<li></span><span class="Comment"> * the array operators &lt;@, &amp;&amp;, and @&gt;.&nbsp; It is invoked by ANALYZE via the<br/></li>
<li></span><span class="Comment"> * compute_stats hook after sample rows have been collected.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We also invoke the standard compute_stats function, which will compute<br/></li>
<li></span><span class="Comment"> * &quot;scalar&quot; statistics relevant to the btree-style array comparison operators.<br/></li>
<li></span><span class="Comment"> * However, exact duplicates of an entire array may be rare despite many<br/></li>
<li></span><span class="Comment"> * arrays sharing individual elements.&nbsp; This especially afflicts long arrays,<br/></li>
<li></span><span class="Comment"> * which are also liable to lack all scalar statistics due to the low<br/></li>
<li></span><span class="Comment"> * <a href="../../statistics/extended_stats.c.html#L58" title="statistics/extended_stats.c:58">WIDTH_THRESHOLD</a> used in <a href="../../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a>.c.&nbsp; So, in addition to the standard stats,<br/></li>
<li></span><span class="Comment"> * we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the most common array elements and compute a histogram of distinct<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> counts.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The algorithm used is Lossy Counting, as proposed in the paper &quot;Approximate<br/></li>
<li></span><span class="Comment"> * frequency counts over data streams&quot; by G. S. Manku and R. Motwani, in<br/></li>
<li></span><span class="Comment"> * Proceedings of the 28th International Conference on Very Large Data Bases,<br/></li>
<li></span><span class="Comment"> * Hong Kong, China, August 2002, section 4.2. The paper is available at<br/></li>
<li></span><span class="Comment"> * http://www.vldb.org/conf/2002/S10P03.pdf<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The Lossy Counting (aka LC) algorithm goes like this:<br/></li>
<li></span><span class="Comment"> * Let s be the threshold frequency for an item (the minimum frequency we<br/></li>
<li></span><span class="Comment"> * are interested in) and epsilon the error margin for the frequency. Let D<br/></li>
<li></span><span class="Comment"> * be a set of triples (e, f, delta), where e is an <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> value, f is that<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>'s frequency (actually, its current occurrence count) and delta is<br/></li>
<li></span><span class="Comment"> * the maximum error in f. We start with D empty and process the elements in<br/></li>
<li></span><span class="Comment"> * batches of size w. (The batch size is also known as &quot;bucket size&quot; and is<br/></li>
<li></span><span class="Comment"> * <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to 1/epsilon.) Let the current batch number be b_current, starting<br/></li>
<li></span><span class="Comment"> * with 1. For each <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> e we either increment its f count, if it's<br/></li>
<li></span><span class="Comment"> * already in D, or insert a new triple into D with <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> (e, 1, b_current<br/></li>
<li></span><span class="Comment"> * - 1). After processing each batch we prune D, by removing from it all<br/></li>
<li></span><span class="Comment"> * elements with f + delta &lt;= b_current.&nbsp; After the algorithm finishes we<br/></li>
<li></span><span class="Comment"> * suppress all elements from D that do not satisfy f &gt;= (s - epsilon) * N,<br/></li>
<li></span><span class="Comment"> * where N is the total number of elements in the input.&nbsp; We emit the<br/></li>
<li></span><span class="Comment"> * remaining elements with estimated frequency f/N.&nbsp; The LC paper proves<br/></li>
<li></span><span class="Comment"> * that this algorithm finds all elements with true frequency at least s,<br/></li>
<li></span><span class="Comment"> * and that no frequency is overestimated or is underestimated by more than<br/></li>
<li></span><span class="Comment"> * epsilon.&nbsp; Furthermore, given reasonable assumptions about the input<br/></li>
<li></span><span class="Comment"> * distribution, the required table size is no more than about 7 times w.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In the absence of a principled basis for other particular <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, we<br/></li>
<li></span><span class="Comment"> * follow <a href="../../tsearch/ts_typanalyze.c.html#L58" title="tsearch/ts_typanalyze.c:58">ts_typanalyze</a>() and use parameters s = 0.07/K, epsilon = s/10.<br/></li>
<li></span><span class="Comment"> * But we leave out the correction for stopwords, which do not apply to<br/></li>
<li></span><span class="Comment"> * arrays.&nbsp; These parameters give bucket width w = K/0.007 and maximum<br/></li>
<li></span><span class="Comment"> * expected hashtable size of about 1000 * K.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Elements may <a href="../../regex/regcomp.c.html#L1584" title="regex/regcomp.c:1584">repeat</a> within an array.&nbsp; Since duplicates do not change the<br/></li>
<li></span><span class="Comment"> * behavior of &lt;@, &amp;&amp; or @&gt;, we want to count each <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> only once per<br/></li>
<li></span><span class="Comment"> * array.&nbsp; Therefore, we store in the finished pg_statistic entry each<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>'s frequency as the fraction of all non-null rows that contain it.<br/></li>
<li></span><span class="Comment"> * We divide the raw counts by nonnull_cnt to get those figures.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L216">&#x200c;</a></span><span class="linkable">compute_array_stats</span>(VacAttrStats *stats, AnalyzeAttrFetchFunc fetchfunc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> samplerows, <span class="Type">double</span> totalrows)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L57" title="utils/adt/array_typanalyze.c:57">ArrayAnalyzeExtraData</a> *extra_data;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_mcelem;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; null_elem_cnt = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; analyzed_rows = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This is D from the LC algorithm. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a>&nbsp; &nbsp; &nbsp;&nbsp; *elements_tab;<br/></li>
<li>&nbsp; &nbsp; HASHCTL&nbsp; &nbsp; &nbsp; &nbsp; elem_hash_ctl;<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS scan_status;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This is the current bucket number from the LC algorithm */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b_current;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This is 'w' from the LC algorithm */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bucket_width;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; array_no;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; element_no;<br/></li>
<li>&nbsp; &nbsp; <a href="#L74" title="utils/adt/array_typanalyze.c:74">TrackItem</a>&nbsp; *item;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot_idx;<br/></li>
<li>&nbsp; &nbsp; <a href="../hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a>&nbsp; &nbsp; &nbsp;&nbsp; *count_tab;<br/></li>
<li>&nbsp; &nbsp; HASHCTL&nbsp; &nbsp; &nbsp; &nbsp; count_hash_ctl;<br/></li>
<li>&nbsp; &nbsp; <a href="#L81" title="utils/adt/array_typanalyze.c:81">DECountItem</a> *count_item;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; extra_data = (<a href="#L57" title="utils/adt/array_typanalyze.c:57">ArrayAnalyzeExtraData</a> *) stats-&gt;extra_data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Invoke <a href="../../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a>.c's standard analysis function to create scalar-style<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * stats for the column.&nbsp; It will expect its own extra_data pointer, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * temporarily install that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; stats-&gt;extra_data = extra_data-&gt;std_extra_data;<br/></li>
<li>&nbsp; &nbsp; extra_data-&gt;std_compute_stats(stats, fetchfunc, samplerows, totalrows);<br/></li>
<li>&nbsp; &nbsp; stats-&gt;extra_data = extra_data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set up static pointer for use by subroutines.&nbsp; We wait till here in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * case std_compute_stats somehow recursively invokes us (probably not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * possible, but ...)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L65" title="utils/adt/array_typanalyze.c:65">array_extra_data</a> = extra_data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We want statistics_target * 10 elements in the MCELEM array. This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * multiplier is pretty arbitrary, but is meant to reflect the fact that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the number of individual elements tracked in pg_statistic ought to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * more than the number of <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for a simple scalar column.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; num_mcelem = stats-&gt;attstattarget * <span class="Constant">10</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We set bucket width <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to num_mcelem / 0.007 as per the comment<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * above.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; bucket_width = num_mcelem * <span class="Constant">1000</span> / <span class="Constant">7</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create the hashtable. It will be in local memory, so we don't need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * worry about overflowing the initial size. Also we don't need to pay <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * attention to locking and memory management.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; elem_hash_ctl.keysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum);<br/></li>
<li>&nbsp; &nbsp; elem_hash_ctl.entrysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L74" title="utils/adt/array_typanalyze.c:74">TrackItem</a>);<br/></li>
<li>&nbsp; &nbsp; elem_hash_ctl.<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> = <a href="#L710" title="utils/adt/array_typanalyze.c:710">element_hash</a>;<br/></li>
<li>&nbsp; &nbsp; elem_hash_ctl.match = <a href="#L725" title="utils/adt/array_typanalyze.c:725">element_match</a>;<br/></li>
<li>&nbsp; &nbsp; elem_hash_ctl.hcxt = <a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li>&nbsp; &nbsp; elements_tab = <a href="../hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(<span class="Constant">&quot;Analyzed elements table&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; num_mcelem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;elem_hash_ctl,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_ELEM | HASH_FUNCTION | HASH_COMPARE | HASH_CONTEXT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* hashtable for array distinct elements counts */<br/></li>
<li></span>&nbsp; &nbsp; count_hash_ctl.keysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>);<br/></li>
<li>&nbsp; &nbsp; count_hash_ctl.entrysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L81" title="utils/adt/array_typanalyze.c:81">DECountItem</a>);<br/></li>
<li>&nbsp; &nbsp; count_hash_ctl.hcxt = <a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li>&nbsp; &nbsp; count_tab = <a href="../hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(<span class="Constant">&quot;Array distinct <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> count table&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">64</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;count_hash_ctl,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ELEM | HASH_BLOBS | HASH_CONTEXT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize counters. */<br/></li>
<li></span>&nbsp; &nbsp; b_current = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; element_no = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Loop over the arrays. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (array_no = <span class="Constant">0</span>; array_no &lt; samplerows; array_no++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; value;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ArrayType&nbsp; *array;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_elems;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *elem_values;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *elem_nulls;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; null_present;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; prev_element_no = element_no;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; distinct_count;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; count_item_found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../commands/vacuum.c.html#L2336" title="commands/vacuum.c:2336">vacuum_delay_point</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; value = fetchfunc(stats, array_no, &amp;isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ignore arrays that are null overall */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Skip too-large <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/common/detoast.c.html#L545" title="access/common/detoast.c:545">toast_raw_datum_size</a>(value) &gt; <a href="#L33" title="utils/adt/array_typanalyze.c:33">ARRAY_WIDTH_THRESHOLD</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; analyzed_rows++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now detoast the array if needed, and deconstruct into datums.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; array = DatumGetArrayTypeP(value);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(ARR_ELEMTYPE(array) == extra_data-&gt;type_id);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="arrayfuncs.c.html#L3612" title="utils/adt/arrayfuncs.c:3612">deconstruct_array</a>(array,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; extra_data-&gt;type_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; extra_data-&gt;typlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; extra_data-&gt;typbyval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; extra_data-&gt;typalign,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;elem_values, &amp;elem_nulls, &amp;num_elems);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We loop through the elements in the array and add them to our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tracking hashtable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; null_present = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = <span class="Constant">0</span>; j &lt; num_elems; j++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; elem_value;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No null <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> processing other than flag setting here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (elem_nulls[j])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; null_present = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Lookup current <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> in hashtable, adding it if new */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elem_value = elem_values[j];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item = (<a href="#L74" title="utils/adt/array_typanalyze.c:74">TrackItem</a> *) <a href="../hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(elements_tab,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;elem_value,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_ENTER, &amp;found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> value is already on the tracking list */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The operators we assist ignore duplicate array elements, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * count a given distinct <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> only once per array.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (item-&gt;last_container == array_no)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item-&gt;frequency++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item-&gt;last_container = array_no;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Initialize new tracking list <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type is pass-by-reference, we must copy it into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d space, so that we can release the array below. (We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * do this so that the space needed for <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * limited by the size of the hashtable; if we kept all the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * array <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> around, it could be much more.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item-&gt;key = <a href="datum.c.html#L132" title="utils/adt/datum.c:132">datumCopy</a>(elem_value,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; extra_data-&gt;typbyval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; extra_data-&gt;typlen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item-&gt;frequency = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item-&gt;delta = b_current - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item-&gt;last_container = array_no;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* element_no is the number of elements processed (ie N) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; element_no++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We prune the D structure after processing each bucket */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (element_no % bucket_width == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L681" title="utils/adt/array_typanalyze.c:681">prune_element_hashtable</a>(elements_tab, b_current);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b_current++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Count null <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> presence once per array. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (null_present)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; null_elem_cnt++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Update frequency of the particular array distinct <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> count. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; distinct_count = (<span class="Type">int</span>) (element_no - prev_element_no);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; count_item = (<a href="#L81" title="utils/adt/array_typanalyze.c:81">DECountItem</a> *) <a href="../hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(count_tab, &amp;distinct_count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_ENTER,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;count_item_found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (count_item_found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count_item-&gt;frequency++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count_item-&gt;frequency = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Free memory allocated while detoasting. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PointerGetDatum(array) != value)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(array);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(elem_values);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(elem_nulls);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Skip pg_statistic slots occupied by standard statistics */<br/></li>
<li></span>&nbsp; &nbsp; slot_idx = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (slot_idx &lt; STATISTIC_NUM_SLOTS &amp;&amp; stats-&gt;stakind[slot_idx] != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot_idx++;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (slot_idx &gt; STATISTIC_NUM_SLOTS - <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;insufficient pg_statistic slots for array stats&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We can only compute real stats if we found some non-null <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (analyzed_rows &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nonnull_cnt = analyzed_rows;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count_items_count;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L74" title="utils/adt/array_typanalyze.c:74">TrackItem</a> **sort_table;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; track_len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; cutoff_freq;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; minfreq,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxfreq;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We assume the standard stats code already took care of setting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * stats_valid, stanullfrac, stawidth, stadistinct.&nbsp; We'd have to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * re-compute those <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> if we wanted to not store the standard<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * stats.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Construct an array of the interesting hashtable items, that is,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * those meeting the cutoff frequency (s - epsilon)*N.&nbsp; Also identify<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the minimum and maximum frequencies among these items.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since epsilon = s/10 and bucket_width = 1/epsilon, the cutoff<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * frequency is 9*N / bucket_width.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; cutoff_freq = <span class="Constant">9</span> * element_no / bucket_width;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i = <a href="../hash/dynahash.c.html#L1341" title="utils/hash/dynahash.c:1341">hash_get_num_entries</a>(elements_tab); <span class="Comment">/* surely enough space */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sort_table = (<a href="#L74" title="utils/adt/array_typanalyze.c:74">TrackItem</a> **) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L74" title="utils/adt/array_typanalyze.c:74">TrackItem</a> *) * i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;scan_status, elements_tab);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; track_len = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; minfreq = element_no;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; maxfreq = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((item = (<a href="#L74" title="utils/adt/array_typanalyze.c:74">TrackItem</a> *) <a href="../hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;scan_status)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (item-&gt;frequency &gt; cutoff_freq)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sort_table[track_len++] = item;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; minfreq = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(minfreq, item-&gt;frequency);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxfreq = Max(maxfreq, item-&gt;frequency);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(track_len &lt;= i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* emit some statistics for debug purposes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG3, <span class="Constant">&quot;<a href="#L216" title="utils/adt/array_typanalyze.c:216">compute_array_stats</a>: target # mces = </span><span class="Special">%d</span><span class="Constant">, &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;bucket width = </span><span class="Special">%d</span><span class="Constant">, &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;# elements = &quot;</span> INT64_FORMAT <span class="Constant">&quot;, hashtable size = </span><span class="Special">%d</span><span class="Constant">, &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;usable entries = </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; num_mcelem, bucket_width, element_no, i, track_len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we obtained more elements than we really want, get rid of those<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with least frequencies.&nbsp; The easiest way is to qsort the array into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * descending frequency order and truncate the array.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (num_mcelem &lt; track_len)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qsort_interruptible(sort_table, track_len, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L74" title="utils/adt/array_typanalyze.c:74">TrackItem</a> *),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L756" title="utils/adt/array_typanalyze.c:756">trackitem_compare_frequencies_desc</a>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* reset minfreq to the smallest frequency we're keeping */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; minfreq = sort_table[num_mcelem - <span class="Constant">1</span>]-&gt;frequency;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_mcelem = track_len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Generate MCELEM slot entry */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (num_mcelem &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContext old_context;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *mcelem_values;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp;&nbsp; *mcelem_freqs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We want to store statistics sorted on the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> value using<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type's default comparison function.&nbsp; This permits<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fast binary searches in selectivity estimation <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qsort_interruptible(sort_table, num_mcelem, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L74" title="utils/adt/array_typanalyze.c:74">TrackItem</a> *),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L768" title="utils/adt/array_typanalyze.c:768">trackitem_compare_element</a>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must copy the target <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> into <a href="../../commands/analyze.c.html#L76" title="commands/analyze.c:76">anl_context</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_context = MemoryContextSwitchTo(stats-&gt;<a href="../../commands/analyze.c.html#L76" title="commands/analyze.c:76">anl_context</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We sorted statistics on the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> value, but we want to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * able to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the minimal and maximal frequencies without going<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * through all the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.&nbsp; We also want the frequency of null<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * elements.&nbsp; Store these three <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> at the end of mcelem_freqs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mcelem_values = (Datum *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(num_mcelem * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mcelem_freqs = (float4 *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>((num_mcelem + <span class="Constant">3</span>) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(float4));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * See comments above about use of nonnull_cnt as the divisor for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the final frequency estimates.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; num_mcelem; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L74" title="utils/adt/array_typanalyze.c:74">TrackItem</a>&nbsp; *titem = sort_table[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mcelem_values[i] = <a href="datum.c.html#L132" title="utils/adt/datum.c:132">datumCopy</a>(titem-&gt;key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; extra_data-&gt;typbyval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; extra_data-&gt;typlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mcelem_freqs[i] = (<span class="Type">double</span>) titem-&gt;frequency /<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">double</span>) nonnull_cnt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mcelem_freqs[i++] = (<span class="Type">double</span>) minfreq / (<span class="Type">double</span>) nonnull_cnt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mcelem_freqs[i++] = (<span class="Type">double</span>) maxfreq / (<span class="Type">double</span>) nonnull_cnt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mcelem_freqs[i++] = (<span class="Type">double</span>) null_elem_cnt / (<span class="Type">double</span>) nonnull_cnt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(old_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stats-&gt;stakind[slot_idx] = STATISTIC_KIND_MCELEM;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stats-&gt;staop[slot_idx] = extra_data-&gt;eq_opr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stats-&gt;stacoll[slot_idx] = extra_data-&gt;coll_id;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stats-&gt;stanumbers[slot_idx] = mcelem_freqs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* See above comment about extra stanumber entries */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stats-&gt;numnumbers[slot_idx] = num_mcelem + <span class="Constant">3</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stats-&gt;stavalues[slot_idx] = mcelem_values;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stats-&gt;numvalues[slot_idx] = num_mcelem;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We are storing <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stats-&gt;statypid[slot_idx] = extra_data-&gt;type_id;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stats-&gt;statyplen[slot_idx] = extra_data-&gt;typlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stats-&gt;statypbyval[slot_idx] = extra_data-&gt;typbyval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stats-&gt;statypalign[slot_idx] = extra_data-&gt;typalign;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot_idx++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Generate DECHIST slot entry */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; count_items_count = <a href="../hash/dynahash.c.html#L1341" title="utils/hash/dynahash.c:1341">hash_get_num_entries</a>(count_tab);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (count_items_count &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_hist = stats-&gt;attstattarget;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L81" title="utils/adt/array_typanalyze.c:81">DECountItem</a> **sorted_count_items;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; delta;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; frac;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp;&nbsp; *hist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* num_hist must be at least 2 for the loop below to work */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_hist = Max(num_hist, <span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Create an array of <a href="#L81" title="utils/adt/array_typanalyze.c:81">DECountItem</a> pointers, and sort them into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * increasing count order.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sorted_count_items = (<a href="#L81" title="utils/adt/array_typanalyze.c:81">DECountItem</a> **)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L81" title="utils/adt/array_typanalyze.c:81">DECountItem</a> *) * count_items_count);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;scan_status, count_tab);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((count_item = (<a href="#L81" title="utils/adt/array_typanalyze.c:81">DECountItem</a> *) <a href="../hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;scan_status)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sorted_count_items[j++] = count_item;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qsort_interruptible(sorted_count_items, count_items_count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L81" title="utils/adt/array_typanalyze.c:81">DECountItem</a> *),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L780" title="utils/adt/array_typanalyze.c:780">countitem_compare_count</a>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Prepare to fill stanumbers with the histogram, followed by the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * average count.&nbsp; This array must be stored in <a href="../../commands/analyze.c.html#L76" title="commands/analyze.c:76">anl_context</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hist = (float4 *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(stats-&gt;<a href="../../commands/analyze.c.html#L76" title="commands/analyze.c:76">anl_context</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(float4) * (num_hist + <span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hist[num_hist] = (<span class="Type">double</span>) element_no / (<span class="Type">double</span>) nonnull_cnt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Construct the histogram of distinct-<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> counts (DECs).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The object of this loop is to copy the min and max DECs to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * hist[0] and hist[num_hist - 1], along with evenly-spaced DECs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in between (where &quot;evenly-spaced&quot; is with reference to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * whole input population of arrays).&nbsp; If we had a complete sorted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * array of DECs, one per analyzed row, the i'th hist value would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * come from DECs[i * (analyzed_rows - 1) / (num_hist - 1)]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (<a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> the histogram-making loop in <a href="../../commands/analyze.c.html#L2351" title="commands/analyze.c:2351">compute_scalar_stats</a>()).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * But instead of that we have the sorted_count_items[] array,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * which holds unique DEC <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> with their frequencies (that is,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a run-length-compressed version of the full array).&nbsp; So we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * control advancing through sorted_count_items[] with the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * variable &quot;frac&quot;, which is defined as (x - y) * (num_hist - 1),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * where x is the index in the notional DECs array corresponding<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to the start of the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> sorted_count_items[] <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>'s run,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and y is the index in DECs from which we should take the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * histogram value.&nbsp; We have to advance whenever x &lt;= y, that is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * frac &lt;= 0.&nbsp; The x component is the sum of the frequencies seen<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so far (up through the current sorted_count_items[] <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and of course y * (num_hist - 1) = i * (analyzed_rows - 1),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * per the subscript calculation above.&nbsp; (The subscript calculation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * implies dropping <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> fractional part of y; in this formulation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that's handled by not advancing until frac reaches 1.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Even though frac has a bounded <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, it could overflow int32<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * when working with very large statistics targets, so we do that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * math in int64.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; delta = analyzed_rows - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* current index in sorted_count_items */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Initialize frac for sorted_count_items[0]; y is initially 0 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; frac = (int64) sorted_count_items[<span class="Constant">0</span>]-&gt;frequency * (num_hist - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; num_hist; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (frac &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Advance, and update x component of frac */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; frac += (int64) sorted_count_items[j]-&gt;frequency * (num_hist - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hist[i] = sorted_count_items[j]-&gt;count;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; frac -= delta;&nbsp; &nbsp; <span class="Comment">/* update y for upcoming i increment */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(j == count_items_count - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stats-&gt;stakind[slot_idx] = STATISTIC_KIND_DECHIST;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stats-&gt;staop[slot_idx] = extra_data-&gt;eq_opr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stats-&gt;stacoll[slot_idx] = extra_data-&gt;coll_id;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stats-&gt;stanumbers[slot_idx] = hist;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stats-&gt;numnumbers[slot_idx] = num_hist + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot_idx++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't need to bother cleaning up <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of our temporary <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'s. The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * hashtable should also go away, as it used a child memory context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * A function to prune the D structure from the Lossy Counting algorithm.<br/></li>
<li></span><span class="Comment"> * Consult <a href="../../tsearch/ts_typanalyze.c.html#L141" title="tsearch/ts_typanalyze.c:141">compute_tsvector_stats</a>() for wider explanation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L681">&#x200c;</a></span><span class="linkable">prune_element_hashtable</span>(<a href="../hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *elements_tab, <span class="Type">int</span> b_current)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS scan_status;<br/></li>
<li>&nbsp; &nbsp; <a href="#L74" title="utils/adt/array_typanalyze.c:74">TrackItem</a>&nbsp; *item;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;scan_status, elements_tab);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((item = (<a href="#L74" title="utils/adt/array_typanalyze.c:74">TrackItem</a> *) <a href="../hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;scan_status)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (item-&gt;frequency + item-&gt;delta &lt;= b_current)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; value = item-&gt;key;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(elements_tab, &amp;item-&gt;key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_REMOVE, <span class="Constant">NULL</span>) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table corrupted&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We should free memory if <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> is not passed by value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L65" title="utils/adt/array_typanalyze.c:65">array_extra_data</a>-&gt;typbyval)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(DatumGetPointer(value));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Hash function for elements.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We use the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type's default <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> opclass, and the column collation<br/></li>
<li></span><span class="Comment"> * if the type is collation-sensitive.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> uint32<br/></li>
<li><a id="L710">&#x200c;</a><span class="linkable">element_hash</span>(<span class="Type">const</span> <span class="Type">void</span> *key, Size keysize)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; d = *((<span class="Type">const</span> Datum *) key);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; h;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; h = <a href="../fmgr/fmgr.c.html#L1129" title="utils/fmgr/fmgr.c:1129">FunctionCall1Coll</a>(<a href="#L65" title="utils/adt/array_typanalyze.c:65">array_extra_data</a>-&gt;<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L65" title="utils/adt/array_typanalyze.c:65">array_extra_data</a>-&gt;coll_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> DatumGetUInt32(h);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Matching function for elements, to be used in hashtable lookups.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L725">&#x200c;</a></span><span class="linkable">element_match</span>(<span class="Type">const</span> <span class="Type">void</span> *key1, <span class="Type">const</span> <span class="Type">void</span> *key2, Size keysize)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The keysize parameter is superfluous here */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="array_selfuncs.c.html#L1165" title="utils/adt/array_selfuncs.c:1165">element_compare</a>(key1, key2);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Comparison function for elements.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We use the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type's default btree opclass, and the column collation<br/></li>
<li></span><span class="Comment"> * if the type is collation-sensitive.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment"> consider using SortSupport infrastructure<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L740">&#x200c;</a></span><span class="linkable">element_compare</span>(<span class="Type">const</span> <span class="Type">void</span> *key1, <span class="Type">const</span> <span class="Type">void</span> *key2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; d1 = *((<span class="Type">const</span> Datum *) key1);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; d2 = *((<span class="Type">const</span> Datum *) key2);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; c;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; c = <a href="../fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(<a href="#L65" title="utils/adt/array_typanalyze.c:65">array_extra_data</a>-&gt;<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L65" title="utils/adt/array_typanalyze.c:65">array_extra_data</a>-&gt;coll_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d1, d2);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> DatumGetInt32(c);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Comparator for sorting TrackItems by frequencies (descending sort)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L756">&#x200c;</a></span><span class="linkable">trackitem_compare_frequencies_desc</span>(<span class="Type">const</span> <span class="Type">void</span> *e1, <span class="Type">const</span> <span class="Type">void</span> *e2, <span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="#L74" title="utils/adt/array_typanalyze.c:74">TrackItem</a> *<span class="Type">const</span> *t1 = (<span class="Type">const</span> <a href="#L74" title="utils/adt/array_typanalyze.c:74">TrackItem</a> *<span class="Type">const</span> *) e1;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="#L74" title="utils/adt/array_typanalyze.c:74">TrackItem</a> *<span class="Type">const</span> *t2 = (<span class="Type">const</span> <a href="#L74" title="utils/adt/array_typanalyze.c:74">TrackItem</a> *<span class="Type">const</span> *) e2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (*t2)-&gt;frequency - (*t1)-&gt;frequency;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Comparator for sorting TrackItems by <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L768">&#x200c;</a></span><span class="linkable">trackitem_compare_element</span>(<span class="Type">const</span> <span class="Type">void</span> *e1, <span class="Type">const</span> <span class="Type">void</span> *e2, <span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="#L74" title="utils/adt/array_typanalyze.c:74">TrackItem</a> *<span class="Type">const</span> *t1 = (<span class="Type">const</span> <a href="#L74" title="utils/adt/array_typanalyze.c:74">TrackItem</a> *<span class="Type">const</span> *) e1;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="#L74" title="utils/adt/array_typanalyze.c:74">TrackItem</a> *<span class="Type">const</span> *t2 = (<span class="Type">const</span> <a href="#L74" title="utils/adt/array_typanalyze.c:74">TrackItem</a> *<span class="Type">const</span> *) e2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="array_selfuncs.c.html#L1165" title="utils/adt/array_selfuncs.c:1165">element_compare</a>(&amp;(*t1)-&gt;key, &amp;(*t2)-&gt;key);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Comparator for sorting DECountItems by count<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L780">&#x200c;</a></span><span class="linkable">countitem_compare_count</span>(<span class="Type">const</span> <span class="Type">void</span> *e1, <span class="Type">const</span> <span class="Type">void</span> *e2, <span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="#L81" title="utils/adt/array_typanalyze.c:81">DECountItem</a> *<span class="Type">const</span> *t1 = (<span class="Type">const</span> <a href="#L81" title="utils/adt/array_typanalyze.c:81">DECountItem</a> *<span class="Type">const</span> *) e1;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="#L81" title="utils/adt/array_typanalyze.c:81">DECountItem</a> *<span class="Type">const</span> *t2 = (<span class="Type">const</span> <a href="#L81" title="utils/adt/array_typanalyze.c:81">DECountItem</a> *<span class="Type">const</span> *) e2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((*t1)-&gt;count &lt; (*t2)-&gt;count)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> ((*t1)-&gt;count == (*t2)-&gt;count)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
