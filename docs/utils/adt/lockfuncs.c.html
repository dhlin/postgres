<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/adt/lockfuncs.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/adt/lockfuncs.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L29">LockTagTypeNames</a></li>
<li><a href="#L48">PredicateLockTagTypeNames</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L64">PG_Lock_Status</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L75">VXIDGetDatum</a></li>
<li><a href="#L887">pg_advisory_lock_int4</a></li>
<li><a href="#L705">pg_advisory_lock_int8</a></li>
<li><a href="#L922">pg_advisory_lock_shared_int4</a></li>
<li><a href="#L738">pg_advisory_lock_shared_int8</a></li>
<li><a href="#L1079">pg_advisory_unlock_all</a></li>
<li><a href="#L1041">pg_advisory_unlock_int4</a></li>
<li><a href="#L851">pg_advisory_unlock_int8</a></li>
<li><a href="#L1061">pg_advisory_unlock_shared_int4</a></li>
<li><a href="#L870">pg_advisory_unlock_shared_int8</a></li>
<li><a href="#L905">pg_advisory_xact_lock_int4</a></li>
<li><a href="#L722">pg_advisory_xact_lock_int8</a></li>
<li><a href="#L940">pg_advisory_xact_lock_shared_int4</a></li>
<li><a href="#L755">pg_advisory_xact_lock_shared_int8</a></li>
<li><a href="#L467">pg_blocking_pids</a></li>
<li><a href="#L616">pg_isolation_test_session_is_blocked</a></li>
<li><a href="#L94">pg_lock_status</a></li>
<li><a href="#L574">pg_safe_snapshot_blocking_pids</a></li>
<li><a href="#L959">pg_try_advisory_lock_int4</a></li>
<li><a href="#L773">pg_try_advisory_lock_int8</a></li>
<li><a href="#L1000">pg_try_advisory_lock_shared_int4</a></li>
<li><a href="#L812">pg_try_advisory_lock_shared_int8</a></li>
<li><a href="#L980">pg_try_advisory_xact_lock_int4</a></li>
<li><a href="#L793">pg_try_advisory_xact_lock_int8</a></li>
<li><a href="#L1021">pg_try_advisory_xact_lock_shared_int4</a></li>
<li><a href="#L832">pg_try_advisory_xact_lock_shared_int8</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L67">NUM_LOCK_STATUS_COLUMNS</a></li>
<li><a href="#L698">SET_LOCKTAG_INT32</a></li>
<li><a href="#L692">SET_LOCKTAG_INT64</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * lockfuncs.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Functions for SQL access to various lock-manager capabilities.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Copyright (c) 2002-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; src/backend/utils/adt/lockfuncs.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;funcapi.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/predicate_internals.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/array.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This must match enum LockTagType!&nbsp; Also, be sure to document <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> changes<br/></li>
<li></span><span class="Comment"> * in the docs for the pg_locks view and update the WaitEventLOCK section in<br/></li>
<li></span><span class="Comment"> * src/backend/utils/activity/wait_event_names.txt.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L29">&#x200c;</a></span><span class="Type">const</span> <span class="Type">char</span> *<span class="Type">const</span> <span class="linkable">LockTagTypeNames</span>[] = {<br/></li>
<li>&nbsp; &nbsp; <span class="Constant">&quot;relation&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; <span class="Constant">&quot;extend&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; <span class="Constant">&quot;frozenid&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; <span class="Constant">&quot;page&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; <span class="Constant">&quot;tuple&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; <span class="Constant">&quot;transactionid&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; <span class="Constant">&quot;virtualxid&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; <span class="Constant">&quot;spectoken&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; <span class="Constant">&quot;object&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; <span class="Constant">&quot;userlock&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; <span class="Constant">&quot;advisory&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; <span class="Constant">&quot;applytransaction&quot;<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li>StaticAssertDecl(lengthof(<a href="#L29" title="utils/adt/lockfuncs.c:29">LockTagTypeNames</a>) == (LOCKTAG_LAST_TYPE + <span class="Constant">1</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;array length mismatch&quot;</span>);<br/></li>
<li><br/></li>
<li><span class="Comment">/* This must match enum PredicateLockTargetType (predicate_internals.h) */<br/></li>
<li><a id="L48">&#x200c;</a></span><span class="Type">static</span> <span class="Type">const</span> <span class="Type">char</span> *<span class="Type">const</span> <span class="linkable">PredicateLockTagTypeNames</span>[] = {<br/></li>
<li>&nbsp; &nbsp; <span class="Constant">&quot;relation&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; <span class="Constant">&quot;page&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; <span class="Constant">&quot;tuple&quot;<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li>StaticAssertDecl(lengthof(<a href="#L48" title="utils/adt/lockfuncs.c:48">PredicateLockTagTypeNames</a>) == (PREDLOCKTAG_TUPLE + <span class="Constant">1</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;array length mismatch&quot;</span>);<br/></li>
<li><br/></li>
<li><span class="Comment">/* Working status for <a href="#L94" title="utils/adt/lockfuncs.c:94">pg_lock_status</a> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; LockData&nbsp;&nbsp; *lockData;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* state data from lmgr */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; currIdx;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* current PROCLOCK index */<br/></li>
<li></span>&nbsp; &nbsp; PredicateLockData *predLockData;&nbsp; &nbsp; <span class="Comment">/* state data for pred locks */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; predLockIdx;&nbsp; &nbsp; <span class="Comment">/* current index for pred lock */<br/></li>
<li><a id="L64">&#x200c;</a></span>} <span class="linkable">PG_Lock_Status</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Number of columns in pg_locks output */<br/></li>
<li><a id="L67">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NUM_LOCK_STATUS_COLUMNS</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">16<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L75" title="utils/adt/lockfuncs.c:75">VXIDGetDatum</a> - Construct a text representation of a VXID<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is currently only used in <a href="#L94" title="utils/adt/lockfuncs.c:94">pg_lock_status</a>, so we put it here.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Datum<br/></li>
<li><a id="L75">&#x200c;</a><span class="linkable">VXIDGetDatum</span>(ProcNumber procNumber, LocalTransactionId lxid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The representation is &quot;&lt;procNumber&gt;/&lt;lxid&gt;&quot;, decimal and unsigned<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * decimal respectively.&nbsp; Note that elog.c also knows how to format a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * vxid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; vxidstr[<span class="Constant">32</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snprintf(vxidstr, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(vxidstr), <span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">/</span><span class="Special">%u</span><span class="Constant">&quot;</span>, procNumber, lxid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> CStringGetTextDatum(vxidstr);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L94" title="utils/adt/lockfuncs.c:94">pg_lock_status</a> - produce a view with one row per held or awaited lock mode<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L94">&#x200c;</a><span class="linkable">pg_lock_status</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FuncCallContext *funcctx;<br/></li>
<li>&nbsp; &nbsp; <a href="#L64" title="utils/adt/lockfuncs.c:64">PG_Lock_Status</a> *mystatus;<br/></li>
<li>&nbsp; &nbsp; LockData&nbsp;&nbsp; *lockData;<br/></li>
<li>&nbsp; &nbsp; PredicateLockData *predLockData;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (SRF_IS_FIRSTCALL())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* create a function context for cross-call persistence */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; funcctx = SRF_FIRSTCALL_INIT();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * switch to memory context appropriate for multiple function calls<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(funcctx-&gt;multi_call_memory_ctx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* build tupdesc for result tuples */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* this had better match function's declaration in pg_proc.h */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tupdesc = <a href="../../access/common/tupdesc.c.html#L67" title="access/common/tupdesc.c:67">CreateTemplateTupleDesc</a>(<a href="#L67" title="utils/adt/lockfuncs.c:67">NUM_LOCK_STATUS_COLUMNS</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/common/tupdesc.c.html#L651" title="access/common/tupdesc.c:651">TupleDescInitEntry</a>(tupdesc, (AttrNumber) <span class="Constant">1</span>, <span class="Constant">&quot;locktype&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TEXTOID, -<span class="Constant">1</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/common/tupdesc.c.html#L651" title="access/common/tupdesc.c:651">TupleDescInitEntry</a>(tupdesc, (AttrNumber) <span class="Constant">2</span>, <span class="Constant">&quot;database&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OIDOID, -<span class="Constant">1</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/common/tupdesc.c.html#L651" title="access/common/tupdesc.c:651">TupleDescInitEntry</a>(tupdesc, (AttrNumber) <span class="Constant">3</span>, <span class="Constant">&quot;relation&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OIDOID, -<span class="Constant">1</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/common/tupdesc.c.html#L651" title="access/common/tupdesc.c:651">TupleDescInitEntry</a>(tupdesc, (AttrNumber) <span class="Constant">4</span>, <span class="Constant">&quot;page&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; INT4OID, -<span class="Constant">1</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/common/tupdesc.c.html#L651" title="access/common/tupdesc.c:651">TupleDescInitEntry</a>(tupdesc, (AttrNumber) <span class="Constant">5</span>, <span class="Constant">&quot;tuple&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; INT2OID, -<span class="Constant">1</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/common/tupdesc.c.html#L651" title="access/common/tupdesc.c:651">TupleDescInitEntry</a>(tupdesc, (AttrNumber) <span class="Constant">6</span>, <span class="Constant">&quot;virtualxid&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TEXTOID, -<span class="Constant">1</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/common/tupdesc.c.html#L651" title="access/common/tupdesc.c:651">TupleDescInitEntry</a>(tupdesc, (AttrNumber) <span class="Constant">7</span>, <span class="Constant">&quot;transactionid&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XIDOID, -<span class="Constant">1</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/common/tupdesc.c.html#L651" title="access/common/tupdesc.c:651">TupleDescInitEntry</a>(tupdesc, (AttrNumber) <span class="Constant">8</span>, <span class="Constant">&quot;classid&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OIDOID, -<span class="Constant">1</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/common/tupdesc.c.html#L651" title="access/common/tupdesc.c:651">TupleDescInitEntry</a>(tupdesc, (AttrNumber) <span class="Constant">9</span>, <span class="Constant">&quot;objid&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OIDOID, -<span class="Constant">1</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/common/tupdesc.c.html#L651" title="access/common/tupdesc.c:651">TupleDescInitEntry</a>(tupdesc, (AttrNumber) <span class="Constant">10</span>, <span class="Constant">&quot;objsubid&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; INT2OID, -<span class="Constant">1</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/common/tupdesc.c.html#L651" title="access/common/tupdesc.c:651">TupleDescInitEntry</a>(tupdesc, (AttrNumber) <span class="Constant">11</span>, <span class="Constant">&quot;virtualtransaction&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TEXTOID, -<span class="Constant">1</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/common/tupdesc.c.html#L651" title="access/common/tupdesc.c:651">TupleDescInitEntry</a>(tupdesc, (AttrNumber) <span class="Constant">12</span>, <span class="Constant">&quot;pid&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; INT4OID, -<span class="Constant">1</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/common/tupdesc.c.html#L651" title="access/common/tupdesc.c:651">TupleDescInitEntry</a>(tupdesc, (AttrNumber) <span class="Constant">13</span>, <span class="Constant">&quot;mode&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TEXTOID, -<span class="Constant">1</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/common/tupdesc.c.html#L651" title="access/common/tupdesc.c:651">TupleDescInitEntry</a>(tupdesc, (AttrNumber) <span class="Constant">14</span>, <span class="Constant">&quot;granted&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BOOLOID, -<span class="Constant">1</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/common/tupdesc.c.html#L651" title="access/common/tupdesc.c:651">TupleDescInitEntry</a>(tupdesc, (AttrNumber) <span class="Constant">15</span>, <span class="Constant">&quot;fastpath&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BOOLOID, -<span class="Constant">1</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/common/tupdesc.c.html#L651" title="access/common/tupdesc.c:651">TupleDescInitEntry</a>(tupdesc, (AttrNumber) <span class="Constant">16</span>, <span class="Constant">&quot;waitstart&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TIMESTAMPTZOID, -<span class="Constant">1</span>, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; funcctx-&gt;tuple_desc = <a href="../../executor/execTuples.c.html#L2158" title="executor/execTuples.c:2158">BlessTupleDesc</a>(tupdesc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Collect all the locking information that we will format and <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * out as a result set.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; mystatus = (<a href="#L64" title="utils/adt/lockfuncs.c:64">PG_Lock_Status</a> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L64" title="utils/adt/lockfuncs.c:64">PG_Lock_Status</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; funcctx-&gt;user_fctx = (<span class="Type">void</span> *) mystatus;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mystatus-&gt;lockData = <a href="../../storage/lmgr/lock.c.html#L3589" title="storage/lmgr/lock.c:3589">GetLockStatusData</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mystatus-&gt;currIdx = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mystatus-&gt;predLockData = <a href="../../storage/lmgr/predicate.c.html#L1430" title="storage/lmgr/predicate.c:1430">GetPredicateLockStatusData</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mystatus-&gt;predLockIdx = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; funcctx = SRF_PERCALL_SETUP();<br/></li>
<li>&nbsp; &nbsp; mystatus = (<a href="#L64" title="utils/adt/lockfuncs.c:64">PG_Lock_Status</a> *) funcctx-&gt;user_fctx;<br/></li>
<li>&nbsp; &nbsp; lockData = mystatus-&gt;lockData;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (mystatus-&gt;currIdx &lt; lockData-&gt;nelements)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; granted;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LOCKMODE&nbsp; &nbsp; mode = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *locktypename;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; tnbuf[<span class="Constant">32</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<a href="#L67" title="utils/adt/lockfuncs.c:67">NUM_LOCK_STATUS_COLUMNS</a>] = {<span class="Constant">0</span>};<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls[<a href="#L67" title="utils/adt/lockfuncs.c:67">NUM_LOCK_STATUS_COLUMNS</a>] = {<span class="Constant">0</span>};<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LockInstanceData *instance;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; instance = &amp;(lockData-&gt;locks[mystatus-&gt;currIdx]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Look to see if there are <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> held lock modes in this PROCLOCK. If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so, report, and destructively modify lockData so we don't report<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; granted = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (instance-&gt;holdMask)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (mode = <span class="Constant">0</span>; mode &lt; MAX_LOCKMODES; mode++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (instance-&gt;holdMask &amp; LOCKBIT_ON(mode))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; granted = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; instance-&gt;holdMask &amp;= LOCKBIT_OFF(mode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If no (more) held modes to report, see if PROC is <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lock on this lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!granted)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (instance-&gt;waitLockMode != NoLock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Yes, so report it with proper mode */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mode = instance-&gt;waitLockMode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We are <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> done with this PROCLOCK, so advance pointer to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * continue with <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> one on <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> call.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mystatus-&gt;currIdx++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Okay, we've displayed all the locks associated with this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * PROCLOCK, proceed to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mystatus-&gt;currIdx++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Form tuple with appropriate data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (instance-&gt;locktag.locktag_type &lt;= LOCKTAG_LAST_TYPE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locktypename = <a href="#L29" title="utils/adt/lockfuncs.c:29">LockTagTypeNames</a>[instance-&gt;locktag.locktag_type];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snprintf(tnbuf, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(tnbuf), <span class="Constant">&quot;unknown </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) instance-&gt;locktag.locktag_type);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locktypename = tnbuf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">0</span>] = CStringGetTextDatum(locktypename);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> ((LockTagType) instance-&gt;locktag.locktag_type)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOCKTAG_RELATION:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOCKTAG_RELATION_EXTEND:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">1</span>] = ObjectIdGetDatum(instance-&gt;locktag.locktag_field1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">2</span>] = ObjectIdGetDatum(instance-&gt;locktag.locktag_field2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">3</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">4</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">5</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">6</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">7</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">8</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">9</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOCKTAG_DATABASE_FROZEN_IDS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">1</span>] = ObjectIdGetDatum(instance-&gt;locktag.locktag_field1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">2</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">3</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">4</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">5</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">6</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">7</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">8</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">9</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOCKTAG_PAGE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">1</span>] = ObjectIdGetDatum(instance-&gt;locktag.locktag_field1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">2</span>] = ObjectIdGetDatum(instance-&gt;locktag.locktag_field2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">3</span>] = UInt32GetDatum(instance-&gt;locktag.locktag_field3);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">4</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">5</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">6</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">7</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">8</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">9</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOCKTAG_TUPLE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">1</span>] = ObjectIdGetDatum(instance-&gt;locktag.locktag_field1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">2</span>] = ObjectIdGetDatum(instance-&gt;locktag.locktag_field2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">3</span>] = UInt32GetDatum(instance-&gt;locktag.locktag_field3);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">4</span>] = UInt16GetDatum(instance-&gt;locktag.locktag_field4);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">5</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">6</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">7</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">8</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">9</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOCKTAG_TRANSACTION:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">6</span>] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionIdGetDatum(instance-&gt;locktag.locktag_field1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">1</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">2</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">3</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">4</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">5</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">7</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">8</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">9</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOCKTAG_VIRTUALTRANSACTION:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">5</span>] = <a href="#L75" title="utils/adt/lockfuncs.c:75">VXIDGetDatum</a>(instance-&gt;locktag.locktag_field1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; instance-&gt;locktag.locktag_field2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">1</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">2</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">3</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">4</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">6</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">7</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">8</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">9</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOCKTAG_SPECULATIVE_TOKEN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">6</span>] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionIdGetDatum(instance-&gt;locktag.locktag_field1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">8</span>] = ObjectIdGetDatum(instance-&gt;locktag.locktag_field2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">1</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">2</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">3</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">4</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">5</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">7</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">9</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOCKTAG_APPLY_TRANSACTION:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">1</span>] = ObjectIdGetDatum(instance-&gt;locktag.locktag_field1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">8</span>] = ObjectIdGetDatum(instance-&gt;locktag.locktag_field2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">6</span>] = ObjectIdGetDatum(instance-&gt;locktag.locktag_field3);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">9</span>] = Int16GetDatum(instance-&gt;locktag.locktag_field4);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">2</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">3</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">4</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">5</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">7</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOCKTAG_OBJECT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOCKTAG_USERLOCK:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOCKTAG_ADVISORY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* treat unknown locktags like OBJECT */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">1</span>] = ObjectIdGetDatum(instance-&gt;locktag.locktag_field1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">7</span>] = ObjectIdGetDatum(instance-&gt;locktag.locktag_field2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">8</span>] = ObjectIdGetDatum(instance-&gt;locktag.locktag_field3);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">9</span>] = Int16GetDatum(instance-&gt;locktag.locktag_field4);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">2</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">3</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">4</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">5</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">6</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">10</span>] = <a href="#L75" title="utils/adt/lockfuncs.c:75">VXIDGetDatum</a>(instance-&gt;vxid.procNumber, instance-&gt;vxid.localTransactionId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (instance-&gt;pid != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">11</span>] = Int32GetDatum(instance-&gt;pid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">11</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">12</span>] = CStringGetTextDatum(<a href="../../storage/lmgr/lock.c.html#L4038" title="storage/lmgr/lock.c:4038">GetLockmodeName</a>(instance-&gt;locktag.locktag_lockmethodid, mode));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">13</span>] = BoolGetDatum(granted);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">14</span>] = BoolGetDatum(instance-&gt;fastpath);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!granted &amp;&amp; instance-&gt;waitStart != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">15</span>] = TimestampTzGetDatum(instance-&gt;waitStart);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">15</span>] = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple = <a href="../../access/common/heaptuple.c.html#L1116" title="access/common/heaptuple.c:1116">heap_form_tuple</a>(funcctx-&gt;tuple_desc, <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, nulls);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = HeapTupleGetDatum(tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SRF_RETURN_NEXT(funcctx, result);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Have returned all regular locks. Now start on the SIREAD predicate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * locks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; predLockData = mystatus-&gt;predLockData;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (mystatus-&gt;predLockIdx &lt; predLockData-&gt;nelements)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PredicateLockTargetType lockType;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PREDICATELOCKTARGETTAG *predTag = &amp;(predLockData-&gt;locktags[mystatus-&gt;predLockIdx]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SERIALIZABLEXACT *xact = &amp;(predLockData-&gt;xacts[mystatus-&gt;predLockIdx]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<a href="#L67" title="utils/adt/lockfuncs.c:67">NUM_LOCK_STATUS_COLUMNS</a>] = {<span class="Constant">0</span>};<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls[<a href="#L67" title="utils/adt/lockfuncs.c:67">NUM_LOCK_STATUS_COLUMNS</a>] = {<span class="Constant">0</span>};<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mystatus-&gt;predLockIdx++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Form tuple with appropriate data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* lock type */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; lockType = GET_PREDICATELOCKTARGETTAG_TYPE(*predTag);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">0</span>] = CStringGetTextDatum(<a href="#L48" title="utils/adt/lockfuncs.c:48">PredicateLockTagTypeNames</a>[lockType]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* lock target */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">1</span>] = GET_PREDICATELOCKTARGETTAG_DB(*predTag);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">2</span>] = GET_PREDICATELOCKTARGETTAG_RELATION(*predTag);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lockType == PREDLOCKTAG_TUPLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">4</span>] = GET_PREDICATELOCKTARGETTAG_OFFSET(*predTag);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">4</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((lockType == PREDLOCKTAG_TUPLE) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lockType == PREDLOCKTAG_PAGE))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">3</span>] = GET_PREDICATELOCKTARGETTAG_PAGE(*predTag);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">3</span>] = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* these fields are targets for other types of locks */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">5</span>] = <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* virtualxid */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">6</span>] = <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* transactionid */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">7</span>] = <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* classid */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">8</span>] = <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* objid */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">9</span>] = <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* objsubid */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* lock holder */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">10</span>] = <a href="#L75" title="utils/adt/lockfuncs.c:75">VXIDGetDatum</a>(xact-&gt;vxid.procNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xact-&gt;vxid.localTransactionId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xact-&gt;pid != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">11</span>] = Int32GetDatum(xact-&gt;pid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">11</span>] = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Lock mode. Currently all predicate locks are SIReadLocks, which are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * always held (never <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>) and have no fast path<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">12</span>] = CStringGetTextDatum(<span class="Constant">&quot;SIReadLock&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">13</span>] = BoolGetDatum(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">14</span>] = BoolGetDatum(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">15</span>] = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple = <a href="../../access/common/heaptuple.c.html#L1116" title="access/common/heaptuple.c:1116">heap_form_tuple</a>(funcctx-&gt;tuple_desc, <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, nulls);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = HeapTupleGetDatum(tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SRF_RETURN_NEXT(funcctx, result);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SRF_RETURN_DONE(funcctx);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L467" title="utils/adt/lockfuncs.c:467">pg_blocking_pids</a> - produce an array of the PIDs blocking given PID<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The reported PIDs are those that hold a lock conflicting with blocked_pid's<br/></li>
<li></span><span class="Comment"> * current request (hard block), or are requesting such a lock and are ahead<br/></li>
<li></span><span class="Comment"> * of blocked_pid in the lock's wait queue (soft block).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In parallel-query cases, we report all PIDs blocking <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> member of the<br/></li>
<li></span><span class="Comment"> * given PID's lock group, and the reported PIDs are those of the blocking<br/></li>
<li></span><span class="Comment"> * PIDs' lock group leaders.&nbsp; This allows callers to <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> the result to<br/></li>
<li></span><span class="Comment"> * lists of clients' <a href="pgstatfuncs.c.html#L661" title="utils/adt/pgstatfuncs.c:661">pg_backend_pid</a>() results even during a parallel query.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Parallel query makes it possible for there to be duplicate PIDs in the<br/></li>
<li></span><span class="Comment"> * result (either because multiple waiters are blocked by same PID, or<br/></li>
<li></span><span class="Comment"> * because multiple blockers have same group leader PID).&nbsp; We do not bother<br/></li>
<li></span><span class="Comment"> * to eliminate such duplicates from the result.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We need not consider predicate locks here, since those don't block anything.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L467">&#x200c;</a><span class="linkable">pg_blocking_pids</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blocked_pid = PG_GETARG_INT32(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *arrayelems;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; narrayelems;<br/></li>
<li>&nbsp; &nbsp; BlockedProcsData *lockData; <span class="Comment">/* state data from lmgr */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Collect a snapshot of lock manager state */<br/></li>
<li></span>&nbsp; &nbsp; lockData = <a href="../../storage/lmgr/lock.c.html#L3781" title="storage/lmgr/lock.c:3781">GetBlockerStatusData</a>(blocked_pid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We can't need more output entries than there are reported PROCLOCKs */<br/></li>
<li></span>&nbsp; &nbsp; arrayelems = (Datum *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(lockData-&gt;nlocks * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li>&nbsp; &nbsp; narrayelems = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* For each blocked proc in the lock group ... */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; lockData-&gt;nprocs; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockedProcData *bproc = &amp;lockData-&gt;procs[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LockInstanceData *instances = &amp;lockData-&gt;locks[bproc-&gt;first_lock];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *preceding_waiters = &amp;lockData-&gt;waiter_pids[bproc-&gt;first_waiter];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LockInstanceData *blocked_instance;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LockMethod&nbsp; &nbsp; lockMethodTable;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; conflictMask;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Locate the blocked proc's own entry in the LockInstanceData array.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There should be exactly one matching entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; blocked_instance = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = <span class="Constant">0</span>; j &lt; bproc-&gt;num_locks; j++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LockInstanceData *instance = &amp;(instances[j]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (instance-&gt;pid == bproc-&gt;pid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(blocked_instance == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blocked_instance = instance;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(blocked_instance != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lockMethodTable = <a href="../../storage/lmgr/lock.c.html#L486" title="storage/lmgr/lock.c:486">GetLockTagsMethodTable</a>(&amp;(blocked_instance-&gt;locktag));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; conflictMask = lockMethodTable-&gt;conflictTab[blocked_instance-&gt;waitLockMode];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now scan the PROCLOCK data for conflicting procs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = <span class="Constant">0</span>; j &lt; bproc-&gt;num_locks; j++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LockInstanceData *instance = &amp;(instances[j]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* A proc never blocks itself, so ignore that entry */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (instance == blocked_instance)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Members of same lock group never block each other, either */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (instance-&gt;leaderPid == blocked_instance-&gt;leaderPid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (conflictMask &amp; instance-&gt;holdMask)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* hard block: blocked by lock already held by this entry */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (instance-&gt;waitLockMode != NoLock &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (conflictMask &amp; LOCKBIT_ON(instance-&gt;waitLockMode)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* conflict in lock requests; who's in front in wait queue? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; ahead = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; k;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (k = <span class="Constant">0</span>; k &lt; bproc-&gt;num_waiters; k++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (preceding_waiters[k] == instance-&gt;pid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* soft block: this entry is ahead of blocked proc */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ahead = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!ahead)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; <span class="Comment">/* not blocked by this entry */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not blocked by this entry */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* blocked by this entry, so emit a record */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arrayelems[narrayelems++] = Int32GetDatum(instance-&gt;leaderPid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Assert we didn't overrun arrayelems[] */<br/></li>
<li></span>&nbsp; &nbsp; Assert(narrayelems &lt;= lockData-&gt;nlocks);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_ARRAYTYPE_P(<a href="arrayfuncs.c.html#L3374" title="utils/adt/arrayfuncs.c:3374">construct_array_builtin</a>(arrayelems, narrayelems, INT4OID));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L574" title="utils/adt/lockfuncs.c:574">pg_safe_snapshot_blocking_pids</a> - produce an array of the PIDs blocking<br/></li>
<li></span><span class="Comment"> * given PID from getting a safe snapshot<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment"> this does not consider parallel-query cases; not clear how big a<br/></li>
<li></span><span class="Comment"> * problem that is in practice<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L574">&#x200c;</a><span class="linkable">pg_safe_snapshot_blocking_pids</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blocked_pid = PG_GETARG_INT32(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *blockers;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_blockers;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *blocker_datums;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* A buffer big enough for <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> possible blocker list without truncation */<br/></li>
<li></span>&nbsp; &nbsp; blockers = (<span class="Type">int</span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<a href="../init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a> * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Collect a snapshot of processes waited for by <a href="../../storage/lmgr/predicate.c.html#L1543" title="storage/lmgr/predicate.c:1543">GetSafeSnapshot</a> */<br/></li>
<li></span>&nbsp; &nbsp; num_blockers =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/predicate.c.html#L1613" title="storage/lmgr/predicate.c:1613">GetSafeSnapshotBlockingPids</a>(blocked_pid, blockers, <a href="../init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Convert int array to Datum array */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (num_blockers &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; blocker_datums = (Datum *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(num_blockers * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; num_blockers; ++i)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blocker_datums[i] = Int32GetDatum(blockers[i]);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; blocker_datums = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_ARRAYTYPE_P(<a href="arrayfuncs.c.html#L3374" title="utils/adt/arrayfuncs.c:3374">construct_array_builtin</a>(blocker_datums, num_blockers, INT4OID));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L616" title="utils/adt/lockfuncs.c:616">pg_isolation_test_session_is_blocked</a> - support function for isolationtester<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Check if specified PID is blocked by <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the PIDs listed in the second<br/></li>
<li></span><span class="Comment"> * argument.&nbsp; Currently, this looks for blocking caused by <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for<br/></li>
<li></span><span class="Comment"> * heavyweight locks or safe snapshots.&nbsp; We ignore blockage caused by PIDs<br/></li>
<li></span><span class="Comment"> * not directly under the isolationtester's control, eg autovacuum.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is an undocumented function intended for use by the isolation tester,<br/></li>
<li></span><span class="Comment"> * and may change in future releases as required for testing purposes.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L616">&#x200c;</a><span class="linkable">pg_isolation_test_session_is_blocked</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blocked_pid = PG_GETARG_INT32(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *interesting_pids_a = PG_GETARG_ARRAYTYPE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *blocking_pids_a;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp;&nbsp; *interesting_pids;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp;&nbsp; *blocking_pids;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_interesting_pids;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_blocking_pids;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dummy;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Validate the passed-in array */<br/></li>
<li></span>&nbsp; &nbsp; Assert(ARR_ELEMTYPE(interesting_pids_a) == INT4OID);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="arrayfuncs.c.html#L3748" title="utils/adt/arrayfuncs.c:3748">array_contains_nulls</a>(interesting_pids_a))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;array must not contain nulls&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; interesting_pids = (int32 *) ARR_DATA_PTR(interesting_pids_a);<br/></li>
<li>&nbsp; &nbsp; num_interesting_pids = <a href="arrayutils.c.html#L57" title="utils/adt/arrayutils.c:57">ArrayGetNItems</a>(ARR_NDIM(interesting_pids_a),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ARR_DIMS(interesting_pids_a));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get the PIDs of all sessions blocking the given session's attempt to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * acquire heavyweight locks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; blocking_pids_a =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; DatumGetArrayTypeP(DirectFunctionCall1(<a href="#L467" title="utils/adt/lockfuncs.c:467">pg_blocking_pids</a>, blocked_pid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(ARR_ELEMTYPE(blocking_pids_a) == INT4OID);<br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="arrayfuncs.c.html#L3748" title="utils/adt/arrayfuncs.c:3748">array_contains_nulls</a>(blocking_pids_a));<br/></li>
<li>&nbsp; &nbsp; blocking_pids = (int32 *) ARR_DATA_PTR(blocking_pids_a);<br/></li>
<li>&nbsp; &nbsp; num_blocking_pids = <a href="arrayutils.c.html#L57" title="utils/adt/arrayutils.c:57">ArrayGetNItems</a>(ARR_NDIM(blocking_pids_a),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ARR_DIMS(blocking_pids_a));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of these are in the list of interesting PIDs, that being<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the sessions that the isolation tester is running.&nbsp; We don't use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &quot;arrayoverlaps&quot; here, because it would lead to cache lookups and one of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * our goals is to run quickly with <a href="../cache/inval.c.html#L240" title="utils/cache/inval.c:240">debug_discard_caches</a> &gt; 0.&nbsp; We expect<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * blocking_pids to be usually empty and otherwise a very small number in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * isolation tester cases, so make that the outer loop of a naive search<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for a match.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; num_blocking_pids; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = <span class="Constant">0</span>; j &lt; num_interesting_pids; j++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (blocking_pids[i] == interesting_pids[j])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check if blocked_pid is <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for a safe snapshot.&nbsp; We could in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * theory check the resulting array of blocker PIDs against the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * interesting PIDs list, but since there is no danger of autovacuum<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * blocking <a href="../../storage/lmgr/predicate.c.html#L1543" title="storage/lmgr/predicate.c:1543">GetSafeSnapshot</a> there seems to be no point in expending cycles<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on allocating a buffer and searching for overlap; so it's presently<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sufficient for the isolation tester's purposes to use a single <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * buffer and check if the number of safe snapshot blockers is non-zero.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/lmgr/predicate.c.html#L1613" title="storage/lmgr/predicate.c:1613">GetSafeSnapshotBlockingPids</a>(blocked_pid, &amp;dummy, <span class="Constant">1</span>) &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Functions for manipulating advisory locks<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We make use of the locktag fields as follows:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; field1: <a href="../init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a> ... ensures locks are local to each database<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; field2: first of 2 int4 keys, or high-order half of an int8 key<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; field3: second of 2 int4 keys, or low-order half of an int8 key<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; field4: 1 if using an int8 key, 2 if using 2 int4 keys<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L692">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SET_LOCKTAG_INT64</span>(tag, key64) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; SET_LOCKTAG_ADVISORY(tag, \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>, \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (uint32) ((key64) &gt;&gt; </span><span class="Constant">32</span><span class="PreProc">), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (uint32) (key64), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="Constant">1</span><span class="PreProc">)<br/></li>
<li><a id="L698">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SET_LOCKTAG_INT32</span>(tag, key1, key2) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; SET_LOCKTAG_ADVISORY(tag, <a href="../init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>, key1, key2, </span><span class="Constant">2</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * pg_advisory_lock(int8) - acquire exclusive lock on an int8 key<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L705">&#x200c;</a><span class="linkable">pg_advisory_lock_int8</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; key = PG_GETARG_INT64(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L692" title="utils/adt/lockfuncs.c:692">SET_LOCKTAG_INT64</a>(tag, key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="../../storage/lmgr/lock.c.html#L734" title="storage/lmgr/lock.c:734">LockAcquire</a>(&amp;tag, ExclusiveLock, <span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VOID();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * pg_advisory_xact_lock(int8) - acquire xact scoped<br/></li>
<li></span><span class="Comment"> * exclusive lock on an int8 key<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L722">&#x200c;</a><span class="linkable">pg_advisory_xact_lock_int8</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; key = PG_GETARG_INT64(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L692" title="utils/adt/lockfuncs.c:692">SET_LOCKTAG_INT64</a>(tag, key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="../../storage/lmgr/lock.c.html#L734" title="storage/lmgr/lock.c:734">LockAcquire</a>(&amp;tag, ExclusiveLock, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VOID();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * pg_advisory_lock_shared(int8) - acquire share lock on an int8 key<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L738">&#x200c;</a><span class="linkable">pg_advisory_lock_shared_int8</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; key = PG_GETARG_INT64(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L692" title="utils/adt/lockfuncs.c:692">SET_LOCKTAG_INT64</a>(tag, key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="../../storage/lmgr/lock.c.html#L734" title="storage/lmgr/lock.c:734">LockAcquire</a>(&amp;tag, ShareLock, <span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VOID();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * pg_advisory_xact_lock_shared(int8) - acquire xact scoped<br/></li>
<li></span><span class="Comment"> * share lock on an int8 key<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L755">&#x200c;</a><span class="linkable">pg_advisory_xact_lock_shared_int8</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; key = PG_GETARG_INT64(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L692" title="utils/adt/lockfuncs.c:692">SET_LOCKTAG_INT64</a>(tag, key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="../../storage/lmgr/lock.c.html#L734" title="storage/lmgr/lock.c:734">LockAcquire</a>(&amp;tag, ShareLock, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VOID();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * pg_try_advisory_lock(int8) - acquire exclusive lock on an int8 key, no wait<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if successful, false if lock not available<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L773">&#x200c;</a><span class="linkable">pg_try_advisory_lock_int8</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; key = PG_GETARG_INT64(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li>&nbsp; &nbsp; LockAcquireResult res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L692" title="utils/adt/lockfuncs.c:692">SET_LOCKTAG_INT64</a>(tag, key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="../../storage/lmgr/lock.c.html#L734" title="storage/lmgr/lock.c:734">LockAcquire</a>(&amp;tag, ExclusiveLock, <span class="Constant">true</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(res != LOCKACQUIRE_NOT_AVAIL);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * pg_try_advisory_xact_lock(int8) - acquire xact scoped<br/></li>
<li></span><span class="Comment"> * exclusive lock on an int8 key, no wait<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if successful, false if lock not available<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L793">&#x200c;</a><span class="linkable">pg_try_advisory_xact_lock_int8</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; key = PG_GETARG_INT64(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li>&nbsp; &nbsp; LockAcquireResult res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L692" title="utils/adt/lockfuncs.c:692">SET_LOCKTAG_INT64</a>(tag, key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="../../storage/lmgr/lock.c.html#L734" title="storage/lmgr/lock.c:734">LockAcquire</a>(&amp;tag, ExclusiveLock, <span class="Constant">false</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(res != LOCKACQUIRE_NOT_AVAIL);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * pg_try_advisory_lock_shared(int8) - acquire share lock on an int8 key, no wait<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if successful, false if lock not available<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L812">&#x200c;</a><span class="linkable">pg_try_advisory_lock_shared_int8</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; key = PG_GETARG_INT64(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li>&nbsp; &nbsp; LockAcquireResult res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L692" title="utils/adt/lockfuncs.c:692">SET_LOCKTAG_INT64</a>(tag, key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="../../storage/lmgr/lock.c.html#L734" title="storage/lmgr/lock.c:734">LockAcquire</a>(&amp;tag, ShareLock, <span class="Constant">true</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(res != LOCKACQUIRE_NOT_AVAIL);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * pg_try_advisory_xact_lock_shared(int8) - acquire xact scoped<br/></li>
<li></span><span class="Comment"> * share lock on an int8 key, no wait<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if successful, false if lock not available<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L832">&#x200c;</a><span class="linkable">pg_try_advisory_xact_lock_shared_int8</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; key = PG_GETARG_INT64(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li>&nbsp; &nbsp; LockAcquireResult res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L692" title="utils/adt/lockfuncs.c:692">SET_LOCKTAG_INT64</a>(tag, key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="../../storage/lmgr/lock.c.html#L734" title="storage/lmgr/lock.c:734">LockAcquire</a>(&amp;tag, ShareLock, <span class="Constant">false</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(res != LOCKACQUIRE_NOT_AVAIL);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * pg_advisory_unlock(int8) - release exclusive lock on an int8 key<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if successful, false if lock was not held<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li></span>Datum<br/></li>
<li><a id="L851">&#x200c;</a><span class="linkable">pg_advisory_unlock_int8</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; key = PG_GETARG_INT64(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L692" title="utils/adt/lockfuncs.c:692">SET_LOCKTAG_INT64</a>(tag, key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="../../storage/lmgr/lock.c.html#L1942" title="storage/lmgr/lock.c:1942">LockRelease</a>(&amp;tag, ExclusiveLock, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(res);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * pg_advisory_unlock_shared(int8) - release share lock on an int8 key<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if successful, false if lock was not held<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L870">&#x200c;</a><span class="linkable">pg_advisory_unlock_shared_int8</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; key = PG_GETARG_INT64(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L692" title="utils/adt/lockfuncs.c:692">SET_LOCKTAG_INT64</a>(tag, key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="../../storage/lmgr/lock.c.html#L1942" title="storage/lmgr/lock.c:1942">LockRelease</a>(&amp;tag, ShareLock, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(res);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * pg_advisory_lock(int4, int4) - acquire exclusive lock on 2 int4 keys<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L887">&#x200c;</a><span class="linkable">pg_advisory_lock_int4</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; key1 = PG_GETARG_INT32(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; key2 = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L698" title="utils/adt/lockfuncs.c:698">SET_LOCKTAG_INT32</a>(tag, key1, key2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="../../storage/lmgr/lock.c.html#L734" title="storage/lmgr/lock.c:734">LockAcquire</a>(&amp;tag, ExclusiveLock, <span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VOID();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * pg_advisory_xact_lock(int4, int4) - acquire xact scoped<br/></li>
<li></span><span class="Comment"> * exclusive lock on 2 int4 keys<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L905">&#x200c;</a><span class="linkable">pg_advisory_xact_lock_int4</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; key1 = PG_GETARG_INT32(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; key2 = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L698" title="utils/adt/lockfuncs.c:698">SET_LOCKTAG_INT32</a>(tag, key1, key2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="../../storage/lmgr/lock.c.html#L734" title="storage/lmgr/lock.c:734">LockAcquire</a>(&amp;tag, ExclusiveLock, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VOID();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * pg_advisory_lock_shared(int4, int4) - acquire share lock on 2 int4 keys<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L922">&#x200c;</a><span class="linkable">pg_advisory_lock_shared_int4</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; key1 = PG_GETARG_INT32(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; key2 = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L698" title="utils/adt/lockfuncs.c:698">SET_LOCKTAG_INT32</a>(tag, key1, key2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="../../storage/lmgr/lock.c.html#L734" title="storage/lmgr/lock.c:734">LockAcquire</a>(&amp;tag, ShareLock, <span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VOID();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * pg_advisory_xact_lock_shared(int4, int4) - acquire xact scoped<br/></li>
<li></span><span class="Comment"> * share lock on 2 int4 keys<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L940">&#x200c;</a><span class="linkable">pg_advisory_xact_lock_shared_int4</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; key1 = PG_GETARG_INT32(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; key2 = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L698" title="utils/adt/lockfuncs.c:698">SET_LOCKTAG_INT32</a>(tag, key1, key2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="../../storage/lmgr/lock.c.html#L734" title="storage/lmgr/lock.c:734">LockAcquire</a>(&amp;tag, ShareLock, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VOID();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * pg_try_advisory_lock(int4, int4) - acquire exclusive lock on 2 int4 keys, no wait<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if successful, false if lock not available<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L959">&#x200c;</a><span class="linkable">pg_try_advisory_lock_int4</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; key1 = PG_GETARG_INT32(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; key2 = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li>&nbsp; &nbsp; LockAcquireResult res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L698" title="utils/adt/lockfuncs.c:698">SET_LOCKTAG_INT32</a>(tag, key1, key2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="../../storage/lmgr/lock.c.html#L734" title="storage/lmgr/lock.c:734">LockAcquire</a>(&amp;tag, ExclusiveLock, <span class="Constant">true</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(res != LOCKACQUIRE_NOT_AVAIL);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * pg_try_advisory_xact_lock(int4, int4) - acquire xact scoped<br/></li>
<li></span><span class="Comment"> * exclusive lock on 2 int4 keys, no wait<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if successful, false if lock not available<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L980">&#x200c;</a><span class="linkable">pg_try_advisory_xact_lock_int4</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; key1 = PG_GETARG_INT32(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; key2 = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li>&nbsp; &nbsp; LockAcquireResult res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L698" title="utils/adt/lockfuncs.c:698">SET_LOCKTAG_INT32</a>(tag, key1, key2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="../../storage/lmgr/lock.c.html#L734" title="storage/lmgr/lock.c:734">LockAcquire</a>(&amp;tag, ExclusiveLock, <span class="Constant">false</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(res != LOCKACQUIRE_NOT_AVAIL);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * pg_try_advisory_lock_shared(int4, int4) - acquire share lock on 2 int4 keys, no wait<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if successful, false if lock not available<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1000">&#x200c;</a><span class="linkable">pg_try_advisory_lock_shared_int4</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; key1 = PG_GETARG_INT32(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; key2 = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li>&nbsp; &nbsp; LockAcquireResult res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L698" title="utils/adt/lockfuncs.c:698">SET_LOCKTAG_INT32</a>(tag, key1, key2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="../../storage/lmgr/lock.c.html#L734" title="storage/lmgr/lock.c:734">LockAcquire</a>(&amp;tag, ShareLock, <span class="Constant">true</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(res != LOCKACQUIRE_NOT_AVAIL);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * pg_try_advisory_xact_lock_shared(int4, int4) - acquire xact scoped<br/></li>
<li></span><span class="Comment"> * share lock on 2 int4 keys, no wait<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if successful, false if lock not available<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1021">&#x200c;</a><span class="linkable">pg_try_advisory_xact_lock_shared_int4</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; key1 = PG_GETARG_INT32(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; key2 = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li>&nbsp; &nbsp; LockAcquireResult res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L698" title="utils/adt/lockfuncs.c:698">SET_LOCKTAG_INT32</a>(tag, key1, key2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="../../storage/lmgr/lock.c.html#L734" title="storage/lmgr/lock.c:734">LockAcquire</a>(&amp;tag, ShareLock, <span class="Constant">false</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(res != LOCKACQUIRE_NOT_AVAIL);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * pg_advisory_unlock(int4, int4) - release exclusive lock on 2 int4 keys<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if successful, false if lock was not held<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1041">&#x200c;</a><span class="linkable">pg_advisory_unlock_int4</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; key1 = PG_GETARG_INT32(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; key2 = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L698" title="utils/adt/lockfuncs.c:698">SET_LOCKTAG_INT32</a>(tag, key1, key2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="../../storage/lmgr/lock.c.html#L1942" title="storage/lmgr/lock.c:1942">LockRelease</a>(&amp;tag, ExclusiveLock, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(res);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * pg_advisory_unlock_shared(int4, int4) - release share lock on 2 int4 keys<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if successful, false if lock was not held<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1061">&#x200c;</a><span class="linkable">pg_advisory_unlock_shared_int4</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; key1 = PG_GETARG_INT32(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; key2 = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L698" title="utils/adt/lockfuncs.c:698">SET_LOCKTAG_INT32</a>(tag, key1, key2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="../../storage/lmgr/lock.c.html#L1942" title="storage/lmgr/lock.c:1942">LockRelease</a>(&amp;tag, ShareLock, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(res);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1079" title="utils/adt/lockfuncs.c:1079">pg_advisory_unlock_all</a>() - release all advisory locks<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1079">&#x200c;</a><span class="linkable">pg_advisory_unlock_all</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lock.c.html#L2412" title="storage/lmgr/lock.c:2412">LockReleaseSession</a>(USER_LOCKMETHOD);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VOID();<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
