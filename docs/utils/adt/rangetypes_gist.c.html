<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/adt/rangetypes_gist.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/adt/rangetypes_gist.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L110">CommonEntry</a></li>
<li><a href="#L88">ConsiderSplitContext</a></li>
<li><a href="#L98">NonEmptyRange</a></li>
<li><a href="#L59">SingleBoundSortItem</a></li>
<li><a href="#L66">SplitLR</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L1788">call_subtype_diff</a></li>
<li><a href="#L1770">common_entry_cmp</a></li>
<li><a href="#L1704">get_gist_range_class</a></li>
<li><a href="#L1744">interval_cmp_lower</a></li>
<li><a href="#L1757">interval_cmp_upper</a></li>
<li><a href="#L245">multirange_gist_compress</a></li>
<li><a href="#L270">multirange_gist_consistent</a></li>
<li><a href="#L888">multirange_union_range_equal</a></li>
<li><a href="#L1186">range_gist_class_split</a></li>
<li><a href="#L1621">range_gist_consider_split</a></li>
<li><a href="#L191">range_gist_consistent</a></li>
<li><a href="#L1039">range_gist_consistent_int_element</a></li>
<li><a href="#L977">range_gist_consistent_int_multirange</a></li>
<li><a href="#L915">range_gist_consistent_int_range</a></li>
<li><a href="#L1128">range_gist_consistent_leaf_element</a></li>
<li><a href="#L1093">range_gist_consistent_leaf_multirange</a></li>
<li><a href="#L1058">range_gist_consistent_leaf_range</a></li>
<li><a href="#L1318">range_gist_double_sorting_split</a></li>
<li><a href="#L1148">range_gist_fallback_split</a></li>
<li><a href="#L362">range_gist_penalty</a></li>
<li><a href="#L619">range_gist_picksplit</a></li>
<li><a href="#L778">range_gist_same</a></li>
<li><a href="#L1229">range_gist_single_sorting_split</a></li>
<li><a href="#L324">range_gist_union</a></li>
<li><a href="#L821">range_super_union</a></li>
<li><a href="#L1731">single_bound_cmp</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L33">CLS_CONTAIN_EMPTY</a></li>
<li><a href="#L36">CLS_COUNT</a></li>
<li><a href="#L34">CLS_EMPTY</a></li>
<li><a href="#L31">CLS_LOWER_INF</a></li>
<li><a href="#L30">CLS_NORMAL</a></li>
<li><a href="#L32">CLS_UPPER_INF</a></li>
<li><a href="#L49">CONTAIN_EMPTY_PENALTY</a></li>
<li><a href="#L50">DEFAULT_SUBTYPE_DIFF_PENALTY</a></li>
<li><a href="#L48">INFINITE_BOUND_PENALTY</a></li>
<li><a href="#L45">LIMIT_RATIO</a></li>
<li><a href="#L114">PLACE_LEFT</a></li>
<li><a href="#L123">PLACE_RIGHT</a></li>
<li><a href="#L133">rangeCopy</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * rangetypes_gist.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; GiST support for <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> types.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/adt/rangetypes_gist.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/gist.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/stratnum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/datum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/float.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgrprotos.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/multirangetypes.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rangetypes.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="geo_spgist.c.html#L107" title="utils/adt/geo_spgist.c:107">Range</a> class properties used to segregate different classes of ranges in<br/></li>
<li></span><span class="Comment"> * GiST.&nbsp; Each unique combination of properties is a class.&nbsp; <a href="#L34" title="utils/adt/rangetypes_gist.c:34">CLS_EMPTY</a> cannot<br/></li>
<li></span><span class="Comment"> * be combined with anything else.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L30">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">CLS_NORMAL</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* Ordinary finite <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> (no bits set) */<br/></li>
<li><a id="L31">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">CLS_LOWER_INF</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">1</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* Lower bound is infinity */<br/></li>
<li><a id="L32">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">CLS_UPPER_INF</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">2</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* Upper bound is infinity */<br/></li>
<li><a id="L33">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">CLS_CONTAIN_EMPTY</span>&nbsp; &nbsp; </span><span class="Constant">4</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* Contains underlying empty ranges */<br/></li>
<li><a id="L34">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">CLS_EMPTY</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">8</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* Special class for empty ranges */<br/></li>
<li></span><br/></li>
<li><a id="L36">&#x200c;</a><span class="PreProc">#define <span class="linkable">CLS_COUNT</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">9</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* # of classes; includes all combinations of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * properties. <a href="#L34" title="utils/adt/rangetypes_gist.c:34">CLS_EMPTY</a> doesn't <a href="../../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * anything else, so it's only 2^3 + 1. */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Minimum accepted ratio of split for items of the same class.&nbsp; If the items<br/></li>
<li></span><span class="Comment"> * are of different classes, we will separate along those lines regardless of<br/></li>
<li></span><span class="Comment"> * the ratio.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L45">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">LIMIT_RATIO</span>&nbsp; </span><span class="Constant">0.3<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Constants for fixed penalty <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li><a id="L48">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">INFINITE_BOUND_PENALTY</span>&nbsp; &nbsp; </span><span class="Constant">2.0<br/></li>
<li><a id="L49">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">CONTAIN_EMPTY_PENALTY</span>&nbsp; </span><span class="Constant">1.0<br/></li>
<li><a id="L50">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">DEFAULT_SUBTYPE_DIFF_PENALTY</span>&nbsp; </span><span class="Constant">1.0<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Per-item data for <a href="#L1229" title="utils/adt/rangetypes_gist.c:1229">range_gist_single_sorting_split</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; bound;<br/></li>
<li><a id="L59">&#x200c;</a>} <span class="linkable">SingleBoundSortItem</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* place on left or right side of split? */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">enum<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; SPLIT_LEFT = <span class="Constant">0</span>,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* makes initialization to SPLIT_LEFT easier */<br/></li>
<li></span>&nbsp; &nbsp; SPLIT_RIGHT,<br/></li>
<li><a id="L66">&#x200c;</a>} <span class="linkable">SplitLR</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Context for <a href="#L1621" title="utils/adt/rangetypes_gist.c:1621">range_gist_consider_split</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;&nbsp; &nbsp; <span class="Comment">/* typcache for <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> type */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; has_subtype_diff;&nbsp; &nbsp; <span class="Comment">/* does it have subtype_diff? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entries_count;&nbsp; &nbsp; <span class="Comment">/* total number of entries being split */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Information about currently selected split follows */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; first;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* true if no split was selected yet */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; RangeBound *left_upper;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound of left interval */<br/></li>
<li></span>&nbsp; &nbsp; RangeBound *right_lower;&nbsp; &nbsp; <span class="Comment">/* <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound of right interval */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; ratio;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* split ratio */<br/></li>
<li></span>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; overlap;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* overlap between left and right predicate */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; common_left;&nbsp; &nbsp; <span class="Comment">/* # common entries destined for each side */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; common_right;<br/></li>
<li><a id="L88">&#x200c;</a>} <span class="linkable">ConsiderSplitContext</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Bounds extracted from a non-empty <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, for use in<br/></li>
<li></span><span class="Comment"> * <a href="#L1318" title="utils/adt/rangetypes_gist.c:1318">range_gist_double_sorting_split</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>;<br/></li>
<li><a id="L98">&#x200c;</a>} <span class="linkable">NonEmptyRange</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Represents information about an entry that can be placed in either group<br/></li>
<li></span><span class="Comment"> * without affecting overlap over selected axis (&quot;common entry&quot;).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Index of entry in the initial array */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Delta between closeness of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> to each of the two groups */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; delta;<br/></li>
<li><a id="L110">&#x200c;</a>} <span class="linkable">CommonEntry</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Helper macros to place an entry in the left or right group during split */<br/></li>
<li></span><span class="Comment">/* Note direct access to variables v, typcache, left_range, right_range */<br/></li>
<li><a id="L114">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PLACE_LEFT</span>(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, off)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">do</span><span class="PreProc"> {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="PreProc"> (v-&gt;spl_nleft &gt; </span><span class="Constant">0</span><span class="PreProc">)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; left_range = <a href="#L821" title="utils/adt/rangetypes_gist.c:821">range_super_union</a>(typcache, left_range, <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">else</span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; left_range = (<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; v-&gt;spl_left[v-&gt;spl_nleft++] = (off);&nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; } </span><span class="Statement">while</span><span class="PreProc">(</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><a id="L123">&#x200c;</a><span class="PreProc">#define <span class="linkable">PLACE_RIGHT</span>(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, off)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">do</span><span class="PreProc"> {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="PreProc"> (v-&gt;spl_nright &gt; </span><span class="Constant">0</span><span class="PreProc">)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; right_range = <a href="#L821" title="utils/adt/rangetypes_gist.c:821">range_super_union</a>(typcache, right_range, <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">else</span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; right_range = (<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; v-&gt;spl_right[v-&gt;spl_nright++] = (off);&nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; } </span><span class="Statement">while</span><span class="PreProc">(</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Copy a RangeType datum (hardwires typbyval and typlen for ranges...) */<br/></li>
<li><a id="L133">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">rangeCopy</span>(r) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((RangeType *) DatumGetPointer(<a href="datum.c.html#L132" title="utils/adt/datum.c:132">datumCopy</a>(PointerGetDatum(r), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="Constant">false</span><span class="PreProc">, -</span><span class="Constant">1</span><span class="PreProc">)))<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> RangeType *<a href="#L821" title="utils/adt/rangetypes_gist.c:821">range_super_union</a>(TypeCacheEntry *typcache, RangeType *r1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeType *r2);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L915" title="utils/adt/rangetypes_gist.c:915">range_gist_consistent_int_range</a>(TypeCacheEntry *typcache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StrategyNumber strategy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> RangeType *key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> RangeType *query);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L977" title="utils/adt/rangetypes_gist.c:977">range_gist_consistent_int_multirange</a>(TypeCacheEntry *typcache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; StrategyNumber strategy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> RangeType *key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> MultirangeType *query);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1039" title="utils/adt/rangetypes_gist.c:1039">range_gist_consistent_int_element</a>(TypeCacheEntry *typcache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StrategyNumber strategy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> RangeType *key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum query);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1058" title="utils/adt/rangetypes_gist.c:1058">range_gist_consistent_leaf_range</a>(TypeCacheEntry *typcache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; StrategyNumber strategy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> RangeType *key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> RangeType *query);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1093" title="utils/adt/rangetypes_gist.c:1093">range_gist_consistent_leaf_multirange</a>(TypeCacheEntry *typcache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StrategyNumber strategy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> RangeType *key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> MultirangeType *query);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1128" title="utils/adt/rangetypes_gist.c:1128">range_gist_consistent_leaf_element</a>(TypeCacheEntry *typcache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; StrategyNumber strategy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> RangeType *key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum query);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1148" title="utils/adt/rangetypes_gist.c:1148">range_gist_fallback_split</a>(TypeCacheEntry *typcache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GistEntryVector *entryvec,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GIST_SPLITVEC *v);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1186" title="utils/adt/rangetypes_gist.c:1186">range_gist_class_split</a>(TypeCacheEntry *typcache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GistEntryVector *entryvec,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GIST_SPLITVEC *v,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L66" title="utils/adt/rangetypes_gist.c:66">SplitLR</a> *classes_groups);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1229" title="utils/adt/rangetypes_gist.c:1229">range_gist_single_sorting_split</a>(TypeCacheEntry *typcache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GistEntryVector *entryvec,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GIST_SPLITVEC *v,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> use_upper_bound);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1318" title="utils/adt/rangetypes_gist.c:1318">range_gist_double_sorting_split</a>(TypeCacheEntry *typcache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GistEntryVector *entryvec,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GIST_SPLITVEC *v);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1621" title="utils/adt/rangetypes_gist.c:1621">range_gist_consider_split</a>(<a href="../../access/gist/gistproc.c.html#L300" title="access/gist/gistproc.c:300">ConsiderSplitContext</a> *context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeBound *right_lower, <span class="Type">int</span> min_left_count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeBound *left_upper, <span class="Type">int</span> max_left_count);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1704" title="utils/adt/rangetypes_gist.c:1704">get_gist_range_class</a>(RangeType *<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1731" title="utils/adt/rangetypes_gist.c:1731">single_bound_cmp</a>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b, <span class="Type">void</span> *arg);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="../../access/gist/gistproc.c.html#L315" title="access/gist/gistproc.c:315">interval_cmp_lower</a>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b, <span class="Type">void</span> *arg);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="../../access/gist/gistproc.c.html#L327" title="access/gist/gistproc.c:327">interval_cmp_upper</a>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b, <span class="Type">void</span> *arg);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="../../access/gist/gistproc.c.html#L460" title="access/gist/gistproc.c:460">common_entry_cmp</a>(<span class="Type">const</span> <span class="Type">void</span> *i1, <span class="Type">const</span> <span class="Type">void</span> *i2);<br/></li>
<li><span class="Type">static</span> float8 <a href="#L1788" title="utils/adt/rangetypes_gist.c:1788">call_subtype_diff</a>(TypeCacheEntry *typcache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum val1, Datum val2);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* GiST query consistency check */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L191">&#x200c;</a><span class="linkable">range_gist_consistent</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GISTENTRY&nbsp; *entry = (GISTENTRY *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; query = PG_GETARG_DATUM(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; StrategyNumber strategy = (StrategyNumber) PG_GETARG_UINT16(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subtype = PG_GETARG_OID(<span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *recheck = (<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) PG_GETARG_POINTER(<span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *key = DatumGetRangeTypeP(entry-&gt;key);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* All operators served by this function are exact */<br/></li>
<li></span>&nbsp; &nbsp; *recheck = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="rangetypes.c.html#L1703" title="utils/adt/rangetypes.c:1703">range_get_typcache</a>(fcinfo, RangeTypeGetOid(key));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Perform consistent checking using function corresponding to key type<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (leaf or <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a>) and query subtype (<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, multirange, or <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that invalid subtype means that query type matches key type<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (GIST_LEAF(entry))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(subtype) || subtype == ANYRANGEOID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L1058" title="utils/adt/rangetypes_gist.c:1058">range_gist_consistent_leaf_range</a>(typcache, strategy, key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DatumGetRangeTypeP(query));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (subtype == ANYMULTIRANGEOID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L1093" title="utils/adt/rangetypes_gist.c:1093">range_gist_consistent_leaf_multirange</a>(typcache, strategy, key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; DatumGetMultirangeTypeP(query));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L1128" title="utils/adt/rangetypes_gist.c:1128">range_gist_consistent_leaf_element</a>(typcache, strategy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key, query);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(subtype) || subtype == ANYRANGEOID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L915" title="utils/adt/rangetypes_gist.c:915">range_gist_consistent_int_range</a>(typcache, strategy, key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; DatumGetRangeTypeP(query));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (subtype == ANYMULTIRANGEOID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L977" title="utils/adt/rangetypes_gist.c:977">range_gist_consistent_int_multirange</a>(typcache, strategy, key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DatumGetMultirangeTypeP(query));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L1039" title="utils/adt/rangetypes_gist.c:1039">range_gist_consistent_int_element</a>(typcache, strategy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; key, query);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GiST compress method for multiranges: multirange is approximated as union<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> with no gaps.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L245">&#x200c;</a><span class="linkable">multirange_gist_compress</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GISTENTRY&nbsp; *entry = (GISTENTRY *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;leafkey)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MultirangeType *mr = DatumGetMultirangeTypeP(entry-&gt;key);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeType&nbsp; *r;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GISTENTRY&nbsp; *retval = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(GISTENTRY));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typcache = <a href="multirangetypes.c.html#L548" title="utils/adt/multirangetypes.c:548">multirange_get_typcache</a>(fcinfo, MultirangeTypeGetOid(mr));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; r = <a href="multirangetypes.c.html#L802" title="utils/adt/multirangetypes.c:802">multirange_get_union_range</a>(typcache-&gt;rngtype, mr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gistentryinit(*retval, RangeTypePGetDatum(r),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;rel, entry-&gt;page, entry-&gt;offset, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_POINTER(retval);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(entry);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* GiST query consistency check for multiranges */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L270">&#x200c;</a><span class="linkable">multirange_gist_consistent</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GISTENTRY&nbsp; *entry = (GISTENTRY *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; query = PG_GETARG_DATUM(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; StrategyNumber strategy = (StrategyNumber) PG_GETARG_UINT16(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subtype = PG_GETARG_OID(<span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *recheck = (<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) PG_GETARG_POINTER(<span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *key = DatumGetRangeTypeP(entry-&gt;key);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * All operators served by this function are inexact because multirange is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * approximated by union <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> with no gaps.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; *recheck = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="rangetypes.c.html#L1703" title="utils/adt/rangetypes.c:1703">range_get_typcache</a>(fcinfo, RangeTypeGetOid(key));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Perform consistent checking using function corresponding to key type<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (leaf or <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a>) and query subtype (<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, multirange, or <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that invalid subtype means that query type matches key type<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (multirange).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (GIST_LEAF(entry))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(subtype) || subtype == ANYMULTIRANGEOID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L1093" title="utils/adt/rangetypes_gist.c:1093">range_gist_consistent_leaf_multirange</a>(typcache, strategy, key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; DatumGetMultirangeTypeP(query));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (subtype == ANYRANGEOID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L1058" title="utils/adt/rangetypes_gist.c:1058">range_gist_consistent_leaf_range</a>(typcache, strategy, key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DatumGetRangeTypeP(query));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L1128" title="utils/adt/rangetypes_gist.c:1128">range_gist_consistent_leaf_element</a>(typcache, strategy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key, query);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(subtype) || subtype == ANYMULTIRANGEOID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L977" title="utils/adt/rangetypes_gist.c:977">range_gist_consistent_int_multirange</a>(typcache, strategy, key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DatumGetMultirangeTypeP(query));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (subtype == ANYRANGEOID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L915" title="utils/adt/rangetypes_gist.c:915">range_gist_consistent_int_range</a>(typcache, strategy, key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; DatumGetRangeTypeP(query));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L1039" title="utils/adt/rangetypes_gist.c:1039">range_gist_consistent_int_element</a>(typcache, strategy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; key, query);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* form union <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L324">&#x200c;</a><span class="linkable">range_gist_union</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GistEntryVector *entryvec = (GistEntryVector *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; GISTENTRY&nbsp; *ent = entryvec-&gt;vector;<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *result_range;<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result_range = DatumGetRangeTypeP(ent[<span class="Constant">0</span>].key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="rangetypes.c.html#L1703" title="utils/adt/rangetypes.c:1703">range_get_typcache</a>(fcinfo, RangeTypeGetOid(result_range));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt; entryvec-&gt;n; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result_range = <a href="#L821" title="utils/adt/rangetypes_gist.c:821">range_super_union</a>(typcache, result_range,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; DatumGetRangeTypeP(ent[i].key));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_RANGE_P(result_range);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * We store ranges as ranges in GiST indexes, so we do not need<br/></li>
<li></span><span class="Comment"> * compress, decompress, or fetch <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.&nbsp; Note this implies a limit<br/></li>
<li></span><span class="Comment"> * on the size of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> that can be indexed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GiST page split penalty function.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The penalty function has the following goals (in order from most to least<br/></li>
<li></span><span class="Comment"> * important):<br/></li>
<li></span><span class="Comment"> * - Keep normal ranges separate<br/></li>
<li></span><span class="Comment"> * - Avoid broadening the class of the original predicate<br/></li>
<li></span><span class="Comment"> * - Avoid broadening (as determined by subtype_diff) the original predicate<br/></li>
<li></span><span class="Comment"> * - Favor adding ranges to narrower original predicates<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L362">&#x200c;</a><span class="linkable">range_gist_penalty</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GISTENTRY&nbsp; *origentry = (GISTENTRY *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; GISTENTRY&nbsp; *newentry = (GISTENTRY *) PG_GETARG_POINTER(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">float</span>&nbsp; &nbsp; &nbsp;&nbsp; *penalty = (<span class="Type">float</span> *) PG_GETARG_POINTER(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *orig = DatumGetRangeTypeP(origentry-&gt;key);<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *new = DatumGetRangeTypeP(newentry-&gt;key);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; has_subtype_diff;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; orig_lower,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_lower,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; orig_upper,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_upper;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; orig_empty,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_empty;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (RangeTypeGetOid(orig) != RangeTypeGetOid(new))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> types do not match&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typcache = <a href="rangetypes.c.html#L1703" title="utils/adt/rangetypes.c:1703">range_get_typcache</a>(fcinfo, RangeTypeGetOid(orig));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; has_subtype_diff = OidIsValid(typcache-&gt;rng_subdiff_finfo.fn_oid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="rangetypes.c.html#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(typcache, orig, &amp;orig_lower, &amp;orig_upper, &amp;orig_empty);<br/></li>
<li>&nbsp; &nbsp; <a href="rangetypes.c.html#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(typcache, new, &amp;new_lower, &amp;new_upper, &amp;new_empty);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Distinct branches for handling distinct classes of ranges.&nbsp; Note that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * penalty <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> only need to be commensurate within the same class of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * new <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (new_empty)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Handle insertion of empty <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (orig_empty)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The best case is to insert it to empty original <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Insertion here means no broadening of original <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>. Also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * original <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> is the most narrow.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *penalty = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (RangeIsOrContainsEmpty(orig))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The second case is to insert empty <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> into <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * contains at least one underlying empty <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.&nbsp; There is still<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * no broadening of original <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, but original <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> is not as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * narrow as possible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *penalty = <a href="#L49" title="utils/adt/rangetypes_gist.c:49">CONTAIN_EMPTY_PENALTY</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (orig_lower.infinite &amp;&amp; orig_upper.infinite)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Original <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> requires broadening.&nbsp; (-inf; +inf) is most far<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * from normal <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> in this case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *penalty = <span class="Constant">2</span> * <a href="#L49" title="utils/adt/rangetypes_gist.c:49">CONTAIN_EMPTY_PENALTY</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (orig_lower.infinite || orig_upper.infinite)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (-inf, x) or (x, +inf) original ranges are closer to normal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ranges, so it's worse to mix it with empty ranges.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *penalty = <span class="Constant">3</span> * <a href="#L49" title="utils/adt/rangetypes_gist.c:49">CONTAIN_EMPTY_PENALTY</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The least preferred case is broadening of normal <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *penalty = <span class="Constant">4</span> * <a href="#L49" title="utils/adt/rangetypes_gist.c:49">CONTAIN_EMPTY_PENALTY</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (new_lower.infinite &amp;&amp; new_upper.infinite)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Handle insertion of (-inf, +inf) <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (orig_lower.infinite &amp;&amp; orig_upper.infinite)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Best case is inserting to (-inf, +inf) original <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *penalty = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (orig_lower.infinite || orig_upper.infinite)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When original <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> is (-inf, x) or (x, +inf) it requires<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * broadening of original <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> (extension of one bound to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * infinity).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *penalty = <a href="#L48" title="utils/adt/rangetypes_gist.c:48">INFINITE_BOUND_PENALTY</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Insertion to normal original <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> is least preferred.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *penalty = <span class="Constant">2</span> * <a href="#L48" title="utils/adt/rangetypes_gist.c:48">INFINITE_BOUND_PENALTY</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RangeIsOrContainsEmpty(orig))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Original <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> is narrower when it doesn't contain empty<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ranges. Add additional penalty otherwise.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *penalty += <a href="#L49" title="utils/adt/rangetypes_gist.c:49">CONTAIN_EMPTY_PENALTY</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (new_lower.infinite)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Handle insertion of (-inf, x) <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!orig_empty &amp;&amp; orig_lower.infinite)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (orig_upper.infinite)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (-inf, +inf) <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> won't be extended by insertion of (-inf,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * x) <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>. It's a less desirable case than insertion to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (-inf, y) original <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> without extension, because in that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * case original <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> is narrower. But we can't express that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in single float value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *penalty = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="rangetypes.c.html#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache, &amp;new_upper, &amp;orig_upper) &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Get extension of original <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> using subtype_diff. Use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * constant if subtype_diff unavailable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (has_subtype_diff)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *penalty = <a href="#L1788" title="utils/adt/rangetypes_gist.c:1788">call_subtype_diff</a>(typcache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; new_upper.val,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; orig_upper.val);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *penalty = <a href="#L50" title="utils/adt/rangetypes_gist.c:50">DEFAULT_SUBTYPE_DIFF_PENALTY</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No extension of original <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *penalty = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound of original <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> is not -inf, then extension of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it is infinity.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *penalty = get_float4_infinity();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (new_upper.infinite)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Handle insertion of (x, +inf) <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!orig_empty &amp;&amp; orig_upper.infinite)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (orig_lower.infinite)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (-inf, +inf) <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> won't be extended by insertion of (x,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * +inf) <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>. It's a less desirable case than insertion to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (y, +inf) original <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> without extension, because in that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * case original <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> is narrower. But we can't express that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in single float value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *penalty = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="rangetypes.c.html#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache, &amp;new_lower, &amp;orig_lower) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Get extension of original <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> using subtype_diff. Use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * constant if subtype_diff unavailable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (has_subtype_diff)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *penalty = <a href="#L1788" title="utils/adt/rangetypes_gist.c:1788">call_subtype_diff</a>(typcache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; orig_lower.val,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; new_lower.val);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *penalty = <a href="#L50" title="utils/adt/rangetypes_gist.c:50">DEFAULT_SUBTYPE_DIFF_PENALTY</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No extension of original <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *penalty = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound of original <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> is not +inf, then extension of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it is infinity.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *penalty = get_float4_infinity();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Handle insertion of normal (non-empty, non-infinite) <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (orig_empty || orig_lower.infinite || orig_upper.infinite)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Avoid mixing normal ranges with infinite and empty ranges.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *penalty = get_float4_infinity();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Calculate extension of original <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> by calling subtype_diff.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Use constant if subtype_diff unavailable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; diff = <span class="Constant">0.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="rangetypes.c.html#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache, &amp;new_lower, &amp;orig_lower) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (has_subtype_diff)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; diff += <a href="#L1788" title="utils/adt/rangetypes_gist.c:1788">call_subtype_diff</a>(typcache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; orig_lower.val,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_lower.val);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; diff += <a href="#L50" title="utils/adt/rangetypes_gist.c:50">DEFAULT_SUBTYPE_DIFF_PENALTY</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="rangetypes.c.html#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache, &amp;new_upper, &amp;orig_upper) &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (has_subtype_diff)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; diff += <a href="#L1788" title="utils/adt/rangetypes_gist.c:1788">call_subtype_diff</a>(typcache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_upper.val,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; orig_upper.val);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; diff += <a href="#L50" title="utils/adt/rangetypes_gist.c:50">DEFAULT_SUBTYPE_DIFF_PENALTY</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *penalty = diff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(penalty);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The GiST PickSplit method for ranges<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Primarily, we try to segregate ranges of different classes.&nbsp; If splitting<br/></li>
<li></span><span class="Comment"> * ranges of the same class, use the appropriate split method for that class.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L619">&#x200c;</a><span class="linkable">range_gist_picksplit</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GistEntryVector *entryvec = (GistEntryVector *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; GIST_SPLITVEC *v = (GIST_SPLITVEC *) PG_GETARG_POINTER(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber i;<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *pred_left;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbytes;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber maxoff;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count_in_classes[<a href="#L36" title="utils/adt/rangetypes_gist.c:36">CLS_COUNT</a>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; non_empty_classes_count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; biggest_class = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; biggest_class_count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; total_count;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* use first item to look up <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> type's info */<br/></li>
<li></span>&nbsp; &nbsp; pred_left = DatumGetRangeTypeP(entryvec-&gt;vector[FirstOffsetNumber].key);<br/></li>
<li>&nbsp; &nbsp; typcache = <a href="rangetypes.c.html#L1703" title="utils/adt/rangetypes.c:1703">range_get_typcache</a>(fcinfo, RangeTypeGetOid(pred_left));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; maxoff = entryvec-&gt;n - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; nbytes = (maxoff + <span class="Constant">1</span>) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(OffsetNumber);<br/></li>
<li>&nbsp; &nbsp; v-&gt;spl_left = (OffsetNumber *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(nbytes);<br/></li>
<li>&nbsp; &nbsp; v-&gt;spl_right = (OffsetNumber *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(nbytes);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get count distribution of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> classes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; memset(count_in_classes, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(count_in_classes));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = FirstOffsetNumber; i &lt;= maxoff; i = OffsetNumberNext(i))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeType&nbsp; *<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> = DatumGetRangeTypeP(entryvec-&gt;vector[i].key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; count_in_classes[<a href="#L1704" title="utils/adt/rangetypes_gist.c:1704">get_gist_range_class</a>(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>)]++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Count non-empty classes and <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> biggest class.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; total_count = maxoff;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (j = <span class="Constant">0</span>; j &lt; <a href="#L36" title="utils/adt/rangetypes_gist.c:36">CLS_COUNT</a>; j++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (count_in_classes[j] &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (count_in_classes[j] &gt; biggest_class_count)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; biggest_class_count = count_in_classes[j];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; biggest_class = j;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; non_empty_classes_count++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(non_empty_classes_count &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (non_empty_classes_count == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* One non-empty class, so split inside class */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((biggest_class &amp; ~<a href="#L33" title="utils/adt/rangetypes_gist.c:33">CLS_CONTAIN_EMPTY</a>) == <a href="#L30" title="utils/adt/rangetypes_gist.c:30">CLS_NORMAL</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* double sorting split for normal ranges */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1318" title="utils/adt/rangetypes_gist.c:1318">range_gist_double_sorting_split</a>(typcache, entryvec, v);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> ((biggest_class &amp; ~<a href="#L33" title="utils/adt/rangetypes_gist.c:33">CLS_CONTAIN_EMPTY</a>) == <a href="#L31" title="utils/adt/rangetypes_gist.c:31">CLS_LOWER_INF</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound sorting split for (-inf, x) ranges */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1229" title="utils/adt/rangetypes_gist.c:1229">range_gist_single_sorting_split</a>(typcache, entryvec, v, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> ((biggest_class &amp; ~<a href="#L33" title="utils/adt/rangetypes_gist.c:33">CLS_CONTAIN_EMPTY</a>) == <a href="#L32" title="utils/adt/rangetypes_gist.c:32">CLS_UPPER_INF</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound sorting split for (x, +inf) ranges */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1229" title="utils/adt/rangetypes_gist.c:1229">range_gist_single_sorting_split</a>(typcache, entryvec, v, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* trivial split for all (-inf, +inf) or all empty ranges */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1148" title="utils/adt/rangetypes_gist.c:1148">range_gist_fallback_split</a>(typcache, entryvec, v);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Class based split.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * To which side of the split should each class go?&nbsp; Initialize them<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * all to go to the left side.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L66" title="utils/adt/rangetypes_gist.c:66">SplitLR</a>&nbsp; &nbsp; &nbsp; &nbsp; classes_groups[<a href="#L36" title="utils/adt/rangetypes_gist.c:36">CLS_COUNT</a>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memset(classes_groups, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(classes_groups));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (count_in_classes[<a href="#L30" title="utils/adt/rangetypes_gist.c:30">CLS_NORMAL</a>] &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* separate normal ranges if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; classes_groups[<a href="#L30" title="utils/adt/rangetypes_gist.c:30">CLS_NORMAL</a>] = SPLIT_RIGHT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Try to split classes in one of two ways:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; 1) containing infinities - not containing infinities<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; 2) containing empty - not containing empty<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Select the way which balances the ranges between left and right<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the best. If split in these ways is not possible, there are at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * most 3 classes, so just separate biggest class.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; infCount,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nonInfCount;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; emptyCount,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nonEmptyCount;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nonInfCount =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count_in_classes[<a href="#L30" title="utils/adt/rangetypes_gist.c:30">CLS_NORMAL</a>] +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count_in_classes[<a href="#L33" title="utils/adt/rangetypes_gist.c:33">CLS_CONTAIN_EMPTY</a>] +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count_in_classes[<a href="#L34" title="utils/adt/rangetypes_gist.c:34">CLS_EMPTY</a>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; infCount = total_count - nonInfCount;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nonEmptyCount =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count_in_classes[<a href="#L30" title="utils/adt/rangetypes_gist.c:30">CLS_NORMAL</a>] +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count_in_classes[<a href="#L31" title="utils/adt/rangetypes_gist.c:31">CLS_LOWER_INF</a>] +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count_in_classes[<a href="#L32" title="utils/adt/rangetypes_gist.c:32">CLS_UPPER_INF</a>] +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count_in_classes[<a href="#L31" title="utils/adt/rangetypes_gist.c:31">CLS_LOWER_INF</a> | <a href="#L32" title="utils/adt/rangetypes_gist.c:32">CLS_UPPER_INF</a>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; emptyCount = total_count - nonEmptyCount;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (infCount &gt; <span class="Constant">0</span> &amp;&amp; nonInfCount &gt; <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (abs(infCount - nonInfCount) &lt;=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; abs(emptyCount - nonEmptyCount)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; classes_groups[<a href="#L30" title="utils/adt/rangetypes_gist.c:30">CLS_NORMAL</a>] = SPLIT_RIGHT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; classes_groups[<a href="#L33" title="utils/adt/rangetypes_gist.c:33">CLS_CONTAIN_EMPTY</a>] = SPLIT_RIGHT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; classes_groups[<a href="#L34" title="utils/adt/rangetypes_gist.c:34">CLS_EMPTY</a>] = SPLIT_RIGHT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (emptyCount &gt; <span class="Constant">0</span> &amp;&amp; nonEmptyCount &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; classes_groups[<a href="#L30" title="utils/adt/rangetypes_gist.c:30">CLS_NORMAL</a>] = SPLIT_RIGHT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; classes_groups[<a href="#L31" title="utils/adt/rangetypes_gist.c:31">CLS_LOWER_INF</a>] = SPLIT_RIGHT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; classes_groups[<a href="#L32" title="utils/adt/rangetypes_gist.c:32">CLS_UPPER_INF</a>] = SPLIT_RIGHT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; classes_groups[<a href="#L31" title="utils/adt/rangetypes_gist.c:31">CLS_LOWER_INF</a> | <a href="#L32" title="utils/adt/rangetypes_gist.c:32">CLS_UPPER_INF</a>] = SPLIT_RIGHT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Either total_count == emptyCount or total_count ==<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * infCount.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; classes_groups[biggest_class] = SPLIT_RIGHT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1186" title="utils/adt/rangetypes_gist.c:1186">range_gist_class_split</a>(typcache, entryvec, v, classes_groups);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(v);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* equality comparator for GiST */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L778">&#x200c;</a><span class="linkable">range_gist_same</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r1 = PG_GETARG_RANGE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *r2 = PG_GETARG_RANGE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *result = (<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) PG_GETARG_POINTER(<span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="rangetypes.c.html#L605" title="utils/adt/rangetypes.c:605">range_eq</a> will ignore the RANGE_CONTAIN_EMPTY flag, so we have to check<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that for ourselves.&nbsp; More generally, if the entries have been properly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * normalized, then unequal flags bytes must mean unequal ranges ... so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * let's just test all the flag bits at once.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="rangetypes.c.html#L1923" title="utils/adt/rangetypes.c:1923">range_get_flags</a>(r1) != <a href="rangetypes.c.html#L1923" title="utils/adt/rangetypes.c:1923">range_get_flags</a>(r2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TypeCacheEntry *typcache;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typcache = <a href="rangetypes.c.html#L1703" title="utils/adt/rangetypes.c:1703">range_get_typcache</a>(fcinfo, RangeTypeGetOid(r1));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *result = <a href="rangetypes.c.html#L573" title="utils/adt/rangetypes.c:573">range_eq_internal</a>(typcache, r1, r2);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *----------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * STATIC FUNCTIONS<br/></li>
<li></span><span class="Comment"> *----------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the smallest <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> that contains r1 and r2<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This differs from regular <a href="rangetypes.c.html#L1098" title="utils/adt/rangetypes.c:1098">range_union</a> in two critical ways:<br/></li>
<li></span><span class="Comment"> * 1. It won't throw an error for non-adjacent r1 and r2, but just absorb<br/></li>
<li></span><span class="Comment"> * the intervening <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> into the result <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.<br/></li>
<li></span><span class="Comment"> * 2. We track whether <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> empty <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> has been union'd into the result,<br/></li>
<li></span><span class="Comment"> * so that contained_by searches can be indexed.&nbsp; Note that this means<br/></li>
<li></span><span class="Comment"> * that *all* unions formed within the GiST index must go through here.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> RangeType *<br/></li>
<li><a id="L821">&#x200c;</a><span class="linkable">range_super_union</span>(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; lower1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lower2;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; upper1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; empty1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; empty2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; flags1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags2;<br/></li>
<li>&nbsp; &nbsp; RangeBound *result_lower;<br/></li>
<li>&nbsp; &nbsp; RangeBound *result_upper;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="rangetypes.c.html#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(typcache, r1, &amp;lower1, &amp;upper1, &amp;empty1);<br/></li>
<li>&nbsp; &nbsp; <a href="rangetypes.c.html#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(typcache, r2, &amp;lower2, &amp;upper2, &amp;empty2);<br/></li>
<li>&nbsp; &nbsp; flags1 = <a href="rangetypes.c.html#L1923" title="utils/adt/rangetypes.c:1923">range_get_flags</a>(r1);<br/></li>
<li>&nbsp; &nbsp; flags2 = <a href="rangetypes.c.html#L1923" title="utils/adt/rangetypes.c:1923">range_get_flags</a>(r2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (empty1)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We can return r2 as-is if it already is or contains empty */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (flags2 &amp; (RANGE_EMPTY | RANGE_CONTAIN_EMPTY))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> r2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Else we'd better copy it (modify-in-place isn't safe) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; r2 = <a href="#L133" title="utils/adt/rangetypes_gist.c:133">rangeCopy</a>(r2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="rangetypes.c.html#L1937" title="utils/adt/rangetypes.c:1937">range_set_contain_empty</a>(r2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> r2;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (empty2)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We can return r1 as-is if it already is or contains empty */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (flags1 &amp; (RANGE_EMPTY | RANGE_CONTAIN_EMPTY))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> r1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Else we'd better copy it (modify-in-place isn't safe) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; r1 = <a href="#L133" title="utils/adt/rangetypes_gist.c:133">rangeCopy</a>(r1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="rangetypes.c.html#L1937" title="utils/adt/rangetypes.c:1937">range_set_contain_empty</a>(r1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> r1;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="rangetypes.c.html#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache, &amp;lower1, &amp;lower2) &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result_lower = &amp;lower1;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result_lower = &amp;lower2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="rangetypes.c.html#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache, &amp;upper1, &amp;upper2) &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result_upper = &amp;upper1;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result_upper = &amp;upper2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* optimization to avoid constructing a new <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (result_lower == &amp;lower1 &amp;&amp; result_upper == &amp;upper1 &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ((flags1 &amp; RANGE_CONTAIN_EMPTY) || !(flags2 &amp; RANGE_CONTAIN_EMPTY)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> r1;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result_lower == &amp;lower2 &amp;&amp; result_upper == &amp;upper2 &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ((flags2 &amp; RANGE_CONTAIN_EMPTY) || !(flags1 &amp; RANGE_CONTAIN_EMPTY)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> r2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="rangetypes.c.html#L1952" title="utils/adt/rangetypes.c:1952">make_range</a>(typcache, result_lower, result_upper, <span class="Constant">false</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((flags1 &amp; RANGE_CONTAIN_EMPTY) || (flags2 &amp; RANGE_CONTAIN_EMPTY))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="rangetypes.c.html#L1937" title="utils/adt/rangetypes.c:1937">range_set_contain_empty</a>(result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L888">&#x200c;</a></span><span class="linkable">multirange_union_range_equal</span>(TypeCacheEntry *typcache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> RangeType *r,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> MultirangeType *mr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; lower1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lower2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; empty;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (RangeIsEmpty(r) || MultirangeIsEmpty(mr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (RangeIsEmpty(r) &amp;&amp; MultirangeIsEmpty(mr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="rangetypes.c.html#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(typcache, r, &amp;lower1, &amp;upper1, &amp;empty);<br/></li>
<li>&nbsp; &nbsp; Assert(!empty);<br/></li>
<li>&nbsp; &nbsp; <a href="multirangetypes.c.html#L744" title="utils/adt/multirangetypes.c:744">multirange_get_bounds</a>(typcache, mr, <span class="Constant">0</span>, &amp;lower2, &amp;tmp);<br/></li>
<li>&nbsp; &nbsp; <a href="multirangetypes.c.html#L744" title="utils/adt/multirangetypes.c:744">multirange_get_bounds</a>(typcache, mr, mr-&gt;rangeCount - <span class="Constant">1</span>, &amp;tmp, &amp;upper2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (<a href="rangetypes.c.html#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache, &amp;lower1, &amp;lower2) == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="rangetypes.c.html#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache, &amp;upper1, &amp;upper2) == <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GiST consistent test on an index <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> page with <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> query<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L915">&#x200c;</a></span><span class="linkable">range_gist_consistent_int_range</span>(TypeCacheEntry *typcache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StrategyNumber strategy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> RangeType *key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> RangeType *query)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (strategy)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RANGESTRAT_BEFORE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RangeIsEmpty(key) || RangeIsEmpty(query))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (!<a href="rangetypes.c.html#L928" title="utils/adt/rangetypes.c:928">range_overright_internal</a>(typcache, key, query));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RANGESTRAT_OVERLEFT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RangeIsEmpty(key) || RangeIsEmpty(query))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (!<a href="rangetypes.c.html#L702" title="utils/adt/rangetypes.c:702">range_after_internal</a>(typcache, key, query));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RANGESTRAT_OVERLAPS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="rangetypes.c.html#L841" title="utils/adt/rangetypes.c:841">range_overlaps_internal</a>(typcache, key, query);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RANGESTRAT_OVERRIGHT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RangeIsEmpty(key) || RangeIsEmpty(query))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (!<a href="rangetypes.c.html#L664" title="utils/adt/rangetypes.c:664">range_before_internal</a>(typcache, key, query));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RANGESTRAT_AFTER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RangeIsEmpty(key) || RangeIsEmpty(query))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (!<a href="rangetypes.c.html#L887" title="utils/adt/rangetypes.c:887">range_overleft_internal</a>(typcache, key, query));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RANGESTRAT_ADJACENT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RangeIsEmpty(key) || RangeIsEmpty(query))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="rangetypes.c.html#L798" title="utils/adt/rangetypes.c:798">range_adjacent_internal</a>(typcache, key, query))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="rangetypes.c.html#L841" title="utils/adt/rangetypes.c:841">range_overlaps_internal</a>(typcache, key, query);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RANGESTRAT_CONTAINS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="rangetypes.c.html#L2586" title="utils/adt/rangetypes.c:2586">range_contains_internal</a>(typcache, key, query);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RANGESTRAT_CONTAINED_BY:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Empty ranges are contained by anything, so if key is or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * contains <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> empty ranges, we must descend into it.&nbsp; Otherwise,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * descend only if key overlaps the query.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RangeIsOrContainsEmpty(key))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="rangetypes.c.html#L841" title="utils/adt/rangetypes.c:841">range_overlaps_internal</a>(typcache, key, query);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RANGESTRAT_EQ:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If query is empty, descend only if the key is or contains <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * empty ranges.&nbsp; Otherwise, descend if key contains query.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RangeIsEmpty(query))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> RangeIsOrContainsEmpty(key);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="rangetypes.c.html#L2586" title="utils/adt/rangetypes.c:2586">range_contains_internal</a>(typcache, key, query);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> strategy: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, strategy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GiST consistent test on an index <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> page with multirange query<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L977">&#x200c;</a></span><span class="linkable">range_gist_consistent_int_multirange</span>(TypeCacheEntry *typcache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; StrategyNumber strategy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> RangeType *key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> MultirangeType *query)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (strategy)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RANGESTRAT_BEFORE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RangeIsEmpty(key) || MultirangeIsEmpty(query))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (!<a href="multirangetypes.c.html#L2158" title="utils/adt/multirangetypes.c:2158">range_overright_multirange_internal</a>(typcache, key, query));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RANGESTRAT_OVERLEFT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RangeIsEmpty(key) || MultirangeIsEmpty(query))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (!<a href="multirangetypes.c.html#L2446" title="utils/adt/multirangetypes.c:2446">range_after_multirange_internal</a>(typcache, key, query));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RANGESTRAT_OVERLAPS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="multirangetypes.c.html#L1993" title="utils/adt/multirangetypes.c:1993">range_overlaps_multirange_internal</a>(typcache, key, query);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RANGESTRAT_OVERRIGHT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RangeIsEmpty(key) || MultirangeIsEmpty(query))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (!<a href="multirangetypes.c.html#L2402" title="utils/adt/multirangetypes.c:2402">range_before_multirange_internal</a>(typcache, key, query));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RANGESTRAT_AFTER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RangeIsEmpty(key) || MultirangeIsEmpty(query))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (!<a href="multirangetypes.c.html#L2073" title="utils/adt/multirangetypes.c:2073">range_overleft_multirange_internal</a>(typcache, key, query));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RANGESTRAT_ADJACENT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RangeIsEmpty(key) || MultirangeIsEmpty(query))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="multirangetypes.c.html#L2471" title="utils/adt/multirangetypes.c:2471">range_adjacent_multirange_internal</a>(typcache, key, query))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="multirangetypes.c.html#L1993" title="utils/adt/multirangetypes.c:1993">range_overlaps_multirange_internal</a>(typcache, key, query);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RANGESTRAT_CONTAINS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="multirangetypes.c.html#L1829" title="utils/adt/multirangetypes.c:1829">range_contains_multirange_internal</a>(typcache, key, query);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RANGESTRAT_CONTAINED_BY:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Empty ranges are contained by anything, so if key is or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * contains <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> empty ranges, we must descend into it.&nbsp; Otherwise,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * descend only if key overlaps the query.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RangeIsOrContainsEmpty(key))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="multirangetypes.c.html#L1993" title="utils/adt/multirangetypes.c:1993">range_overlaps_multirange_internal</a>(typcache, key, query);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RANGESTRAT_EQ:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If query is empty, descend only if the key is or contains <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * empty ranges.&nbsp; Otherwise, descend if key contains query.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (MultirangeIsEmpty(query))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> RangeIsOrContainsEmpty(key);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="multirangetypes.c.html#L1829" title="utils/adt/multirangetypes.c:1829">range_contains_multirange_internal</a>(typcache, key, query);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> strategy: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, strategy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GiST consistent test on an index <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> page with <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> query<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1039">&#x200c;</a></span><span class="linkable">range_gist_consistent_int_element</span>(TypeCacheEntry *typcache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StrategyNumber strategy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> RangeType *key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum query)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (strategy)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RANGESTRAT_CONTAINS_ELEM:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="rangetypes.c.html#L2627" title="utils/adt/rangetypes.c:2627">range_contains_elem_internal</a>(typcache, key, query);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> strategy: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, strategy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GiST consistent test on an index leaf page with <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> query<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1058">&#x200c;</a></span><span class="linkable">range_gist_consistent_leaf_range</span>(TypeCacheEntry *typcache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; StrategyNumber strategy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> RangeType *key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> RangeType *query)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (strategy)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RANGESTRAT_BEFORE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="rangetypes.c.html#L664" title="utils/adt/rangetypes.c:664">range_before_internal</a>(typcache, key, query);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RANGESTRAT_OVERLEFT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="rangetypes.c.html#L887" title="utils/adt/rangetypes.c:887">range_overleft_internal</a>(typcache, key, query);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RANGESTRAT_OVERLAPS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="rangetypes.c.html#L841" title="utils/adt/rangetypes.c:841">range_overlaps_internal</a>(typcache, key, query);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RANGESTRAT_OVERRIGHT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="rangetypes.c.html#L928" title="utils/adt/rangetypes.c:928">range_overright_internal</a>(typcache, key, query);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RANGESTRAT_AFTER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="rangetypes.c.html#L702" title="utils/adt/rangetypes.c:702">range_after_internal</a>(typcache, key, query);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RANGESTRAT_ADJACENT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="rangetypes.c.html#L798" title="utils/adt/rangetypes.c:798">range_adjacent_internal</a>(typcache, key, query);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RANGESTRAT_CONTAINS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="rangetypes.c.html#L2586" title="utils/adt/rangetypes.c:2586">range_contains_internal</a>(typcache, key, query);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RANGESTRAT_CONTAINED_BY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="rangetypes.c.html#L2618" title="utils/adt/rangetypes.c:2618">range_contained_by_internal</a>(typcache, key, query);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RANGESTRAT_EQ:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="rangetypes.c.html#L573" title="utils/adt/rangetypes.c:573">range_eq_internal</a>(typcache, key, query);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> strategy: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, strategy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GiST consistent test on an index leaf page with multirange query<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1093">&#x200c;</a></span><span class="linkable">range_gist_consistent_leaf_multirange</span>(TypeCacheEntry *typcache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StrategyNumber strategy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> RangeType *key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> MultirangeType *query)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (strategy)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RANGESTRAT_BEFORE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="multirangetypes.c.html#L2402" title="utils/adt/multirangetypes.c:2402">range_before_multirange_internal</a>(typcache, key, query);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RANGESTRAT_OVERLEFT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="multirangetypes.c.html#L2073" title="utils/adt/multirangetypes.c:2073">range_overleft_multirange_internal</a>(typcache, key, query);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RANGESTRAT_OVERLAPS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="multirangetypes.c.html#L1993" title="utils/adt/multirangetypes.c:1993">range_overlaps_multirange_internal</a>(typcache, key, query);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RANGESTRAT_OVERRIGHT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="multirangetypes.c.html#L2158" title="utils/adt/multirangetypes.c:2158">range_overright_multirange_internal</a>(typcache, key, query);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RANGESTRAT_AFTER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="multirangetypes.c.html#L2446" title="utils/adt/multirangetypes.c:2446">range_after_multirange_internal</a>(typcache, key, query);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RANGESTRAT_ADJACENT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="multirangetypes.c.html#L2471" title="utils/adt/multirangetypes.c:2471">range_adjacent_multirange_internal</a>(typcache, key, query);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RANGESTRAT_CONTAINS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="multirangetypes.c.html#L1829" title="utils/adt/multirangetypes.c:1829">range_contains_multirange_internal</a>(typcache, key, query);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RANGESTRAT_CONTAINED_BY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="multirangetypes.c.html#L1801" title="utils/adt/multirangetypes.c:1801">multirange_contains_range_internal</a>(typcache, query, key);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RANGESTRAT_EQ:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L888" title="utils/adt/rangetypes_gist.c:888">multirange_union_range_equal</a>(typcache, key, query);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> strategy: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, strategy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GiST consistent test on an index leaf page with <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> query<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1128">&#x200c;</a></span><span class="linkable">range_gist_consistent_leaf_element</span>(TypeCacheEntry *typcache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; StrategyNumber strategy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> RangeType *key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum query)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (strategy)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RANGESTRAT_CONTAINS_ELEM:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="rangetypes.c.html#L2627" title="utils/adt/rangetypes.c:2627">range_contains_elem_internal</a>(typcache, key, query);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> strategy: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, strategy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Trivial split: half of entries will be placed on one page<br/></li>
<li></span><span class="Comment"> * and the other half on the other page.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1148">&#x200c;</a></span><span class="linkable">range_gist_fallback_split</span>(TypeCacheEntry *typcache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GistEntryVector *entryvec,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GIST_SPLITVEC *v)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *left_range = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *right_range = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxoff,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; split_idx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; maxoff = entryvec-&gt;n - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Split entries <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> this to left page, after to right: */<br/></li>
<li></span>&nbsp; &nbsp; split_idx = (maxoff - FirstOffsetNumber) / <span class="Constant">2</span> + FirstOffsetNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; v-&gt;spl_nleft = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; v-&gt;spl_nright = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = FirstOffsetNumber; i &lt;= maxoff; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeType&nbsp; *<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> = DatumGetRangeTypeP(entryvec-&gt;vector[i].key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &lt; split_idx)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/gist/gistproc.c.html#L712" title="access/gist/gistproc.c:712">PLACE_LEFT</a>(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/gist/gistproc.c.html#L721" title="access/gist/gistproc.c:721">PLACE_RIGHT</a>(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, i);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; v-&gt;spl_ldatum = RangeTypePGetDatum(left_range);<br/></li>
<li>&nbsp; &nbsp; v-&gt;spl_rdatum = RangeTypePGetDatum(right_range);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Split based on classes of ranges.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See <a href="#L1704" title="utils/adt/rangetypes_gist.c:1704">get_gist_range_class</a> for class definitions.<br/></li>
<li></span><span class="Comment"> * classes_groups is an array of length <a href="#L36" title="utils/adt/rangetypes_gist.c:36">CLS_COUNT</a> indicating the side of the<br/></li>
<li></span><span class="Comment"> * split to which each class should go.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1186">&#x200c;</a></span><span class="linkable">range_gist_class_split</span>(TypeCacheEntry *typcache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GistEntryVector *entryvec,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GIST_SPLITVEC *v,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L66" title="utils/adt/rangetypes_gist.c:66">SplitLR</a> *classes_groups)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *left_range = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *right_range = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxoff;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; maxoff = entryvec-&gt;n - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; v-&gt;spl_nleft = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; v-&gt;spl_nright = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = FirstOffsetNumber; i &lt;= maxoff; i = OffsetNumberNext(i))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeType&nbsp; *<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> = DatumGetRangeTypeP(entryvec-&gt;vector[i].key);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; class;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get class of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; class = <a href="#L1704" title="utils/adt/rangetypes_gist.c:1704">get_gist_range_class</a>(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Place <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> to appropriate page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (classes_groups[class] == SPLIT_LEFT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/gist/gistproc.c.html#L712" title="access/gist/gistproc.c:712">PLACE_LEFT</a>(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(classes_groups[class] == SPLIT_RIGHT);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/gist/gistproc.c.html#L721" title="access/gist/gistproc.c:721">PLACE_RIGHT</a>(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; v-&gt;spl_ldatum = RangeTypePGetDatum(left_range);<br/></li>
<li>&nbsp; &nbsp; v-&gt;spl_rdatum = RangeTypePGetDatum(right_range);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Sorting based split. First half of entries according to the sort will be<br/></li>
<li></span><span class="Comment"> * placed to one page, and second half of entries will be placed to other<br/></li>
<li></span><span class="Comment"> * page. use_upper_bound parameter indicates whether to use <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> or <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a><br/></li>
<li></span><span class="Comment"> * bound for sorting.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1229">&#x200c;</a></span><span class="linkable">range_gist_single_sorting_split</span>(TypeCacheEntry *typcache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GistEntryVector *entryvec,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GIST_SPLITVEC *v,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> use_upper_bound)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L59" title="utils/adt/rangetypes_gist.c:59">SingleBoundSortItem</a> *sortItems;<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *left_range = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *right_range = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxoff,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; split_idx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; maxoff = entryvec-&gt;n - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sortItems = (<a href="#L59" title="utils/adt/rangetypes_gist.c:59">SingleBoundSortItem</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(maxoff * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L59" title="utils/adt/rangetypes_gist.c:59">SingleBoundSortItem</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Prepare auxiliary array and sort the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = FirstOffsetNumber; i &lt;= maxoff; i = OffsetNumberNext(i))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeType&nbsp; *<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> = DatumGetRangeTypeP(entryvec-&gt;vector[i].key);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeBound&nbsp; &nbsp; bound2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; empty;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sortItems[i - <span class="Constant">1</span>].index = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Put appropriate bound into array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (use_upper_bound)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="rangetypes.c.html#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(typcache, <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, &amp;bound2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;sortItems[i - <span class="Constant">1</span>].bound, &amp;empty);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="rangetypes.c.html#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(typcache, <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, &amp;sortItems[i - <span class="Constant">1</span>].bound,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;bound2, &amp;empty);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!empty);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; qsort_arg(sortItems, maxoff, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L59" title="utils/adt/rangetypes_gist.c:59">SingleBoundSortItem</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1731" title="utils/adt/rangetypes_gist.c:1731">single_bound_cmp</a>, typcache);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; split_idx = maxoff / <span class="Constant">2</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; v-&gt;spl_nleft = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; v-&gt;spl_nright = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; maxoff; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idx = sortItems[i].index;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeType&nbsp; *<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> = DatumGetRangeTypeP(entryvec-&gt;vector[idx].key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &lt; split_idx)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/gist/gistproc.c.html#L712" title="access/gist/gistproc.c:712">PLACE_LEFT</a>(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, idx);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/gist/gistproc.c.html#L721" title="access/gist/gistproc.c:721">PLACE_RIGHT</a>(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, idx);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; v-&gt;spl_ldatum = RangeTypePGetDatum(left_range);<br/></li>
<li>&nbsp; &nbsp; v-&gt;spl_rdatum = RangeTypePGetDatum(right_range);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Double sorting split algorithm.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The algorithm considers dividing ranges into two groups. The first (left)<br/></li>
<li></span><span class="Comment"> * group contains general left bound. The second (right) group contains<br/></li>
<li></span><span class="Comment"> * general right bound. The challenge is to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound of left group<br/></li>
<li></span><span class="Comment"> * and <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound of right group so that overlap of groups is minimal and<br/></li>
<li></span><span class="Comment"> * ratio of distribution is acceptable. Algorithm finds for each <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound of<br/></li>
<li></span><span class="Comment"> * right group minimal <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound of left group, and for each <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound of<br/></li>
<li></span><span class="Comment"> * left group maximal <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound of right group. For each found pair<br/></li>
<li></span><span class="Comment"> * <a href="#L1621" title="utils/adt/rangetypes_gist.c:1621">range_gist_consider_split</a> considers replacement of currently selected<br/></li>
<li></span><span class="Comment"> * split with the new one.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * After that, all the entries are divided into three groups:<br/></li>
<li></span><span class="Comment"> * 1) Entries which should be placed to the left group<br/></li>
<li></span><span class="Comment"> * 2) Entries which should be placed to the right group<br/></li>
<li></span><span class="Comment"> * 3) &quot;Common entries&quot; which can be placed to either group without affecting<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; amount of overlap.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The common ranges are distributed by difference of distance from <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a><br/></li>
<li></span><span class="Comment"> * bound of common <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> to <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound of right group and distance from <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a><br/></li>
<li></span><span class="Comment"> * bound of common <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> to <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound of left group.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For details see:<br/></li>
<li></span><span class="Comment"> * &quot;A new double sorting-based node splitting algorithm for R-tree&quot;,<br/></li>
<li></span><span class="Comment"> * A. Korotkov<br/></li>
<li></span><span class="Comment"> * http://syrcose.ispras.ru/2011/files/SYRCoSE2011_Proceedings.pdf#page=36<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1318">&#x200c;</a></span><span class="linkable">range_gist_double_sorting_split</span>(TypeCacheEntry *typcache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GistEntryVector *entryvec,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GIST_SPLITVEC *v)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/gist/gistproc.c.html#L300" title="access/gist/gistproc.c:300">ConsiderSplitContext</a> context;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxoff;<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *left_range = <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *right_range = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; common_entries_count;<br/></li>
<li>&nbsp; &nbsp; <a href="#L98" title="utils/adt/rangetypes_gist.c:98">NonEmptyRange</a> *by_lower,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *by_upper;<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/gist/gistproc.c.html#L277" title="access/gist/gistproc.c:277">CommonEntry</a> *common_entries;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nentries,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i2;<br/></li>
<li>&nbsp; &nbsp; RangeBound *right_lower,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *left_upper;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memset(&amp;context, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="../../access/gist/gistproc.c.html#L300" title="access/gist/gistproc.c:300">ConsiderSplitContext</a>));<br/></li>
<li>&nbsp; &nbsp; context.typcache = typcache;<br/></li>
<li>&nbsp; &nbsp; context.has_subtype_diff = OidIsValid(typcache-&gt;rng_subdiff_finfo.fn_oid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; maxoff = entryvec-&gt;n - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; nentries = context.entries_count = maxoff - FirstOffsetNumber + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; context.first = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allocate arrays for sorted <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> bounds */<br/></li>
<li></span>&nbsp; &nbsp; by_lower = (<a href="#L98" title="utils/adt/rangetypes_gist.c:98">NonEmptyRange</a> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(nentries * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L98" title="utils/adt/rangetypes_gist.c:98">NonEmptyRange</a>));<br/></li>
<li>&nbsp; &nbsp; by_upper = (<a href="#L98" title="utils/adt/rangetypes_gist.c:98">NonEmptyRange</a> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(nentries * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L98" title="utils/adt/rangetypes_gist.c:98">NonEmptyRange</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fill arrays of bounds */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = FirstOffsetNumber; i &lt;= maxoff; i = OffsetNumberNext(i))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeType&nbsp; *<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> = DatumGetRangeTypeP(entryvec-&gt;vector[i].key);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; empty;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="rangetypes.c.html#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(typcache, <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;by_lower[i - FirstOffsetNumber].<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;by_lower[i - FirstOffsetNumber].<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;empty);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!empty);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make two arrays of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> bounds: one sorted by <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound and another<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sorted by <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; memcpy(by_upper, by_lower, nentries * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L98" title="utils/adt/rangetypes_gist.c:98">NonEmptyRange</a>));<br/></li>
<li>&nbsp; &nbsp; qsort_arg(by_lower, nentries, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L98" title="utils/adt/rangetypes_gist.c:98">NonEmptyRange</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/gist/gistproc.c.html#L315" title="access/gist/gistproc.c:315">interval_cmp_lower</a>, typcache);<br/></li>
<li>&nbsp; &nbsp; qsort_arg(by_upper, nentries, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L98" title="utils/adt/rangetypes_gist.c:98">NonEmptyRange</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/gist/gistproc.c.html#L327" title="access/gist/gistproc.c:327">interval_cmp_upper</a>, typcache);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The goal is to form a left and right <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, so that every entry<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> is contained by either left or right interval (or both).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For example, with the ranges (0,1), (1,3), (2,3), (2,4):<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 0 1 2 3 4<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * +-+<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp;&nbsp; +---+<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp;&nbsp; +-+<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp;&nbsp; +---+<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The left and right ranges are of the form (0,a) and (b,4).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We first consider splits where b is the <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound of an entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We iterate through all entries, and for each b, calculate the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * smallest possible a. Then we consider splits where a is the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound of an entry, and for each a, calculate the greatest<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * possible b.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In the above example, the first loop would consider splits:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * b=0: (0,1)-(0,4)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * b=1: (0,1)-(1,4)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * b=2: (0,3)-(2,4)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * And the second loop:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a=1: (0,1)-(1,4)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a=3: (0,3)-(2,4)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a=4: (0,4)-(2,4)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Iterate over <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound of right group, finding smallest possible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound of left group.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; i1 = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; i2 = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; right_lower = &amp;by_lower[i1].<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>;<br/></li>
<li>&nbsp; &nbsp; left_upper = &amp;by_upper[i2].<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<span class="Constant">true</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Find <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound of right group.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (i1 &lt; nentries &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="rangetypes.c.html#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache, right_lower,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;by_lower[i1].<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="rangetypes.c.html#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache, &amp;by_lower[i1].<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; left_upper) &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; left_upper = &amp;by_lower[i1].<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i1++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i1 &gt;= nentries)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; right_lower = &amp;by_lower[i1].<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Find count of ranges which anyway should be placed to the left<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * group.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (i2 &lt; nentries &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="rangetypes.c.html#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache, &amp;by_upper[i2].<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; left_upper) &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i2++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Consider found split to see if it's better than what we had.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1621" title="utils/adt/rangetypes_gist.c:1621">range_gist_consider_split</a>(&amp;context, right_lower, i1, left_upper, i2);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Iterate over <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound of left group finding greatest possible <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bound of right group.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; i1 = nentries - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; i2 = nentries - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; right_lower = &amp;by_lower[i1].<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>;<br/></li>
<li>&nbsp; &nbsp; left_upper = &amp;by_upper[i2].<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<span class="Constant">true</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Find <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound of left group.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (i2 &gt;= <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="rangetypes.c.html#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache, left_upper,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;by_upper[i2].<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="rangetypes.c.html#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache, &amp;by_upper[i2].<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; right_lower) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; right_lower = &amp;by_upper[i2].<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i2--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i2 &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; left_upper = &amp;by_upper[i2].<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Find count of intervals which anyway should be placed to the right<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * group.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (i1 &gt;= <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="rangetypes.c.html#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache, &amp;by_lower[i1].<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; right_lower) &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i1--;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Consider found split to see if it's better than what we had.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1621" title="utils/adt/rangetypes_gist.c:1621">range_gist_consider_split</a>(&amp;context, right_lower, i1 + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; left_upper, i2 + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we failed to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> acceptable splits, use trivial split.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (context.first)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1148" title="utils/adt/rangetypes_gist.c:1148">range_gist_fallback_split</a>(typcache, entryvec, v);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ok, we have <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> selected bounds of the groups. Now we have to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * distribute entries themselves. At first we distribute entries which can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be placed unambiguously and collect &quot;common entries&quot; to array.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allocate vectors for results */<br/></li>
<li></span>&nbsp; &nbsp; v-&gt;spl_left = (OffsetNumber *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(nentries * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(OffsetNumber));<br/></li>
<li>&nbsp; &nbsp; v-&gt;spl_right = (OffsetNumber *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(nentries * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(OffsetNumber));<br/></li>
<li>&nbsp; &nbsp; v-&gt;spl_nleft = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; v-&gt;spl_nright = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate an array for &quot;common entries&quot; - entries which can be placed to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * either group without affecting overlap along selected axis.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; common_entries_count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; common_entries = (<a href="../../access/gist/gistproc.c.html#L277" title="access/gist/gistproc.c:277">CommonEntry</a> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(nentries * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="../../access/gist/gistproc.c.html#L277" title="access/gist/gistproc.c:277">CommonEntry</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Distribute entries which can be distributed unambiguously, and collect<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * common entries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = FirstOffsetNumber; i &lt;= maxoff; i = OffsetNumberNext(i))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeType&nbsp; *<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeBound&nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; empty;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Get <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> and <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bounds along selected axis.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> = DatumGetRangeTypeP(entryvec-&gt;vector[i].key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="rangetypes.c.html#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(typcache, <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, &amp;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, &amp;<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>, &amp;empty);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="rangetypes.c.html#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache, &amp;<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>, context.left_upper) &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fits in the left group */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="rangetypes.c.html#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache, &amp;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, context.right_lower) &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fits also in the right group, so &quot;common entry&quot; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; common_entries[common_entries_count].index = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (context.has_subtype_diff)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * delta = (<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> - context.right_lower) -<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (context.left_upper - <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; common_entries[common_entries_count].delta =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1788" title="utils/adt/rangetypes_gist.c:1788">call_subtype_diff</a>(typcache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.val,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context.right_lower-&gt;val) -<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1788" title="utils/adt/rangetypes_gist.c:1788">call_subtype_diff</a>(typcache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context.left_upper-&gt;val,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.val);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Without subtype_diff, take all deltas as zero */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; common_entries[common_entries_count].delta = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; common_entries_count++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Doesn't fit to the right group, so join to the left group */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/gist/gistproc.c.html#L712" title="access/gist/gistproc.c:712">PLACE_LEFT</a>(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Each entry should fit on either left or right group. Since this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entry didn't fit in the left group, it better fit in the right<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * group.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="rangetypes.c.html#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache, &amp;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context.right_lower) &gt;= <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/gist/gistproc.c.html#L721" title="access/gist/gistproc.c:721">PLACE_RIGHT</a>(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Distribute &quot;common entries&quot;, if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (common_entries_count &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Sort &quot;common entries&quot; by calculated deltas in order to distribute<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the most ambiguous entries first.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; qsort(common_entries, common_entries_count, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="../../access/gist/gistproc.c.html#L277" title="access/gist/gistproc.c:277">CommonEntry</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/gist/gistproc.c.html#L460" title="access/gist/gistproc.c:460">common_entry_cmp</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Distribute &quot;common entries&quot; between groups according to sorting.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; common_entries_count; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeType&nbsp; *<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idx = common_entries[i].index;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> = DatumGetRangeTypeP(entryvec-&gt;vector[idx].key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check if we have to place this entry in either group to achieve<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../access/gist/gistproc.c.html#L44" title="access/gist/gistproc.c:44">LIMIT_RATIO</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &lt; context.common_left)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/gist/gistproc.c.html#L712" title="access/gist/gistproc.c:712">PLACE_LEFT</a>(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, idx);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/gist/gistproc.c.html#L721" title="access/gist/gistproc.c:721">PLACE_RIGHT</a>(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, idx);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; v-&gt;spl_ldatum = PointerGetDatum(left_range);<br/></li>
<li>&nbsp; &nbsp; v-&gt;spl_rdatum = PointerGetDatum(right_range);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Consider replacement of currently selected split with a better one<br/></li>
<li></span><span class="Comment"> * during <a href="#L1318" title="utils/adt/rangetypes_gist.c:1318">range_gist_double_sorting_split</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1621">&#x200c;</a></span><span class="linkable">range_gist_consider_split</span>(<a href="../../access/gist/gistproc.c.html#L300" title="access/gist/gistproc.c:300">ConsiderSplitContext</a> *context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeBound *right_lower, <span class="Type">int</span> min_left_count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeBound *left_upper, <span class="Type">int</span> max_left_count)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; left_count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; right_count;<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; ratio,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; overlap;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Calculate entries distribution ratio assuming most uniform distribution<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of common entries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (min_left_count &gt;= (context-&gt;entries_count + <span class="Constant">1</span>) / <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; left_count = min_left_count;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (max_left_count &lt;= context-&gt;entries_count / <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; left_count = max_left_count;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; left_count = context-&gt;entries_count / <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; right_count = context-&gt;entries_count - left_count;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ratio of split: quotient between size of smaller group and total<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * entries count.&nbsp; This is necessarily 0.5 or less; if it's less than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../access/gist/gistproc.c.html#L44" title="access/gist/gistproc.c:44">LIMIT_RATIO</a> then we will never <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> the new split.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ratio = ((float4) <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(left_count, right_count)) /<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ((float4) context-&gt;entries_count);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ratio &gt; <a href="../../access/gist/gistproc.c.html#L44" title="access/gist/gistproc.c:44">LIMIT_RATIO</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; selectthis = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The ratio is acceptable, so <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> current split with previously<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * selected one. We search for minimal overlap (allowing negative<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>) and minimal ratio secondarily.&nbsp; If subtype_diff is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * available, it's used for overlap measure.&nbsp; Without subtype_diff we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * use number of &quot;common entries&quot; as an overlap measure.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (context-&gt;has_subtype_diff)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; overlap = <a href="#L1788" title="utils/adt/rangetypes_gist.c:1788">call_subtype_diff</a>(context-&gt;typcache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; left_upper-&gt;val,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; right_lower-&gt;val);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; overlap = max_left_count - min_left_count;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If there is no previous selection, <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> this split */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (context-&gt;first)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selectthis = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Choose the new split if it has a smaller overlap, or same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * overlap but better ratio.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (overlap &lt; context-&gt;overlap ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (overlap == context-&gt;overlap &amp;&amp; ratio &gt; context-&gt;ratio))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selectthis = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (selectthis)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* save information about selected split */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;first = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;ratio = ratio;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;overlap = overlap;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;right_lower = right_lower;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;left_upper = left_upper;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;common_left = max_left_count - left_count;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;common_right = left_count - min_left_count;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Find class number for <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The class number is a valid combination of the properties of the<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.&nbsp; Note: the highest possible number is 8, because <a href="#L34" title="utils/adt/rangetypes_gist.c:34">CLS_EMPTY</a><br/></li>
<li></span><span class="Comment"> * can't be combined with anything else.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1704">&#x200c;</a></span><span class="linkable">get_gist_range_class</span>(RangeType *<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; classNumber;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; flags;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; flags = <a href="rangetypes.c.html#L1923" title="utils/adt/rangetypes.c:1923">range_get_flags</a>(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (flags &amp; RANGE_EMPTY)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; classNumber = <a href="#L34" title="utils/adt/rangetypes_gist.c:34">CLS_EMPTY</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; classNumber = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (flags &amp; RANGE_LB_INF)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; classNumber |= <a href="#L31" title="utils/adt/rangetypes_gist.c:31">CLS_LOWER_INF</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (flags &amp; RANGE_UB_INF)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; classNumber |= <a href="#L32" title="utils/adt/rangetypes_gist.c:32">CLS_UPPER_INF</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (flags &amp; RANGE_CONTAIN_EMPTY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; classNumber |= <a href="#L33" title="utils/adt/rangetypes_gist.c:33">CLS_CONTAIN_EMPTY</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> classNumber;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Comparison function for <a href="#L1229" title="utils/adt/rangetypes_gist.c:1229">range_gist_single_sorting_split</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1731">&#x200c;</a></span><span class="linkable">single_bound_cmp</span>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b, <span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L59" title="utils/adt/rangetypes_gist.c:59">SingleBoundSortItem</a> *i1 = (<a href="#L59" title="utils/adt/rangetypes_gist.c:59">SingleBoundSortItem</a> *) a;<br/></li>
<li>&nbsp; &nbsp; <a href="#L59" title="utils/adt/rangetypes_gist.c:59">SingleBoundSortItem</a> *i2 = (<a href="#L59" title="utils/adt/rangetypes_gist.c:59">SingleBoundSortItem</a> *) b;<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache = (TypeCacheEntry *) arg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="rangetypes.c.html#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache, &amp;i1-&gt;bound, &amp;i2-&gt;bound);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compare NonEmptyRanges by <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1744">&#x200c;</a></span><span class="linkable">interval_cmp_lower</span>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b, <span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L98" title="utils/adt/rangetypes_gist.c:98">NonEmptyRange</a> *i1 = (<a href="#L98" title="utils/adt/rangetypes_gist.c:98">NonEmptyRange</a> *) a;<br/></li>
<li>&nbsp; &nbsp; <a href="#L98" title="utils/adt/rangetypes_gist.c:98">NonEmptyRange</a> *i2 = (<a href="#L98" title="utils/adt/rangetypes_gist.c:98">NonEmptyRange</a> *) b;<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache = (TypeCacheEntry *) arg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="rangetypes.c.html#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache, &amp;i1-&gt;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, &amp;i2-&gt;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compare NonEmptyRanges by <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1757">&#x200c;</a></span><span class="linkable">interval_cmp_upper</span>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b, <span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L98" title="utils/adt/rangetypes_gist.c:98">NonEmptyRange</a> *i1 = (<a href="#L98" title="utils/adt/rangetypes_gist.c:98">NonEmptyRange</a> *) a;<br/></li>
<li>&nbsp; &nbsp; <a href="#L98" title="utils/adt/rangetypes_gist.c:98">NonEmptyRange</a> *i2 = (<a href="#L98" title="utils/adt/rangetypes_gist.c:98">NonEmptyRange</a> *) b;<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache = (TypeCacheEntry *) arg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="rangetypes.c.html#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache, &amp;i1-&gt;<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>, &amp;i2-&gt;<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compare CommonEntrys by their deltas.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1770">&#x200c;</a></span><span class="linkable">common_entry_cmp</span>(<span class="Type">const</span> <span class="Type">void</span> *i1, <span class="Type">const</span> <span class="Type">void</span> *i2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; delta1 = ((<a href="../../access/gist/gistproc.c.html#L277" title="access/gist/gistproc.c:277">CommonEntry</a> *) i1)-&gt;delta;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; delta2 = ((<a href="../../access/gist/gistproc.c.html#L277" title="access/gist/gistproc.c:277">CommonEntry</a> *) i2)-&gt;delta;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (delta1 &lt; delta2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (delta1 &gt; delta2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convenience function to invoke type-specific subtype_diff function.<br/></li>
<li></span><span class="Comment"> * Caller must have already checked that there is one for the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> type.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> float8<br/></li>
<li><a id="L1788">&#x200c;</a><span class="linkable">call_subtype_diff</span>(TypeCacheEntry *typcache, Datum val1, Datum val2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; value;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; value = DatumGetFloat8(<a href="../fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(&amp;typcache-&gt;rng_subdiff_finfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typcache-&gt;rng_collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; val1, val2));<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Cope with buggy subtype_diff function by returning zero */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (value &gt;= <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> value;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0.0</span>;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
