<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/adt/pg_locale.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/adt/pg_locale.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L121">CurrentLCTimeValid</a></li>
<li><a href="#L120">CurrentLocaleConvValid</a></li>
<li><a href="#L134">collation_cache</a></li>
<li><a href="#L117">database_ctype_is_c</a></li>
<li><a href="#L1446">default_locale</a></li>
<li><a href="#L147">icu_converter</a></li>
<li><a href="#L102">icu_validation_level</a></li>
<li><a href="#L97">locale_messages</a></li>
<li><a href="#L98">locale_monetary</a></li>
<li><a href="#L99">locale_numeric</a></li>
<li><a href="#L100">locale_time</a></li>
<li><a href="#L111">localized_abbrev_days</a></li>
<li><a href="#L113">localized_abbrev_months</a></li>
<li><a href="#L112">localized_full_days</a></li>
<li><a href="#L114">localized_full_months</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L132">collation_cache_entry</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L1178">IsoLocaleName</a></li>
<li><a href="#L1195">IsoLocaleName</a></li>
<li><a href="#L524">PGLC_localeconv</a></li>
<li><a href="#L427">assign_locale_messages</a></li>
<li><a href="#L364">assign_locale_monetary</a></li>
<li><a href="#L376">assign_locale_numeric</a></li>
<li><a href="#L388">assign_locale_time</a></li>
<li><a href="#L2527">builtin_locale_encoding</a></li>
<li><a href="#L2551">builtin_validate_locale</a></li>
<li><a href="#L806">cache_locale_time</a></li>
<li><a href="#L783">cache_single_string</a></li>
<li><a href="#L3121">char2wchar</a></li>
<li><a href="#L315">check_locale</a></li>
<li><a href="#L404">check_locale_messages</a></li>
<li><a href="#L358">check_locale_monetary</a></li>
<li><a href="#L370">check_locale_numeric</a></li>
<li><a href="#L382">check_locale_time</a></li>
<li><a href="#L494">db_encoding_convert</a></li>
<li><a href="#L444">free_struct_lconv</a></li>
<li><a href="#L1729">get_collation_actual_version</a></li>
<li><a href="#L1103">get_iso_localename</a></li>
<li><a href="#L2768">icu_from_uchar</a></li>
<li><a href="#L2927">icu_language_tag</a></li>
<li><a href="#L2811">icu_set_collation_attributes</a></li>
<li><a href="#L2741">icu_to_uchar</a></li>
<li><a href="#L2984">icu_validate_locale</a></li>
<li><a href="#L2667">init_icu_converter</a></li>
<li><a href="#L1317">lc_collate_is_c</a></li>
<li><a href="#L1384">lc_ctype_is_c</a></li>
<li><a href="#L1230">lookup_collation_cache</a></li>
<li><a href="#L1449">make_icu_collator</a></li>
<li><a href="#L166">mbstowcs_l</a></li>
<li><a href="#L1531">pg_locale_deterministic</a></li>
<li><a href="#L1551">pg_newlocale_from_collation</a></li>
<li><a href="#L212">pg_perm_setlocale</a></li>
<li><a href="#L2098">pg_strcoll</a></li>
<li><a href="#L1916">pg_strcoll_libc</a></li>
<li><a href="#L2133">pg_strncoll</a></li>
<li><a href="#L2052">pg_strncoll_icu</a></li>
<li><a href="#L1997">pg_strncoll_icu_no_utf8</a></li>
<li><a href="#L1945">pg_strncoll_libc</a></li>
<li><a href="#L1839">pg_strncoll_libc_win32_utf8</a></li>
<li><a href="#L2417">pg_strnxfrm</a></li>
<li><a href="#L2203">pg_strnxfrm_icu</a></li>
<li><a href="#L2171">pg_strnxfrm_libc</a></li>
<li><a href="#L2502">pg_strnxfrm_prefix</a></li>
<li><a href="#L2298">pg_strnxfrm_prefix_icu</a></li>
<li><a href="#L2250">pg_strnxfrm_prefix_icu_no_utf8</a></li>
<li><a href="#L2381">pg_strxfrm</a></li>
<li><a href="#L2349">pg_strxfrm_enabled</a></li>
<li><a href="#L2153">pg_strxfrm_libc</a></li>
<li><a href="#L2467">pg_strxfrm_prefix</a></li>
<li><a href="#L2440">pg_strxfrm_prefix_enabled</a></li>
<li><a href="#L2585">pg_ucol_open</a></li>
<li><a href="#L1502">report_newlocale_failure</a></li>
<li><a href="#L1037">search_locale_enum</a></li>
<li><a href="#L735">strftime_win32</a></li>
<li><a href="#L463">struct_lconv_is_valid</a></li>
<li><a href="#L2714">uchar_convert</a></li>
<li><a href="#L2697">uchar_length</a></li>
<li><a href="#L3065">wchar2char</a></li>
<li><a href="#L182">wcstombs_l</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L93">MAX_L10N_DATA</a></li>
<li><a href="#L84">PGLOCALE_SUPPORT_ERROR</a></li>
<li><a href="#L91">TEXTBUFLEN</a></li>
<li><a href="#L774">strftime</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-----------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * PostgreSQL locale utilities<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 2002-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * src/backend/utils/adt/pg_locale.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-----------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*----------<br/></li>
<li></span><span class="Comment"> * Here is how the locale stuff is handled: LC_COLLATE and LC_CTYPE<br/></li>
<li></span><span class="Comment"> * are fixed at CREATE DATABASE time, stored in pg_database, and cannot<br/></li>
<li></span><span class="Comment"> * be changed. Thus, the effects of strcoll(), strxfrm(), isupper(),<br/></li>
<li></span><span class="Comment"> * toupper(), etc. are always in the same fixed locale.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * LC_MESSAGES is settable at run time and will take effect<br/></li>
<li></span><span class="Comment"> * immediately.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The other categories, LC_MONETARY, LC_NUMERIC, and LC_TIME are also<br/></li>
<li></span><span class="Comment"> * settable at run-time.&nbsp; However, we don't actually set those locale<br/></li>
<li></span><span class="Comment"> * categories permanently.&nbsp; This would have bizarre effects like no<br/></li>
<li></span><span class="Comment"> * longer accepting standard floating-point literals in some locales.<br/></li>
<li></span><span class="Comment"> * Instead, we only set these locale categories briefly when needed,<br/></li>
<li></span><span class="Comment"> * cache the required information obtained from localeconv() or<br/></li>
<li></span><span class="Comment"> * <a href="#L774" title="utils/adt/pg_locale.c:774">strftime</a>(), and then set the locale categories back to &quot;C&quot;.<br/></li>
<li></span><span class="Comment"> * The cached information is only used by the formatting <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> * (to_char, etc.) and the money type.&nbsp; For the user, this should all be<br/></li>
<li></span><span class="Comment"> * transparent.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * !!! NOW HEAR THIS !!!<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We've been bitten repeatedly by this bug, so let's try to keep it in<br/></li>
<li></span><span class="Comment"> * mind in future: on some platforms, the locale <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> return pointers<br/></li>
<li></span><span class="Comment"> * to static data that will be overwritten by <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> later locale function.<br/></li>
<li></span><span class="Comment"> * Thus, for example, the obvious-looking sequence<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save = setlocale(category, NULL);<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!setlocale(category, value))<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fail = true;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; setlocale(category, save);<br/></li>
<li></span><span class="Comment"> * DOES NOT <a href="../../regex/regexec.c.html#L87" title="regex/regexec.c:87">WORK</a> RELIABLY: on some platforms the second setlocale() call<br/></li>
<li></span><span class="Comment"> * will change the memory save is pointing at.&nbsp; To do this sort of thing<br/></li>
<li></span><span class="Comment"> * safely, you *must* <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a> what setlocale returns the first time.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The POSIX locale standard is available here:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap07.html<br/></li>
<li></span><span class="Comment"> *----------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;time.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_collation.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;mb/pg_wchar.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/formatting.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/guc_hooks.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/hsearch.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/pg_locale.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/syscache.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef USE_ICU<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;unicode/ucnv.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;unicode/ustring.h&gt;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef __GLIBC__<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;gnu/libc-version.h&gt;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef WIN32<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;shlwapi.h&gt;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Error triggered for locale-sensitive subroutines */<br/></li>
<li><a id="L84">&#x200c;</a></span><span class="PreProc">#define&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">PGLOCALE_SUPPORT_ERROR</span>(<a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a>) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; elog(ERROR, </span><span class="Constant">&quot;unsupported collprovider for </span><span class="Special">%s</span><span class="Constant">: </span><span class="Special">%c</span><span class="Constant">&quot;</span><span class="PreProc">, </span><span class="Constant">__func__</span><span class="PreProc">, <a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a>)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This should be large enough that most strings will fit, but small enough<br/></li>
<li></span><span class="Comment"> * that we feel comfortable putting it on the stack<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L91">&#x200c;</a></span><span class="PreProc">#define&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">TEXTBUFLEN</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">1024<br/></li>
<li></span><br/></li>
<li><a id="L93">&#x200c;</a><span class="PreProc">#define&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">MAX_L10N_DATA</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">80<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* GUC settings */<br/></li>
<li><a id="L97">&#x200c;</a></span><span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *<span class="linkable">locale_messages</span>;<br/></li>
<li><a id="L98">&#x200c;</a><span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *<span class="linkable">locale_monetary</span>;<br/></li>
<li><a id="L99">&#x200c;</a><span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *<span class="linkable">locale_numeric</span>;<br/></li>
<li><a id="L100">&#x200c;</a><span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *<span class="linkable">locale_time</span>;<br/></li>
<li><br/></li>
<li><a id="L102">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">icu_validation_level</span> = WARNING;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * lc_time localization cache.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We use only the first 7 or 12 entries of these arrays.&nbsp; The last array<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> is left as NULL for the convenience of outside code that wants<br/></li>
<li></span><span class="Comment"> * to sequentially scan these arrays.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L111">&#x200c;</a></span><span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *<span class="linkable">localized_abbrev_days</span>[<span class="Constant">7</span> + <span class="Constant">1</span>];<br/></li>
<li><a id="L112">&#x200c;</a><span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *<span class="linkable">localized_full_days</span>[<span class="Constant">7</span> + <span class="Constant">1</span>];<br/></li>
<li><a id="L113">&#x200c;</a><span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *<span class="linkable">localized_abbrev_months</span>[<span class="Constant">12</span> + <span class="Constant">1</span>];<br/></li>
<li><a id="L114">&#x200c;</a><span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *<span class="linkable">localized_full_months</span>[<span class="Constant">12</span> + <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li><span class="Comment">/* is the databases's LC_CTYPE the C locale? */<br/></li>
<li><a id="L117">&#x200c;</a></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">database_ctype_is_c</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* indicates whether locale information cache is valid */<br/></li>
<li><a id="L120">&#x200c;</a></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">CurrentLocaleConvValid</span> = <span class="Constant">false</span>;<br/></li>
<li><a id="L121">&#x200c;</a><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">CurrentLCTimeValid</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Cache for collation-related knowledge */<br/></li>
<li></span><br/></li>
<li><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collid;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> key: pg_collation OID */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; collate_is_c;&nbsp; &nbsp; <span class="Comment">/* is collation's LC_COLLATE C? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; ctype_is_c;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* is collation's LC_CTYPE C? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; flags_valid;&nbsp; &nbsp; <span class="Comment">/* true if above flags are valid */<br/></li>
<li></span>&nbsp; &nbsp; pg_locale_t locale;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* locale_t struct, or 0 if not valid */<br/></li>
<li><a id="L132">&#x200c;</a></span>} <span class="linkable">collation_cache_entry</span>;<br/></li>
<li><br/></li>
<li><a id="L134">&#x200c;</a><span class="Type">static</span> <a href="../hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *<span class="linkable">collation_cache</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="PreProc">#if defined(WIN32) &amp;&amp; defined(LC_MESSAGES)<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<a href="#L1178" title="utils/adt/pg_locale.c:1178">IsoLocaleName</a>(<span class="Type">const</span> <span class="Type">char</span> *);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef USE_ICU<br/></li>
<li></span><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Converter object for converting between ICU's UChar strings and C strings<br/></li>
<li></span><span class="Comment"> * in database encoding.&nbsp; Since the database encoding doesn't change, we only<br/></li>
<li></span><span class="Comment"> * need one of these per session.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L147">&#x200c;</a></span><span class="Type">static</span> UConverter *<span class="linkable">icu_converter</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> UCollator *<a href="#L2585" title="utils/adt/pg_locale.c:2585">pg_ucol_open</a>(<span class="Type">const</span> <span class="Type">char</span> *loc_str);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2667" title="utils/adt/pg_locale.c:2667">init_icu_converter</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">size_t</span> <a href="#L2697" title="utils/adt/pg_locale.c:2697">uchar_length</a>(UConverter *converter,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *str, <span class="Type">int32_t</span> len);<br/></li>
<li><span class="Type">static</span> <span class="Type">int32_t</span> <a href="#L2714" title="utils/adt/pg_locale.c:2714">uchar_convert</a>(UConverter *converter,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; UChar *dest, <span class="Type">int32_t</span> destlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *src, <span class="Type">int32_t</span> srclen);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2811" title="utils/adt/pg_locale.c:2811">icu_set_collation_attributes</a>(UCollator *collator, <span class="Type">const</span> <span class="Type">char</span> *loc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; UErrorCode *status);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * POSIX doesn't define _l-variants of these <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, but several systems<br/></li>
<li></span><span class="Comment"> * have them.&nbsp; We provide our own replacements here.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#ifndef HAVE_MBSTOWCS_L<br/></li>
<li></span><span class="Type">static</span> <span class="Type">size_t<br/></li>
<li><a id="L166">&#x200c;</a></span><span class="linkable">mbstowcs_l</span>(<span class="Type">wchar_t</span> *dest, <span class="Type">const</span> <span class="Type">char</span> *src, <span class="Type">size_t</span> n, locale_t loc)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef WIN32<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> _mbstowcs_l(dest, src, n, loc);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; locale_t&nbsp; &nbsp; save_locale = uselocale(loc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = mbstowcs(dest, src, n);<br/></li>
<li>&nbsp; &nbsp; uselocale(save_locale);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifndef HAVE_WCSTOMBS_L<br/></li>
<li></span><span class="Type">static</span> <span class="Type">size_t<br/></li>
<li><a id="L182">&#x200c;</a></span><span class="linkable">wcstombs_l</span>(<span class="Type">char</span> *dest, <span class="Type">const</span> <span class="Type">wchar_t</span> *src, <span class="Type">size_t</span> n, locale_t loc)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef WIN32<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> _wcstombs_l(dest, src, n, loc);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; locale_t&nbsp; &nbsp; save_locale = uselocale(loc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = wcstombs(dest, src, n);<br/></li>
<li>&nbsp; &nbsp; uselocale(save_locale);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L212" title="utils/adt/pg_locale.c:212">pg_perm_setlocale</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This wraps the libc function setlocale(), with two additions.&nbsp; First, when<br/></li>
<li></span><span class="Comment"> * changing LC_CTYPE, update gettext's encoding for the current message<br/></li>
<li></span><span class="Comment"> * domain.&nbsp; GNU gettext automatically tracks LC_CTYPE on most platforms, but<br/></li>
<li></span><span class="Comment"> * not on Windows.&nbsp; Second, if the operation is successful, the corresponding<br/></li>
<li></span><span class="Comment"> * LC_XXX environment variable is set to match.&nbsp; By setting the environment<br/></li>
<li></span><span class="Comment"> * variable, we ensure that <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> subsequent use of setlocale(..., &quot;&quot;) will<br/></li>
<li></span><span class="Comment"> * preserve the settings made through this routine.&nbsp; Of course, LC_ALL must<br/></li>
<li></span><span class="Comment"> * also be unset to fully ensure that, but that has to be done elsewhere after<br/></li>
<li></span><span class="Comment"> * all the individual LC_XXX variables have been set correctly.&nbsp; (Thank you<br/></li>
<li></span><span class="Comment"> * Perl for making this kluge necessary.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L212">&#x200c;</a><span class="linkable">pg_perm_setlocale</span>(<span class="Type">int</span> category, <span class="Type">const</span> <span class="Type">char</span> *locale)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *envvar;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifndef WIN32<br/></li>
<li></span>&nbsp; &nbsp; result = setlocale(category, locale);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * On Windows, setlocale(LC_MESSAGES) does not work, so just assume that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the given value is good and set it in the environment variables. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * must ignore attempts to set to &quot;&quot;, which means &quot;keep using the old<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * environment value&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef LC_MESSAGES<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (category == LC_MESSAGES)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = (<span class="Type">char</span> *) locale;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (locale == <span class="Constant">NULL</span> || locale[<span class="Constant">0</span>] == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = setlocale(category, locale);<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* WIN32 */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fall out immediately on failure */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Use the right encoding in translated messages.&nbsp; Under ENABLE_NLS, let<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../mb/mbutils.c.html#L1226" title="utils/mb/mbutils.c:1226">pg_bind_textdomain_codeset</a>() figure it out.&nbsp; Under !ENABLE_NLS, message<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * format strings are ASCII, but database-encoding strings may enter the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * message via %s.&nbsp; This makes the overall message encoding <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * database encoding.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (category == <span class="Constant">LC_CTYPE</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">static</span> <span class="Type">char</span> save_lc_ctype[LOCALE_NAME_BUFLEN];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* copy setlocale() return value <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> callee invokes it again */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; strlcpy(save_lc_ctype, result, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(save_lc_ctype));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = save_lc_ctype;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef ENABLE_NLS<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mb/mbutils.c.html#L1171" title="utils/mb/mbutils.c:1171">SetMessageEncoding</a>(<a href="../mb/mbutils.c.html#L1226" title="utils/mb/mbutils.c:1226">pg_bind_textdomain_codeset</a>(textdomain(<span class="Constant">NULL</span>)));<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mb/mbutils.c.html#L1171" title="utils/mb/mbutils.c:1171">SetMessageEncoding</a>(<a href="../mb/mbutils.c.html#L1261" title="utils/mb/mbutils.c:1261">GetDatabaseEncoding</a>());<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (category)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">LC_COLLATE</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; envvar = <span class="Constant">&quot;LC_COLLATE&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">LC_CTYPE</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; envvar = <span class="Constant">&quot;LC_CTYPE&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><span class="PreProc">#ifdef LC_MESSAGES<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LC_MESSAGES:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; envvar = <span class="Constant">&quot;LC_MESSAGES&quot;</span>;<br/></li>
<li><span class="PreProc">#ifdef WIN32<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L1178" title="utils/adt/pg_locale.c:1178">IsoLocaleName</a>(locale);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = (<span class="Type">char</span> *) locale;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG3, <span class="Constant">&quot;<a href="#L1178" title="utils/adt/pg_locale.c:1178">IsoLocaleName</a>() executed; locale: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, result);<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* WIN32 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* LC_MESSAGES */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">LC_MONETARY</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; envvar = <span class="Constant">&quot;LC_MONETARY&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">LC_NUMERIC</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; envvar = <span class="Constant">&quot;LC_NUMERIC&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">LC_TIME</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; envvar = <span class="Constant">&quot;LC_TIME&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;unrecognized LC category: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, category);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (setenv(envvar, result, <span class="Constant">1</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Is the locale name valid for the locale category?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If successful, and canonname isn't NULL, a <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d copy of the locale's<br/></li>
<li></span><span class="Comment"> * canonical name is stored there.&nbsp; This is especially useful for figuring out<br/></li>
<li></span><span class="Comment"> * what locale name &quot;&quot; means (ie, the server environment value).&nbsp; (Actually,<br/></li>
<li></span><span class="Comment"> * it seems that on most implementations that's the only thing it's good for;<br/></li>
<li></span><span class="Comment"> * we could wish that setlocale gave back a canonically spelled version of<br/></li>
<li></span><span class="Comment"> * the locale name, but typically it doesn't.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L315">&#x200c;</a></span><span class="linkable">check_locale</span>(<span class="Type">int</span> category, <span class="Type">const</span> <span class="Type">char</span> *locale, <span class="Type">char</span> **canonname)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *save;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (canonname)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *canonname = <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* in case of failure */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; save = setlocale(category, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!save)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* won't happen, we hope */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* save may be pointing at a modifiable scratch variable, see above. */<br/></li>
<li></span>&nbsp; &nbsp; save = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(save);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set the locale with setlocale, to see if it accepts it. */<br/></li>
<li></span>&nbsp; &nbsp; res = setlocale(category, locale);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* save canonical name if requested. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (res &amp;&amp; canonname)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *canonname = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(res);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* restore old value. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!setlocale(category, save))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;failed to restore old locale </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, save);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(save);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (res != <span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC check/assign hooks<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For most locale categories, the assign hook doesn't actually set the locale<br/></li>
<li></span><span class="Comment"> * permanently, just reset flags so that the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> use will cache the<br/></li>
<li></span><span class="Comment"> * appropriate <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.&nbsp; (See explanation at the top of this file.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: we <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> value = &quot;&quot; as selecting the postmaster's environment<br/></li>
<li></span><span class="Comment"> * value, whatever it was (so long as the environment setting is legal).<br/></li>
<li></span><span class="Comment"> * This will have been locked down by an earlier call to <a href="#L212" title="utils/adt/pg_locale.c:212">pg_perm_setlocale</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L358">&#x200c;</a></span><span class="linkable">check_locale_monetary</span>(<span class="Type">char</span> **<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> **extra, GucSource source)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L315" title="utils/adt/pg_locale.c:315">check_locale</a>(<span class="Constant">LC_MONETARY</span>, *<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L364">&#x200c;</a></span><span class="linkable">assign_locale_monetary</span>(<span class="Type">const</span> <span class="Type">char</span> *<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> *extra)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L120" title="utils/adt/pg_locale.c:120">CurrentLocaleConvValid</a> = <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L370">&#x200c;</a></span><span class="linkable">check_locale_numeric</span>(<span class="Type">char</span> **<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> **extra, GucSource source)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L315" title="utils/adt/pg_locale.c:315">check_locale</a>(<span class="Constant">LC_NUMERIC</span>, *<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L376">&#x200c;</a></span><span class="linkable">assign_locale_numeric</span>(<span class="Type">const</span> <span class="Type">char</span> *<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> *extra)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L120" title="utils/adt/pg_locale.c:120">CurrentLocaleConvValid</a> = <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L382">&#x200c;</a></span><span class="linkable">check_locale_time</span>(<span class="Type">char</span> **<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> **extra, GucSource source)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L315" title="utils/adt/pg_locale.c:315">check_locale</a>(<span class="Constant">LC_TIME</span>, *<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L388">&#x200c;</a></span><span class="linkable">assign_locale_time</span>(<span class="Type">const</span> <span class="Type">char</span> *<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> *extra)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L121" title="utils/adt/pg_locale.c:121">CurrentLCTimeValid</a> = <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * We allow LC_MESSAGES to actually be set globally.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: we normally disallow value = &quot;&quot; because it wouldn't have consistent<br/></li>
<li></span><span class="Comment"> * semantics (it'd effectively just use the previous value).&nbsp; However, this<br/></li>
<li></span><span class="Comment"> * is the value passed for PGC_S_DEFAULT, so don't complain in that case,<br/></li>
<li></span><span class="Comment"> * not even if the attempted setting fails due to invalid environment value.<br/></li>
<li></span><span class="Comment"> * The idea there is just to <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> the environment setting *if possible*<br/></li>
<li></span><span class="Comment"> * during startup, until we can read the proper value from postgresql.conf.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L404">&#x200c;</a></span><span class="linkable">check_locale_messages</span>(<span class="Type">char</span> **<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> **extra, GucSource source)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (**<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (source == PGC_S_DEFAULT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * LC_MESSAGES category does not exist everywhere, but <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> it anyway<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * On Windows, we can't even check the value, so <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> blindly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#if defined(LC_MESSAGES) &amp;&amp; !defined(WIN32)<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L315" title="utils/adt/pg_locale.c:315">check_locale</a>(LC_MESSAGES, *<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Constant">NULL</span>);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L427">&#x200c;</a></span><span class="linkable">assign_locale_messages</span>(<span class="Type">const</span> <span class="Type">char</span> *<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> *extra)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * LC_MESSAGES category does not exist everywhere, but <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> it anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We ignore failure, as per comment above.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef LC_MESSAGES<br/></li>
<li></span>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L212" title="utils/adt/pg_locale.c:212">pg_perm_setlocale</a>(LC_MESSAGES, <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Frees the malloced content of a struct lconv.&nbsp; (But not the struct<br/></li>
<li></span><span class="Comment"> * itself.)&nbsp; It's important that this not throw elog(ERROR).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L444">&#x200c;</a></span><span class="linkable">free_struct_lconv</span>(<span class="Type">struct</span> lconv *s)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; free(s-&gt;decimal_point);<br/></li>
<li>&nbsp; &nbsp; free(s-&gt;thousands_sep);<br/></li>
<li>&nbsp; &nbsp; free(s-&gt;grouping);<br/></li>
<li>&nbsp; &nbsp; free(s-&gt;int_curr_symbol);<br/></li>
<li>&nbsp; &nbsp; free(s-&gt;currency_symbol);<br/></li>
<li>&nbsp; &nbsp; free(s-&gt;mon_decimal_point);<br/></li>
<li>&nbsp; &nbsp; free(s-&gt;mon_thousands_sep);<br/></li>
<li>&nbsp; &nbsp; free(s-&gt;mon_grouping);<br/></li>
<li>&nbsp; &nbsp; free(s-&gt;positive_sign);<br/></li>
<li>&nbsp; &nbsp; free(s-&gt;negative_sign);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check that all fields of a struct lconv (or at least, the ones we care<br/></li>
<li></span><span class="Comment"> * about) are non-NULL.&nbsp; The field list must match <a href="#L444" title="utils/adt/pg_locale.c:444">free_struct_lconv</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L463">&#x200c;</a></span><span class="linkable">struct_lconv_is_valid</span>(<span class="Type">struct</span> lconv *s)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;decimal_point == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;thousands_sep == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;grouping == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;int_curr_symbol == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;currency_symbol == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;mon_decimal_point == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;mon_thousands_sep == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;mon_grouping == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;positive_sign == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;negative_sign == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert the strdup'd string at *str from the specified encoding to the<br/></li>
<li></span><span class="Comment"> * database encoding.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L494">&#x200c;</a></span><span class="linkable">db_encoding_convert</span>(<span class="Type">int</span> encoding, <span class="Type">char</span> **str)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *pstr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *mstr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* convert the string to the database encoding */<br/></li>
<li></span>&nbsp; &nbsp; pstr = <a href="../mb/mbutils.c.html#L676" title="utils/mb/mbutils.c:676">pg_any_to_server</a>(*str, strlen(*str), encoding);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pstr == *str)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no conversion happened */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* need it malloc'd not <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d */<br/></li>
<li></span>&nbsp; &nbsp; mstr = strdup(pstr);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (mstr == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OUT_OF_MEMORY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;out of memory&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* replace old string */<br/></li>
<li></span>&nbsp; &nbsp; free(*str);<br/></li>
<li>&nbsp; &nbsp; *str = mstr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(pstr);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the POSIX lconv struct (contains number/money formatting<br/></li>
<li></span><span class="Comment"> * information) with locale information for all categories.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">struct</span> lconv *<br/></li>
<li><a id="L524">&#x200c;</a><span class="linkable">PGLC_localeconv</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">struct</span> lconv CurrentLocaleConv;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> CurrentLocaleConvAllocated = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> lconv *extlconv;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> lconv worklconv;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *save_lc_monetary;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *save_lc_numeric;<br/></li>
<li><span class="PreProc">#ifdef WIN32<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *save_lc_ctype;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Did we do it already? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L120" title="utils/adt/pg_locale.c:120">CurrentLocaleConvValid</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> &amp;CurrentLocaleConv;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Free <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> already-allocated storage */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (CurrentLocaleConvAllocated)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L444" title="utils/adt/pg_locale.c:444">free_struct_lconv</a>(&amp;CurrentLocaleConv);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CurrentLocaleConvAllocated = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is tricky because we really don't want to risk throwing error<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * while the locale is set to other than our usual settings.&nbsp; Therefore,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the process is: collect the usual settings, set locale to special<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * setting, copy relevant data into worklconv using strdup(), restore<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * normal settings, convert data to desired encoding, and finally stash<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the collected data in CurrentLocaleConv.&nbsp; This makes it safe if we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * throw an error during encoding conversion or run out of memory anywhere<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in the process.&nbsp; All data pointed to by struct lconv members is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allocated with strdup, to avoid premature elog(ERROR) and to allow<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * using a single <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> routine.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; memset(&amp;worklconv, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(worklconv));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Save prevailing <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of monetary and <a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> locales */<br/></li>
<li></span>&nbsp; &nbsp; save_lc_monetary = setlocale(<span class="Constant">LC_MONETARY</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!save_lc_monetary)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;setlocale(NULL) failed&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; save_lc_monetary = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(save_lc_monetary);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; save_lc_numeric = setlocale(<span class="Constant">LC_NUMERIC</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!save_lc_numeric)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;setlocale(NULL) failed&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; save_lc_numeric = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(save_lc_numeric);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef WIN32<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The POSIX standard explicitly says that it is undefined what happens if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * LC_MONETARY or LC_NUMERIC imply an encoding (codeset) different from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that implied by LC_CTYPE.&nbsp; In practice, all Unix-ish platforms seem to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * believe that localeconv() should return strings that are encoded in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * codeset implied by the LC_MONETARY or LC_NUMERIC locale name.&nbsp; Hence,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * once we have successfully collected the localeconv() results, we will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * convert them from that codeset to the desired server encoding.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Windows, of course, resolutely does things its own way; on that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * platform LC_CTYPE has to match LC_MONETARY/LC_NUMERIC to get sane<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * results.&nbsp; Hence, we must temporarily set that category as well.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Save prevailing value of ctype locale */<br/></li>
<li></span>&nbsp; &nbsp; save_lc_ctype = setlocale(<span class="Constant">LC_CTYPE</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!save_lc_ctype)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;setlocale(NULL) failed&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; save_lc_ctype = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(save_lc_ctype);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Here begins the critical section where we must not throw error */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* use <a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> to set the ctype */<br/></li>
<li></span>&nbsp; &nbsp; setlocale(<span class="Constant">LC_CTYPE</span>, <a href="#L99" title="utils/adt/pg_locale.c:99">locale_numeric</a>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get formatting information for <a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> */<br/></li>
<li></span>&nbsp; &nbsp; setlocale(<span class="Constant">LC_NUMERIC</span>, <a href="#L99" title="utils/adt/pg_locale.c:99">locale_numeric</a>);<br/></li>
<li>&nbsp; &nbsp; extlconv = localeconv();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Must copy data <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> in case setlocale() overwrites it */<br/></li>
<li></span>&nbsp; &nbsp; worklconv.decimal_point = strdup(extlconv-&gt;decimal_point);<br/></li>
<li>&nbsp; &nbsp; worklconv.thousands_sep = strdup(extlconv-&gt;thousands_sep);<br/></li>
<li>&nbsp; &nbsp; worklconv.grouping = strdup(extlconv-&gt;grouping);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef WIN32<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* use monetary to set the ctype */<br/></li>
<li></span>&nbsp; &nbsp; setlocale(<span class="Constant">LC_CTYPE</span>, <a href="#L98" title="utils/adt/pg_locale.c:98">locale_monetary</a>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get formatting information for monetary */<br/></li>
<li></span>&nbsp; &nbsp; setlocale(<span class="Constant">LC_MONETARY</span>, <a href="#L98" title="utils/adt/pg_locale.c:98">locale_monetary</a>);<br/></li>
<li>&nbsp; &nbsp; extlconv = localeconv();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Must copy data <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> in case setlocale() overwrites it */<br/></li>
<li></span>&nbsp; &nbsp; worklconv.int_curr_symbol = strdup(extlconv-&gt;int_curr_symbol);<br/></li>
<li>&nbsp; &nbsp; worklconv.currency_symbol = strdup(extlconv-&gt;currency_symbol);<br/></li>
<li>&nbsp; &nbsp; worklconv.mon_decimal_point = strdup(extlconv-&gt;mon_decimal_point);<br/></li>
<li>&nbsp; &nbsp; worklconv.mon_thousands_sep = strdup(extlconv-&gt;mon_thousands_sep);<br/></li>
<li>&nbsp; &nbsp; worklconv.mon_grouping = strdup(extlconv-&gt;mon_grouping);<br/></li>
<li>&nbsp; &nbsp; worklconv.positive_sign = strdup(extlconv-&gt;positive_sign);<br/></li>
<li>&nbsp; &nbsp; worklconv.negative_sign = strdup(extlconv-&gt;negative_sign);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Copy scalar fields as well */<br/></li>
<li></span>&nbsp; &nbsp; worklconv.int_frac_digits = extlconv-&gt;int_frac_digits;<br/></li>
<li>&nbsp; &nbsp; worklconv.frac_digits = extlconv-&gt;frac_digits;<br/></li>
<li>&nbsp; &nbsp; worklconv.p_cs_precedes = extlconv-&gt;p_cs_precedes;<br/></li>
<li>&nbsp; &nbsp; worklconv.p_sep_by_space = extlconv-&gt;p_sep_by_space;<br/></li>
<li>&nbsp; &nbsp; worklconv.n_cs_precedes = extlconv-&gt;n_cs_precedes;<br/></li>
<li>&nbsp; &nbsp; worklconv.n_sep_by_space = extlconv-&gt;n_sep_by_space;<br/></li>
<li>&nbsp; &nbsp; worklconv.p_sign_posn = extlconv-&gt;p_sign_posn;<br/></li>
<li>&nbsp; &nbsp; worklconv.n_sign_posn = extlconv-&gt;n_sign_posn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Restore the prevailing locale settings; failure to do so is fatal.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Possibly we could limp along with nondefault LC_MONETARY or LC_NUMERIC,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but proceeding with the wrong value of LC_CTYPE would certainly be bad<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * news; and considering that the prevailing LC_MONETARY and LC_NUMERIC<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are almost certainly &quot;C&quot;, there's really no reason that restoring those<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * should fail.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef WIN32<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!setlocale(<span class="Constant">LC_CTYPE</span>, save_lc_ctype))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;failed to restore LC_CTYPE to </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, save_lc_ctype);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!setlocale(<span class="Constant">LC_MONETARY</span>, save_lc_monetary))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;failed to restore LC_MONETARY to </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, save_lc_monetary);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!setlocale(<span class="Constant">LC_NUMERIC</span>, save_lc_numeric))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;failed to restore LC_NUMERIC to </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, save_lc_numeric);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * At this point we've done our best to clean up, and can call <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that might possibly throw errors with a clean conscience.&nbsp; But let's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * make sure we don't leak <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> already-strdup'd fields in worklconv.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; PG_TRY();<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; encoding;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Release the <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>'d locale names */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(save_lc_monetary);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(save_lc_numeric);<br/></li>
<li><span class="PreProc">#ifdef WIN32<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(save_lc_ctype);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the preceding strdup calls failed, complain <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L463" title="utils/adt/pg_locale.c:463">struct_lconv_is_valid</a>(&amp;worklconv))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OUT_OF_MEMORY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;out of memory&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now we must perform encoding conversion from whatever's associated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with the locales into the database encoding.&nbsp; If we can't identify<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the encoding implied by LC_NUMERIC or LC_MONETARY (ie we get -1),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * use PG_SQL_ASCII, which will result in just validating that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * strings are OK in the database encoding.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; encoding = pg_get_encoding_from_locale(<a href="#L99" title="utils/adt/pg_locale.c:99">locale_numeric</a>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (encoding &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; encoding = PG_SQL_ASCII;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L494" title="utils/adt/pg_locale.c:494">db_encoding_convert</a>(encoding, &amp;worklconv.decimal_point);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L494" title="utils/adt/pg_locale.c:494">db_encoding_convert</a>(encoding, &amp;worklconv.thousands_sep);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* grouping is not text and does not require conversion */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; encoding = pg_get_encoding_from_locale(<a href="#L98" title="utils/adt/pg_locale.c:98">locale_monetary</a>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (encoding &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; encoding = PG_SQL_ASCII;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L494" title="utils/adt/pg_locale.c:494">db_encoding_convert</a>(encoding, &amp;worklconv.int_curr_symbol);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L494" title="utils/adt/pg_locale.c:494">db_encoding_convert</a>(encoding, &amp;worklconv.currency_symbol);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L494" title="utils/adt/pg_locale.c:494">db_encoding_convert</a>(encoding, &amp;worklconv.mon_decimal_point);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L494" title="utils/adt/pg_locale.c:494">db_encoding_convert</a>(encoding, &amp;worklconv.mon_thousands_sep);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* mon_grouping is not text and does not require conversion */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L494" title="utils/adt/pg_locale.c:494">db_encoding_convert</a>(encoding, &amp;worklconv.positive_sign);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L494" title="utils/adt/pg_locale.c:494">db_encoding_convert</a>(encoding, &amp;worklconv.negative_sign);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_CATCH();<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L444" title="utils/adt/pg_locale.c:444">free_struct_lconv</a>(&amp;worklconv);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RE_THROW();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_END_TRY();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Everything is good, so save the results.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; CurrentLocaleConv = worklconv;<br/></li>
<li>&nbsp; &nbsp; CurrentLocaleConvAllocated = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L120" title="utils/adt/pg_locale.c:120">CurrentLocaleConvValid</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> &amp;CurrentLocaleConv;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef WIN32<br/></li>
<li></span><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * On Windows, <a href="#L774" title="utils/adt/pg_locale.c:774">strftime</a>() returns its output in encoding CP_ACP (the default<br/></li>
<li></span><span class="Comment"> * operating system codepage for the computer), which is likely different<br/></li>
<li></span><span class="Comment"> * from SERVER_ENCODING.&nbsp; This is especially important in Japanese versions<br/></li>
<li></span><span class="Comment"> * of Windows which will use SJIS encoding, which we don't support as a<br/></li>
<li></span><span class="Comment"> * server encoding.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * So, instead of using <a href="#L774" title="utils/adt/pg_locale.c:774">strftime</a>(), use wcsftime() to return the value in<br/></li>
<li></span><span class="Comment"> * wide characters (internally UTF16) and then convert to UTF8, which we<br/></li>
<li></span><span class="Comment"> * know how to handle directly.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that this only affects the calls to <a href="#L774" title="utils/adt/pg_locale.c:774">strftime</a>() in this file, which are<br/></li>
<li></span><span class="Comment"> * used to get the locale-aware strings. Other parts of the backend use<br/></li>
<li></span><span class="Comment"> * pg_strftime(), which isn't locale-aware and does not need to be replaced.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">size_t<br/></li>
<li><a id="L735">&#x200c;</a></span><span class="linkable">strftime_win32</span>(<span class="Type">char</span> *dst, <span class="Type">size_t</span> dstlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *format, <span class="Type">const</span> <span class="Type">struct</span> tm *tm)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">wchar_t</span>&nbsp; &nbsp; &nbsp; &nbsp; wformat[<span class="Constant">8</span>];&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* formats used below need 3 chars */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">wchar_t</span>&nbsp; &nbsp; &nbsp; &nbsp; wbuf[<a href="#L93" title="utils/adt/pg_locale.c:93">MAX_L10N_DATA</a>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get a wchar_t version of the format string.&nbsp; We only actually use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * plain-ASCII formats in this file, so we can say that they're UTF8.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; len = MultiByteToWideChar(CP_UTF8, <span class="Constant">0</span>, format, -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wformat, lengthof(wformat));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (len == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not convert format string from UTF-8: error code </span><span class="Special">%lu</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GetLastError());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len = wcsftime(wbuf, <a href="#L93" title="utils/adt/pg_locale.c:93">MAX_L10N_DATA</a>, wformat, tm);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (len == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * wcsftime failed, possibly because the result would not fit in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L93" title="utils/adt/pg_locale.c:93">MAX_L10N_DATA</a>.&nbsp; Return 0 with the contents of dst unspecified.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len = WideCharToMultiByte(CP_UTF8, <span class="Constant">0</span>, wbuf, len, dst, dstlen - <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (len == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not convert string to UTF-8: error code </span><span class="Special">%lu</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GetLastError());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dst[len] = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> len;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* redefine <a href="#L774" title="utils/adt/pg_locale.c:774">strftime</a>() */<br/></li>
<li><a id="L774">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">strftime</span>(a,b,c,d) <a href="#L735" title="utils/adt/pg_locale.c:735">strftime_win32</a>(a,b,c,d)<br/></li>
<li></span><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* WIN32 */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Subroutine for <a href="#L806" title="utils/adt/pg_locale.c:806">cache_locale_time</a>().<br/></li>
<li></span><span class="Comment"> * Convert the given string from encoding &quot;encoding&quot; to the database<br/></li>
<li></span><span class="Comment"> * encoding, and store the result at *dst, replacing <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> previous value.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L783">&#x200c;</a></span><span class="linkable">cache_single_string</span>(<span class="Type">char</span> **dst, <span class="Type">const</span> <span class="Type">char</span> *src, <span class="Type">int</span> encoding)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *olddst;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Convert the string to the database encoding, or validate it's OK */<br/></li>
<li></span>&nbsp; &nbsp; ptr = <a href="../mb/mbutils.c.html#L676" title="utils/mb/mbutils.c:676">pg_any_to_server</a>(src, strlen(src), encoding);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Store the string in long-lived storage, replacing <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> previous value */<br/></li>
<li></span>&nbsp; &nbsp; olddst = *dst;<br/></li>
<li>&nbsp; &nbsp; *dst = <a href="../mmgr/mcxt.c.html#L1682" title="utils/mmgr/mcxt.c:1682">MemoryContextStrdup</a>(<a href="../mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>, ptr);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (olddst)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(olddst);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Might as well clean up <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d conversion result, too */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ptr != src)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(ptr);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Update the lc_time localization cache variables if needed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L806">&#x200c;</a></span><span class="linkable">cache_locale_time</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; buf[(<span class="Constant">2</span> * <span class="Constant">7</span> + <span class="Constant">2</span> * <span class="Constant">12</span>) * <a href="#L93" title="utils/adt/pg_locale.c:93">MAX_L10N_DATA</a>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *bufptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">time_t</span>&nbsp; &nbsp; &nbsp; &nbsp; timenow;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> tm&nbsp; *timeinfo;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; strftimefail = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; encoding;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *save_lc_time;<br/></li>
<li><span class="PreProc">#ifdef WIN32<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *save_lc_ctype;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* did we do this already? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L121" title="utils/adt/pg_locale.c:121">CurrentLCTimeValid</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elog(DEBUG3, <span class="Constant">&quot;<a href="#L806" title="utils/adt/pg_locale.c:806">cache_locale_time</a>() executed; locale: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, <a href="#L100" title="utils/adt/pg_locale.c:100">locale_time</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * As in <a href="#L524" title="utils/adt/pg_locale.c:524">PGLC_localeconv</a>(), it's critical that we not throw error while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * libc's locale settings have nondefault <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.&nbsp; Hence, we just call<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L774" title="utils/adt/pg_locale.c:774">strftime</a>() within the critical section, and then convert and save its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * results afterwards.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Save prevailing value of time locale */<br/></li>
<li></span>&nbsp; &nbsp; save_lc_time = setlocale(<span class="Constant">LC_TIME</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!save_lc_time)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;setlocale(NULL) failed&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; save_lc_time = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(save_lc_time);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef WIN32<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * On Windows, it appears that wcsftime() internally uses LC_CTYPE, so we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * must set it here.&nbsp; This code looks the same as what <a href="#L524" title="utils/adt/pg_locale.c:524">PGLC_localeconv</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * does, but the underlying reason is different: this does NOT determine<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the encoding we'll get back from <a href="#L735" title="utils/adt/pg_locale.c:735">strftime_win32</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Save prevailing value of ctype locale */<br/></li>
<li></span>&nbsp; &nbsp; save_lc_ctype = setlocale(<span class="Constant">LC_CTYPE</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!save_lc_ctype)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;setlocale(NULL) failed&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; save_lc_ctype = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(save_lc_ctype);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* use lc_time to set the ctype */<br/></li>
<li></span>&nbsp; &nbsp; setlocale(<span class="Constant">LC_CTYPE</span>, <a href="#L100" title="utils/adt/pg_locale.c:100">locale_time</a>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; setlocale(<span class="Constant">LC_TIME</span>, <a href="#L100" title="utils/adt/pg_locale.c:100">locale_time</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We use times close to current time as data for <a href="#L774" title="utils/adt/pg_locale.c:774">strftime</a>(). */<br/></li>
<li></span>&nbsp; &nbsp; timenow = time(<span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; timeinfo = localtime(&amp;timenow);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Store the <a href="#L774" title="utils/adt/pg_locale.c:774">strftime</a> results in <a href="#L93" title="utils/adt/pg_locale.c:93">MAX_L10N_DATA</a>-sized portions of buf[] */<br/></li>
<li></span>&nbsp; &nbsp; bufptr = buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L93" title="utils/adt/pg_locale.c:93">MAX_L10N_DATA</a> is sufficient buffer space for every known locale, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * POSIX defines no <a href="#L774" title="utils/adt/pg_locale.c:774">strftime</a>() errors.&nbsp; (Buffer space exhaustion is not an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * error.)&nbsp; An implementation might report errors (e.g. ENOMEM) by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * returning 0 (or, less plausibly, a negative value) and setting errno.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Report errno just in case the implementation did that, but clear it in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * advance of the calls so we don't emit a stale, unrelated errno.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* localized <a href="datetime.c.html#L84" title="utils/adt/datetime.c:84">days</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <span class="Constant">7</span>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; timeinfo-&gt;tm_wday = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L774" title="utils/adt/pg_locale.c:774">strftime</a>(bufptr, <a href="#L93" title="utils/adt/pg_locale.c:93">MAX_L10N_DATA</a>, <span class="Constant">&quot;</span><span class="Special">%a</span><span class="Constant">&quot;</span>, timeinfo) &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strftimefail = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bufptr += <a href="#L93" title="utils/adt/pg_locale.c:93">MAX_L10N_DATA</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L774" title="utils/adt/pg_locale.c:774">strftime</a>(bufptr, <a href="#L93" title="utils/adt/pg_locale.c:93">MAX_L10N_DATA</a>, <span class="Constant">&quot;</span><span class="Special">%A</span><span class="Constant">&quot;</span>, timeinfo) &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strftimefail = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bufptr += <a href="#L93" title="utils/adt/pg_locale.c:93">MAX_L10N_DATA</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* localized <a href="datetime.c.html#L81" title="utils/adt/datetime.c:81">months</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <span class="Constant">12</span>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; timeinfo-&gt;tm_mon = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; timeinfo-&gt;tm_mday = <span class="Constant">1</span>;&nbsp; &nbsp; <span class="Comment">/* make sure we don't have invalid date */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L774" title="utils/adt/pg_locale.c:774">strftime</a>(bufptr, <a href="#L93" title="utils/adt/pg_locale.c:93">MAX_L10N_DATA</a>, <span class="Constant">&quot;</span><span class="Special">%b</span><span class="Constant">&quot;</span>, timeinfo) &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strftimefail = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bufptr += <a href="#L93" title="utils/adt/pg_locale.c:93">MAX_L10N_DATA</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L774" title="utils/adt/pg_locale.c:774">strftime</a>(bufptr, <a href="#L93" title="utils/adt/pg_locale.c:93">MAX_L10N_DATA</a>, <span class="Constant">&quot;%B&quot;</span>, timeinfo) &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strftimefail = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bufptr += <a href="#L93" title="utils/adt/pg_locale.c:93">MAX_L10N_DATA</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Restore the prevailing locale settings; as in <a href="#L524" title="utils/adt/pg_locale.c:524">PGLC_localeconv</a>(),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * failure to do so is fatal.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef WIN32<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!setlocale(<span class="Constant">LC_CTYPE</span>, save_lc_ctype))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;failed to restore LC_CTYPE to </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, save_lc_ctype);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!setlocale(<span class="Constant">LC_TIME</span>, save_lc_time))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;failed to restore LC_TIME to </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, save_lc_time);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * At this point we've done our best to clean up, and can throw errors, or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * call <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> that might throw errors, with a clean conscience.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (strftimefail)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L774" title="utils/adt/pg_locale.c:774">strftime</a>() failed: %m&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Release the <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>'d locale names */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(save_lc_time);<br/></li>
<li><span class="PreProc">#ifdef WIN32<br/></li>
<li></span>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(save_lc_ctype);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifndef WIN32<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * As in <a href="#L524" title="utils/adt/pg_locale.c:524">PGLC_localeconv</a>(), we must convert <a href="#L774" title="utils/adt/pg_locale.c:774">strftime</a>()'s output from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * encoding implied by LC_TIME to the database encoding.&nbsp; If we can't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * identify the LC_TIME encoding, just perform encoding validation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; encoding = pg_get_encoding_from_locale(<a href="#L100" title="utils/adt/pg_locale.c:100">locale_time</a>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (encoding &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; encoding = PG_SQL_ASCII;<br/></li>
<li><br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * On Windows, <a href="#L735" title="utils/adt/pg_locale.c:735">strftime_win32</a>() always returns UTF8 data, so convert from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that if necessary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; encoding = PG_UTF8;<br/></li>
<li><br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* WIN32 */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; bufptr = buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* localized <a href="datetime.c.html#L84" title="utils/adt/datetime.c:84">days</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <span class="Constant">7</span>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L783" title="utils/adt/pg_locale.c:783">cache_single_string</a>(&amp;<a href="#L111" title="utils/adt/pg_locale.c:111">localized_abbrev_days</a>[i], bufptr, encoding);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bufptr += <a href="#L93" title="utils/adt/pg_locale.c:93">MAX_L10N_DATA</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L783" title="utils/adt/pg_locale.c:783">cache_single_string</a>(&amp;<a href="#L112" title="utils/adt/pg_locale.c:112">localized_full_days</a>[i], bufptr, encoding);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bufptr += <a href="#L93" title="utils/adt/pg_locale.c:93">MAX_L10N_DATA</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="#L111" title="utils/adt/pg_locale.c:111">localized_abbrev_days</a>[<span class="Constant">7</span>] = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L112" title="utils/adt/pg_locale.c:112">localized_full_days</a>[<span class="Constant">7</span>] = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* localized <a href="datetime.c.html#L81" title="utils/adt/datetime.c:81">months</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <span class="Constant">12</span>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L783" title="utils/adt/pg_locale.c:783">cache_single_string</a>(&amp;<a href="#L113" title="utils/adt/pg_locale.c:113">localized_abbrev_months</a>[i], bufptr, encoding);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bufptr += <a href="#L93" title="utils/adt/pg_locale.c:93">MAX_L10N_DATA</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L783" title="utils/adt/pg_locale.c:783">cache_single_string</a>(&amp;<a href="#L114" title="utils/adt/pg_locale.c:114">localized_full_months</a>[i], bufptr, encoding);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bufptr += <a href="#L93" title="utils/adt/pg_locale.c:93">MAX_L10N_DATA</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="#L113" title="utils/adt/pg_locale.c:113">localized_abbrev_months</a>[<span class="Constant">12</span>] = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L114" title="utils/adt/pg_locale.c:114">localized_full_months</a>[<span class="Constant">12</span>] = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L121" title="utils/adt/pg_locale.c:121">CurrentLCTimeValid</a> = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="PreProc">#if defined(WIN32) &amp;&amp; defined(LC_MESSAGES)<br/></li>
<li></span><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert a Windows setlocale() argument to a Unix-style one.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Regardless of platform, we install message catalogs under a Unix-style<br/></li>
<li></span><span class="Comment"> * LL[_CC][.ENCODING][@VARIANT] naming convention.&nbsp; Only LC_MESSAGES settings<br/></li>
<li></span><span class="Comment"> * following that style will elicit localized interface strings.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Before Visual Studio 2012 (msvcr110.dll), Windows setlocale() accepted &quot;C&quot;<br/></li>
<li></span><span class="Comment"> * (but not &quot;c&quot;) and strings of the form &lt;Language&gt;[<a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>&lt;Country&gt;][.&lt;CodePage&gt;],<br/></li>
<li></span><span class="Comment"> * case-insensitive.&nbsp; setlocale() returns the fully-qualified form; for<br/></li>
<li></span><span class="Comment"> * example, setlocale(&quot;thaI&quot;) returns &quot;Thai_Thailand.874&quot;.&nbsp; Internally,<br/></li>
<li></span><span class="Comment"> * setlocale() and _create_locale() <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> a &quot;locale identifier&quot;[1] and store<br/></li>
<li></span><span class="Comment"> * it in an undocumented _locale_t field.&nbsp; From that LCID, we can retrieve the<br/></li>
<li></span><span class="Comment"> * ISO 639 language and the ISO 3166 country.&nbsp; Character encoding does not<br/></li>
<li></span><span class="Comment"> * matter, because the server and client encodings govern that.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Windows Vista introduced the &quot;locale name&quot; concept[2], closely following<br/></li>
<li></span><span class="Comment"> * RFC 4646.&nbsp; Locale identifiers are <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> deprecated.&nbsp; Starting with Visual<br/></li>
<li></span><span class="Comment"> * Studio 2012, setlocale() accepts locale names in addition to the strings it<br/></li>
<li></span><span class="Comment"> * accepted historically.&nbsp; It does not standardize them; setlocale(&quot;Th-tH&quot;)<br/></li>
<li></span><span class="Comment"> * returns &quot;Th-tH&quot;.&nbsp; setlocale(category, &quot;&quot;) still returns a traditional<br/></li>
<li></span><span class="Comment"> * string.&nbsp; Furthermore, msvcr110.dll changed the undocumented _locale_t<br/></li>
<li></span><span class="Comment"> * content to carry locale names instead of locale identifiers.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Visual Studio 2015 should still be able to do the same as Visual Studio<br/></li>
<li></span><span class="Comment"> * 2012, but the declaration of locale_name is missing in _locale_t, causing<br/></li>
<li></span><span class="Comment"> * this code compilation to fail, hence this falls back instead on to<br/></li>
<li></span><span class="Comment"> * enumerating all system locales by using EnumSystemLocalesEx to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the<br/></li>
<li></span><span class="Comment"> * required locale name.&nbsp; If the input argument is in Unix-style then we can<br/></li>
<li></span><span class="Comment"> * get ISO Locale name directly by using GetLocaleInfoEx() with LCType as<br/></li>
<li></span><span class="Comment"> * LOCALE_SNAME.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * MinGW headers declare _create_locale(), but msvcrt.dll lacks that symbol in<br/></li>
<li></span><span class="Comment"> * releases <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> Windows 8. <a href="#L1178" title="utils/adt/pg_locale.c:1178">IsoLocaleName</a>() always fails in a MinGW-built<br/></li>
<li></span><span class="Comment"> * postgres.exe, so only Unix-style <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of the lc_messages GUC can elicit<br/></li>
<li></span><span class="Comment"> * localized messages. In particular, every lc_messages setting that initdb<br/></li>
<li></span><span class="Comment"> * can <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> automatically will yield only C-locale messages. </span><span class="Todo">XXX</span><span class="Comment"> This could<br/></li>
<li></span><span class="Comment"> * be fixed by running the fully-qualified locale name through a lookup table.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function returns a pointer to a static buffer bearing the converted<br/></li>
<li></span><span class="Comment"> * name or NULL if conversion fails.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * [1] https://docs.microsoft.com/en-us/windows/win32/intl/locale-identifiers<br/></li>
<li></span><span class="Comment"> * [2] https://docs.microsoft.com/en-us/windows/win32/intl/locale-names<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#if defined(_MSC_VER)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Callback function for EnumSystemLocalesEx() in <a href="#L1103" title="utils/adt/pg_locale.c:1103">get_iso_localename</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function enumerates all system locales, searching for one that matches<br/></li>
<li></span><span class="Comment"> * an input with the format: &lt;Language&gt;[<a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>&lt;Country&gt;], e.g.<br/></li>
<li></span><span class="Comment"> * English[_United States]<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The input is a three wchar_t array as an LPARAM. The first <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> is the<br/></li>
<li></span><span class="Comment"> * locale_name we want to match, the second <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> is an allocated buffer<br/></li>
<li></span><span class="Comment"> * where the Unix-style locale is copied if a match is found, and the third<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> is the search status, 1 if a match was found, 0 otherwise.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> BOOL CALLBACK<br/></li>
<li><a id="L1037">&#x200c;</a><span class="linkable">search_locale_enum</span>(LPWSTR pStr, DWORD dwFlags, LPARAM lparam)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">wchar_t</span>&nbsp; &nbsp; &nbsp; &nbsp; test_locale[LOCALE_NAME_MAX_LENGTH];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">wchar_t</span>&nbsp;&nbsp; **argv;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) (dwFlags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; argv = (<span class="Type">wchar_t</span> **) lparam;<br/></li>
<li>&nbsp; &nbsp; *argv[<span class="Constant">2</span>] = (<span class="Type">wchar_t</span>) <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memset(test_locale, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(test_locale));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get the name of the &lt;Language&gt; in English */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (GetLocaleInfoEx(pStr, LOCALE_SENGLISHLANGUAGENAME,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; test_locale, LOCALE_NAME_MAX_LENGTH))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the enumerated locale does not have a hyphen (&quot;en&quot;) OR the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * locale_name input does not have an underscore (&quot;English&quot;), we only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * need to <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> the &lt;Language&gt; tags.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (wcsrchr(pStr, <span class="Constant">'-'</span>) == <span class="Constant">NULL</span> || wcsrchr(argv[<span class="Constant">0</span>], <span class="Constant">'<a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>'</span>) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (_wcsicmp(argv[<span class="Constant">0</span>], test_locale) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wcscpy(argv[<span class="Constant">1</span>], pStr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *argv[<span class="Constant">2</span>] = (<span class="Type">wchar_t</span>) <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> FALSE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have to <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> a full &lt;Language&gt;<a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>&lt;Country&gt; tag, so we append<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the underscore and name of the country/region in English, e.g.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * &quot;English_United States&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wcscat(test_locale, <span class="Constant">L&quot;<a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len = wcslen(test_locale);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (GetLocaleInfoEx(pStr, LOCALE_SENGLISHCOUNTRYNAME,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; test_locale + len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LOCALE_NAME_MAX_LENGTH - len))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (_wcsicmp(argv[<span class="Constant">0</span>], test_locale) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wcscpy(argv[<span class="Constant">1</span>], pStr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *argv[<span class="Constant">2</span>] = (<span class="Type">wchar_t</span>) <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> FALSE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> TRUE;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This function converts a Windows locale name to an ISO formatted version<br/></li>
<li></span><span class="Comment"> * for Visual Studio 2015 or greater.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns NULL, if no valid conversion was found.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L1103">&#x200c;</a><span class="linkable">get_iso_localename</span>(<span class="Type">const</span> <span class="Type">char</span> *winlocname)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">wchar_t</span>&nbsp; &nbsp; &nbsp; &nbsp; wc_locale_name[LOCALE_NAME_MAX_LENGTH];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">wchar_t</span>&nbsp; &nbsp; &nbsp; &nbsp; buffer[LOCALE_NAME_MAX_LENGTH];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">char</span> iso_lc_messages[LOCALE_NAME_MAX_LENGTH];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *period;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret_val;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Valid locales have the following syntax:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &lt;Language&gt;[<a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>&lt;Country&gt;[.&lt;CodePage&gt;]]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * GetLocaleInfoEx can only take locale name without code-page and for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * purpose of this API the code-page doesn't matter.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; period = strchr(winlocname, <span class="Constant">'.'</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (period != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len = period - winlocname;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; len = <a href="../mb/mbutils.c.html#L1037" title="utils/mb/mbutils.c:1037">pg_mbstrlen</a>(winlocname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memset(wc_locale_name, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(wc_locale_name));<br/></li>
<li>&nbsp; &nbsp; memset(buffer, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(buffer));<br/></li>
<li>&nbsp; &nbsp; MultiByteToWideChar(CP_ACP, <span class="Constant">0</span>, winlocname, len, wc_locale_name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LOCALE_NAME_MAX_LENGTH);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the lc_messages is already a Unix-style string, we have a direct<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * match with LOCALE_SNAME, e.g. en-US, en_US.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ret_val = GetLocaleInfoEx(wc_locale_name, LOCALE_SNAME, (LPWSTR) &amp;buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LOCALE_NAME_MAX_LENGTH);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!ret_val)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Search for a locale in the system that matches language and country<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * name.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">wchar_t</span>&nbsp; &nbsp; *argv[<span class="Constant">3</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; argv[<span class="Constant">0</span>] = wc_locale_name;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; argv[<span class="Constant">1</span>] = buffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; argv[<span class="Constant">2</span>] = (<span class="Type">wchar_t</span> *) &amp;ret_val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; EnumSystemLocalesEx(<a href="#L1037" title="utils/adt/pg_locale.c:1037">search_locale_enum</a>, LOCALE_WINDOWS, (LPARAM) argv,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ret_val)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; rc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *hyphen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Locale names use only ASCII, <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> conversion locale suffices. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rc = <a href="#L3065" title="utils/adt/pg_locale.c:3065">wchar2char</a>(iso_lc_messages, buffer, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(iso_lc_messages), <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rc == -<span class="Constant">1</span> || rc == <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(iso_lc_messages))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since the message catalogs sit on a case-insensitive filesystem, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * need not standardize letter case here.&nbsp; So long as we do not ship<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * message catalogs for which it would matter, we also need not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="oracle_compat.c.html#L797" title="utils/adt/oracle_compat.c:797">translate</a> the script/variant portion, e.g.&nbsp; uz-Cyrl-UZ to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * uz_UZ@cyrillic.&nbsp; Simply replace the hyphen with an underscore.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; hyphen = strchr(iso_lc_messages, <span class="Constant">'-'</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hyphen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *hyphen = <span class="Constant">'<a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> iso_lc_messages;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L1178">&#x200c;</a><span class="linkable">IsoLocaleName</span>(<span class="Type">const</span> <span class="Type">char</span> *winlocname)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">char</span> iso_lc_messages[LOCALE_NAME_MAX_LENGTH];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pg_strcasecmp(<span class="Constant">&quot;c&quot;</span>, winlocname) == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_strcasecmp(<span class="Constant">&quot;posix&quot;</span>, winlocname) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; strcpy(iso_lc_messages, <span class="Constant">&quot;C&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> iso_lc_messages;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1103" title="utils/adt/pg_locale.c:1103">get_iso_localename</a>(winlocname);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#else</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* !defined(_MSC_VER) */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L1195">&#x200c;</a><span class="linkable">IsoLocaleName</span>(<span class="Type">const</span> <span class="Type">char</span> *winlocname)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Not supported on MinGW */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* defined(_MSC_VER) */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* WIN32 &amp;&amp; LC_MESSAGES */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Cache mechanism for collation information.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We cache two flags: whether the collation's LC_COLLATE or LC_CTYPE is C<br/></li>
<li></span><span class="Comment"> * (or POSIX), so we can <a href="../../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> a few code paths in various places.<br/></li>
<li></span><span class="Comment"> * For the built-in C and POSIX collations, we can know that without even<br/></li>
<li></span><span class="Comment"> * doing a cache lookup, but we want to support aliases for C/POSIX too.<br/></li>
<li></span><span class="Comment"> * For the &quot;default&quot; collation, there are separate static cache variables,<br/></li>
<li></span><span class="Comment"> * since consulting the pg_collation catalog doesn't tell us what we need.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Also, if a pg_locale_t has been requested for a collation, we cache that<br/></li>
<li></span><span class="Comment"> * for the life of a backend.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that some code relies on the flags not reporting false negatives<br/></li>
<li></span><span class="Comment"> * (that is, saying it's not C when it is).&nbsp; For example, <a href="#L3121" title="utils/adt/pg_locale.c:3121">char2wchar</a>()<br/></li>
<li></span><span class="Comment"> * could fail if the locale is C, so <a href="formatting.c.html#L1636" title="utils/adt/formatting.c:1636">str_tolower</a>() shouldn't call it<br/></li>
<li></span><span class="Comment"> * in that case.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that we currently lack <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> way to flush the cache.&nbsp; Since we don't<br/></li>
<li></span><span class="Comment"> * support ALTER COLLATION, this is OK.&nbsp; The worst case is that someone<br/></li>
<li></span><span class="Comment"> * drops a collation, and a useless cache entry hangs around in existing<br/></li>
<li></span><span class="Comment"> * backends.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <a href="#L132" title="utils/adt/pg_locale.c:132">collation_cache_entry</a> *<br/></li>
<li><a id="L1230">&#x200c;</a><span class="linkable">lookup_collation_cache</span>(Oid collation, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> set_flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L132" title="utils/adt/pg_locale.c:132">collation_cache_entry</a> *cache_entry;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(OidIsValid(collation));<br/></li>
<li>&nbsp; &nbsp; Assert(collation != DEFAULT_COLLATION_OID);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L134" title="utils/adt/pg_locale.c:134">collation_cache</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* First time through, <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; HASHCTL&nbsp; &nbsp; &nbsp; &nbsp; ctl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ctl.keysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ctl.entrysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L132" title="utils/adt/pg_locale.c:132">collation_cache_entry</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L134" title="utils/adt/pg_locale.c:134">collation_cache</a> = <a href="../hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(<span class="Constant">&quot;Collation cache&quot;</span>, <span class="Constant">100</span>, &amp;ctl,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ELEM | HASH_BLOBS);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cache_entry = <a href="../hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L134" title="utils/adt/pg_locale.c:134">collation_cache</a>, &amp;collation, HASH_ENTER, &amp;found);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make sure cache entry is marked invalid, in case we fail <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * setting things.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; cache_entry-&gt;flags_valid = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cache_entry-&gt;locale = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (set_flags &amp;&amp; !cache_entry-&gt;flags_valid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Attempt to set the flags */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_collation collform;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tp = <a href="../cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(COLLOID, ObjectIdGetDatum(collation));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for collation </span><span class="Special">%u</span><span class="Constant">&quot;</span>, collation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; collform = (Form_pg_collation) GETSTRUCT(tp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (collform-&gt;collprovider == COLLPROVIDER_BUILTIN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; datum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *colllocale;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datum = <a href="../cache/syscache.c.html#L510" title="utils/cache/syscache.c:510">SysCacheGetAttrNotNull</a>(COLLOID, tp, Anum_pg_collation_colllocale);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colllocale = TextDatumGetCString(datum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cache_entry-&gt;collate_is_c = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cache_entry-&gt;ctype_is_c = (strcmp(colllocale, <span class="Constant">&quot;C&quot;</span>) == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (collform-&gt;collprovider == COLLPROVIDER_LIBC)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; datum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *collcollate;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *collctype;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datum = <a href="../cache/syscache.c.html#L510" title="utils/cache/syscache.c:510">SysCacheGetAttrNotNull</a>(COLLOID, tp, Anum_pg_collation_collcollate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collcollate = TextDatumGetCString(datum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datum = <a href="../cache/syscache.c.html#L510" title="utils/cache/syscache.c:510">SysCacheGetAttrNotNull</a>(COLLOID, tp, Anum_pg_collation_collctype);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collctype = TextDatumGetCString(datum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cache_entry-&gt;collate_is_c = ((strcmp(collcollate, <span class="Constant">&quot;C&quot;</span>) == <span class="Constant">0</span>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (strcmp(collcollate, <span class="Constant">&quot;POSIX&quot;</span>) == <span class="Constant">0</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cache_entry-&gt;ctype_is_c = ((strcmp(collctype, <span class="Constant">&quot;C&quot;</span>) == <span class="Constant">0</span>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (strcmp(collctype, <span class="Constant">&quot;POSIX&quot;</span>) == <span class="Constant">0</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cache_entry-&gt;collate_is_c = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cache_entry-&gt;ctype_is_c = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cache_entry-&gt;flags_valid = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> cache_entry;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Detect whether collation's LC_COLLATE property is C<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1317">&#x200c;</a></span><span class="linkable">lc_collate_is_c</span>(Oid collation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're asked about &quot;collation 0&quot;, return false, so that the code will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * go into the non-C path and report that the collation is bogus.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(collation))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're asked about the default collation, we have to inquire of the C<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * library.&nbsp; Cache the result so we only have to compute it once.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (collation == DEFAULT_COLLATION_OID)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; result = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *localeptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>) result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1446" title="utils/adt/pg_locale.c:1446">default_locale</a>.<a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a> == COLLPROVIDER_BUILTIN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>) result;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L1446" title="utils/adt/pg_locale.c:1446">default_locale</a>.<a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a> == COLLPROVIDER_ICU)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>) result;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L1446" title="utils/adt/pg_locale.c:1446">default_locale</a>.<a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a> == COLLPROVIDER_LIBC)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; localeptr = setlocale(<span class="Constant">LC_CTYPE</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!localeptr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid LC_CTYPE setting&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected collation <a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a> '</span><span class="Special">%c</span><span class="Constant">'&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L1446" title="utils/adt/pg_locale.c:1446">default_locale</a>.<a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(localeptr, <span class="Constant">&quot;C&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(localeptr, <span class="Constant">&quot;POSIX&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>) result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're asked about the built-in C/POSIX collations, we know that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (collation == C_COLLATION_OID ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; collation == POSIX_COLLATION_OID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Otherwise, we have to consult pg_collation, but we cache that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> (<a href="#L1230" title="utils/adt/pg_locale.c:1230">lookup_collation_cache</a>(collation, <span class="Constant">true</span>))-&gt;collate_is_c;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Detect whether collation's LC_CTYPE property is C<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1384">&#x200c;</a></span><span class="linkable">lc_ctype_is_c</span>(Oid collation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're asked about &quot;collation 0&quot;, return false, so that the code will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * go into the non-C path and report that the collation is bogus.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(collation))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're asked about the default collation, we have to inquire of the C<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * library.&nbsp; Cache the result so we only have to compute it once.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (collation == DEFAULT_COLLATION_OID)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; result = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *localeptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>) result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1446" title="utils/adt/pg_locale.c:1446">default_locale</a>.<a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a> == COLLPROVIDER_BUILTIN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; localeptr = <a href="#L1446" title="utils/adt/pg_locale.c:1446">default_locale</a>.info.builtin.locale;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L1446" title="utils/adt/pg_locale.c:1446">default_locale</a>.<a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a> == COLLPROVIDER_ICU)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>) result;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L1446" title="utils/adt/pg_locale.c:1446">default_locale</a>.<a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a> == COLLPROVIDER_LIBC)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; localeptr = setlocale(<span class="Constant">LC_CTYPE</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!localeptr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid LC_CTYPE setting&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected collation <a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a> '</span><span class="Special">%c</span><span class="Constant">'&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L1446" title="utils/adt/pg_locale.c:1446">default_locale</a>.<a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(localeptr, <span class="Constant">&quot;C&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(localeptr, <span class="Constant">&quot;POSIX&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>) result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're asked about the built-in C/POSIX collations, we know that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (collation == C_COLLATION_OID ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; collation == POSIX_COLLATION_OID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Otherwise, we have to consult pg_collation, but we cache that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> (<a href="#L1230" title="utils/adt/pg_locale.c:1230">lookup_collation_cache</a>(collation, <span class="Constant">true</span>))-&gt;ctype_is_c;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1446">&#x200c;</a><span class="Type">struct</span> pg_locale_struct <span class="linkable">default_locale</span>;<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L1449">&#x200c;</a></span><span class="linkable">make_icu_collator</span>(<span class="Type">const</span> <span class="Type">char</span> *iculocstr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *icurules,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> pg_locale_struct *resultp)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef USE_ICU<br/></li>
<li></span>&nbsp; &nbsp; UCollator&nbsp; *collator;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; collator = <a href="#L2585" title="utils/adt/pg_locale.c:2585">pg_ucol_open</a>(iculocstr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If rules are specified, we extract the rules of the standard collation,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * add our own rules, and make a new collator with the combined rules.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (icurules)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> UChar *default_rules;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; UChar&nbsp; &nbsp; &nbsp;&nbsp; *agg_rules;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; UChar&nbsp; &nbsp; &nbsp;&nbsp; *my_rules;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; UErrorCode&nbsp; &nbsp; status;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int32_t</span>&nbsp; &nbsp; &nbsp; &nbsp; length;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; default_rules = ucol_getRules(collator, &amp;length);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2741" title="utils/adt/pg_locale.c:2741">icu_to_uchar</a>(&amp;my_rules, icurules, strlen(icurules));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; agg_rules = palloc_array(UChar, u_strlen(default_rules) + u_strlen(my_rules) + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; u_strcpy(agg_rules, default_rules);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; u_strcat(agg_rules, my_rules);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ucol_close(collator);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; status = U_ZERO_ERROR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; collator = ucol_openRules(agg_rules, u_strlen(agg_rules),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UCOL_DEFAULT, UCOL_DEFAULT_STRENGTH, <span class="Constant">NULL</span>, &amp;status);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (U_FAILURE(status))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not open collator for locale </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> with rules </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iculocstr, icurules, u_errorName(status))));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We will leak this string if the caller errors later :-( */<br/></li>
<li></span>&nbsp; &nbsp; resultp-&gt;info.icu.locale = <a href="../mmgr/mcxt.c.html#L1682" title="utils/mmgr/mcxt.c:1682">MemoryContextStrdup</a>(<a href="../mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>, iculocstr);<br/></li>
<li>&nbsp; &nbsp; resultp-&gt;info.icu.ucol = collator;<br/></li>
<li><span class="PreProc">#else</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not USE_ICU */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* could get here if a collation was created by a build with ICU */<br/></li>
<li></span>&nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;ICU is not supported in this build&quot;</span>)));<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not USE_ICU */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* simple subroutine for reporting errors from newlocale() */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1502">&#x200c;</a></span><span class="linkable">report_newlocale_failure</span>(<span class="Type">const</span> <span class="Type">char</span> *localename)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Windows doesn't provide <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> useful error indication from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * _create_locale(), and BSD-derived platforms don't seem to feel they<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need to set errno either (even though POSIX is pretty clear that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * newlocale should do so).&nbsp; So, if errno hasn't been set, assume ENOENT<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is what to report.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">ENOENT</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ENOENT means &quot;no such locale&quot;, not &quot;no such file&quot;, so clarify that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * errno with an <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a> message.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; save_errno = errno;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* auxiliary funcs might change errno */<br/></li>
<li></span>&nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not create locale </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; localename),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (save_errno == <span class="Constant">ENOENT</span> ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;The operating system could not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> locale data for the locale name </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; localename) : <span class="Constant">0</span>)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1531">&#x200c;</a></span><span class="linkable">pg_locale_deterministic</span>(pg_locale_t locale)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* default locale must always be deterministic */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (locale == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> locale-&gt;deterministic;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create a locale_t from a collation OID.&nbsp; Results are cached for the<br/></li>
<li></span><span class="Comment"> * lifetime of the backend.&nbsp; Thus, do not free the result with freelocale().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As a special optimization, the default/database collation returns 0.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For simplicity, we always generate COLLATE + CTYPE even though we<br/></li>
<li></span><span class="Comment"> * might only need one of them.&nbsp; Since this is called only once per session,<br/></li>
<li></span><span class="Comment"> * it shouldn't cost much.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>pg_locale_t<br/></li>
<li><a id="L1551">&#x200c;</a><span class="linkable">pg_newlocale_from_collation</span>(Oid collid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L132" title="utils/adt/pg_locale.c:132">collation_cache_entry</a> *cache_entry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Callers must pass a valid OID */<br/></li>
<li></span>&nbsp; &nbsp; Assert(OidIsValid(collid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (collid == DEFAULT_COLLATION_OID)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1446" title="utils/adt/pg_locale.c:1446">default_locale</a>.<a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a> == COLLPROVIDER_LIBC)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (pg_locale_t) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> &amp;<a href="#L1446" title="utils/adt/pg_locale.c:1446">default_locale</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cache_entry = <a href="#L1230" title="utils/adt/pg_locale.c:1230">lookup_collation_cache</a>(collid, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cache_entry-&gt;locale == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We haven't computed this yet in this session, so do it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_collation collform;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> pg_locale_struct result;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_locale_t resultp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; datum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tp = <a href="../cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(COLLOID, ObjectIdGetDatum(collid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for collation </span><span class="Special">%u</span><span class="Constant">&quot;</span>, collid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; collform = (Form_pg_collation) GETSTRUCT(tp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We'll fill in the result struct locally <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> allocating memory */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memset(&amp;result, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(result));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result.<a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a> = collform-&gt;collprovider;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result.deterministic = collform-&gt;collisdeterministic;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (collform-&gt;collprovider == COLLPROVIDER_BUILTIN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *locstr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datum = <a href="../cache/syscache.c.html#L510" title="utils/cache/syscache.c:510">SysCacheGetAttrNotNull</a>(COLLOID, tp, Anum_pg_collation_colllocale);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locstr = TextDatumGetCString(datum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2551" title="utils/adt/pg_locale.c:2551">builtin_validate_locale</a>(<a href="../mb/mbutils.c.html#L1261" title="utils/mb/mbutils.c:1261">GetDatabaseEncoding</a>(), locstr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result.info.builtin.locale = <a href="../mmgr/mcxt.c.html#L1682" title="utils/mmgr/mcxt.c:1682">MemoryContextStrdup</a>(<a href="../mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; locstr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (collform-&gt;collprovider == COLLPROVIDER_LIBC)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *collcollate;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *collctype pg_attribute_unused();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locale_t&nbsp; &nbsp; loc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datum = <a href="../cache/syscache.c.html#L510" title="utils/cache/syscache.c:510">SysCacheGetAttrNotNull</a>(COLLOID, tp, Anum_pg_collation_collcollate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collcollate = TextDatumGetCString(datum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datum = <a href="../cache/syscache.c.html#L510" title="utils/cache/syscache.c:510">SysCacheGetAttrNotNull</a>(COLLOID, tp, Anum_pg_collation_collctype);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collctype = TextDatumGetCString(datum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(collcollate, collctype) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Normal case where they're the same */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li><span class="PreProc">#ifndef WIN32<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; loc = newlocale(LC_COLLATE_MASK | LC_CTYPE_MASK, collcollate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; loc = _create_locale(<span class="Constant">LC_ALL</span>, collcollate);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!loc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1502" title="utils/adt/pg_locale.c:1502">report_newlocale_failure</a>(collcollate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li><span class="PreProc">#ifndef WIN32<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We need two newlocale() steps */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locale_t&nbsp; &nbsp; loc1;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; loc1 = newlocale(LC_COLLATE_MASK, collcollate, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!loc1)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1502" title="utils/adt/pg_locale.c:1502">report_newlocale_failure</a>(collcollate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; loc = newlocale(LC_CTYPE_MASK, collctype, loc1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!loc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1502" title="utils/adt/pg_locale.c:1502">report_newlocale_failure</a>(collctype);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> The _create_locale() API doesn't appear to support<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this. Could perhaps be worked around by changing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pg_locale_t to contain two separate fields.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;collations with different collate and ctype <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are not supported on this platform&quot;</span>)));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result.info.lt = loc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (collform-&gt;collprovider == COLLPROVIDER_ICU)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *iculocstr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *icurules;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datum = <a href="../cache/syscache.c.html#L510" title="utils/cache/syscache.c:510">SysCacheGetAttrNotNull</a>(COLLOID, tp, Anum_pg_collation_colllocale);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iculocstr = TextDatumGetCString(datum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datum = <a href="../cache/syscache.c.html#L479" title="utils/cache/syscache.c:479">SysCacheGetAttr</a>(COLLOID, tp, Anum_pg_collation_collicurules, &amp;isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; icurules = TextDatumGetCString(datum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; icurules = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1449" title="utils/adt/pg_locale.c:1449">make_icu_collator</a>(iculocstr, icurules, &amp;result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; datum = <a href="../cache/syscache.c.html#L479" title="utils/cache/syscache.c:479">SysCacheGetAttr</a>(COLLOID, tp, Anum_pg_collation_collversion,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *actual_versionstr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *collversionstr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collversionstr = TextDatumGetCString(datum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (collform-&gt;collprovider == COLLPROVIDER_LIBC)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datum = <a href="../cache/syscache.c.html#L510" title="utils/cache/syscache.c:510">SysCacheGetAttrNotNull</a>(COLLOID, tp, Anum_pg_collation_collcollate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datum = <a href="../cache/syscache.c.html#L510" title="utils/cache/syscache.c:510">SysCacheGetAttrNotNull</a>(COLLOID, tp, Anum_pg_collation_colllocale);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; actual_versionstr = <a href="#L1729" title="utils/adt/pg_locale.c:1729">get_collation_actual_version</a>(collform-&gt;collprovider,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TextDatumGetCString(datum));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!actual_versionstr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This could happen when specifying a version in CREATE<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * COLLATION but the <a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a> does not support versioning, or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * manually creating a mess in the catalogs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;collation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> has no actual version, but a version was recorded&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(collform-&gt;collname))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(actual_versionstr, collversionstr) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;collation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> has version mismatch&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(collform-&gt;collname)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;The collation in the database was created using version </span><span class="Special">%s</span><span class="Constant">, &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;but the operating system provides version </span><span class="Special">%s</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; collversionstr, actual_versionstr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Rebuild all objects affected by this collation and run &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;ALTER COLLATION </span><span class="Special">%s</span><span class="Constant"> REFRESH VERSION, &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;or build PostgreSQL with the right library version.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="ruleutils.c.html#L12707" title="utils/adt/ruleutils.c:12707">quote_qualified_identifier</a>(<a href="../cache/lsyscache.c.html#L3366" title="utils/cache/lsyscache.c:3366">get_namespace_name</a>(collform-&gt;collnamespace),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(collform-&gt;collname)))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We'll keep the pg_locale_t structures in <a href="../mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; resultp = <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(<a href="../mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(*resultp));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *resultp = result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cache_entry-&gt;locale = resultp;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> cache_entry-&gt;locale;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get <a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a>-specific collation version string for the given collation from<br/></li>
<li></span><span class="Comment"> * the operating system/library.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L1729">&#x200c;</a><span class="linkable">get_collation_actual_version</span>(<span class="Type">char</span> collprovider, <span class="Type">const</span> <span class="Type">char</span> *collcollate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *collversion = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The only two supported locales (C and C.UTF-8) are both based on memcmp<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and are not expected to change, but track the version anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that the character semantics may change for some locales, but the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * collation version only tracks changes to sort order.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (collprovider == COLLPROVIDER_BUILTIN)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(collcollate, <span class="Constant">&quot;C&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;1&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(collcollate, <span class="Constant">&quot;C.UTF-8&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;1&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid locale name </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> for builtin <a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collcollate)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_ICU<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (collprovider == COLLPROVIDER_ICU)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; UCollator&nbsp; *collator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; UVersionInfo versioninfo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; buf[U_MAX_VERSION_STRING_LENGTH];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; collator = <a href="#L2585" title="utils/adt/pg_locale.c:2585">pg_ucol_open</a>(collcollate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ucol_getVersion(collator, versioninfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ucol_close(collator);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; u_versionToString(versioninfo, buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; collversion = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(buf);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (collprovider == COLLPROVIDER_LIBC &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_strcasecmp(<span class="Constant">&quot;C&quot;</span>, collcollate) != <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_strncasecmp(<span class="Constant">&quot;C.&quot;</span>, collcollate, <span class="Constant">2</span>) != <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_strcasecmp(<span class="Constant">&quot;POSIX&quot;</span>, collcollate) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li><span class="PreProc">#if defined(__GLIBC__)<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Use the glibc version because we don't have anything better. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; collversion = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(gnu_get_libc_version());<br/></li>
<li><span class="PreProc">#elif defined(LC_VERSION_MASK)<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; locale_t&nbsp; &nbsp; loc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Look up FreeBSD collation version. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; loc = newlocale(<span class="Constant">LC_COLLATE</span>, collcollate, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (loc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collversion =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(querylocale(LC_COLLATE_MASK | LC_VERSION_MASK, loc));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; freelocale(loc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not load locale </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, collcollate)));<br/></li>
<li><span class="PreProc">#elif defined(WIN32)<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we are targeting Windows Vista and above, we can ask for a name<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * given a collation name (earlier versions required a location code<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that we don't have).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; NLSVERSIONINFOEX version = {<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(NLSVERSIONINFOEX)};<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; WCHAR&nbsp; &nbsp; &nbsp; &nbsp; wide_collcollate[LOCALE_NAME_MAX_LENGTH];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MultiByteToWideChar(CP_ACP, <span class="Constant">0</span>, collcollate, -<span class="Constant">1</span>, wide_collcollate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LOCALE_NAME_MAX_LENGTH);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!GetNLSVersionEx(COMPARE_STRING, wide_collcollate, &amp;version))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * GetNLSVersionEx() wants a language tag such as &quot;en-US&quot;, not a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * locale name like &quot;English_United States.1252&quot;.&nbsp; Until those<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> can be prevented from entering the system, or 100%<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reliably converted to the more useful tag format, tolerate the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * resulting error and report that we have no version data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (GetLastError() == ERROR_INVALID_PARAMETER)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not get collation version for locale </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: error code </span><span class="Special">%lu</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collcollate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GetLastError())));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; collversion = psprintf(<span class="Constant">&quot;</span><span class="Special">%lu</span><span class="Constant">.</span><span class="Special">%lu</span><span class="Constant">,</span><span class="Special">%lu</span><span class="Constant">.</span><span class="Special">%lu</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (version.dwNLSVersion &gt;&gt; <span class="Constant">8</span>) &amp; <span class="Constant">0xFFFF</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; version.dwNLSVersion &amp; <span class="Constant">0xFF</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (version.dwDefinedVersion &gt;&gt; <span class="Constant">8</span>) &amp; <span class="Constant">0xFFFF</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; version.dwDefinedVersion &amp; <span class="Constant">0xFF</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> collversion;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1839" title="utils/adt/pg_locale.c:1839">pg_strncoll_libc_win32_utf8</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Win32 does not have UTF-8. Convert UTF8 arguments to wide characters and<br/></li>
<li></span><span class="Comment"> * invoke wcscoll() or wcscoll_l().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#ifdef WIN32<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1839">&#x200c;</a></span><span class="linkable">pg_strncoll_libc_win32_utf8</span>(<span class="Type">const</span> <span class="Type">char</span> *arg1, <span class="Type">size_t</span> len1, <span class="Type">const</span> <span class="Type">char</span> *arg2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span> len2, pg_locale_t locale)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; sbuf[<a href="#L91" title="utils/adt/pg_locale.c:91">TEXTBUFLEN</a>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *buf = sbuf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *a1p,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *a2p;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a1len = len1 * <span class="Constant">2</span> + <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a2len = len2 * <span class="Constant">2</span> + <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!locale || locale-&gt;<a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a> == COLLPROVIDER_LIBC);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../mb/mbutils.c.html#L1261" title="utils/mb/mbutils.c:1261">GetDatabaseEncoding</a>() == PG_UTF8);<br/></li>
<li><span class="PreProc">#ifndef WIN32<br/></li>
<li></span>&nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (a1len + a2len &gt; <a href="#L91" title="utils/adt/pg_locale.c:91">TEXTBUFLEN</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(a1len + a2len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; a1p = buf;<br/></li>
<li>&nbsp; &nbsp; a2p = buf + a1len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* API does not work for zero-length input */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (len1 == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; r = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; r = MultiByteToWideChar(CP_UTF8, <span class="Constant">0</span>, arg1, len1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (LPWSTR) a1p, a1len / <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!r)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not convert string to UTF-16: error code </span><span class="Special">%lu</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GetLastError())));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; ((LPWSTR) a1p)[r] = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (len2 == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; r = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; r = MultiByteToWideChar(CP_UTF8, <span class="Constant">0</span>, arg2, len2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (LPWSTR) a2p, a2len / <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!r)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not convert string to UTF-16: error code </span><span class="Special">%lu</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GetLastError())));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; ((LPWSTR) a2p)[r] = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (locale)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = wcscoll_l((LPWSTR) a1p, (LPWSTR) a2p, locale-&gt;info.lt);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = wcscoll((LPWSTR) a1p, (LPWSTR) a2p);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result == <span class="Constant">2147483647</span>)&nbsp; &nbsp; <span class="Comment">/* _NLSCMPERROR; missing from mingw headers */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> Unicode strings: %m&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (buf != sbuf)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* WIN32 */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1916" title="utils/adt/pg_locale.c:1916">pg_strcoll_libc</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Call strcoll(), strcoll_l(), wcscoll(), or wcscoll_l() as appropriate for<br/></li>
<li></span><span class="Comment"> * the given locale, platform, and database encoding. If the locale is NULL,<br/></li>
<li></span><span class="Comment"> * use the database collation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Arguments must be encoded in the database encoding and nul-terminated.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1916">&#x200c;</a></span><span class="linkable">pg_strcoll_libc</span>(<span class="Type">const</span> <span class="Type">char</span> *arg1, <span class="Type">const</span> <span class="Type">char</span> *arg2, pg_locale_t locale)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!locale || locale-&gt;<a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a> == COLLPROVIDER_LIBC);<br/></li>
<li><span class="PreProc">#ifdef WIN32<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../mb/mbutils.c.html#L1261" title="utils/mb/mbutils.c:1261">GetDatabaseEncoding</a>() == PG_UTF8)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; len1 = strlen(arg1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; len2 = strlen(arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L1839" title="utils/adt/pg_locale.c:1839">pg_strncoll_libc_win32_utf8</a>(arg1, len1, arg2, len2, locale);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* WIN32 */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (locale)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = strcoll_l(arg1, arg2, locale-&gt;info.lt);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = strcoll(arg1, arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1945" title="utils/adt/pg_locale.c:1945">pg_strncoll_libc</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Nul-terminate the arguments and call <a href="#L1916" title="utils/adt/pg_locale.c:1916">pg_strcoll_libc</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1945">&#x200c;</a></span><span class="linkable">pg_strncoll_libc</span>(<span class="Type">const</span> <span class="Type">char</span> *arg1, <span class="Type">size_t</span> len1, <span class="Type">const</span> <span class="Type">char</span> *arg2, <span class="Type">size_t</span> len2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pg_locale_t locale)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; sbuf[<a href="#L91" title="utils/adt/pg_locale.c:91">TEXTBUFLEN</a>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *buf = sbuf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; bufsize1 = len1 + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; bufsize2 = len2 + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *arg1n;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *arg2n;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!locale || locale-&gt;<a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a> == COLLPROVIDER_LIBC);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef WIN32<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* check for this case <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> doing the work for nul-termination */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../mb/mbutils.c.html#L1261" title="utils/mb/mbutils.c:1261">GetDatabaseEncoding</a>() == PG_UTF8)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1839" title="utils/adt/pg_locale.c:1839">pg_strncoll_libc_win32_utf8</a>(arg1, len1, arg2, len2, locale);<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* WIN32 */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (bufsize1 + bufsize2 &gt; <a href="#L91" title="utils/adt/pg_locale.c:91">TEXTBUFLEN</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(bufsize1 + bufsize2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; arg1n = buf;<br/></li>
<li>&nbsp; &nbsp; arg2n = buf + bufsize1;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* nul-terminate arguments */<br/></li>
<li></span>&nbsp; &nbsp; memcpy(arg1n, arg1, len1);<br/></li>
<li>&nbsp; &nbsp; arg1n[len1] = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; memcpy(arg2n, arg2, len2);<br/></li>
<li>&nbsp; &nbsp; arg2n[len2] = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L1916" title="utils/adt/pg_locale.c:1916">pg_strcoll_libc</a>(arg1n, arg2n, locale);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (buf != sbuf)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_ICU<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1997" title="utils/adt/pg_locale.c:1997">pg_strncoll_icu_no_utf8</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Convert the arguments from the database encoding to UChar strings, then<br/></li>
<li></span><span class="Comment"> * call ucol_strcoll(). An argument length of -1 means that the string is<br/></li>
<li></span><span class="Comment"> * NUL-terminated.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When the database encoding is UTF-8, and ICU supports ucol_strcollUTF8(),<br/></li>
<li></span><span class="Comment"> * caller should call that instead.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1997">&#x200c;</a></span><span class="linkable">pg_strncoll_icu_no_utf8</span>(<span class="Type">const</span> <span class="Type">char</span> *arg1, <span class="Type">int32_t</span> len1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *arg2, <span class="Type">int32_t</span> len2, pg_locale_t locale)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; sbuf[<a href="#L91" title="utils/adt/pg_locale.c:91">TEXTBUFLEN</a>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *buf = sbuf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int32_t</span>&nbsp; &nbsp; &nbsp; &nbsp; ulen1;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int32_t</span>&nbsp; &nbsp; &nbsp; &nbsp; ulen2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; bufsize1;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; bufsize2;<br/></li>
<li>&nbsp; &nbsp; UChar&nbsp; &nbsp; &nbsp;&nbsp; *uchar1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *uchar2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(locale-&gt;<a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a> == COLLPROVIDER_ICU);<br/></li>
<li><span class="PreProc">#ifdef HAVE_UCOL_STRCOLLUTF8<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../mb/mbutils.c.html#L1261" title="utils/mb/mbutils.c:1261">GetDatabaseEncoding</a>() != PG_UTF8);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="#L2667" title="utils/adt/pg_locale.c:2667">init_icu_converter</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ulen1 = <a href="#L2697" title="utils/adt/pg_locale.c:2697">uchar_length</a>(<a href="#L147" title="utils/adt/pg_locale.c:147">icu_converter</a>, arg1, len1);<br/></li>
<li>&nbsp; &nbsp; ulen2 = <a href="#L2697" title="utils/adt/pg_locale.c:2697">uchar_length</a>(<a href="#L147" title="utils/adt/pg_locale.c:147">icu_converter</a>, arg2, len2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; bufsize1 = (ulen1 + <span class="Constant">1</span>) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(UChar);<br/></li>
<li>&nbsp; &nbsp; bufsize2 = (ulen2 + <span class="Constant">1</span>) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(UChar);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (bufsize1 + bufsize2 &gt; <a href="#L91" title="utils/adt/pg_locale.c:91">TEXTBUFLEN</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(bufsize1 + bufsize2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; uchar1 = (UChar *) buf;<br/></li>
<li>&nbsp; &nbsp; uchar2 = (UChar *) (buf + bufsize1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ulen1 = <a href="#L2714" title="utils/adt/pg_locale.c:2714">uchar_convert</a>(<a href="#L147" title="utils/adt/pg_locale.c:147">icu_converter</a>, uchar1, ulen1 + <span class="Constant">1</span>, arg1, len1);<br/></li>
<li>&nbsp; &nbsp; ulen2 = <a href="#L2714" title="utils/adt/pg_locale.c:2714">uchar_convert</a>(<a href="#L147" title="utils/adt/pg_locale.c:147">icu_converter</a>, uchar2, ulen2 + <span class="Constant">1</span>, arg2, len2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = ucol_strcoll(locale-&gt;info.icu.ucol,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uchar1, ulen1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uchar2, ulen2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (buf != sbuf)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2052" title="utils/adt/pg_locale.c:2052">pg_strncoll_icu</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Call ucol_strcollUTF8() or ucol_strcoll() as appropriate for the given<br/></li>
<li></span><span class="Comment"> * database encoding. An argument length of -1 means the string is<br/></li>
<li></span><span class="Comment"> * NUL-terminated.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Arguments must be encoded in the database encoding.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L2052">&#x200c;</a></span><span class="linkable">pg_strncoll_icu</span>(<span class="Type">const</span> <span class="Type">char</span> *arg1, <span class="Type">int32_t</span> len1, <span class="Type">const</span> <span class="Type">char</span> *arg2, <span class="Type">int32_t</span> len2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_locale_t locale)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(locale-&gt;<a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a> == COLLPROVIDER_ICU);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef HAVE_UCOL_STRCOLLUTF8<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../mb/mbutils.c.html#L1261" title="utils/mb/mbutils.c:1261">GetDatabaseEncoding</a>() == PG_UTF8)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; UErrorCode&nbsp; &nbsp; status;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; status = U_ZERO_ERROR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = ucol_strcollUTF8(locale-&gt;info.icu.ucol,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arg1, len1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arg2, len2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;status);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (U_FAILURE(status))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;collation failed: </span><span class="Special">%s</span><span class="Constant">&quot;</span>, u_errorName(status))));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L1997" title="utils/adt/pg_locale.c:1997">pg_strncoll_icu_no_utf8</a>(arg1, len1, arg2, len2, locale);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* USE_ICU */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2098" title="utils/adt/pg_locale.c:2098">pg_strcoll</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Call ucol_strcollUTF8(), ucol_strcoll(), strcoll(), strcoll_l(), wcscoll(),<br/></li>
<li></span><span class="Comment"> * or wcscoll_l() as appropriate for the given locale, platform, and database<br/></li>
<li></span><span class="Comment"> * encoding. If the locale is not specified, use the database collation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Arguments must be encoded in the database encoding and nul-terminated.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller is responsible for breaking ties if the collation is<br/></li>
<li></span><span class="Comment"> * deterministic; this maintains consistency with <a href="#L2381" title="utils/adt/pg_locale.c:2381">pg_strxfrm</a>(), which cannot<br/></li>
<li></span><span class="Comment"> * easily account for deterministic collations.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L2098">&#x200c;</a></span><span class="linkable">pg_strcoll</span>(<span class="Type">const</span> <span class="Type">char</span> *arg1, <span class="Type">const</span> <span class="Type">char</span> *arg2, pg_locale_t locale)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!locale || locale-&gt;<a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a> == COLLPROVIDER_LIBC)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L1916" title="utils/adt/pg_locale.c:1916">pg_strcoll_libc</a>(arg1, arg2, locale);<br/></li>
<li><span class="PreProc">#ifdef USE_ICU<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (locale-&gt;<a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a> == COLLPROVIDER_ICU)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L2052" title="utils/adt/pg_locale.c:2052">pg_strncoll_icu</a>(arg1, -<span class="Constant">1</span>, arg2, -<span class="Constant">1</span>, locale);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* shouldn't happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L84" title="utils/adt/pg_locale.c:84">PGLOCALE_SUPPORT_ERROR</a>(locale-&gt;<a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2133" title="utils/adt/pg_locale.c:2133">pg_strncoll</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Call ucol_strcollUTF8(), ucol_strcoll(), strcoll(), strcoll_l(), wcscoll(),<br/></li>
<li></span><span class="Comment"> * or wcscoll_l() as appropriate for the given locale, platform, and database<br/></li>
<li></span><span class="Comment"> * encoding. If the locale is not specified, use the database collation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Arguments must be encoded in the database encoding.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function may need to nul-terminate the arguments for libc <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>;<br/></li>
<li></span><span class="Comment"> * so if the caller already has nul-terminated strings, it should call<br/></li>
<li></span><span class="Comment"> * <a href="#L2098" title="utils/adt/pg_locale.c:2098">pg_strcoll</a>() instead.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller is responsible for breaking ties if the collation is<br/></li>
<li></span><span class="Comment"> * deterministic; this maintains consistency with <a href="#L2417" title="utils/adt/pg_locale.c:2417">pg_strnxfrm</a>(), which cannot<br/></li>
<li></span><span class="Comment"> * easily account for deterministic collations.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L2133">&#x200c;</a></span><span class="linkable">pg_strncoll</span>(<span class="Type">const</span> <span class="Type">char</span> *arg1, <span class="Type">size_t</span> len1, <span class="Type">const</span> <span class="Type">char</span> *arg2, <span class="Type">size_t</span> len2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_locale_t locale)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!locale || locale-&gt;<a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a> == COLLPROVIDER_LIBC)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L1945" title="utils/adt/pg_locale.c:1945">pg_strncoll_libc</a>(arg1, len1, arg2, len2, locale);<br/></li>
<li><span class="PreProc">#ifdef USE_ICU<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (locale-&gt;<a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a> == COLLPROVIDER_ICU)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L2052" title="utils/adt/pg_locale.c:2052">pg_strncoll_icu</a>(arg1, len1, arg2, len2, locale);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* shouldn't happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L84" title="utils/adt/pg_locale.c:84">PGLOCALE_SUPPORT_ERROR</a>(locale-&gt;<a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">size_t<br/></li>
<li><a id="L2153">&#x200c;</a></span><span class="linkable">pg_strxfrm_libc</span>(<span class="Type">char</span> *dest, <span class="Type">const</span> <span class="Type">char</span> *src, <span class="Type">size_t</span> destsize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_locale_t locale)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(!locale || locale-&gt;<a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a> == COLLPROVIDER_LIBC);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef TRUST_STRXFRM<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (locale)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> strxfrm_l(dest, src, destsize, locale-&gt;info.lt);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> strxfrm(dest, src, destsize);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* shouldn't happen */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L84" title="utils/adt/pg_locale.c:84">PGLOCALE_SUPPORT_ERROR</a>(locale-&gt;<a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">size_t<br/></li>
<li><a id="L2171">&#x200c;</a></span><span class="linkable">pg_strnxfrm_libc</span>(<span class="Type">char</span> *dest, <span class="Type">const</span> <span class="Type">char</span> *src, <span class="Type">size_t</span> srclen, <span class="Type">size_t</span> destsize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pg_locale_t locale)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; sbuf[<a href="#L91" title="utils/adt/pg_locale.c:91">TEXTBUFLEN</a>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *buf = sbuf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; bufsize = srclen + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!locale || locale-&gt;<a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a> == COLLPROVIDER_LIBC);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (bufsize &gt; <a href="#L91" title="utils/adt/pg_locale.c:91">TEXTBUFLEN</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(bufsize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* nul-terminate arguments */<br/></li>
<li></span>&nbsp; &nbsp; memcpy(buf, src, srclen);<br/></li>
<li>&nbsp; &nbsp; buf[srclen] = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L2153" title="utils/adt/pg_locale.c:2153">pg_strxfrm_libc</a>(dest, buf, destsize, locale);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (buf != sbuf)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if dest is defined, it should be nul-terminated */<br/></li>
<li></span>&nbsp; &nbsp; Assert(result &gt;= destsize || dest[result] == <span class="Special">'\0'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_ICU<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* 'srclen' of -1 means the strings are NUL-terminated */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">size_t<br/></li>
<li><a id="L2203">&#x200c;</a></span><span class="linkable">pg_strnxfrm_icu</span>(<span class="Type">char</span> *dest, <span class="Type">const</span> <span class="Type">char</span> *src, <span class="Type">int32_t</span> srclen, <span class="Type">int32_t</span> destsize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_locale_t locale)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; sbuf[<a href="#L91" title="utils/adt/pg_locale.c:91">TEXTBUFLEN</a>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *buf = sbuf;<br/></li>
<li>&nbsp; &nbsp; UChar&nbsp; &nbsp; &nbsp;&nbsp; *uchar;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int32_t</span>&nbsp; &nbsp; &nbsp; &nbsp; ulen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; uchar_bsize;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; result_bsize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(locale-&gt;<a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a> == COLLPROVIDER_ICU);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2667" title="utils/adt/pg_locale.c:2667">init_icu_converter</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ulen = <a href="#L2697" title="utils/adt/pg_locale.c:2697">uchar_length</a>(<a href="#L147" title="utils/adt/pg_locale.c:147">icu_converter</a>, src, srclen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; uchar_bsize = (ulen + <span class="Constant">1</span>) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(UChar);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (uchar_bsize &gt; <a href="#L91" title="utils/adt/pg_locale.c:91">TEXTBUFLEN</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(uchar_bsize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; uchar = (UChar *) buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ulen = <a href="#L2714" title="utils/adt/pg_locale.c:2714">uchar_convert</a>(<a href="#L147" title="utils/adt/pg_locale.c:147">icu_converter</a>, uchar, ulen + <span class="Constant">1</span>, src, srclen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result_bsize = ucol_getSortKey(locale-&gt;info.icu.ucol,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; uchar, ulen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">uint8_t</span> *) dest, destsize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ucol_getSortKey() counts the nul-terminator in the result length, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this function should not.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(result_bsize &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; result_bsize--;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (buf != sbuf)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if dest is defined, it should be nul-terminated */<br/></li>
<li></span>&nbsp; &nbsp; Assert(result_bsize &gt;= destsize || dest[result_bsize] == <span class="Special">'\0'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result_bsize;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* 'srclen' of -1 means the strings are NUL-terminated */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">size_t<br/></li>
<li><a id="L2250">&#x200c;</a></span><span class="linkable">pg_strnxfrm_prefix_icu_no_utf8</span>(<span class="Type">char</span> *dest, <span class="Type">const</span> <span class="Type">char</span> *src, <span class="Type">int32_t</span> srclen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int32_t</span> destsize, pg_locale_t locale)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; sbuf[<a href="#L91" title="utils/adt/pg_locale.c:91">TEXTBUFLEN</a>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *buf = sbuf;<br/></li>
<li>&nbsp; &nbsp; UCharIterator iter;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">uint32_t</span>&nbsp; &nbsp; state[<span class="Constant">2</span>];<br/></li>
<li>&nbsp; &nbsp; UErrorCode&nbsp; &nbsp; status;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int32_t</span>&nbsp; &nbsp; &nbsp; &nbsp; ulen = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; UChar&nbsp; &nbsp; &nbsp;&nbsp; *uchar = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; uchar_bsize;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; result_bsize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(locale-&gt;<a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a> == COLLPROVIDER_ICU);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../mb/mbutils.c.html#L1261" title="utils/mb/mbutils.c:1261">GetDatabaseEncoding</a>() != PG_UTF8);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2667" title="utils/adt/pg_locale.c:2667">init_icu_converter</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ulen = <a href="#L2697" title="utils/adt/pg_locale.c:2697">uchar_length</a>(<a href="#L147" title="utils/adt/pg_locale.c:147">icu_converter</a>, src, srclen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; uchar_bsize = (ulen + <span class="Constant">1</span>) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(UChar);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (uchar_bsize &gt; <a href="#L91" title="utils/adt/pg_locale.c:91">TEXTBUFLEN</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(uchar_bsize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; uchar = (UChar *) buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ulen = <a href="#L2714" title="utils/adt/pg_locale.c:2714">uchar_convert</a>(<a href="#L147" title="utils/adt/pg_locale.c:147">icu_converter</a>, uchar, ulen + <span class="Constant">1</span>, src, srclen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; uiter_setString(&amp;iter, uchar, ulen);<br/></li>
<li>&nbsp; &nbsp; state[<span class="Constant">0</span>] = state[<span class="Constant">1</span>] = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* won't need that again */<br/></li>
<li></span>&nbsp; &nbsp; status = U_ZERO_ERROR;<br/></li>
<li>&nbsp; &nbsp; result_bsize = ucol_nextSortKeyPart(locale-&gt;info.icu.ucol,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;iter,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">uint8_t</span> *) dest,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; destsize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;status);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (U_FAILURE(status))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;sort key generation failed: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; u_errorName(status))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result_bsize;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* 'srclen' of -1 means the strings are NUL-terminated */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">size_t<br/></li>
<li><a id="L2298">&#x200c;</a></span><span class="linkable">pg_strnxfrm_prefix_icu</span>(<span class="Type">char</span> *dest, <span class="Type">const</span> <span class="Type">char</span> *src, <span class="Type">int32_t</span> srclen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int32_t</span> destsize, pg_locale_t locale)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(locale-&gt;<a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a> == COLLPROVIDER_ICU);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../mb/mbutils.c.html#L1261" title="utils/mb/mbutils.c:1261">GetDatabaseEncoding</a>() == PG_UTF8)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; UCharIterator iter;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">uint32_t</span>&nbsp; &nbsp; state[<span class="Constant">2</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; UErrorCode&nbsp; &nbsp; status;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uiter_setUTF8(&amp;iter, src, srclen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state[<span class="Constant">0</span>] = state[<span class="Constant">1</span>] = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* won't need that again */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; status = U_ZERO_ERROR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = ucol_nextSortKeyPart(locale-&gt;info.icu.ucol,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;iter,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">uint8_t</span> *) dest,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; destsize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;status);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (U_FAILURE(status))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;sort key generation failed: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; u_errorName(status))));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L2250" title="utils/adt/pg_locale.c:2250">pg_strnxfrm_prefix_icu_no_utf8</a>(dest, src, srclen, destsize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locale);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return true if the collation <a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a> supports <a href="#L2381" title="utils/adt/pg_locale.c:2381">pg_strxfrm</a>() and<br/></li>
<li></span><span class="Comment"> * <a href="#L2417" title="utils/adt/pg_locale.c:2417">pg_strnxfrm</a>(); otherwise false.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Unfortunately, it seems that strxfrm() for non-C collations is broken on<br/></li>
<li></span><span class="Comment"> * many common platforms; testing of multiple versions of glibc reveals that,<br/></li>
<li></span><span class="Comment"> * for many locales, strcoll() and strxfrm() do not return consistent<br/></li>
<li></span><span class="Comment"> * results. While no other libc other than Cygwin has so far been shown to<br/></li>
<li></span><span class="Comment"> * have a problem, we take the conservative course of action for right <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> and<br/></li>
<li></span><span class="Comment"> * disable this categorically.&nbsp; (Users who are certain this isn't a problem on<br/></li>
<li></span><span class="Comment"> * their system can define TRUST_STRXFRM.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * No similar problem is known for the ICU <a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2349">&#x200c;</a></span><span class="linkable">pg_strxfrm_enabled</span>(pg_locale_t locale)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!locale || locale-&gt;<a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a> == COLLPROVIDER_LIBC)<br/></li>
<li><span class="PreProc">#ifdef TRUST_STRXFRM<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (locale-&gt;<a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a> == COLLPROVIDER_ICU)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* shouldn't happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L84" title="utils/adt/pg_locale.c:84">PGLOCALE_SUPPORT_ERROR</a>(locale-&gt;<a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2381" title="utils/adt/pg_locale.c:2381">pg_strxfrm</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Transforms 'src' to a nul-terminated string stored in 'dest' such that<br/></li>
<li></span><span class="Comment"> * ordinary strcmp() on transformed strings is equivalent to <a href="#L2098" title="utils/adt/pg_locale.c:2098">pg_strcoll</a>() on<br/></li>
<li></span><span class="Comment"> * untransformed strings.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The provided 'src' must be nul-terminated. If 'destsize' is zero, 'dest'<br/></li>
<li></span><span class="Comment"> * may be NULL.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the number of bytes needed to store the transformed string,<br/></li>
<li></span><span class="Comment"> * excluding the terminating nul byte. If the value returned is 'destsize' or<br/></li>
<li></span><span class="Comment"> * greater, the resulting contents of 'dest' are undefined.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">size_t<br/></li>
<li><a id="L2381">&#x200c;</a></span><span class="linkable">pg_strxfrm</span>(<span class="Type">char</span> *dest, <span class="Type">const</span> <span class="Type">char</span> *src, <span class="Type">size_t</span> destsize, pg_locale_t locale)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!locale || locale-&gt;<a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a> == COLLPROVIDER_LIBC)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L2153" title="utils/adt/pg_locale.c:2153">pg_strxfrm_libc</a>(dest, src, destsize, locale);<br/></li>
<li><span class="PreProc">#ifdef USE_ICU<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (locale-&gt;<a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a> == COLLPROVIDER_ICU)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L2203" title="utils/adt/pg_locale.c:2203">pg_strnxfrm_icu</a>(dest, src, -<span class="Constant">1</span>, destsize, locale);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* shouldn't happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L84" title="utils/adt/pg_locale.c:84">PGLOCALE_SUPPORT_ERROR</a>(locale-&gt;<a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2417" title="utils/adt/pg_locale.c:2417">pg_strnxfrm</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Transforms 'src' to a nul-terminated string stored in 'dest' such that<br/></li>
<li></span><span class="Comment"> * ordinary strcmp() on transformed strings is equivalent to <a href="#L2098" title="utils/adt/pg_locale.c:2098">pg_strcoll</a>() on<br/></li>
<li></span><span class="Comment"> * untransformed strings.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'src' does not need to be nul-terminated. If 'destsize' is zero, 'dest' may<br/></li>
<li></span><span class="Comment"> * be NULL.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the number of bytes needed to store the transformed string,<br/></li>
<li></span><span class="Comment"> * excluding the terminating nul byte. If the value returned is 'destsize' or<br/></li>
<li></span><span class="Comment"> * greater, the resulting contents of 'dest' are undefined.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function may need to nul-terminate the argument for libc <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>;<br/></li>
<li></span><span class="Comment"> * so if the caller already has a nul-terminated string, it should call<br/></li>
<li></span><span class="Comment"> * <a href="#L2381" title="utils/adt/pg_locale.c:2381">pg_strxfrm</a>() instead.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">size_t<br/></li>
<li><a id="L2417">&#x200c;</a></span><span class="linkable">pg_strnxfrm</span>(<span class="Type">char</span> *dest, <span class="Type">size_t</span> destsize, <span class="Type">const</span> <span class="Type">char</span> *src, <span class="Type">size_t</span> srclen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_locale_t locale)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!locale || locale-&gt;<a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a> == COLLPROVIDER_LIBC)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L2171" title="utils/adt/pg_locale.c:2171">pg_strnxfrm_libc</a>(dest, src, srclen, destsize, locale);<br/></li>
<li><span class="PreProc">#ifdef USE_ICU<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (locale-&gt;<a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a> == COLLPROVIDER_ICU)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L2203" title="utils/adt/pg_locale.c:2203">pg_strnxfrm_icu</a>(dest, src, srclen, destsize, locale);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* shouldn't happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L84" title="utils/adt/pg_locale.c:84">PGLOCALE_SUPPORT_ERROR</a>(locale-&gt;<a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return true if the collation <a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a> supports <a href="#L2467" title="utils/adt/pg_locale.c:2467">pg_strxfrm_prefix</a>() and<br/></li>
<li></span><span class="Comment"> * <a href="#L2502" title="utils/adt/pg_locale.c:2502">pg_strnxfrm_prefix</a>(); otherwise false.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2440">&#x200c;</a></span><span class="linkable">pg_strxfrm_prefix_enabled</span>(pg_locale_t locale)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!locale || locale-&gt;<a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a> == COLLPROVIDER_LIBC)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (locale-&gt;<a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a> == COLLPROVIDER_ICU)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* shouldn't happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L84" title="utils/adt/pg_locale.c:84">PGLOCALE_SUPPORT_ERROR</a>(locale-&gt;<a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2467" title="utils/adt/pg_locale.c:2467">pg_strxfrm_prefix</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Transforms 'src' to a byte sequence stored in 'dest' such that ordinary<br/></li>
<li></span><span class="Comment"> * memcmp() on the byte sequence is equivalent to <a href="#L2098" title="utils/adt/pg_locale.c:2098">pg_strcoll</a>() on<br/></li>
<li></span><span class="Comment"> * untransformed strings. The result is not nul-terminated.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The provided 'src' must be nul-terminated.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If destsize is not large enough to hold the resulting byte sequence, stores<br/></li>
<li></span><span class="Comment"> * only the first destsize bytes in 'dest'. Returns the number of bytes<br/></li>
<li></span><span class="Comment"> * actually copied to 'dest'.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">size_t<br/></li>
<li><a id="L2467">&#x200c;</a></span><span class="linkable">pg_strxfrm_prefix</span>(<span class="Type">char</span> *dest, <span class="Type">const</span> <span class="Type">char</span> *src, <span class="Type">size_t</span> destsize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_locale_t locale)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!locale)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L84" title="utils/adt/pg_locale.c:84">PGLOCALE_SUPPORT_ERROR</a>(COLLPROVIDER_LIBC);<br/></li>
<li><span class="PreProc">#ifdef USE_ICU<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (locale-&gt;<a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a> == COLLPROVIDER_ICU)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L2298" title="utils/adt/pg_locale.c:2298">pg_strnxfrm_prefix_icu</a>(dest, src, -<span class="Constant">1</span>, destsize, locale);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L84" title="utils/adt/pg_locale.c:84">PGLOCALE_SUPPORT_ERROR</a>(locale-&gt;<a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2502" title="utils/adt/pg_locale.c:2502">pg_strnxfrm_prefix</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Transforms 'src' to a byte sequence stored in 'dest' such that ordinary<br/></li>
<li></span><span class="Comment"> * memcmp() on the byte sequence is equivalent to <a href="#L2098" title="utils/adt/pg_locale.c:2098">pg_strcoll</a>() on<br/></li>
<li></span><span class="Comment"> * untransformed strings. The result is not nul-terminated.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The provided 'src' must be nul-terminated.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If destsize is not large enough to hold the resulting byte sequence, stores<br/></li>
<li></span><span class="Comment"> * only the first destsize bytes in 'dest'. Returns the number of bytes<br/></li>
<li></span><span class="Comment"> * actually copied to 'dest'.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function may need to nul-terminate the argument for libc <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>;<br/></li>
<li></span><span class="Comment"> * so if the caller already has a nul-terminated string, it should call<br/></li>
<li></span><span class="Comment"> * <a href="#L2467" title="utils/adt/pg_locale.c:2467">pg_strxfrm_prefix</a>() instead.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">size_t<br/></li>
<li><a id="L2502">&#x200c;</a></span><span class="linkable">pg_strnxfrm_prefix</span>(<span class="Type">char</span> *dest, <span class="Type">size_t</span> destsize, <span class="Type">const</span> <span class="Type">char</span> *src,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">size_t</span> srclen, pg_locale_t locale)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!locale)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L84" title="utils/adt/pg_locale.c:84">PGLOCALE_SUPPORT_ERROR</a>(COLLPROVIDER_LIBC);<br/></li>
<li><span class="PreProc">#ifdef USE_ICU<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (locale-&gt;<a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a> == COLLPROVIDER_ICU)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L2298" title="utils/adt/pg_locale.c:2298">pg_strnxfrm_prefix_icu</a>(dest, src, -<span class="Constant">1</span>, destsize, locale);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L84" title="utils/adt/pg_locale.c:84">PGLOCALE_SUPPORT_ERROR</a>(locale-&gt;<a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return required encoding ID for the given locale, or -1 if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> encoding is<br/></li>
<li></span><span class="Comment"> * valid for the locale.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The only supported locale for the builtin <a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a> is &quot;C&quot;, and it's<br/></li>
<li></span><span class="Comment"> * available for <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> encoding.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L2527">&#x200c;</a></span><span class="linkable">builtin_locale_encoding</span>(<span class="Type">const</span> <span class="Type">char</span> *locale)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (strcmp(locale, <span class="Constant">&quot;C&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (strcmp(locale, <span class="Constant">&quot;C.UTF-8&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PG_UTF8;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid locale name </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> for builtin <a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locale)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Validate the locale and encoding combination, and return the canonical form<br/></li>
<li></span><span class="Comment"> * of the locale name.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The only supported locale for the builtin <a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a> is &quot;C&quot;, and it's<br/></li>
<li></span><span class="Comment"> * available for <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> encoding.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">const</span> <span class="Type">char</span> *<br/></li>
<li><a id="L2551">&#x200c;</a><span class="linkable">builtin_validate_locale</span>(<span class="Type">int</span> encoding, <span class="Type">const</span> <span class="Type">char</span> *locale)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *canonical_name = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; required_encoding;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (strcmp(locale, <span class="Constant">&quot;C&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; canonical_name = <span class="Constant">&quot;C&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(locale, <span class="Constant">&quot;C.UTF-8&quot;</span>) == <span class="Constant">0</span> || strcmp(locale, <span class="Constant">&quot;C.UTF8&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; canonical_name = <span class="Constant">&quot;C.UTF-8&quot;</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!canonical_name)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid locale name </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> for builtin <a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locale)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; required_encoding = <a href="#L2527" title="utils/adt/pg_locale.c:2527">builtin_locale_encoding</a>(canonical_name);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (required_encoding &gt;= <span class="Constant">0</span> &amp;&amp; encoding != required_encoding)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;encoding </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not match locale </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_encoding_to_char(encoding), locale)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> canonical_name;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_ICU<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Wrapper around ucol_open() to handle API differences for older ICU<br/></li>
<li></span><span class="Comment"> * versions.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> UCollator *<br/></li>
<li><a id="L2585">&#x200c;</a><span class="linkable">pg_ucol_open</span>(<span class="Type">const</span> <span class="Type">char</span> *loc_str)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; UCollator&nbsp; *collator;<br/></li>
<li>&nbsp; &nbsp; UErrorCode&nbsp; &nbsp; status;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *orig_str = loc_str;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *fixed_str = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Must never open default collator, because it depends on the environment<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and may change at <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> time. Should not happen, but check here to catch<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bugs that might be hard to catch otherwise.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NB: the default collator is not the same as the collator for the root<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * locale. The root locale may be specified as the empty string, &quot;und&quot;, or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &quot;root&quot;. The default collator is opened by passing NULL to ucol_open().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (loc_str == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;opening default collator is not supported&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In ICU versions 54 and earlier, &quot;und&quot; is not a recognized spelling of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the root locale. If the first component of the locale is &quot;und&quot;, replace<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with &quot;root&quot; <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> opening.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (U_ICU_VERSION_MAJOR_NUM &lt; <span class="Constant">55</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; lang[ULOC_LANG_CAPACITY];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; status = U_ZERO_ERROR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uloc_getLanguage(loc_str, lang, ULOC_LANG_CAPACITY, &amp;status);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (U_FAILURE(status) || status == U_STRING_NOT_TERMINATED_WARNING)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not get language from locale </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; loc_str, u_errorName(status))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(lang, <span class="Constant">&quot;und&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *remainder = loc_str + strlen(<span class="Constant">&quot;und&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fixed_str = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(strlen(<span class="Constant">&quot;root&quot;</span>) + strlen(remainder) + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strcpy(fixed_str, <span class="Constant">&quot;root&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strcat(fixed_str, remainder);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; loc_str = fixed_str;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; status = U_ZERO_ERROR;<br/></li>
<li>&nbsp; &nbsp; collator = ucol_open(loc_str, &amp;status);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (U_FAILURE(status))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* use original string for error report */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not open collator for locale </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; orig_str, u_errorName(status))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (U_ICU_VERSION_MAJOR_NUM &lt; <span class="Constant">54</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; status = U_ZERO_ERROR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2811" title="utils/adt/pg_locale.c:2811">icu_set_collation_attributes</a>(collator, loc_str, &amp;status);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Pretend the error came from ucol_open(), for consistent error<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * message across ICU versions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (U_FAILURE(status) || status == U_STRING_NOT_TERMINATED_WARNING)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ucol_close(collator);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not open collator for locale </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; orig_str, u_errorName(status))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fixed_str != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(fixed_str);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> collator;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2667">&#x200c;</a></span><span class="linkable">init_icu_converter</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *icu_encoding_name;<br/></li>
<li>&nbsp; &nbsp; UErrorCode&nbsp; &nbsp; status;<br/></li>
<li>&nbsp; &nbsp; UConverter *conv;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L147" title="utils/adt/pg_locale.c:147">icu_converter</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* already done */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; icu_encoding_name = get_encoding_name_for_icu(<a href="../mb/mbutils.c.html#L1261" title="utils/mb/mbutils.c:1261">GetDatabaseEncoding</a>());<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!icu_encoding_name)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;encoding </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> not supported by ICU&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_encoding_to_char(<a href="../mb/mbutils.c.html#L1261" title="utils/mb/mbutils.c:1261">GetDatabaseEncoding</a>()))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; status = U_ZERO_ERROR;<br/></li>
<li>&nbsp; &nbsp; conv = ucnv_open(icu_encoding_name, &amp;status);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (U_FAILURE(status))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not open ICU converter for encoding </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; icu_encoding_name, u_errorName(status))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L147" title="utils/adt/pg_locale.c:147">icu_converter</a> = conv;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Find length, in UChars, of given string if converted to UChar string.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">size_t<br/></li>
<li><a id="L2697">&#x200c;</a></span><span class="linkable">uchar_length</span>(UConverter *converter, <span class="Type">const</span> <span class="Type">char</span> *str, <span class="Type">int32_t</span> len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; UErrorCode&nbsp; &nbsp; status = U_ZERO_ERROR;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int32_t</span>&nbsp; &nbsp; &nbsp; &nbsp; ulen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ulen = ucnv_toUChars(converter, <span class="Constant">NULL</span>, <span class="Constant">0</span>, str, len, &amp;status);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (U_FAILURE(status) &amp;&amp; status != U_BUFFER_OVERFLOW_ERROR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> failed: </span><span class="Special">%s</span><span class="Constant">&quot;</span>, <span class="Constant">&quot;ucnv_toUChars&quot;</span>, u_errorName(status))));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ulen;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert the given source string into a UChar string, stored in dest, and<br/></li>
<li></span><span class="Comment"> * return the length (in UChars).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int32_t<br/></li>
<li><a id="L2714">&#x200c;</a></span><span class="linkable">uchar_convert</span>(UConverter *converter, UChar *dest, <span class="Type">int32_t</span> destlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *src, <span class="Type">int32_t</span> srclen)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; UErrorCode&nbsp; &nbsp; status = U_ZERO_ERROR;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int32_t</span>&nbsp; &nbsp; &nbsp; &nbsp; ulen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; status = U_ZERO_ERROR;<br/></li>
<li>&nbsp; &nbsp; ulen = ucnv_toUChars(converter, dest, destlen, src, srclen, &amp;status);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (U_FAILURE(status))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> failed: </span><span class="Special">%s</span><span class="Constant">&quot;</span>, <span class="Constant">&quot;ucnv_toUChars&quot;</span>, u_errorName(status))));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ulen;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert a string in the database encoding into a string of UChars.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The source string at buff is of length nbytes<br/></li>
<li></span><span class="Comment"> * (it needn't be nul-terminated)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * *buff_uchar receives a pointer to the <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d result string, and<br/></li>
<li></span><span class="Comment"> * the function's result is the number of UChars generated.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The result string is nul-terminated, though most callers rely on the<br/></li>
<li></span><span class="Comment"> * result length instead.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int32_t<br/></li>
<li><a id="L2741">&#x200c;</a></span><span class="linkable">icu_to_uchar</span>(UChar **buff_uchar, <span class="Type">const</span> <span class="Type">char</span> *buff, <span class="Type">size_t</span> nbytes)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int32_t</span>&nbsp; &nbsp; &nbsp; &nbsp; len_uchar;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2667" title="utils/adt/pg_locale.c:2667">init_icu_converter</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len_uchar = <a href="#L2697" title="utils/adt/pg_locale.c:2697">uchar_length</a>(<a href="#L147" title="utils/adt/pg_locale.c:147">icu_converter</a>, buff, nbytes);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *buff_uchar = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>((len_uchar + <span class="Constant">1</span>) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(**buff_uchar));<br/></li>
<li>&nbsp; &nbsp; len_uchar = <a href="#L2714" title="utils/adt/pg_locale.c:2714">uchar_convert</a>(<a href="#L147" title="utils/adt/pg_locale.c:147">icu_converter</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *buff_uchar, len_uchar + <span class="Constant">1</span>, buff, nbytes);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> len_uchar;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert a string of UChars into the database encoding.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The source string at buff_uchar is of length len_uchar<br/></li>
<li></span><span class="Comment"> * (it needn't be nul-terminated)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * *result receives a pointer to the <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d result string, and the<br/></li>
<li></span><span class="Comment"> * function's result is the number of bytes generated (not counting nul).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The result string is nul-terminated.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int32_t<br/></li>
<li><a id="L2768">&#x200c;</a></span><span class="linkable">icu_from_uchar</span>(<span class="Type">char</span> **result, <span class="Type">const</span> UChar *buff_uchar, <span class="Type">int32_t</span> len_uchar)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; UErrorCode&nbsp; &nbsp; status;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int32_t</span>&nbsp; &nbsp; &nbsp; &nbsp; len_result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2667" title="utils/adt/pg_locale.c:2667">init_icu_converter</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; status = U_ZERO_ERROR;<br/></li>
<li>&nbsp; &nbsp; len_result = ucnv_fromUChars(<a href="#L147" title="utils/adt/pg_locale.c:147">icu_converter</a>, <span class="Constant">NULL</span>, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; buff_uchar, len_uchar, &amp;status);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (U_FAILURE(status) &amp;&amp; status != U_BUFFER_OVERFLOW_ERROR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> failed: </span><span class="Special">%s</span><span class="Constant">&quot;</span>, <span class="Constant">&quot;ucnv_fromUChars&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; u_errorName(status))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *result = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(len_result + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; status = U_ZERO_ERROR;<br/></li>
<li>&nbsp; &nbsp; len_result = ucnv_fromUChars(<a href="#L147" title="utils/adt/pg_locale.c:147">icu_converter</a>, *result, len_result + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; buff_uchar, len_uchar, &amp;status);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (U_FAILURE(status) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; status == U_STRING_NOT_TERMINATED_WARNING)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> failed: </span><span class="Special">%s</span><span class="Constant">&quot;</span>, <span class="Constant">&quot;ucnv_fromUChars&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; u_errorName(status))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> len_result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Parse collation attributes from the given locale string and apply them to<br/></li>
<li></span><span class="Comment"> * the open collator.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * First, the locale string is canonicalized to an ICU format locale ID such<br/></li>
<li></span><span class="Comment"> * as &quot;und@colStrength=primary;colCaseLevel=yes&quot;. Then, it parses and applies<br/></li>
<li></span><span class="Comment"> * the key-value arguments.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Starting with ICU version 54, the attributes are processed automatically by<br/></li>
<li></span><span class="Comment"> * ucol_open(), so this is only necessary for emulating this behavior on older<br/></li>
<li></span><span class="Comment"> * versions.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>pg_attribute_unused()<br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2811">&#x200c;</a></span><span class="linkable">icu_set_collation_attributes</span>(UCollator *collator, <span class="Type">const</span> <span class="Type">char</span> *loc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; UErrorCode *status)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int32_t</span>&nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *icu_locale_id;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *lower_str;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *str;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The input locale may be a BCP 47 language tag, e.g.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &quot;und-u-kc-ks-level1&quot;, which expresses the same attributes in a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * different form. It will be converted to the equivalent ICU format<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * locale ID, e.g. &quot;und@colcaselevel=yes;colstrength=primary&quot;, by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * uloc_canonicalize().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; *status = U_ZERO_ERROR;<br/></li>
<li>&nbsp; &nbsp; len = uloc_canonicalize(loc, <span class="Constant">NULL</span>, <span class="Constant">0</span>, status);<br/></li>
<li>&nbsp; &nbsp; icu_locale_id = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(len + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; *status = U_ZERO_ERROR;<br/></li>
<li>&nbsp; &nbsp; len = uloc_canonicalize(loc, icu_locale_id, len + <span class="Constant">1</span>, status);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (U_FAILURE(*status) || *status == U_STRING_NOT_TERMINATED_WARNING)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; lower_str = <a href="formatting.c.html#L2158" title="utils/adt/formatting.c:2158">asc_tolower</a>(icu_locale_id, strlen(icu_locale_id));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(icu_locale_id);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; str = strchr(lower_str, <span class="Constant">'@'</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!str)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; str++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">char</span> *token = strtok(str, <span class="Constant">&quot;;&quot;</span>); token; token = strtok(<span class="Constant">NULL</span>, <span class="Constant">&quot;;&quot;</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *e = strchr(token, <span class="Constant">'='</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (e)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *name;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *value;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UColAttribute uattr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UColAttributeValue uvalue;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *status = U_ZERO_ERROR;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *e = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name = token;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value = e + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * See attribute name and value lists in ICU i18n/coll.cpp<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(name, <span class="Constant">&quot;colstrength&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uattr = UCOL_STRENGTH;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(name, <span class="Constant">&quot;colbackwards&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uattr = UCOL_FRENCH_COLLATION;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(name, <span class="Constant">&quot;colcaselevel&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uattr = UCOL_CASE_LEVEL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(name, <span class="Constant">&quot;colcasefirst&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uattr = UCOL_CASE_FIRST;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(name, <span class="Constant">&quot;colalternate&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uattr = UCOL_ALTERNATE_HANDLING;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(name, <span class="Constant">&quot;colnormalization&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uattr = UCOL_NORMALIZATION_MODE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(name, <span class="Constant">&quot;colnumeric&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uattr = UCOL_NUMERIC_COLLATION;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ignore if unknown */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(value, <span class="Constant">&quot;primary&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uvalue = UCOL_PRIMARY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(value, <span class="Constant">&quot;secondary&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uvalue = UCOL_SECONDARY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(value, <span class="Constant">&quot;tertiary&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uvalue = UCOL_TERTIARY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(value, <span class="Constant">&quot;quaternary&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uvalue = UCOL_QUATERNARY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(value, <span class="Constant">&quot;identical&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uvalue = UCOL_IDENTICAL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(value, <span class="Constant">&quot;no&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uvalue = UCOL_OFF;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(value, <span class="Constant">&quot;yes&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uvalue = UCOL_ON;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(value, <span class="Constant">&quot;shifted&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uvalue = UCOL_SHIFTED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(value, <span class="Constant">&quot;non-ignorable&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uvalue = UCOL_NON_IGNORABLE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(value, <span class="Constant">&quot;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uvalue = UCOL_LOWER_FIRST;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(value, <span class="Constant">&quot;<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uvalue = UCOL_UPPER_FIRST;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *status = U_ILLEGAL_ARGUMENT_ERROR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ucol_setAttribute(collator, uattr, uvalue, status);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(lower_str);<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the BCP47 language tag representation of the requested locale.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function should be called <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> passing the string to ucol_open(),<br/></li>
<li></span><span class="Comment"> * because conversion to a language tag also performs &quot;level 2<br/></li>
<li></span><span class="Comment"> * canonicalization&quot;. In addition to producing a consistent format, level 2<br/></li>
<li></span><span class="Comment"> * canonicalization is able to more accurately interpret different input<br/></li>
<li></span><span class="Comment"> * locale string formats, such as POSIX and .NET IDs.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L2927">&#x200c;</a><span class="linkable">icu_language_tag</span>(<span class="Type">const</span> <span class="Type">char</span> *loc_str, <span class="Type">int</span> elevel)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef USE_ICU<br/></li>
<li></span>&nbsp; &nbsp; UErrorCode&nbsp; &nbsp; status;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *langtag;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; buflen = <span class="Constant">32</span>;&nbsp; &nbsp; <span class="Comment">/* arbitrary starting buffer size */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; strict = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * A BCP47 language tag doesn't have a clearly-defined <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> limit (cf.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * RFC5646 section 4.4). Additionally, in older ICU versions,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * uloc_toLanguageTag() doesn't always return the ultimate length on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * first call, necessitating a loop.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; langtag = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(buflen);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<span class="Constant">true</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; status = U_ZERO_ERROR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uloc_toLanguageTag(loc_str, langtag, buflen, strict, &amp;status);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* try again if the buffer is not large enough */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((status == U_BUFFER_OVERFLOW_ERROR ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; status == U_STRING_NOT_TERMINATED_WARNING) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buflen &lt; MaxAllocSize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buflen = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(buflen * <span class="Constant">2</span>, MaxAllocSize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; langtag = <a href="../mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(langtag, buflen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (U_FAILURE(status))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(langtag);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (elevel &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not convert locale name </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> to language tag: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; loc_str, u_errorName(status))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> langtag;<br/></li>
<li><span class="PreProc">#else</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not USE_ICU */<br/></li>
<li></span>&nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;ICU is not supported in this build&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not USE_ICU */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Perform best-effort check that the locale is a valid one.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2984">&#x200c;</a></span><span class="linkable">icu_validate_locale</span>(<span class="Type">const</span> <span class="Type">char</span> *loc_str)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef USE_ICU<br/></li>
<li></span>&nbsp; &nbsp; UCollator&nbsp; *collator;<br/></li>
<li>&nbsp; &nbsp; UErrorCode&nbsp; &nbsp; status;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; lang[ULOC_LANG_CAPACITY];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elevel = <a href="#L102" title="utils/adt/pg_locale.c:102">icu_validation_level</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* no validation */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (elevel &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* downgrade to WARNING during pg_upgrade */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../init/globals.c.html#L118" title="utils/init/globals.c:118">IsBinaryUpgrade</a> &amp;&amp; elevel &gt; WARNING)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elevel = WARNING;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* validate that we can extract the language */<br/></li>
<li></span>&nbsp; &nbsp; status = U_ZERO_ERROR;<br/></li>
<li>&nbsp; &nbsp; uloc_getLanguage(loc_str, lang, ULOC_LANG_CAPACITY, &amp;status);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (U_FAILURE(status) || status == U_STRING_NOT_TERMINATED_WARNING)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not get language from ICU locale </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; loc_str, u_errorName(status)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;To disable ICU locale validation, set the parameter </span><span class="Special">%s</span><span class="Constant"> to </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;<a href="#L102" title="utils/adt/pg_locale.c:102">icu_validation_level</a>&quot;</span>, <span class="Constant">&quot;disabled&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check for special language name */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (strcmp(lang, <span class="Constant">&quot;&quot;</span>) == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; strcmp(lang, <span class="Constant">&quot;root&quot;</span>) == <span class="Constant">0</span> || strcmp(lang, <span class="Constant">&quot;und&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* search for matching language within ICU */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int32_t</span> i = <span class="Constant">0</span>; !found &amp;&amp; i &lt; uloc_countAvailable(); i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *otherloc = uloc_getAvailable(i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; otherlang[ULOC_LANG_CAPACITY];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; status = U_ZERO_ERROR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uloc_getLanguage(otherloc, otherlang, ULOC_LANG_CAPACITY, &amp;status);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (U_FAILURE(status) || status == U_STRING_NOT_TERMINATED_WARNING)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(lang, otherlang) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;ICU locale </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> has unknown language </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; loc_str, lang),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;To disable ICU locale validation, set the parameter </span><span class="Special">%s</span><span class="Constant"> to </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;<a href="#L102" title="utils/adt/pg_locale.c:102">icu_validation_level</a>&quot;</span>, <span class="Constant">&quot;disabled&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check that it can be opened */<br/></li>
<li></span>&nbsp; &nbsp; collator = <a href="#L2585" title="utils/adt/pg_locale.c:2585">pg_ucol_open</a>(loc_str);<br/></li>
<li>&nbsp; &nbsp; ucol_close(collator);<br/></li>
<li><span class="PreProc">#else</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not USE_ICU */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* could get here if a collation was created by a build with ICU */<br/></li>
<li></span>&nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;ICU is not supported in this build&quot;</span>)));<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not USE_ICU */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * These <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> convert from/to libc's wchar_t, *not* pg_wchar_t.<br/></li>
<li></span><span class="Comment"> * Therefore we keep them here rather than with the mbutils code.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3065" title="utils/adt/pg_locale.c:3065">wchar2char</a> --- convert wide characters to multibyte format<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This has the same API as the standard <a href="#L182" title="utils/adt/pg_locale.c:182">wcstombs_l</a>() function; in particular,<br/></li>
<li></span><span class="Comment"> * tolen is the maximum number of bytes to store at *to, and *from must be<br/></li>
<li></span><span class="Comment"> * zero-terminated.&nbsp; The output will be zero-terminated iff there is room.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">size_t<br/></li>
<li><a id="L3065">&#x200c;</a></span><span class="linkable">wchar2char</span>(<span class="Type">char</span> *to, <span class="Type">const</span> <span class="Type">wchar_t</span> *from, <span class="Type">size_t</span> tolen, pg_locale_t locale)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!locale || locale-&gt;<a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a> == COLLPROVIDER_LIBC);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tolen == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef WIN32<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * On Windows, the &quot;Unicode&quot; locales assume UTF16 not UTF8 encoding, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for some reason mbstowcs and wcstombs won't do this for us, so we use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * MultiByteToWideChar().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../mb/mbutils.c.html#L1261" title="utils/mb/mbutils.c:1261">GetDatabaseEncoding</a>() == PG_UTF8)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = WideCharToMultiByte(CP_UTF8, <span class="Constant">0</span>, from, -<span class="Constant">1</span>, to, tolen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* A zero return is failure */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(result &lt;= tolen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Microsoft counts the zero terminator in the result */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* WIN32 */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (locale == (pg_locale_t) <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Use wcstombs directly for the default locale */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = wcstombs(to, from, tolen);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Use <a href="#L182" title="utils/adt/pg_locale.c:182">wcstombs_l</a> for nondefault locales */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L182" title="utils/adt/pg_locale.c:182">wcstombs_l</a>(to, from, tolen, locale-&gt;info.lt);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3121" title="utils/adt/pg_locale.c:3121">char2wchar</a> --- convert multibyte characters to wide characters<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This has almost the API of <a href="#L166" title="utils/adt/pg_locale.c:166">mbstowcs_l</a>(), except that *from need not be<br/></li>
<li></span><span class="Comment"> * null-terminated; instead, the number of input bytes is specified as<br/></li>
<li></span><span class="Comment"> * fromlen.&nbsp; Also, we ereport() rather than returning -1 for invalid<br/></li>
<li></span><span class="Comment"> * input encoding.&nbsp; tolen is the maximum number of wchar_t's to store at *to.<br/></li>
<li></span><span class="Comment"> * The output will be zero-terminated iff there is room.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">size_t<br/></li>
<li><a id="L3121">&#x200c;</a></span><span class="linkable">char2wchar</span>(<span class="Type">wchar_t</span> *to, <span class="Type">size_t</span> tolen, <span class="Type">const</span> <span class="Type">char</span> *from, <span class="Type">size_t</span> fromlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pg_locale_t locale)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!locale || locale-&gt;<a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a> == COLLPROVIDER_LIBC);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tolen == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef WIN32<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* See WIN32 &quot;Unicode&quot; comment above */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../mb/mbutils.c.html#L1261" title="utils/mb/mbutils.c:1261">GetDatabaseEncoding</a>() == PG_UTF8)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Win32 API does not work for zero-length input */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fromlen == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = MultiByteToWideChar(CP_UTF8, <span class="Constant">0</span>, from, fromlen, to, tolen - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* A zero return is failure */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result != -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(result &lt; tolen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Append trailing null wchar (MultiByteToWideChar() does not) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; to[result] = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* WIN32 */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* mbstowcs requires ending '\0' */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *str = <a href="../mmgr/mcxt.c.html#L1706" title="utils/mmgr/mcxt.c:1706">pnstrdup</a>(from, fromlen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (locale == (pg_locale_t) <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Use mbstowcs directly for the default locale */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = mbstowcs(to, str, tolen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Use <a href="#L166" title="utils/adt/pg_locale.c:166">mbstowcs_l</a> for nondefault locales */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L166" title="utils/adt/pg_locale.c:166">mbstowcs_l</a>(to, str, tolen, locale-&gt;info.lt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(str);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Invalid multibyte character encountered.&nbsp; We try to give a useful<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * error message by letting <a href="../mb/mbutils.c.html#L1556" title="utils/mb/mbutils.c:1556">pg_verifymbstr</a> check the string.&nbsp; But it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * possible that the string is OK to us, and not OK to mbstowcs ---<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this suggests that the LC_CTYPE locale is different from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * database encoding.&nbsp; Give a generic error message if <a href="../mb/mbutils.c.html#L1556" title="utils/mb/mbutils.c:1556">pg_verifymbstr</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can't <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> anything wrong.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mb/mbutils.c.html#L1556" title="utils/mb/mbutils.c:1556">pg_verifymbstr</a>(from, fromlen, <span class="Constant">false</span>);&nbsp; &nbsp; <span class="Comment">/* might not return */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* but if it does ... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_CHARACTER_NOT_IN_REPERTOIRE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid multibyte character for locale&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;The server's LC_CTYPE locale is probably incompatible with the database encoding.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
