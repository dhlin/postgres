<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/adt/jsonb_gin.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/adt/jsonb_gin.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L80">GinEntries</a></li>
<li><a href="#L85">GinEntries</a></li>
<li><a href="#L134">JsonPathGinAddPathItemFunc</a></li>
<li><a href="#L131">JsonPathGinContext</a></li>
<li><a href="#L147">JsonPathGinContext</a></li>
<li><a href="#L141">JsonPathGinExtractNodesFunc</a></li>
<li><a href="#L94">JsonPathGinNode</a></li>
<li><a href="#L97">JsonPathGinNode</a></li>
<li><a href="#L87">JsonPathGinNodeType</a></li>
<li><a href="#L92">JsonPathGinNodeType</a></li>
<li><a href="#L125">JsonPathGinPath</a></li>
<li><a href="#L129">JsonPathGinPath</a></li>
<li><a href="#L117">JsonPathGinPathItem</a></li>
<li><a href="#L122">JsonPathGinPathItem</a></li>
<li><a href="#L73">PathHashStack</a></li>
<li><a href="#L77">PathHashStack</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L172">add_gin_entry</a></li>
<li><a href="#L719">emit_jsp_gin_entries</a></li>
<li><a href="#L799">execute_jsp_gin_node</a></li>
<li><a href="#L583">extract_jsp_bool_expr</a></li>
<li><a href="#L564">extract_jsp_path_expr</a></li>
<li><a href="#L504">extract_jsp_path_expr_nodes</a></li>
<li><a href="#L748">extract_jsp_query</a></li>
<li><a href="#L203">gin_compare_jsonb</a></li>
<li><a href="#L929">gin_consistent_jsonb</a></li>
<li><a href="#L1220">gin_consistent_jsonb_path</a></li>
<li><a href="#L229">gin_extract_jsonb</a></li>
<li><a href="#L1090">gin_extract_jsonb_path</a></li>
<li><a href="#L848">gin_extract_jsonb_query</a></li>
<li><a href="#L1180">gin_extract_jsonb_query_path</a></li>
<li><a href="#L1013">gin_triconsistent_jsonb</a></li>
<li><a href="#L1272">gin_triconsistent_jsonb_path</a></li>
<li><a href="#L163">init_gin_entries</a></li>
<li><a href="#L278">jsonb_ops__add_path_item</a></li>
<li><a href="#L408">jsonb_ops__extract_nodes</a></li>
<li><a href="#L323">jsonb_path_ops__add_path_item</a></li>
<li><a href="#L478">jsonb_path_ops__extract_nodes</a></li>
<li><a href="#L353">make_jsp_entry_node</a></li>
<li><a href="#L364">make_jsp_entry_node_scalar</a></li>
<li><a href="#L370">make_jsp_expr_node</a></li>
<li><a href="#L382">make_jsp_expr_node_args</a></li>
<li><a href="#L395">make_jsp_expr_node_binary</a></li>
<li><a href="#L1364">make_scalar_key</a></li>
<li><a href="#L1326">make_text_key</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * jsonb_gin.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; GIN support <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for jsonb<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Copyright (c) 2014-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We provide two opclasses for jsonb indexing: jsonb_ops and jsonb_path_ops.<br/></li>
<li></span><span class="Comment"> * For their description see json.sgml and comments in jsonb.h.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The operators support, among the others, &quot;jsonb @? jsonpath&quot; and<br/></li>
<li></span><span class="Comment"> * &quot;jsonb @@ jsonpath&quot;.&nbsp; Expressions containing these operators are easily<br/></li>
<li></span><span class="Comment"> * expressed through each other.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; jb @? 'path' &lt;=&gt; jb @@ 'EXISTS(path)'<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; jb @@ 'expr' &lt;=&gt; jb @? '$ ? (expr)'<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Thus, we're going to consider only @@ operator, while regarding @? operator<br/></li>
<li></span><span class="Comment"> * the same is true for jb @@ 'EXISTS(path)'.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Result of jsonpath query extraction is a tree, which leaf nodes are index<br/></li>
<li></span><span class="Comment"> * entries and non-leaf nodes are AND/OR logical expressions.&nbsp; Basically we<br/></li>
<li></span><span class="Comment"> * extract following statements out of jsonpath:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; 1) &quot;accessors_chain = const&quot;,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; 2) &quot;EXISTS(accessors_chain)&quot;.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Accessors chain may consist of .key, [*] and [index] accessors.&nbsp; jsonb_ops<br/></li>
<li></span><span class="Comment"> * additionally supports .* and .**.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, both jsonb_ops and jsonb_path_ops supports only statements of<br/></li>
<li></span><span class="Comment"> * the 1st <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a>.&nbsp; jsonb_ops might also support statements of the 2nd kind,<br/></li>
<li></span><span class="Comment"> * but given we have no statistics keys extracted from accessors chain<br/></li>
<li></span><span class="Comment"> * are likely non-selective.&nbsp; Therefore, we choose to not confuse optimizer<br/></li>
<li></span><span class="Comment"> * and <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> statements of the 2nd kind altogether.&nbsp; In future versions that<br/></li>
<li></span><span class="Comment"> * might be changed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In jsonb_ops statement of the 1st kind is split into expression of AND'ed<br/></li>
<li></span><span class="Comment"> * keys and const.&nbsp; Sometimes const might be interpreted as both value or key<br/></li>
<li></span><span class="Comment"> * in jsonb_ops.&nbsp; Then statement of 1st kind is decomposed into the expression<br/></li>
<li></span><span class="Comment"> * below.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; key1 AND key2 AND ... AND keyN AND (const_as_value OR const_as_key)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * jsonb_path_ops transforms each statement of the 1st kind into single <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a><br/></li>
<li></span><span class="Comment"> * entry below.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="../../regex/regexec.c.html#L49" title="regex/regexec.c:49">HASH</a>(key1, key2, ... , keyN, const)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Despite statements of the 2nd kind are not supported by both jsonb_ops and<br/></li>
<li></span><span class="Comment"> * jsonb_path_ops, EXISTS(path) expressions might be still supported,<br/></li>
<li></span><span class="Comment"> * when statements of 1st kind could be extracted out of their filters.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/adt/jsonb_gin.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/gin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/stratnum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_collation.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/hashfn.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgrprotos.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/jsonb.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/jsonpath.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/varlena.h&quot;<br/></li>
<li></span><br/></li>
<li><a id="L73">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">PathHashStack</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L73" title="utils/adt/jsonb_gin.c:73">PathHashStack</a> *parent;<br/></li>
<li><a id="L77">&#x200c;</a>} <span class="linkable">PathHashStack</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Buffer for GIN entries */<br/></li>
<li><a id="L80">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">GinEntries</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *buf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; allocated;<br/></li>
<li><a id="L85">&#x200c;</a>} <span class="linkable">GinEntries</span>;<br/></li>
<li><br/></li>
<li><a id="L87">&#x200c;</a><span class="Type">typedef</span> <span class="Type">enum</span> <span class="linkable">JsonPathGinNodeType</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JSP_GIN_OR,<br/></li>
<li>&nbsp; &nbsp; JSP_GIN_AND,<br/></li>
<li>&nbsp; &nbsp; JSP_GIN_ENTRY,<br/></li>
<li><a id="L92">&#x200c;</a>} <span class="linkable">JsonPathGinNodeType</span>;<br/></li>
<li><br/></li>
<li><a id="L94">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">JsonPathGinNode</span> <span class="linkable">JsonPathGinNode</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Node in jsonpath expression tree */<br/></li>
<li><a id="L97">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">JsonPathGinNode</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L87" title="utils/adt/jsonb_gin.c:87">JsonPathGinNodeType</a> type;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">union<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nargs;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* valid for OR and AND nodes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entryIndex; <span class="Comment">/* index in <a href="#L80" title="utils/adt/jsonb_gin.c:80">GinEntries</a> array, valid for ENTRY<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * nodes after entries output */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; entryDatum; <span class="Comment">/* path <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> or key name/scalar, valid for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ENTRY nodes <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> entries output */<br/></li>
<li></span>&nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li>&nbsp; &nbsp; <a href="#L97" title="utils/adt/jsonb_gin.c:97">JsonPathGinNode</a> *args[FLEXIBLE_ARRAY_MEMBER];&nbsp; &nbsp; <span class="Comment">/* valid for OR and AND<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * nodes */<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * jsonb_ops entry extracted from jsonpath item.&nbsp; Corresponding path item<br/></li>
<li></span><span class="Comment"> * may be: '.key', '.*', '.**', '[index]' or '[*]'.<br/></li>
<li></span><span class="Comment"> * Entry type is stored in 'type' field.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L117">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">JsonPathGinPathItem</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L117" title="utils/adt/jsonb_gin.c:117">JsonPathGinPathItem</a> *parent;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; keyName;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* key name (for '.key' path item) or NULL */<br/></li>
<li></span>&nbsp; &nbsp; JsonPathItemType type;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* type of jsonpath item */<br/></li>
<li><a id="L122">&#x200c;</a></span>} <span class="linkable">JsonPathGinPathItem</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* GIN representation of the extracted json path */<br/></li>
<li><a id="L125">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">union</span> <span class="linkable">JsonPathGinPath</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L117" title="utils/adt/jsonb_gin.c:117">JsonPathGinPathItem</a> *items; <span class="Comment">/* list of path items (jsonb_ops) */<br/></li>
<li></span>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> of the path (jsonb_path_ops) */<br/></li>
<li><a id="L129">&#x200c;</a></span>} <span class="linkable">JsonPathGinPath</span>;<br/></li>
<li><br/></li>
<li><a id="L131">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">JsonPathGinContext</span> <span class="linkable">JsonPathGinContext</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Callback, which stores information about path item into <a href="#L125" title="utils/adt/jsonb_gin.c:125">JsonPathGinPath</a> */<br/></li>
<li><a id="L134">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> (*<span class="linkable">JsonPathGinAddPathItemFunc</span>) (<a href="#L125" title="utils/adt/jsonb_gin.c:125">JsonPathGinPath</a> *path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JsonPathItem *jsp);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Callback, which extracts set of nodes from statement of 1st kind<br/></li>
<li></span><span class="Comment"> * (scalar != NULL) or statement of 2nd kind (scalar == NULL).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L141">&#x200c;</a></span><span class="Type">typedef</span> List *(*<span class="linkable">JsonPathGinExtractNodesFunc</span>) (<a href="#L147" title="utils/adt/jsonb_gin.c:147">JsonPathGinContext</a> *cxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L125" title="utils/adt/jsonb_gin.c:125">JsonPathGinPath</a> path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JsonbValue *scalar,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *nodes);<br/></li>
<li><br/></li>
<li><span class="Comment">/* Context for jsonpath entries extraction */<br/></li>
<li><a id="L147">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">JsonPathGinContext</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L134" title="utils/adt/jsonb_gin.c:134">JsonPathGinAddPathItemFunc</a> add_path_item;<br/></li>
<li>&nbsp; &nbsp; <a href="#L141" title="utils/adt/jsonb_gin.c:141">JsonPathGinExtractNodesFunc</a> extract_nodes;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; lax;<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><span class="Type">static</span> Datum <a href="#L1326" title="utils/adt/jsonb_gin.c:1326">make_text_key</a>(<span class="Type">char</span> flag, <span class="Type">const</span> <span class="Type">char</span> *str, <span class="Type">int</span> len);<br/></li>
<li><span class="Type">static</span> Datum <a href="#L1364" title="utils/adt/jsonb_gin.c:1364">make_scalar_key</a>(<span class="Type">const</span> JsonbValue *scalarVal, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_key);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <a href="#L97" title="utils/adt/jsonb_gin.c:97">JsonPathGinNode</a> *<a href="#L583" title="utils/adt/jsonb_gin.c:583">extract_jsp_bool_expr</a>(<a href="#L147" title="utils/adt/jsonb_gin.c:147">JsonPathGinContext</a> *cxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L125" title="utils/adt/jsonb_gin.c:125">JsonPathGinPath</a> path, JsonPathItem *jsp, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> not);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* Initialize <a href="#L80" title="utils/adt/jsonb_gin.c:80">GinEntries</a> struct */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L163">&#x200c;</a></span><span class="linkable">init_gin_entries</span>(<a href="#L80" title="utils/adt/jsonb_gin.c:80">GinEntries</a> *entries, <span class="Type">int</span> preallocated)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; entries-&gt;allocated = preallocated;<br/></li>
<li>&nbsp; &nbsp; entries-&gt;buf = preallocated ? <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum) * preallocated) : <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; entries-&gt;count = <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Add new entry to <a href="#L80" title="utils/adt/jsonb_gin.c:80">GinEntries</a> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L172">&#x200c;</a></span><span class="linkable">add_gin_entry</span>(<a href="#L80" title="utils/adt/jsonb_gin.c:80">GinEntries</a> *entries, Datum entry)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; id = entries-&gt;count;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (entries-&gt;count &gt;= entries-&gt;allocated)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (entries-&gt;allocated)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entries-&gt;allocated *= <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entries-&gt;buf = <a href="../mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(entries-&gt;buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum) * entries-&gt;allocated);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entries-&gt;allocated = <span class="Constant">8</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entries-&gt;buf = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum) * entries-&gt;allocated);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; entries-&gt;buf[entries-&gt;count++] = entry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> id;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * jsonb_ops GIN opclass support <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L203">&#x200c;</a><span class="linkable">gin_compare_jsonb</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *arg1 = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *arg2 = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *a1p,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *a2p;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; a1p = VARDATA_ANY(arg1);<br/></li>
<li>&nbsp; &nbsp; a2p = VARDATA_ANY(arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len1 = VARSIZE_ANY_EXHDR(arg1);<br/></li>
<li>&nbsp; &nbsp; len2 = VARSIZE_ANY_EXHDR(arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Compare text as <a href="varlena.c.html#L1831" title="utils/adt/varlena.c:1831">bttextcmp</a> does, but always using C collation */<br/></li>
<li></span>&nbsp; &nbsp; result = <a href="varlena.c.html#L1539" title="utils/adt/varlena.c:1539">varstr_cmp</a>(a1p, len1, a2p, len2, C_COLLATION_OID);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg2, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L229">&#x200c;</a><span class="linkable">gin_extract_jsonb</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Jsonb&nbsp; &nbsp; &nbsp;&nbsp; *jb = (Jsonb *) PG_GETARG_JSONB_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp;&nbsp; *nentries = (int32 *) PG_GETARG_POINTER(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; total = JB_ROOT_COUNT(jb);<br/></li>
<li>&nbsp; &nbsp; JsonbIterator *it;<br/></li>
<li>&nbsp; &nbsp; JsonbValue&nbsp; &nbsp; v;<br/></li>
<li>&nbsp; &nbsp; JsonbIteratorToken r;<br/></li>
<li>&nbsp; &nbsp; <a href="#L80" title="utils/adt/jsonb_gin.c:80">GinEntries</a>&nbsp; &nbsp; entries;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If the root level is empty, we certainly have no keys */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (total == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *nentries = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_POINTER(<span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Otherwise, use 2 * root count as initial estimate of result size */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L163" title="utils/adt/jsonb_gin.c:163">init_gin_entries</a>(&amp;entries, <span class="Constant">2</span> * total);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; it = <a href="jsonb_util.c.html#L817" title="utils/adt/jsonb_util.c:817">JsonbIteratorInit</a>(&amp;jb-&gt;root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((r = <a href="jsonb_util.c.html#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a>(&amp;it, &amp;v, <span class="Constant">false</span>)) != WJB_DONE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (r)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WJB_KEY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L172" title="utils/adt/jsonb_gin.c:172">add_gin_entry</a>(&amp;entries, <a href="#L1364" title="utils/adt/jsonb_gin.c:1364">make_scalar_key</a>(&amp;v, <span class="Constant">true</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WJB_ELEM:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Pretend string array elements are keys, see jsonb.h */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L172" title="utils/adt/jsonb_gin.c:172">add_gin_entry</a>(&amp;entries, <a href="#L1364" title="utils/adt/jsonb_gin.c:1364">make_scalar_key</a>(&amp;v, v.type == jbvString));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WJB_VALUE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L172" title="utils/adt/jsonb_gin.c:172">add_gin_entry</a>(&amp;entries, <a href="#L1364" title="utils/adt/jsonb_gin.c:1364">make_scalar_key</a>(&amp;v, <span class="Constant">false</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we can ignore structural items */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *nentries = entries.count;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(entries.buf);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Append <a href="#L117" title="utils/adt/jsonb_gin.c:117">JsonPathGinPathItem</a> to <a href="#L125" title="utils/adt/jsonb_gin.c:125">JsonPathGinPath</a> (jsonb_ops) */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L278">&#x200c;</a></span><span class="linkable">jsonb_ops__add_path_item</span>(<a href="#L125" title="utils/adt/jsonb_gin.c:125">JsonPathGinPath</a> *path, JsonPathItem *jsp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L117" title="utils/adt/jsonb_gin.c:117">JsonPathGinPathItem</a> *pentry;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; keyName;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (jsp-&gt;type)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jpiRoot:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path-&gt;items = <span class="Constant">NULL</span>; <span class="Comment">/* reset path */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jpiKey:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *key = <a href="jsonpath.c.html#L1219" title="utils/adt/jsonpath.c:1219">jspGetString</a>(jsp, &amp;len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keyName = <a href="#L1326" title="utils/adt/jsonb_gin.c:1326">make_text_key</a>(JGINFLAG_KEY, key, len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jpiAny:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jpiAnyKey:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jpiAnyArray:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jpiIndexArray:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keyName = PointerGetDatum(<span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* other path items like item methods are not supported */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pentry = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(*pentry));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pentry-&gt;type = jsp-&gt;type;<br/></li>
<li>&nbsp; &nbsp; pentry-&gt;keyName = keyName;<br/></li>
<li>&nbsp; &nbsp; pentry-&gt;parent = path-&gt;items;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; path-&gt;items = pentry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Combine existing path <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> with <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> key <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> (jsonb_path_ops) */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L323">&#x200c;</a></span><span class="linkable">jsonb_path_ops__add_path_item</span>(<a href="#L125" title="utils/adt/jsonb_gin.c:125">JsonPathGinPath</a> *path, JsonPathItem *jsp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (jsp-&gt;type)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jpiRoot:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path-&gt;<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* reset path <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jpiKey:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JsonbValue&nbsp; &nbsp; jbv;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jbv.type = jbvString;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jbv.val.string.val = <a href="jsonpath.c.html#L1219" title="utils/adt/jsonpath.c:1219">jspGetString</a>(jsp, &amp;jbv.val.string.len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="jsonb_util.c.html#L1316" title="utils/adt/jsonb_util.c:1316">JsonbHashScalarValue</a>(&amp;jbv, &amp;path-&gt;<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jpiIndexArray:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jpiAnyArray:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* path <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> is unchanged */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* other items (wildcard paths, item methods) are not supported */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <a href="#L97" title="utils/adt/jsonb_gin.c:97">JsonPathGinNode</a> *<br/></li>
<li><a id="L353">&#x200c;</a><span class="linkable">make_jsp_entry_node</span>(Datum entry)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L97" title="utils/adt/jsonb_gin.c:97">JsonPathGinNode</a> *node = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(offsetof(<a href="#L97" title="utils/adt/jsonb_gin.c:97">JsonPathGinNode</a>, args));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; node-&gt;type = JSP_GIN_ENTRY;<br/></li>
<li>&nbsp; &nbsp; node-&gt;val.entryDatum = entry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> node;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <a href="#L97" title="utils/adt/jsonb_gin.c:97">JsonPathGinNode</a> *<br/></li>
<li><a id="L364">&#x200c;</a><span class="linkable">make_jsp_entry_node_scalar</span>(JsonbValue *scalar, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> iskey)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L353" title="utils/adt/jsonb_gin.c:353">make_jsp_entry_node</a>(<a href="#L1364" title="utils/adt/jsonb_gin.c:1364">make_scalar_key</a>(scalar, iskey));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <a href="#L97" title="utils/adt/jsonb_gin.c:97">JsonPathGinNode</a> *<br/></li>
<li><a id="L370">&#x200c;</a><span class="linkable">make_jsp_expr_node</span>(<a href="#L87" title="utils/adt/jsonb_gin.c:87">JsonPathGinNodeType</a> type, <span class="Type">int</span> nargs)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L97" title="utils/adt/jsonb_gin.c:97">JsonPathGinNode</a> *node = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(offsetof(<a href="#L97" title="utils/adt/jsonb_gin.c:97">JsonPathGinNode</a>, args) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(node-&gt;args[<span class="Constant">0</span>]) * nargs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; node-&gt;type = type;<br/></li>
<li>&nbsp; &nbsp; node-&gt;val.nargs = nargs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> node;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <a href="#L97" title="utils/adt/jsonb_gin.c:97">JsonPathGinNode</a> *<br/></li>
<li><a id="L382">&#x200c;</a><span class="linkable">make_jsp_expr_node_args</span>(<a href="#L87" title="utils/adt/jsonb_gin.c:87">JsonPathGinNodeType</a> type, List *args)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L97" title="utils/adt/jsonb_gin.c:97">JsonPathGinNode</a> *node = <a href="#L370" title="utils/adt/jsonb_gin.c:370">make_jsp_expr_node</a>(type, list_length(args));<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, args)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; node-&gt;args[i++] = lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> node;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <a href="#L97" title="utils/adt/jsonb_gin.c:97">JsonPathGinNode</a> *<br/></li>
<li><a id="L395">&#x200c;</a><span class="linkable">make_jsp_expr_node_binary</span>(<a href="#L87" title="utils/adt/jsonb_gin.c:87">JsonPathGinNodeType</a> type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L97" title="utils/adt/jsonb_gin.c:97">JsonPathGinNode</a> *arg1, <a href="#L97" title="utils/adt/jsonb_gin.c:97">JsonPathGinNode</a> *arg2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L97" title="utils/adt/jsonb_gin.c:97">JsonPathGinNode</a> *node = <a href="#L370" title="utils/adt/jsonb_gin.c:370">make_jsp_expr_node</a>(type, <span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; node-&gt;args[<span class="Constant">0</span>] = arg1;<br/></li>
<li>&nbsp; &nbsp; node-&gt;args[<span class="Constant">1</span>] = arg2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> node;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Append a list of nodes from the jsonpath (jsonb_ops). */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L408">&#x200c;</a><span class="linkable">jsonb_ops__extract_nodes</span>(<a href="#L147" title="utils/adt/jsonb_gin.c:147">JsonPathGinContext</a> *cxt, <a href="#L125" title="utils/adt/jsonb_gin.c:125">JsonPathGinPath</a> path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; JsonbValue *scalar, List *nodes)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L117" title="utils/adt/jsonb_gin.c:117">JsonPathGinPathItem</a> *pentry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (scalar)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L97" title="utils/adt/jsonb_gin.c:97">JsonPathGinNode</a> *node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Append path entry nodes only if scalar is provided.&nbsp; See header<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * comment for details.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (pentry = path.items; pentry; pentry = pentry-&gt;parent)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pentry-&gt;type == jpiKey) <span class="Comment">/* only keys are indexed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nodes = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(nodes, <a href="#L353" title="utils/adt/jsonb_gin.c:353">make_jsp_entry_node</a>(pentry-&gt;keyName));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Append scalar node for equality queries. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (scalar-&gt;type == jbvString)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L117" title="utils/adt/jsonb_gin.c:117">JsonPathGinPathItem</a> *last = path.items;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GinTernaryValue key_entry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Assuming that jsonb_ops interprets string array elements as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * keys, we may extract key or non-key entry or even both.&nbsp; In the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * latter case we create OR-node.&nbsp; It is possible in lax mode<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * where arrays are automatically unwrapped, or in strict mode for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * jpiAny items.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cxt-&gt;lax)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key_entry = GIN_MAYBE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!last)&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* root ($) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key_entry = GIN_FALSE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (last-&gt;type == jpiAnyArray || last-&gt;type == jpiIndexArray)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key_entry = GIN_TRUE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (last-&gt;type == jpiAny)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key_entry = GIN_MAYBE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key_entry = GIN_FALSE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (key_entry == GIN_MAYBE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L97" title="utils/adt/jsonb_gin.c:97">JsonPathGinNode</a> *n1 = <a href="#L364" title="utils/adt/jsonb_gin.c:364">make_jsp_entry_node_scalar</a>(scalar, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L97" title="utils/adt/jsonb_gin.c:97">JsonPathGinNode</a> *n2 = <a href="#L364" title="utils/adt/jsonb_gin.c:364">make_jsp_entry_node_scalar</a>(scalar, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node = <a href="#L395" title="utils/adt/jsonb_gin.c:395">make_jsp_expr_node_binary</a>(JSP_GIN_OR, n1, n2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node = <a href="#L364" title="utils/adt/jsonb_gin.c:364">make_jsp_entry_node_scalar</a>(scalar,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key_entry == GIN_TRUE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node = <a href="#L364" title="utils/adt/jsonb_gin.c:364">make_jsp_entry_node_scalar</a>(scalar, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nodes = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(nodes, node);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> nodes;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Append a list of nodes from the jsonpath (jsonb_path_ops). */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L478">&#x200c;</a><span class="linkable">jsonb_path_ops__extract_nodes</span>(<a href="#L147" title="utils/adt/jsonb_gin.c:147">JsonPathGinContext</a> *cxt, <a href="#L125" title="utils/adt/jsonb_gin.c:125">JsonPathGinPath</a> path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JsonbValue *scalar, List *nodes)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (scalar)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* append path <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> node for equality queries */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> = path.<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="jsonb_util.c.html#L1316" title="utils/adt/jsonb_util.c:1316">JsonbHashScalarValue</a>(scalar, &amp;<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(nodes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L353" title="utils/adt/jsonb_gin.c:353">make_jsp_entry_node</a>(UInt32GetDatum(<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* jsonb_path_ops doesn't support EXISTS queries =&gt; nothing to append */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> nodes;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Extract a list of expression nodes that need to be AND-ed by the caller.<br/></li>
<li></span><span class="Comment"> * Extracted expression is 'path == scalar' if 'scalar' is non-NULL, and<br/></li>
<li></span><span class="Comment"> * 'EXISTS(path)' otherwise.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L504">&#x200c;</a><span class="linkable">extract_jsp_path_expr_nodes</span>(<a href="#L147" title="utils/adt/jsonb_gin.c:147">JsonPathGinContext</a> *cxt, <a href="#L125" title="utils/adt/jsonb_gin.c:125">JsonPathGinPath</a> path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JsonPathItem *jsp, JsonbValue *scalar)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JsonPathItem <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *nodes = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (jsp-&gt;type)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jpiCurrent:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jpiFilter:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JsonPathItem arg;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L97" title="utils/adt/jsonb_gin.c:97">JsonPathGinNode</a> *filter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="jsonpath.c.html#L1074" title="utils/adt/jsonpath.c:1074">jspGetArg</a>(jsp, &amp;arg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; filter = <a href="#L583" title="utils/adt/jsonb_gin.c:583">extract_jsp_bool_expr</a>(cxt, path, &amp;arg, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (filter)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nodes = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(nodes, filter);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!cxt-&gt;add_path_item(&amp;path, jsp))<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Path is not supported by the index opclass, return only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the extracted filter nodes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> nodes;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="jsonpath.c.html#L1092" title="utils/adt/jsonpath.c:1092">jspGetNext</a>(jsp, &amp;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; jsp = &amp;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Append nodes from the path expression itself to the already extracted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * list of filter nodes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> cxt-&gt;extract_nodes(cxt, path, scalar, nodes);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Extract an expression node from one of following jsonpath path expressions:<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; EXISTS(jsp)&nbsp; &nbsp; (when 'scalar' is NULL)<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; jsp == scalar&nbsp; (when 'scalar' is not NULL).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The current path (@) is passed in 'path'.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L97" title="utils/adt/jsonb_gin.c:97">JsonPathGinNode</a> *<br/></li>
<li><a id="L564">&#x200c;</a><span class="linkable">extract_jsp_path_expr</span>(<a href="#L147" title="utils/adt/jsonb_gin.c:147">JsonPathGinContext</a> *cxt, <a href="#L125" title="utils/adt/jsonb_gin.c:125">JsonPathGinPath</a> path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JsonPathItem *jsp, JsonbValue *scalar)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* extract a list of nodes to be AND-ed */<br/></li>
<li></span>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *nodes = <a href="#L504" title="utils/adt/jsonb_gin.c:504">extract_jsp_path_expr_nodes</a>(cxt, path, jsp, scalar);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nodes == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no nodes were extracted =&gt; full scan is needed for this path */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(nodes) == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> linitial(nodes); <span class="Comment">/* avoid extra AND-node */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* construct AND-node for path with filters */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L382" title="utils/adt/jsonb_gin.c:382">make_jsp_expr_node_args</a>(JSP_GIN_AND, nodes);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Recursively extract nodes from the boolean jsonpath expression. */<br/></li>
<li></span><span class="Type">static</span> <a href="#L97" title="utils/adt/jsonb_gin.c:97">JsonPathGinNode</a> *<br/></li>
<li><a id="L583">&#x200c;</a><span class="linkable">extract_jsp_bool_expr</span>(<a href="#L147" title="utils/adt/jsonb_gin.c:147">JsonPathGinContext</a> *cxt, <a href="#L125" title="utils/adt/jsonb_gin.c:125">JsonPathGinPath</a> path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JsonPathItem *jsp, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> not)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (jsp-&gt;type)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jpiAnd:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* expr &amp;&amp; expr */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jpiOr:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* expr || expr */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JsonPathItem arg;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L97" title="utils/adt/jsonb_gin.c:97">JsonPathGinNode</a> *larg;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L97" title="utils/adt/jsonb_gin.c:97">JsonPathGinNode</a> *rarg;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L87" title="utils/adt/jsonb_gin.c:87">JsonPathGinNodeType</a> type;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="jsonpath.c.html#L1159" title="utils/adt/jsonpath.c:1159">jspGetLeftArg</a>(jsp, &amp;arg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; larg = <a href="#L583" title="utils/adt/jsonb_gin.c:583">extract_jsp_bool_expr</a>(cxt, path, &amp;arg, not);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="jsonpath.c.html#L1181" title="utils/adt/jsonpath.c:1181">jspGetRightArg</a>(jsp, &amp;arg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rarg = <a href="#L583" title="utils/adt/jsonb_gin.c:583">extract_jsp_bool_expr</a>(cxt, path, &amp;arg, not);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!larg || !rarg)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (jsp-&gt;type == jpiOr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> larg ? larg : rarg;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type = not ^ (jsp-&gt;type == jpiAnd) ? JSP_GIN_AND : JSP_GIN_OR;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L395" title="utils/adt/jsonb_gin.c:395">make_jsp_expr_node_binary</a>(type, larg, rarg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jpiNot:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* !expr&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JsonPathItem arg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="jsonpath.c.html#L1074" title="utils/adt/jsonpath.c:1074">jspGetArg</a>(jsp, &amp;arg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* extract child expression inverting 'not' flag */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L583" title="utils/adt/jsonb_gin.c:583">extract_jsp_bool_expr</a>(cxt, path, &amp;arg, !not);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jpiExists:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* EXISTS(path) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JsonPathItem arg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (not)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;&nbsp; &nbsp; <span class="Comment">/* NOT EXISTS is not supported */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="jsonpath.c.html#L1074" title="utils/adt/jsonpath.c:1074">jspGetArg</a>(jsp, &amp;arg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L564" title="utils/adt/jsonb_gin.c:564">extract_jsp_path_expr</a>(cxt, path, &amp;arg, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jpiNotEqual:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * 'not' == true case is not supported here because '!(path !=<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * scalar)' is not equivalent to 'path == scalar' in the general<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * case because of sequence comparison semantics: 'path == scalar'<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * === 'EXISTS (path, @ == scalar)', '!(path != scalar)' ===<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * 'FOR_ALL(path, @ == scalar)'. So, we should <a href="oracle_compat.c.html#L797" title="utils/adt/oracle_compat.c:797">translate</a> '!(path<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * != scalar)' into GIN query 'path == scalar || <a href="../../regex/regcomp.c.html#L328" title="regex/regcomp.c:328">EMPTY</a>(path)', but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * '<a href="../../regex/regcomp.c.html#L328" title="regex/regcomp.c:328">EMPTY</a>(path)' queries are not supported by the both jsonb<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * opclasses.&nbsp; However in strict mode we could omit '<a href="../../regex/regcomp.c.html#L328" title="regex/regcomp.c:328">EMPTY</a>(path)'<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * part if the path can return exactly one item (it does not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * contain wildcard accessors or item methods like .keyvalue()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * etc.).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jpiEqual:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* path == scalar */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JsonPathItem left_item;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JsonPathItem right_item;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JsonPathItem *path_item;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JsonPathItem *scalar_item;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JsonbValue&nbsp; &nbsp; scalar;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (not)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="jsonpath.c.html#L1159" title="utils/adt/jsonpath.c:1159">jspGetLeftArg</a>(jsp, &amp;left_item);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="jsonpath.c.html#L1181" title="utils/adt/jsonpath.c:1181">jspGetRightArg</a>(jsp, &amp;right_item);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (jspIsScalar(left_item.type))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scalar_item = &amp;left_item;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path_item = &amp;right_item;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (jspIsScalar(right_item.type))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scalar_item = &amp;right_item;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path_item = &amp;left_item;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;&nbsp; &nbsp; <span class="Comment">/* at least one operand should be a scalar */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (scalar_item-&gt;type)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jpiNull:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scalar.type = jbvNull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jpiBool:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scalar.type = jbvBool;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scalar.val.boolean = !!*scalar_item-&gt;content.value.data;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jpiNumeric:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scalar.type = jbvNumeric;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scalar.val.<a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Numeric) scalar_item-&gt;content.value.data;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jpiString:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scalar.type = jbvString;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scalar.val.string.val = scalar_item-&gt;content.value.data;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scalar.val.string.len =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scalar_item-&gt;content.value.datalen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid scalar jsonpath item type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; scalar_item-&gt;type);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L564" title="utils/adt/jsonb_gin.c:564">extract_jsp_path_expr</a>(cxt, path, path_item, &amp;scalar);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not a boolean expression */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Recursively emit all GIN entries found in the node tree */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L719">&#x200c;</a></span><span class="linkable">emit_jsp_gin_entries</span>(<a href="#L97" title="utils/adt/jsonb_gin.c:97">JsonPathGinNode</a> *node, <a href="#L80" title="utils/adt/jsonb_gin.c:80">GinEntries</a> *entries)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (node-&gt;type)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JSP_GIN_ENTRY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* replace datum with its index in the array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;val.entryIndex = <a href="#L172" title="utils/adt/jsonb_gin.c:172">add_gin_entry</a>(entries, node-&gt;val.entryDatum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JSP_GIN_OR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JSP_GIN_AND:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; node-&gt;val.nargs; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L719" title="utils/adt/jsonb_gin.c:719">emit_jsp_gin_entries</a>(node-&gt;args[i], entries);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Recursively extract GIN entries from jsonpath query.<br/></li>
<li></span><span class="Comment"> * Root expression node is put into (*extra_data)[0].<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Datum *<br/></li>
<li><a id="L748">&#x200c;</a><span class="linkable">extract_jsp_query</span>(JsonPath *jp, StrategyNumber strat, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> pathOps,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int32 *nentries, Pointer **extra_data)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L147" title="utils/adt/jsonb_gin.c:147">JsonPathGinContext</a> cxt;<br/></li>
<li>&nbsp; &nbsp; JsonPathItem root;<br/></li>
<li>&nbsp; &nbsp; <a href="#L97" title="utils/adt/jsonb_gin.c:97">JsonPathGinNode</a> *node;<br/></li>
<li>&nbsp; &nbsp; <a href="#L125" title="utils/adt/jsonb_gin.c:125">JsonPathGinPath</a> path = {<span class="Constant">0</span>};<br/></li>
<li>&nbsp; &nbsp; <a href="#L80" title="utils/adt/jsonb_gin.c:80">GinEntries</a>&nbsp; &nbsp; entries = {<span class="Constant">0</span>};<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cxt.lax = (jp-&gt;header &amp; JSONPATH_LAX) != <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pathOps)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cxt.add_path_item = <a href="#L323" title="utils/adt/jsonb_gin.c:323">jsonb_path_ops__add_path_item</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cxt.extract_nodes = <a href="#L478" title="utils/adt/jsonb_gin.c:478">jsonb_path_ops__extract_nodes</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cxt.add_path_item = <a href="#L278" title="utils/adt/jsonb_gin.c:278">jsonb_ops__add_path_item</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cxt.extract_nodes = <a href="#L408" title="utils/adt/jsonb_gin.c:408">jsonb_ops__extract_nodes</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="jsonpath.c.html#L973" title="utils/adt/jsonpath.c:973">jspInit</a>(&amp;root, jp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; node = strat == JsonbJsonpathExistsStrategyNumber<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ? <a href="#L564" title="utils/adt/jsonb_gin.c:564">extract_jsp_path_expr</a>(&amp;cxt, path, &amp;root, <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; : <a href="#L583" title="utils/adt/jsonb_gin.c:583">extract_jsp_bool_expr</a>(&amp;cxt, path, &amp;root, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!node)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *nentries = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L719" title="utils/adt/jsonb_gin.c:719">emit_jsp_gin_entries</a>(node, &amp;entries);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *nentries = entries.count;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!*nentries)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *extra_data = <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(**extra_data) * entries.count);<br/></li>
<li>&nbsp; &nbsp; **extra_data = (Pointer) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> entries.buf;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Recursively execute jsonpath expression.<br/></li>
<li></span><span class="Comment"> * 'check' is a <a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a>[] or a GinTernaryValue[] depending on 'ternary' flag.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> GinTernaryValue<br/></li>
<li><a id="L799">&#x200c;</a><span class="linkable">execute_jsp_gin_node</span>(<a href="#L97" title="utils/adt/jsonb_gin.c:97">JsonPathGinNode</a> *node, <span class="Type">void</span> *check, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> ternary)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GinTernaryValue res;<br/></li>
<li>&nbsp; &nbsp; GinTernaryValue v;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (node-&gt;type)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JSP_GIN_AND:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = GIN_TRUE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; node-&gt;val.nargs; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v = <a href="#L799" title="utils/adt/jsonb_gin.c:799">execute_jsp_gin_node</a>(node-&gt;args[i], check, ternary);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (v == GIN_FALSE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> GIN_FALSE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (v == GIN_MAYBE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = GIN_MAYBE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JSP_GIN_OR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = GIN_FALSE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; node-&gt;val.nargs; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v = <a href="#L799" title="utils/adt/jsonb_gin.c:799">execute_jsp_gin_node</a>(node-&gt;args[i], check, ternary);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (v == GIN_TRUE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> GIN_TRUE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (v == GIN_MAYBE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = GIN_MAYBE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JSP_GIN_ENTRY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index = node-&gt;val.entryIndex;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ternary)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> ((GinTernaryValue *) check)[index];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> ((<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) check)[index] ? GIN_TRUE : GIN_FALSE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid jsonpath gin node type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, node-&gt;type);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> GIN_FALSE;&nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L848">&#x200c;</a><span class="linkable">gin_extract_jsonb_query</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp;&nbsp; *nentries = (int32 *) PG_GETARG_POINTER(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; StrategyNumber strategy = PG_GETARG_UINT16(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp;&nbsp; *searchMode = (int32 *) PG_GETARG_POINTER(<span class="Constant">6</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *entries;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (strategy == JsonbContainsStrategyNumber)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Query is a jsonb, so just apply <a href="#L229" title="utils/adt/jsonb_gin.c:229">gin_extract_jsonb</a>... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; entries = (Datum *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DatumGetPointer(DirectFunctionCall2(<a href="#L229" title="utils/adt/jsonb_gin.c:229">gin_extract_jsonb</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_GETARG_DATUM(<span class="Constant">0</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(nentries)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ...although &quot;contains {}&quot; requires a full index scan */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*nentries == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *searchMode = GIN_SEARCH_MODE_ALL;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strategy == JsonbExistsStrategyNumber)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Query is a text string, which we treat as a key */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *query = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *nentries = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entries = (Datum *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entries[<span class="Constant">0</span>] = <a href="#L1326" title="utils/adt/jsonb_gin.c:1326">make_text_key</a>(JGINFLAG_KEY,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VARDATA_ANY(query),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VARSIZE_ANY_EXHDR(query));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strategy == JsonbExistsAnyStrategyNumber ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; strategy == JsonbExistsAllStrategyNumber)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Query is a text array; each <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> is treated as a key */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ArrayType&nbsp; *query = PG_GETARG_ARRAYTYPE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *key_datums;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *key_nulls;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key_count;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="arrayfuncs.c.html#L3678" title="utils/adt/arrayfuncs.c:3678">deconstruct_array_builtin</a>(query, TEXTOID, &amp;key_datums, &amp;key_nulls, &amp;key_count);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entries = (Datum *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum) * key_count);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>, j = <span class="Constant">0</span>; i &lt; key_count; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../bootstrap/bootstrap.c.html#L153" title="bootstrap/bootstrap.c:153">Nulls</a> in the array are ignored */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (key_nulls[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We rely on the array elements not being toasted */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entries[j++] = <a href="#L1326" title="utils/adt/jsonb_gin.c:1326">make_text_key</a>(JGINFLAG_KEY,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VARDATA_ANY(key_datums[i]),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VARSIZE_ANY_EXHDR(key_datums[i]));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *nentries = j;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ExistsAll with no keys should match everything */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (j == <span class="Constant">0</span> &amp;&amp; strategy == JsonbExistsAllStrategyNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *searchMode = GIN_SEARCH_MODE_ALL;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strategy == JsonbJsonpathPredicateStrategyNumber ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; strategy == JsonbJsonpathExistsStrategyNumber)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; JsonPath&nbsp;&nbsp; *jp = PG_GETARG_JSONPATH_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Pointer&nbsp;&nbsp; **extra_data = (Pointer **) PG_GETARG_POINTER(<span class="Constant">4</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entries = <a href="#L748" title="utils/adt/jsonb_gin.c:748">extract_jsp_query</a>(jp, strategy, <span class="Constant">false</span>, nentries, extra_data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!entries)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *searchMode = GIN_SEARCH_MODE_ALL;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized strategy number: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, strategy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entries = <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(entries);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L929">&#x200c;</a><span class="linkable">gin_consistent_jsonb</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *check = (<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; StrategyNumber strategy = PG_GETARG_UINT16(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Jsonb&nbsp; &nbsp; &nbsp;&nbsp; *query = PG_GETARG_JSONB_P(2); */<br/></li>
<li></span>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; nkeys = PG_GETARG_INT32(<span class="Constant">3</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Pointer&nbsp; &nbsp; *extra_data = (Pointer *) PG_GETARG_POINTER(<span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *recheck = (<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) PG_GETARG_POINTER(<span class="Constant">5</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; res = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (strategy == JsonbContainsStrategyNumber)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We must always recheck, since we can't tell from the index whether<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the positions of the matched items match the structure of the query<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * object.&nbsp; (Even if we could, we'd also have to worry about hashed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * keys and the index's failure to distinguish keys from string array<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * elements.)&nbsp; However, the tuple certainly doesn't match unless it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * contains all the query keys.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *recheck = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nkeys; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!check[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strategy == JsonbExistsStrategyNumber)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Although the key is certainly present in the index, we must recheck<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because (1) the key might be hashed, and (2) the index match might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be for a key that's not at top level of the JSON object.&nbsp; For (1),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we could look at the query key to see if it's hashed and not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * recheck if not, but the index lacks enough info to tell about (2).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *recheck = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strategy == JsonbExistsAnyStrategyNumber)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* As for plain exists, we must recheck */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *recheck = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strategy == JsonbExistsAllStrategyNumber)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* As for plain exists, we must recheck */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *recheck = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ... but unless all the keys are present, we can say &quot;false&quot; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nkeys; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!check[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strategy == JsonbJsonpathPredicateStrategyNumber ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; strategy == JsonbJsonpathExistsStrategyNumber)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *recheck = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nkeys &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(extra_data &amp;&amp; extra_data[<span class="Constant">0</span>]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <a href="#L799" title="utils/adt/jsonb_gin.c:799">execute_jsp_gin_node</a>((<a href="#L97" title="utils/adt/jsonb_gin.c:97">JsonPathGinNode</a> *) extra_data[<span class="Constant">0</span>], check,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>) != GIN_FALSE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized strategy number: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, strategy);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(res);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1013">&#x200c;</a><span class="linkable">gin_triconsistent_jsonb</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GinTernaryValue *check = (GinTernaryValue *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; StrategyNumber strategy = PG_GETARG_UINT16(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Jsonb&nbsp; &nbsp; &nbsp;&nbsp; *query = PG_GETARG_JSONB_P(2); */<br/></li>
<li></span>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; nkeys = PG_GETARG_INT32(<span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; Pointer&nbsp; &nbsp; *extra_data = (Pointer *) PG_GETARG_POINTER(<span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; GinTernaryValue res = GIN_MAYBE;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that we never return GIN_TRUE, only GIN_MAYBE or GIN_FALSE; this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * corresponds to always forcing recheck in the regular consistent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * function, for the reasons listed there.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (strategy == JsonbContainsStrategyNumber ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; strategy == JsonbExistsAllStrategyNumber)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* All extracted keys must be present */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nkeys; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (check[i] == GIN_FALSE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = GIN_FALSE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strategy == JsonbExistsStrategyNumber ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; strategy == JsonbExistsAnyStrategyNumber)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* At least one extracted key must be present */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; res = GIN_FALSE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nkeys; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (check[i] == GIN_TRUE ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; check[i] == GIN_MAYBE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = GIN_MAYBE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strategy == JsonbJsonpathPredicateStrategyNumber ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; strategy == JsonbJsonpathExistsStrategyNumber)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nkeys &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(extra_data &amp;&amp; extra_data[<span class="Constant">0</span>]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <a href="#L799" title="utils/adt/jsonb_gin.c:799">execute_jsp_gin_node</a>((<a href="#L97" title="utils/adt/jsonb_gin.c:97">JsonPathGinNode</a> *) extra_data[<span class="Constant">0</span>], check,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Should always recheck the result */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (res == GIN_TRUE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = GIN_MAYBE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized strategy number: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, strategy);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_GIN_TERNARY_VALUE(res);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * jsonb_path_ops GIN opclass support <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In a jsonb_path_ops index, the GIN keys are uint32 hashes, one per JSON<br/></li>
<li></span><span class="Comment"> * value; but the JSON key(s) leading to each value are also included in its<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> computation.&nbsp; This means we can only support containment queries,<br/></li>
<li></span><span class="Comment"> * but the index can distinguish, for example, {&quot;foo&quot;: 42} from {&quot;bar&quot;: 42}<br/></li>
<li></span><span class="Comment"> * since different hashes will be generated.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L1090">&#x200c;</a><span class="linkable">gin_extract_jsonb_path</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Jsonb&nbsp; &nbsp; &nbsp;&nbsp; *jb = PG_GETARG_JSONB_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp;&nbsp; *nentries = (int32 *) PG_GETARG_POINTER(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; total = JB_ROOT_COUNT(jb);<br/></li>
<li>&nbsp; &nbsp; JsonbIterator *it;<br/></li>
<li>&nbsp; &nbsp; JsonbValue&nbsp; &nbsp; v;<br/></li>
<li>&nbsp; &nbsp; JsonbIteratorToken r;<br/></li>
<li>&nbsp; &nbsp; <a href="#L73" title="utils/adt/jsonb_gin.c:73">PathHashStack</a> tail;<br/></li>
<li>&nbsp; &nbsp; <a href="#L73" title="utils/adt/jsonb_gin.c:73">PathHashStack</a> *stack;<br/></li>
<li>&nbsp; &nbsp; <a href="#L80" title="utils/adt/jsonb_gin.c:80">GinEntries</a>&nbsp; &nbsp; entries;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If the root level is empty, we certainly have no keys */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (total == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *nentries = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_POINTER(<span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Otherwise, use 2 * root count as initial estimate of result size */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L163" title="utils/adt/jsonb_gin.c:163">init_gin_entries</a>(&amp;entries, <span class="Constant">2</span> * total);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We keep a stack of partial hashes corresponding to parent key levels */<br/></li>
<li></span>&nbsp; &nbsp; tail.parent = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; tail.<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; stack = &amp;tail;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; it = <a href="jsonb_util.c.html#L817" title="utils/adt/jsonb_util.c:817">JsonbIteratorInit</a>(&amp;jb-&gt;root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((r = <a href="jsonb_util.c.html#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a>(&amp;it, &amp;v, <span class="Constant">false</span>)) != WJB_DONE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L73" title="utils/adt/jsonb_gin.c:73">PathHashStack</a> *parent;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (r)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WJB_BEGIN_ARRAY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WJB_BEGIN_OBJECT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Push a stack level for this object */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parent = stack;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stack = (<a href="#L73" title="utils/adt/jsonb_gin.c:73">PathHashStack</a> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L73" title="utils/adt/jsonb_gin.c:73">PathHashStack</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We pass forward hashes from outer nesting levels so that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the hashes for nested <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> will include outer keys as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * well as their own keys.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Nesting an array within another array will not alter<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * innermost scalar <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, but that seems<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * inconsequential.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stack-&gt;<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> = parent-&gt;<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stack-&gt;parent = parent;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WJB_KEY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* mix this key into the current outer <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="jsonb_util.c.html#L1316" title="utils/adt/jsonb_util.c:1316">JsonbHashScalarValue</a>(&amp;v, &amp;stack-&gt;<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> is <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> ready to incorporate the value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WJB_ELEM:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WJB_VALUE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* mix the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> or value's <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> into the prepared <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="jsonb_util.c.html#L1316" title="utils/adt/jsonb_util.c:1316">JsonbHashScalarValue</a>(&amp;v, &amp;stack-&gt;<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* and emit an index entry */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L172" title="utils/adt/jsonb_gin.c:172">add_gin_entry</a>(&amp;entries, UInt32GetDatum(stack-&gt;<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* reset <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> for <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> key, value, or sub-object */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stack-&gt;<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> = stack-&gt;parent-&gt;<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WJB_END_ARRAY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WJB_END_OBJECT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Pop the stack */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parent = stack-&gt;parent;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(stack);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stack = parent;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* reset <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> for <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> key, value, or sub-object */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (stack-&gt;parent)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stack-&gt;<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> = stack-&gt;parent-&gt;<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stack-&gt;<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid <a href="jsonb_util.c.html#L853" title="utils/adt/jsonb_util.c:853">JsonbIteratorNext</a> rc: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, (<span class="Type">int</span>) r);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *nentries = entries.count;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(entries.buf);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1180">&#x200c;</a><span class="linkable">gin_extract_jsonb_query_path</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp;&nbsp; *nentries = (int32 *) PG_GETARG_POINTER(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; StrategyNumber strategy = PG_GETARG_UINT16(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp;&nbsp; *searchMode = (int32 *) PG_GETARG_POINTER(<span class="Constant">6</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *entries;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (strategy == JsonbContainsStrategyNumber)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Query is a jsonb, so just apply <a href="#L1090" title="utils/adt/jsonb_gin.c:1090">gin_extract_jsonb_path</a> ... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; entries = (Datum *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DatumGetPointer(DirectFunctionCall2(<a href="#L1090" title="utils/adt/jsonb_gin.c:1090">gin_extract_jsonb_path</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_GETARG_DATUM(<span class="Constant">0</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(nentries)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ... although &quot;contains {}&quot; requires a full index scan */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*nentries == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *searchMode = GIN_SEARCH_MODE_ALL;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strategy == JsonbJsonpathPredicateStrategyNumber ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; strategy == JsonbJsonpathExistsStrategyNumber)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; JsonPath&nbsp;&nbsp; *jp = PG_GETARG_JSONPATH_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Pointer&nbsp;&nbsp; **extra_data = (Pointer **) PG_GETARG_POINTER(<span class="Constant">4</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entries = <a href="#L748" title="utils/adt/jsonb_gin.c:748">extract_jsp_query</a>(jp, strategy, <span class="Constant">true</span>, nentries, extra_data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!entries)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *searchMode = GIN_SEARCH_MODE_ALL;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized strategy number: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, strategy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entries = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(entries);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1220">&#x200c;</a><span class="linkable">gin_consistent_jsonb_path</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *check = (<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; StrategyNumber strategy = PG_GETARG_UINT16(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Jsonb&nbsp; &nbsp; &nbsp;&nbsp; *query = PG_GETARG_JSONB_P(2); */<br/></li>
<li></span>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; nkeys = PG_GETARG_INT32(<span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; Pointer&nbsp; &nbsp; *extra_data = (Pointer *) PG_GETARG_POINTER(<span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *recheck = (<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) PG_GETARG_POINTER(<span class="Constant">5</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; res = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (strategy == JsonbContainsStrategyNumber)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * jsonb_path_ops is necessarily lossy, not only because of <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * collisions but also because it doesn't preserve complete<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * information about the structure of the JSON object.&nbsp; Besides, there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * are some special rules around the containment of raw scalars in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * arrays that are not handled here.&nbsp; So we must always recheck a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * match.&nbsp; However, if not all of the keys are present, the tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * certainly doesn't match.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *recheck = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nkeys; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!check[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strategy == JsonbJsonpathPredicateStrategyNumber ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; strategy == JsonbJsonpathExistsStrategyNumber)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *recheck = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nkeys &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(extra_data &amp;&amp; extra_data[<span class="Constant">0</span>]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <a href="#L799" title="utils/adt/jsonb_gin.c:799">execute_jsp_gin_node</a>((<a href="#L97" title="utils/adt/jsonb_gin.c:97">JsonPathGinNode</a> *) extra_data[<span class="Constant">0</span>], check,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>) != GIN_FALSE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized strategy number: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, strategy);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(res);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1272">&#x200c;</a><span class="linkable">gin_triconsistent_jsonb_path</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GinTernaryValue *check = (GinTernaryValue *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; StrategyNumber strategy = PG_GETARG_UINT16(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Jsonb&nbsp; &nbsp; &nbsp;&nbsp; *query = PG_GETARG_JSONB_P(2); */<br/></li>
<li></span>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; nkeys = PG_GETARG_INT32(<span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; Pointer&nbsp; &nbsp; *extra_data = (Pointer *) PG_GETARG_POINTER(<span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; GinTernaryValue res = GIN_MAYBE;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (strategy == JsonbContainsStrategyNumber)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that we never return GIN_TRUE, only GIN_MAYBE or GIN_FALSE;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this corresponds to always forcing recheck in the regular<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * consistent function, for the reasons listed there.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nkeys; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (check[i] == GIN_FALSE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = GIN_FALSE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strategy == JsonbJsonpathPredicateStrategyNumber ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; strategy == JsonbJsonpathExistsStrategyNumber)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nkeys &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(extra_data &amp;&amp; extra_data[<span class="Constant">0</span>]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <a href="#L799" title="utils/adt/jsonb_gin.c:799">execute_jsp_gin_node</a>((<a href="#L97" title="utils/adt/jsonb_gin.c:97">JsonPathGinNode</a> *) extra_data[<span class="Constant">0</span>], check,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Should always recheck the result */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (res == GIN_TRUE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = GIN_MAYBE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized strategy number: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, strategy);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_GIN_TERNARY_VALUE(res);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Construct a jsonb_ops GIN key from a flag byte and a textual representation<br/></li>
<li></span><span class="Comment"> * (which need not be null-terminated).&nbsp; This function is responsible<br/></li>
<li></span><span class="Comment"> * for hashing overlength text representations; it will add the<br/></li>
<li></span><span class="Comment"> * JGINFLAG_HASHED <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> to the flag value if it does that.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Datum<br/></li>
<li><a id="L1326">&#x200c;</a><span class="linkable">make_text_key</span>(<span class="Type">char</span> flag, <span class="Type">const</span> <span class="Type">char</span> *str, <span class="Type">int</span> len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *item;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; hashbuf[<span class="Constant">10</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (len &gt; JGIN_MAXLENGTH)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; hashval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hashval = DatumGetUInt32(hash_any((<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">char</span> *) str, len));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(hashbuf, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(hashbuf), <span class="Constant">&quot;</span><span class="Special">%08x</span><span class="Constant">&quot;</span>, hashval);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; str = hashbuf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len = <span class="Constant">8</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; flag |= JGINFLAG_HASHED;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now build the text Datum.&nbsp; For simplicity we build a 4-byte-header<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * varlena text Datum here, but we expect it will get converted to short<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * header format when stored in the index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; item = (text *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(VARHDRSZ + len + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(item, VARHDRSZ + len + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *VARDATA(item) = flag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memcpy(VARDATA(item) + <span class="Constant">1</span>, str, len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> PointerGetDatum(item);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create a textual representation of a JsonbValue that will serve as a GIN<br/></li>
<li></span><span class="Comment"> * key in a jsonb_ops index.&nbsp; is_key is true if the JsonbValue is a key,<br/></li>
<li></span><span class="Comment"> * or if it is a string array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> (since we pretend those are keys,<br/></li>
<li></span><span class="Comment"> * see jsonb.h).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Datum<br/></li>
<li><a id="L1364">&#x200c;</a><span class="linkable">make_scalar_key</span>(<span class="Type">const</span> JsonbValue *scalarVal, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_key)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; item;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *cstr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (scalarVal-&gt;type)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jbvNull:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!is_key);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item = <a href="#L1326" title="utils/adt/jsonb_gin.c:1326">make_text_key</a>(JGINFLAG_NULL, <span class="Constant">&quot;&quot;</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jbvBool:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!is_key);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item = <a href="#L1326" title="utils/adt/jsonb_gin.c:1326">make_text_key</a>(JGINFLAG_BOOL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; scalarVal-&gt;val.boolean ? <span class="Constant">&quot;t&quot;</span> : <span class="Constant">&quot;f&quot;</span>, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jbvNumeric:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!is_key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * A normalized textual representation, free of trailing zeroes,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is required so that numerically <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> will produce <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * strings.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It isn't ideal that numerics are stored in a relatively bulky<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * textual format.&nbsp; However, it's a notationally convenient way of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * storing a &quot;union&quot; type in the GIN B-Tree, and indexing Jsonb<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * strings takes precedence.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cstr = <a href="numeric.c.html#L1017" title="utils/adt/numeric.c:1017">numeric_normalize</a>(scalarVal-&gt;val.<a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item = <a href="#L1326" title="utils/adt/jsonb_gin.c:1326">make_text_key</a>(JGINFLAG_NUM, cstr, strlen(cstr));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(cstr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jbvString:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item = <a href="#L1326" title="utils/adt/jsonb_gin.c:1326">make_text_key</a>(is_key ? JGINFLAG_KEY : JGINFLAG_STR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; scalarVal-&gt;val.string.val,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; scalarVal-&gt;val.string.len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized jsonb scalar type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, scalarVal-&gt;type);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> item;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
