<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/adt/network_selfuncs.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/adt/network_selfuncs.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L742">inet_hist_inclusion_join_sel</a></li>
<li><a href="#L939">inet_hist_match_divider</a></li>
<li><a href="#L604">inet_hist_value_sel</a></li>
<li><a href="#L879">inet_inclusion_cmp</a></li>
<li><a href="#L905">inet_masklen_inclusion_cmp</a></li>
<li><a href="#L705">inet_mcv_hist_sel</a></li>
<li><a href="#L673">inet_mcv_join_sel</a></li>
<li><a href="#L836">inet_opr_codenum</a></li>
<li><a href="#L793">inet_semi_join_sel</a></li>
<li><a href="#L539">mcv_population</a></li>
<li><a href="#L196">networkjoinsel</a></li>
<li><a href="#L263">networkjoinsel_inner</a></li>
<li><a href="#L390">networkjoinsel_semi</a></li>
<li><a href="#L79">networksel</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L36">DEFAULT_INCLUSION_SEL</a></li>
<li><a href="#L33">DEFAULT_OVERLAP_SEL</a></li>
<li><a href="#L39">DEFAULT_SEL</a></li>
<li><a href="#L44">MAX_CONSIDERED_ELEMS</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * network_selfuncs.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Functions for selectivity estimation of inet/cidr operators<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This module provides estimators for the subnet inclusion and overlap<br/></li>
<li></span><span class="Comment"> * operators.&nbsp; Estimates are based on null fraction, most common <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>,<br/></li>
<li></span><span class="Comment"> * and histogram of inet/cidr columns.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/adt/network_selfuncs.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;math.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_operator.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_statistic.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgrprotos.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/inet.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/selfuncs.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* Default selectivity for the inet overlap operator */<br/></li>
<li><a id="L33">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">DEFAULT_OVERLAP_SEL</span> </span><span class="Constant">0.01<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Default selectivity for the various inclusion operators */<br/></li>
<li><a id="L36">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">DEFAULT_INCLUSION_SEL</span> </span><span class="Constant">0.005<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Default selectivity for specified operator */<br/></li>
<li><a id="L39">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">DEFAULT_SEL</span>(operator) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((operator) == OID_INET_OVERLAP_OP ? \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp;&nbsp; <a href="array_selfuncs.c.html#L33" title="utils/adt/array_selfuncs.c:33">DEFAULT_OVERLAP_SEL</a> : <a href="#L36" title="utils/adt/network_selfuncs.c:36">DEFAULT_INCLUSION_SEL</a>)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Maximum number of items to consider in join selectivity calculations */<br/></li>
<li><a id="L44">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MAX_CONSIDERED_ELEMS</span> </span><span class="Constant">1024<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> Selectivity <a href="#L263" title="utils/adt/network_selfuncs.c:263">networkjoinsel_inner</a>(Oid operator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VariableStatData *vardata1, VariableStatData *vardata2);<br/></li>
<li><span class="Type">static</span> Selectivity <a href="#L390" title="utils/adt/network_selfuncs.c:390">networkjoinsel_semi</a>(Oid operator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VariableStatData *vardata1, VariableStatData *vardata2);<br/></li>
<li><span class="Type">static</span> Selectivity <a href="#L539" title="utils/adt/network_selfuncs.c:539">mcv_population</a>(float4 *mcv_numbers, <span class="Type">int</span> mcv_nvalues);<br/></li>
<li><span class="Type">static</span> Selectivity <a href="#L604" title="utils/adt/network_selfuncs.c:604">inet_hist_value_sel</a>(Datum *<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, <span class="Type">int</span> nvalues,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum constvalue, <span class="Type">int</span> opr_codenum);<br/></li>
<li><span class="Type">static</span> Selectivity <a href="#L673" title="utils/adt/network_selfuncs.c:673">inet_mcv_join_sel</a>(Datum *mcv1_values,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; float4 *mcv1_numbers, <span class="Type">int</span> mcv1_nvalues, Datum *mcv2_values,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; float4 *mcv2_numbers, <span class="Type">int</span> mcv2_nvalues, Oid operator);<br/></li>
<li><span class="Type">static</span> Selectivity <a href="#L705" title="utils/adt/network_selfuncs.c:705">inet_mcv_hist_sel</a>(Datum *mcv_values, float4 *mcv_numbers,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> mcv_nvalues, Datum *hist_values, <span class="Type">int</span> hist_nvalues,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> opr_codenum);<br/></li>
<li><span class="Type">static</span> Selectivity <a href="#L742" title="utils/adt/network_selfuncs.c:742">inet_hist_inclusion_join_sel</a>(Datum *hist1_values,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> hist1_nvalues,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum *hist2_values, <span class="Type">int</span> hist2_nvalues,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> opr_codenum);<br/></li>
<li><span class="Type">static</span> Selectivity <a href="#L793" title="utils/adt/network_selfuncs.c:793">inet_semi_join_sel</a>(Datum lhs_value,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> mcv_exists, Datum *mcv_values, <span class="Type">int</span> mcv_nvalues,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> hist_exists, Datum *hist_values, <span class="Type">int</span> hist_nvalues,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span> hist_weight,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FmgrInfo *proc, <span class="Type">int</span> opr_codenum);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L836" title="utils/adt/network_selfuncs.c:836">inet_opr_codenum</a>(Oid operator);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L879" title="utils/adt/network_selfuncs.c:879">inet_inclusion_cmp</a>(inet *left, inet *right, <span class="Type">int</span> opr_codenum);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L905" title="utils/adt/network_selfuncs.c:905">inet_masklen_inclusion_cmp</a>(inet *left, inet *right,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> opr_codenum);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L939" title="utils/adt/network_selfuncs.c:939">inet_hist_match_divider</a>(inet *boundary, inet *query,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> opr_codenum);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Selectivity estimation for the subnet inclusion/overlap operators<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L79">&#x200c;</a><span class="linkable">networksel</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; operator = PG_GETARG_OID(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *args = (List *) PG_GETARG_POINTER(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; varRelid = PG_GETARG_INT32(<span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; VariableStatData vardata;<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *other;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; varonleft;<br/></li>
<li>&nbsp; &nbsp; Selectivity selec,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mcv_selec,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; non_mcv_selec;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; constvalue;<br/></li>
<li>&nbsp; &nbsp; Form_pg_statistic stats;<br/></li>
<li>&nbsp; &nbsp; AttStatsSlot hslot;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; sumcommon,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nullfrac;<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; proc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If expression is not (variable op something) or (something op<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * variable), then punt and return a default estimate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="selfuncs.c.html#L4883" title="utils/adt/selfuncs.c:4883">get_restriction_variable</a>(root, args, varRelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;vardata, &amp;other, &amp;varonleft))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(<a href="array_selfuncs.c.html#L36" title="utils/adt/array_selfuncs.c:36">DEFAULT_SEL</a>(operator));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Can't do anything useful if the something is not a constant, either.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!IsA(other, Const))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ReleaseVariableStats(vardata);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(<a href="array_selfuncs.c.html#L36" title="utils/adt/array_selfuncs.c:36">DEFAULT_SEL</a>(operator));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* All of the operators handled here are strict. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (((Const *) other)-&gt;constisnull)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ReleaseVariableStats(vardata);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(<span class="Constant">0.0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; constvalue = ((Const *) other)-&gt;constvalue;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Otherwise, we need stats in order to produce a non-default estimate. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(vardata.statsTuple))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ReleaseVariableStats(vardata);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(<a href="array_selfuncs.c.html#L36" title="utils/adt/array_selfuncs.c:36">DEFAULT_SEL</a>(operator));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; stats = (Form_pg_statistic) GETSTRUCT(vardata.statsTuple);<br/></li>
<li>&nbsp; &nbsp; nullfrac = stats-&gt;stanullfrac;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we have most-common-<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> info, add up the fractions of the MCV<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * entries that satisfy MCV OP CONST.&nbsp; These fractions contribute directly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to the result selectivity.&nbsp; Also add up the total fraction represented<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * by MCV entries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../fmgr/fmgr.c.html#L127" title="utils/fmgr/fmgr.c:127">fmgr_info</a>(<a href="../cache/lsyscache.c.html#L1285" title="utils/cache/lsyscache.c:1285">get_opcode</a>(operator), &amp;proc);<br/></li>
<li>&nbsp; &nbsp; mcv_selec = <a href="selfuncs.c.html#L732" title="utils/adt/selfuncs.c:732">mcv_selectivity</a>(&amp;vardata, &amp;proc, InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constvalue, varonleft,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;sumcommon);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we have a histogram, use it to estimate the proportion of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * non-MCV population that satisfies the clause.&nbsp; If we don't, apply the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * default selectivity to that population.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../cache/lsyscache.c.html#L3234" title="utils/cache/lsyscache.c:3234">get_attstatsslot</a>(&amp;hslot, vardata.statsTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; STATISTIC_KIND_HISTOGRAM, InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ATTSTATSSLOT_VALUES))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opr_codenum = <a href="#L836" title="utils/adt/network_selfuncs.c:836">inet_opr_codenum</a>(operator);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Commute if needed, so we can consider histogram to be on the left */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!varonleft)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opr_codenum = -opr_codenum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; non_mcv_selec = <a href="#L604" title="utils/adt/network_selfuncs.c:604">inet_hist_value_sel</a>(hslot.<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, hslot.nvalues,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constvalue, opr_codenum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L3344" title="utils/cache/lsyscache.c:3344">free_attstatsslot</a>(&amp;hslot);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; non_mcv_selec = <a href="array_selfuncs.c.html#L36" title="utils/adt/array_selfuncs.c:36">DEFAULT_SEL</a>(operator);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Combine selectivities for MCV and non-MCV populations */<br/></li>
<li></span>&nbsp; &nbsp; selec = mcv_selec + (<span class="Constant">1.0</span> - nullfrac - sumcommon) * non_mcv_selec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Result should be in <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, but make sure... */<br/></li>
<li></span>&nbsp; &nbsp; CLAMP_PROBABILITY(selec);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ReleaseVariableStats(vardata);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(selec);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Join selectivity estimation for the subnet inclusion/overlap operators<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function has the same structure as <a href="selfuncs.c.html#L2269" title="utils/adt/selfuncs.c:2269">eqjoinsel</a>() in selfuncs.c.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Throughout <a href="#L196" title="utils/adt/network_selfuncs.c:196">networkjoinsel</a> and its subroutines, we have a performance issue<br/></li>
<li></span><span class="Comment"> * in that the amount of work to be done is O(N^2) in the length of the MCV<br/></li>
<li></span><span class="Comment"> * and histogram arrays.&nbsp; To keep the runtime from getting out of hand when<br/></li>
<li></span><span class="Comment"> * large statistics targets have been set, we arbitrarily limit the number of<br/></li>
<li></span><span class="Comment"> * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> considered to 1024 (<a href="#L44" title="utils/adt/network_selfuncs.c:44">MAX_CONSIDERED_ELEMS</a>).&nbsp; For the MCV arrays, this<br/></li>
<li></span><span class="Comment"> * is easy: just consider at most the first N elements.&nbsp; (Since the MCVs are<br/></li>
<li></span><span class="Comment"> * sorted by decreasing frequency, this correctly gets us the first N MCVs.)<br/></li>
<li></span><span class="Comment"> * For the histogram arrays, we decimate; that is consider only every k'th<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>, where k is chosen so that no more than <a href="#L44" title="utils/adt/network_selfuncs.c:44">MAX_CONSIDERED_ELEMS</a><br/></li>
<li></span><span class="Comment"> * elements are considered.&nbsp; This should still give us a good random sample of<br/></li>
<li></span><span class="Comment"> * the non-MCV population.&nbsp; Decimation is done on-the-fly in the loops that<br/></li>
<li></span><span class="Comment"> * iterate over the histogram arrays.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L196">&#x200c;</a><span class="linkable">networkjoinsel</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; operator = PG_GETARG_OID(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *args = (List *) PG_GETARG_POINTER(<span class="Constant">2</span>);<br/></li>
<li><span class="PreProc">#ifdef NOT_USED<br/></li>
<li></span>&nbsp; &nbsp; JoinType&nbsp; &nbsp; jointype = (JoinType) PG_GETARG_INT16(<span class="Constant">3</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; SpecialJoinInfo *sjinfo = (SpecialJoinInfo *) PG_GETARG_POINTER(<span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; selec;<br/></li>
<li>&nbsp; &nbsp; VariableStatData vardata1;<br/></li>
<li>&nbsp; &nbsp; VariableStatData vardata2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; join_is_reversed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="selfuncs.c.html#L4943" title="utils/adt/selfuncs.c:4943">get_join_variables</a>(root, args, sjinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;vardata1, &amp;vardata2, &amp;join_is_reversed);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (sjinfo-&gt;jointype)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JOIN_INNER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JOIN_LEFT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JOIN_FULL:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Selectivity for left/full join is not exactly the same as inner<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * join, but we neglect the difference, as <a href="selfuncs.c.html#L2269" title="utils/adt/selfuncs.c:2269">eqjoinsel</a> does.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = <a href="#L263" title="utils/adt/network_selfuncs.c:263">networkjoinsel_inner</a>(operator, &amp;vardata1, &amp;vardata2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JOIN_SEMI:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JOIN_ANTI:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Here, it's important that we pass the outer var on the left. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!join_is_reversed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = <a href="#L390" title="utils/adt/network_selfuncs.c:390">networkjoinsel_semi</a>(operator, &amp;vardata1, &amp;vardata2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = <a href="#L390" title="utils/adt/network_selfuncs.c:390">networkjoinsel_semi</a>(<a href="../cache/lsyscache.c.html#L1509" title="utils/cache/lsyscache.c:1509">get_commutator</a>(operator),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;vardata2, &amp;vardata1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* other <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> not expected here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized join type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) sjinfo-&gt;jointype);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ReleaseVariableStats(vardata1);<br/></li>
<li>&nbsp; &nbsp; ReleaseVariableStats(vardata2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; CLAMP_PROBABILITY(selec);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8((float8) selec);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Inner join selectivity estimation for subnet inclusion/overlap operators<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Calculates MCV vs MCV, MCV vs histogram and histogram vs histogram<br/></li>
<li></span><span class="Comment"> * selectivity for join using the subnet inclusion operators.&nbsp; Unlike the<br/></li>
<li></span><span class="Comment"> * join selectivity function for the equality operator, <a href="selfuncs.c.html#L2434" title="utils/adt/selfuncs.c:2434">eqjoinsel_inner</a>(),<br/></li>
<li></span><span class="Comment"> * one to one matching of the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> is not enough.&nbsp; Network inclusion<br/></li>
<li></span><span class="Comment"> * operators are likely to match many to many, so we must check all pairs.<br/></li>
<li></span><span class="Comment"> * (Note: it might be possible to exploit understanding of the histogram's<br/></li>
<li></span><span class="Comment"> * btree ordering to reduce the work needed, but we don't currently try.)<br/></li>
<li></span><span class="Comment"> * Also, MCV vs histogram selectivity is not neglected as in <a href="selfuncs.c.html#L2434" title="utils/adt/selfuncs.c:2434">eqjoinsel_inner</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Selectivity<br/></li>
<li><a id="L263">&#x200c;</a><span class="linkable">networkjoinsel_inner</span>(Oid operator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VariableStatData *vardata1, VariableStatData *vardata2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Form_pg_statistic stats;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; nullfrac1 = <span class="Constant">0.0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nullfrac2 = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; Selectivity selec = <span class="Constant">0.0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sumcommon1 = <span class="Constant">0.0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sumcommon2 = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; mcv1_exists = <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mcv2_exists = <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hist1_exists = <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hist2_exists = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opr_codenum;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mcv1_length = <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mcv2_length = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; AttStatsSlot mcv1_slot;<br/></li>
<li>&nbsp; &nbsp; AttStatsSlot mcv2_slot;<br/></li>
<li>&nbsp; &nbsp; AttStatsSlot hist1_slot;<br/></li>
<li>&nbsp; &nbsp; AttStatsSlot hist2_slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(vardata1-&gt;statsTuple))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stats = (Form_pg_statistic) GETSTRUCT(vardata1-&gt;statsTuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nullfrac1 = stats-&gt;stanullfrac;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mcv1_exists = <a href="../cache/lsyscache.c.html#L3234" title="utils/cache/lsyscache.c:3234">get_attstatsslot</a>(&amp;mcv1_slot, vardata1-&gt;statsTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; STATISTIC_KIND_MCV, InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hist1_exists = <a href="../cache/lsyscache.c.html#L3234" title="utils/cache/lsyscache.c:3234">get_attstatsslot</a>(&amp;hist1_slot, vardata1-&gt;statsTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; STATISTIC_KIND_HISTOGRAM, InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ATTSTATSSLOT_VALUES);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Arbitrarily limit number of MCVs considered */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; mcv1_length = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(mcv1_slot.nvalues, <a href="#L44" title="utils/adt/network_selfuncs.c:44">MAX_CONSIDERED_ELEMS</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (mcv1_exists)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sumcommon1 = <a href="#L539" title="utils/adt/network_selfuncs.c:539">mcv_population</a>(mcv1_slot.numbers, mcv1_length);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memset(&amp;mcv1_slot, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(mcv1_slot));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memset(&amp;hist1_slot, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(hist1_slot));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(vardata2-&gt;statsTuple))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stats = (Form_pg_statistic) GETSTRUCT(vardata2-&gt;statsTuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nullfrac2 = stats-&gt;stanullfrac;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mcv2_exists = <a href="../cache/lsyscache.c.html#L3234" title="utils/cache/lsyscache.c:3234">get_attstatsslot</a>(&amp;mcv2_slot, vardata2-&gt;statsTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; STATISTIC_KIND_MCV, InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hist2_exists = <a href="../cache/lsyscache.c.html#L3234" title="utils/cache/lsyscache.c:3234">get_attstatsslot</a>(&amp;hist2_slot, vardata2-&gt;statsTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; STATISTIC_KIND_HISTOGRAM, InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ATTSTATSSLOT_VALUES);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Arbitrarily limit number of MCVs considered */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; mcv2_length = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(mcv2_slot.nvalues, <a href="#L44" title="utils/adt/network_selfuncs.c:44">MAX_CONSIDERED_ELEMS</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (mcv2_exists)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sumcommon2 = <a href="#L539" title="utils/adt/network_selfuncs.c:539">mcv_population</a>(mcv2_slot.numbers, mcv2_length);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memset(&amp;mcv2_slot, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(mcv2_slot));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memset(&amp;hist2_slot, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(hist2_slot));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; opr_codenum = <a href="#L836" title="utils/adt/network_selfuncs.c:836">inet_opr_codenum</a>(operator);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Calculate selectivity for MCV vs MCV matches.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (mcv1_exists &amp;&amp; mcv2_exists)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; selec += <a href="#L673" title="utils/adt/network_selfuncs.c:673">inet_mcv_join_sel</a>(mcv1_slot.<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, mcv1_slot.numbers,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; mcv1_length,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; mcv2_slot.<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, mcv2_slot.numbers,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; mcv2_length,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; operator);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Add in selectivities for MCV vs histogram matches, scaling according to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the fractions of the populations represented by the histograms. Note<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that the second case needs to commute the operator.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (mcv1_exists &amp;&amp; hist2_exists)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; selec += (<span class="Constant">1.0</span> - nullfrac2 - sumcommon2) *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L705" title="utils/adt/network_selfuncs.c:705">inet_mcv_hist_sel</a>(mcv1_slot.<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, mcv1_slot.numbers, mcv1_length,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hist2_slot.<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, hist2_slot.nvalues,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opr_codenum);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (mcv2_exists &amp;&amp; hist1_exists)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; selec += (<span class="Constant">1.0</span> - nullfrac1 - sumcommon1) *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L705" title="utils/adt/network_selfuncs.c:705">inet_mcv_hist_sel</a>(mcv2_slot.<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, mcv2_slot.numbers, mcv2_length,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hist1_slot.<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, hist1_slot.nvalues,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -opr_codenum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Add in selectivity for histogram vs histogram matches, again scaling<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * appropriately.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (hist1_exists &amp;&amp; hist2_exists)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; selec += (<span class="Constant">1.0</span> - nullfrac1 - sumcommon1) *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Constant">1.0</span> - nullfrac2 - sumcommon2) *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L742" title="utils/adt/network_selfuncs.c:742">inet_hist_inclusion_join_sel</a>(hist1_slot.<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, hist1_slot.nvalues,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hist2_slot.<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, hist2_slot.nvalues,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; opr_codenum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If useful statistics are not available then use the default estimate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can apply null fractions if known, though.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((!mcv1_exists &amp;&amp; !hist1_exists) || (!mcv2_exists &amp;&amp; !hist2_exists))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; selec = (<span class="Constant">1.0</span> - nullfrac1) * (<span class="Constant">1.0</span> - nullfrac2) * <a href="array_selfuncs.c.html#L36" title="utils/adt/array_selfuncs.c:36">DEFAULT_SEL</a>(operator);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Release stats. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L3344" title="utils/cache/lsyscache.c:3344">free_attstatsslot</a>(&amp;mcv1_slot);<br/></li>
<li>&nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L3344" title="utils/cache/lsyscache.c:3344">free_attstatsslot</a>(&amp;mcv2_slot);<br/></li>
<li>&nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L3344" title="utils/cache/lsyscache.c:3344">free_attstatsslot</a>(&amp;hist1_slot);<br/></li>
<li>&nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L3344" title="utils/cache/lsyscache.c:3344">free_attstatsslot</a>(&amp;hist2_slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> selec;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Semi join selectivity estimation for subnet inclusion/overlap operators<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Calculates MCV vs MCV, MCV vs histogram, histogram vs MCV, and histogram vs<br/></li>
<li></span><span class="Comment"> * histogram selectivity for semi/anti join cases.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Selectivity<br/></li>
<li><a id="L390">&#x200c;</a><span class="linkable">networkjoinsel_semi</span>(Oid operator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VariableStatData *vardata1, VariableStatData *vardata2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Form_pg_statistic stats;<br/></li>
<li>&nbsp; &nbsp; Selectivity selec = <span class="Constant">0.0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sumcommon1 = <span class="Constant">0.0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sumcommon2 = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; nullfrac1 = <span class="Constant">0.0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nullfrac2 = <span class="Constant">0.0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hist2_weight = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; mcv1_exists = <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mcv2_exists = <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hist1_exists = <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hist2_exists = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opr_codenum;<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; proc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mcv1_length = <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mcv2_length = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; AttStatsSlot mcv1_slot;<br/></li>
<li>&nbsp; &nbsp; AttStatsSlot mcv2_slot;<br/></li>
<li>&nbsp; &nbsp; AttStatsSlot hist1_slot;<br/></li>
<li>&nbsp; &nbsp; AttStatsSlot hist2_slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(vardata1-&gt;statsTuple))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stats = (Form_pg_statistic) GETSTRUCT(vardata1-&gt;statsTuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nullfrac1 = stats-&gt;stanullfrac;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mcv1_exists = <a href="../cache/lsyscache.c.html#L3234" title="utils/cache/lsyscache.c:3234">get_attstatsslot</a>(&amp;mcv1_slot, vardata1-&gt;statsTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; STATISTIC_KIND_MCV, InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hist1_exists = <a href="../cache/lsyscache.c.html#L3234" title="utils/cache/lsyscache.c:3234">get_attstatsslot</a>(&amp;hist1_slot, vardata1-&gt;statsTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; STATISTIC_KIND_HISTOGRAM, InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ATTSTATSSLOT_VALUES);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Arbitrarily limit number of MCVs considered */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; mcv1_length = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(mcv1_slot.nvalues, <a href="#L44" title="utils/adt/network_selfuncs.c:44">MAX_CONSIDERED_ELEMS</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (mcv1_exists)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sumcommon1 = <a href="#L539" title="utils/adt/network_selfuncs.c:539">mcv_population</a>(mcv1_slot.numbers, mcv1_length);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memset(&amp;mcv1_slot, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(mcv1_slot));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memset(&amp;hist1_slot, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(hist1_slot));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(vardata2-&gt;statsTuple))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stats = (Form_pg_statistic) GETSTRUCT(vardata2-&gt;statsTuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nullfrac2 = stats-&gt;stanullfrac;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mcv2_exists = <a href="../cache/lsyscache.c.html#L3234" title="utils/cache/lsyscache.c:3234">get_attstatsslot</a>(&amp;mcv2_slot, vardata2-&gt;statsTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; STATISTIC_KIND_MCV, InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hist2_exists = <a href="../cache/lsyscache.c.html#L3234" title="utils/cache/lsyscache.c:3234">get_attstatsslot</a>(&amp;hist2_slot, vardata2-&gt;statsTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; STATISTIC_KIND_HISTOGRAM, InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ATTSTATSSLOT_VALUES);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Arbitrarily limit number of MCVs considered */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; mcv2_length = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(mcv2_slot.nvalues, <a href="#L44" title="utils/adt/network_selfuncs.c:44">MAX_CONSIDERED_ELEMS</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (mcv2_exists)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sumcommon2 = <a href="#L539" title="utils/adt/network_selfuncs.c:539">mcv_population</a>(mcv2_slot.numbers, mcv2_length);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memset(&amp;mcv2_slot, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(mcv2_slot));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memset(&amp;hist2_slot, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(hist2_slot));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; opr_codenum = <a href="#L836" title="utils/adt/network_selfuncs.c:836">inet_opr_codenum</a>(operator);<br/></li>
<li>&nbsp; &nbsp; <a href="../fmgr/fmgr.c.html#L127" title="utils/fmgr/fmgr.c:127">fmgr_info</a>(<a href="../cache/lsyscache.c.html#L1285" title="utils/cache/lsyscache.c:1285">get_opcode</a>(operator), &amp;proc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Estimate number of input rows represented by RHS histogram. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (hist2_exists &amp;&amp; vardata2-&gt;rel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hist2_weight = (<span class="Constant">1.0</span> - nullfrac2 - sumcommon2) * vardata2-&gt;rel-&gt;rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Consider each <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> of the LHS MCV list, matching it to whatever RHS<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * stats we have.&nbsp; Scale according to the known frequency of the MCV.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (mcv1_exists &amp;&amp; (mcv2_exists || hist2_exists))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; mcv1_length; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec += mcv1_slot.numbers[i] *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L793" title="utils/adt/network_selfuncs.c:793">inet_semi_join_sel</a>(mcv1_slot.<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; mcv2_exists, mcv2_slot.<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, mcv2_length,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hist2_exists,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hist2_slot.<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, hist2_slot.nvalues,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hist2_weight,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;proc, opr_codenum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Consider each <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> of the LHS histogram, except for the first and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * last elements, which we exclude on the grounds that they're outliers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and thus not very representative.&nbsp; Scale on the assumption that each<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * such histogram <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> represents an <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> share of the LHS histogram<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * population (which is a <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> bogus, because the members of its bucket may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not all act the same with respect to the join clause, but it's hard to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * do better).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there are too many histogram elements, decimate to limit runtime.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (hist1_exists &amp;&amp; hist1_slot.nvalues &gt; <span class="Constant">2</span> &amp;&amp; (mcv2_exists || hist2_exists))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; hist_selec_sum = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; k,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; k = (hist1_slot.nvalues - <span class="Constant">3</span>) / <a href="#L44" title="utils/adt/network_selfuncs.c:44">MAX_CONSIDERED_ELEMS</a> + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; n = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt; hist1_slot.nvalues - <span class="Constant">1</span>; i += k)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hist_selec_sum +=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L793" title="utils/adt/network_selfuncs.c:793">inet_semi_join_sel</a>(hist1_slot.<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; mcv2_exists, mcv2_slot.<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, mcv2_length,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hist2_exists,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hist2_slot.<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, hist2_slot.nvalues,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hist2_weight,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;proc, opr_codenum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; selec += (<span class="Constant">1.0</span> - nullfrac1 - sumcommon1) * hist_selec_sum / n;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If useful statistics are not available then use the default estimate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can apply null fractions if known, though.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((!mcv1_exists &amp;&amp; !hist1_exists) || (!mcv2_exists &amp;&amp; !hist2_exists))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; selec = (<span class="Constant">1.0</span> - nullfrac1) * (<span class="Constant">1.0</span> - nullfrac2) * <a href="array_selfuncs.c.html#L36" title="utils/adt/array_selfuncs.c:36">DEFAULT_SEL</a>(operator);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Release stats. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L3344" title="utils/cache/lsyscache.c:3344">free_attstatsslot</a>(&amp;mcv1_slot);<br/></li>
<li>&nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L3344" title="utils/cache/lsyscache.c:3344">free_attstatsslot</a>(&amp;mcv2_slot);<br/></li>
<li>&nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L3344" title="utils/cache/lsyscache.c:3344">free_attstatsslot</a>(&amp;hist1_slot);<br/></li>
<li>&nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L3344" title="utils/cache/lsyscache.c:3344">free_attstatsslot</a>(&amp;hist2_slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> selec;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute the fraction of a relation's population that is represented<br/></li>
<li></span><span class="Comment"> * by the MCV list.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Selectivity<br/></li>
<li><a id="L539">&#x200c;</a><span class="linkable">mcv_population</span>(float4 *mcv_numbers, <span class="Type">int</span> mcv_nvalues)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Selectivity sumcommon = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; mcv_nvalues; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sumcommon += mcv_numbers[i];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> sumcommon;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Inet histogram vs single value selectivity estimation<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Estimate the fraction of the histogram population that satisfies<br/></li>
<li></span><span class="Comment"> * &quot;value OPR CONST&quot;.&nbsp; (The result needs to be scaled to reflect the<br/></li>
<li></span><span class="Comment"> * proportion of the total population represented by the histogram.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The histogram is originally for the inet btree comparison operators.<br/></li>
<li></span><span class="Comment"> * Only the common bits of the network part and the length of the network part<br/></li>
<li></span><span class="Comment"> * (masklen) are interesting for the subnet inclusion operators.&nbsp; Fortunately,<br/></li>
<li></span><span class="Comment"> * btree comparison treats the network part as the major sort key.&nbsp; Even so,<br/></li>
<li></span><span class="Comment"> * the length of the network part would not really be significant in the<br/></li>
<li></span><span class="Comment"> * histogram.&nbsp; This would lead to big mistakes for data sets with uneven<br/></li>
<li></span><span class="Comment"> * masklen distribution.&nbsp; To reduce this problem, comparisons with the left<br/></li>
<li></span><span class="Comment"> * and the right sides of the buckets are used together.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Histogram bucket matches are calculated in two forms.&nbsp; If the constant<br/></li>
<li></span><span class="Comment"> * matches both bucket endpoints the bucket is considered as fully matched.<br/></li>
<li></span><span class="Comment"> * The second form is to match the bucket partially; we recognize this when<br/></li>
<li></span><span class="Comment"> * the constant matches just one endpoint, or the two endpoints fall on<br/></li>
<li></span><span class="Comment"> * opposite sides of the constant.&nbsp; (Note that when the constant matches an<br/></li>
<li></span><span class="Comment"> * interior histogram <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>, it gets credit for partial matches to the<br/></li>
<li></span><span class="Comment"> * buckets on both sides, while a match to a histogram endpoint gets credit<br/></li>
<li></span><span class="Comment"> * for only one partial match.&nbsp; This is desirable.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The divider in the partial bucket match is imagined as the distance<br/></li>
<li></span><span class="Comment"> * between the decisive bits and the common bits of the addresses.&nbsp; It will<br/></li>
<li></span><span class="Comment"> * be used as a power of two as it is the natural scale for the IP network<br/></li>
<li></span><span class="Comment"> * inclusion.&nbsp; This partial bucket match divider calculation is an empirical<br/></li>
<li></span><span class="Comment"> * formula and subject to change with more experiment.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For a partial match, we try to calculate dividers for both of the<br/></li>
<li></span><span class="Comment"> * boundaries.&nbsp; If the address family of a boundary value does not match the<br/></li>
<li></span><span class="Comment"> * constant or comparison of the length of the network parts is not correct<br/></li>
<li></span><span class="Comment"> * for the operator, the divider for that boundary will not be taken into<br/></li>
<li></span><span class="Comment"> * account.&nbsp; If both of the dividers are valid, the greater one will be used<br/></li>
<li></span><span class="Comment"> * to minimize the mistake in buckets that have disparate masklens.&nbsp; This<br/></li>
<li></span><span class="Comment"> * calculation is unfair when dividers can be calculated for both of the<br/></li>
<li></span><span class="Comment"> * boundaries but they are far from each other; but it is not a common<br/></li>
<li></span><span class="Comment"> * situation as the boundaries are expected to share most of their significant<br/></li>
<li></span><span class="Comment"> * bits of their masklens.&nbsp; The mistake would be greater, if we would use the<br/></li>
<li></span><span class="Comment"> * minimum instead of the maximum, and we don't know a sensible way to <a href="../../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a><br/></li>
<li></span><span class="Comment"> * them.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For partial match in buckets that have different address families on the<br/></li>
<li></span><span class="Comment"> * left and right sides, only the boundary with the same address family is<br/></li>
<li></span><span class="Comment"> * taken into consideration.&nbsp; This can cause more mistakes for these buckets<br/></li>
<li></span><span class="Comment"> * if the masklens of their boundaries are also disparate.&nbsp; But this can only<br/></li>
<li></span><span class="Comment"> * happen in one bucket, since only two address families exist.&nbsp; It seems a<br/></li>
<li></span><span class="Comment"> * better option than not considering these buckets at all.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Selectivity<br/></li>
<li><a id="L604">&#x200c;</a><span class="linkable">inet_hist_value_sel</span>(Datum *<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, <span class="Type">int</span> nvalues, Datum constvalue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> opr_codenum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Selectivity match = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *query,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *left,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *right;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; k,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; left_order,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; right_order,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; left_divider,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; right_divider;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* guard against zero-divide below */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nvalues &lt;= <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if there are too many histogram elements, decimate to limit runtime */<br/></li>
<li></span>&nbsp; &nbsp; k = (nvalues - <span class="Constant">2</span>) / <a href="#L44" title="utils/adt/network_selfuncs.c:44">MAX_CONSIDERED_ELEMS</a> + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; query = DatumGetInetPP(constvalue);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* &quot;left&quot; is the left boundary value of the current bucket ... */<br/></li>
<li></span>&nbsp; &nbsp; left = DatumGetInetPP(<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">0</span>]);<br/></li>
<li>&nbsp; &nbsp; left_order = <a href="#L879" title="utils/adt/network_selfuncs.c:879">inet_inclusion_cmp</a>(left, query, opr_codenum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; n = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = k; i &lt; nvalues; i += k)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ... and &quot;right&quot; is the right boundary value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; right = DatumGetInetPP(<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; right_order = <a href="#L879" title="utils/adt/network_selfuncs.c:879">inet_inclusion_cmp</a>(right, query, opr_codenum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (left_order == <span class="Constant">0</span> &amp;&amp; right_order == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The whole bucket matches, since both endpoints do. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; match += <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> ((left_order &lt;= <span class="Constant">0</span> &amp;&amp; right_order &gt;= <span class="Constant">0</span>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (left_order &gt;= <span class="Constant">0</span> &amp;&amp; right_order &lt;= <span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Partial bucket match. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; left_divider = <a href="#L939" title="utils/adt/network_selfuncs.c:939">inet_hist_match_divider</a>(left, query, opr_codenum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; right_divider = <a href="#L939" title="utils/adt/network_selfuncs.c:939">inet_hist_match_divider</a>(right, query, opr_codenum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (left_divider &gt;= <span class="Constant">0</span> || right_divider &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; match += <span class="Constant">1.0</span> / pow(<span class="Constant">2.0</span>, Max(left_divider, right_divider));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Shift the variables. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; left = right;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; left_order = right_order;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Count the number of buckets considered. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; n++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> match / n;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Inet MCV vs MCV join selectivity estimation<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We simply add up the fractions of the populations that satisfy the clause.<br/></li>
<li></span><span class="Comment"> * The result is exact and does not need to be scaled further.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Selectivity<br/></li>
<li><a id="L673">&#x200c;</a><span class="linkable">inet_mcv_join_sel</span>(Datum *mcv1_values, float4 *mcv1_numbers, <span class="Type">int</span> mcv1_nvalues,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum *mcv2_values, float4 *mcv2_numbers, <span class="Type">int</span> mcv2_nvalues,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid operator)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Selectivity selec = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; proc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../fmgr/fmgr.c.html#L127" title="utils/fmgr/fmgr.c:127">fmgr_info</a>(<a href="../cache/lsyscache.c.html#L1285" title="utils/cache/lsyscache.c:1285">get_opcode</a>(operator), &amp;proc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; mcv1_nvalues; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = <span class="Constant">0</span>; j &lt; mcv2_nvalues; j++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (DatumGetBool(FunctionCall2(&amp;proc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; mcv1_values[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; mcv2_values[j])))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec += mcv1_numbers[i] * mcv2_numbers[j];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> selec;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Inet MCV vs histogram join selectivity estimation<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For each MCV on the lefthand side, estimate the fraction of the righthand's<br/></li>
<li></span><span class="Comment"> * histogram population that satisfies the join clause, and add those up,<br/></li>
<li></span><span class="Comment"> * scaling by the MCV's frequency.&nbsp; The result still needs to be scaled<br/></li>
<li></span><span class="Comment"> * according to the fraction of the righthand's population represented by<br/></li>
<li></span><span class="Comment"> * the histogram.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Selectivity<br/></li>
<li><a id="L705">&#x200c;</a><span class="linkable">inet_mcv_hist_sel</span>(Datum *mcv_values, float4 *mcv_numbers, <span class="Type">int</span> mcv_nvalues,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum *hist_values, <span class="Type">int</span> hist_nvalues,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> opr_codenum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Selectivity selec = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We'll call inet_hist_value_selec with the histogram on the left, so we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * must commute the operator.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; opr_codenum = -opr_codenum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; mcv_nvalues; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; selec += mcv_numbers[i] *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L604" title="utils/adt/network_selfuncs.c:604">inet_hist_value_sel</a>(hist_values, hist_nvalues, mcv_values[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opr_codenum);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> selec;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Inet histogram vs histogram join selectivity estimation<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Here, we take all <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> listed in the second histogram (except for the<br/></li>
<li></span><span class="Comment"> * first and last elements, which are excluded on the grounds of possibly<br/></li>
<li></span><span class="Comment"> * not being very representative) and treat them as a uniform sample of<br/></li>
<li></span><span class="Comment"> * the non-MCV population for that relation.&nbsp; For each one, we apply<br/></li>
<li></span><span class="Comment"> * inet_hist_value_selec to see what fraction of the first histogram<br/></li>
<li></span><span class="Comment"> * it matches.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We could alternatively do this the other way around using the operator's<br/></li>
<li></span><span class="Comment"> * commutator.&nbsp; </span><span class="Todo">XXX</span><span class="Comment"> would it be worthwhile to do it both ways and take the<br/></li>
<li></span><span class="Comment"> * average?&nbsp; That would at least avoid non-commutative estimation results.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Selectivity<br/></li>
<li><a id="L742">&#x200c;</a><span class="linkable">inet_hist_inclusion_join_sel</span>(Datum *hist1_values, <span class="Type">int</span> hist1_nvalues,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum *hist2_values, <span class="Type">int</span> hist2_nvalues,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> opr_codenum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; match = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; k,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (hist2_nvalues &lt;= <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0.0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no interior histogram elements */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if there are too many histogram elements, decimate to limit runtime */<br/></li>
<li></span>&nbsp; &nbsp; k = (hist2_nvalues - <span class="Constant">3</span>) / <a href="#L44" title="utils/adt/network_selfuncs.c:44">MAX_CONSIDERED_ELEMS</a> + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; n = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt; hist2_nvalues - <span class="Constant">1</span>; i += k)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; match += <a href="#L604" title="utils/adt/network_selfuncs.c:604">inet_hist_value_sel</a>(hist1_values, hist1_nvalues,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hist2_values[i], opr_codenum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; n++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> match / n;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Inet semi join selectivity estimation for one value<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The function calculates the probability that there is at least one row<br/></li>
<li></span><span class="Comment"> * in the RHS table that satisfies the &quot;lhs_value op column&quot; condition.<br/></li>
<li></span><span class="Comment"> * It is used in semi join estimation to check a sample from the left hand<br/></li>
<li></span><span class="Comment"> * side table.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The MCV and histogram from the right hand side table should be provided as<br/></li>
<li></span><span class="Comment"> * arguments with the lhs_value from the left hand side table for the join.<br/></li>
<li></span><span class="Comment"> * hist_weight is the total number of rows represented by the histogram.<br/></li>
<li></span><span class="Comment"> * For example, if the table has 1000 rows, and 10% of the rows are in the MCV<br/></li>
<li></span><span class="Comment"> * list, and another 10% are NULLs, hist_weight would be 800.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * First, the lhs_value will be matched to the most common <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.&nbsp; If it<br/></li>
<li></span><span class="Comment"> * matches <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of them, 1.0 will be returned, because then there is surely<br/></li>
<li></span><span class="Comment"> * a match.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Otherwise, the histogram will be used to estimate the number of rows in<br/></li>
<li></span><span class="Comment"> * the second table that match the condition.&nbsp; If the estimate is greater<br/></li>
<li></span><span class="Comment"> * than 1.0, 1.0 will be returned, because it means there is a greater chance<br/></li>
<li></span><span class="Comment"> * that the lhs_value will match more than one row in the table.&nbsp; If it is<br/></li>
<li></span><span class="Comment"> * between 0.0 and 1.0, it will be returned as the probability.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Selectivity<br/></li>
<li><a id="L793">&#x200c;</a><span class="linkable">inet_semi_join_sel</span>(Datum lhs_value,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> mcv_exists, Datum *mcv_values, <span class="Type">int</span> mcv_nvalues,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> hist_exists, Datum *hist_values, <span class="Type">int</span> hist_nvalues,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">double</span> hist_weight,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; FmgrInfo *proc, <span class="Type">int</span> opr_codenum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (mcv_exists)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; mcv_nvalues; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (DatumGetBool(FunctionCall2(proc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lhs_value,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; mcv_values[i])))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (hist_exists &amp;&amp; hist_weight &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Selectivity hist_selec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Commute operator, since we're passing lhs_value on the right */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; hist_selec = <a href="#L604" title="utils/adt/network_selfuncs.c:604">inet_hist_value_sel</a>(hist_values, hist_nvalues,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lhs_value, -opr_codenum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hist_selec &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(<span class="Constant">1.0</span>, hist_weight * hist_selec);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0.0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Assign useful code numbers for the subnet inclusion/overlap operators<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Only <a href="#L905" title="utils/adt/network_selfuncs.c:905">inet_masklen_inclusion_cmp</a>() and <a href="#L939" title="utils/adt/network_selfuncs.c:939">inet_hist_match_divider</a>() depend<br/></li>
<li></span><span class="Comment"> * on the exact codes assigned here; but many other places in this file<br/></li>
<li></span><span class="Comment"> * know that they can negate a code to obtain the code for the commutator<br/></li>
<li></span><span class="Comment"> * operator.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L836">&#x200c;</a></span><span class="linkable">inet_opr_codenum</span>(Oid operator)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (operator)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_INET_SUP_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_INET_SUPEQ_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_INET_OVERLAP_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_INET_SUBEQ_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_INET_SUB_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized operator </span><span class="Special">%u</span><span class="Constant"> for inet selectivity&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; operator);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* unreached, but keep compiler quiet */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Comparison function for the subnet inclusion/overlap operators<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the comparison is okay for the specified inclusion operator, the return<br/></li>
<li></span><span class="Comment"> * value will be 0.&nbsp; Otherwise the return value will be less than or greater<br/></li>
<li></span><span class="Comment"> * than 0 as appropriate for the operator.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Comparison is compatible with the basic comparison function for the inet<br/></li>
<li></span><span class="Comment"> * type.&nbsp; See <a href="network.c.html#L405" title="utils/adt/network.c:405">network_cmp_internal</a>() in network.c for the original.&nbsp; Basic<br/></li>
<li></span><span class="Comment"> * comparison operators are implemented with the <a href="network.c.html#L405" title="utils/adt/network.c:405">network_cmp_internal</a>()<br/></li>
<li></span><span class="Comment"> * function.&nbsp; It is possible to implement the subnet inclusion operators with<br/></li>
<li></span><span class="Comment"> * this function.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Comparison is first on the common bits of the network part, then on the<br/></li>
<li></span><span class="Comment"> * length of the network part (masklen) as in the <a href="network.c.html#L405" title="utils/adt/network.c:405">network_cmp_internal</a>()<br/></li>
<li></span><span class="Comment"> * function.&nbsp; Only the first part is in this function.&nbsp; The second part is<br/></li>
<li></span><span class="Comment"> * separated to another function for reusability.&nbsp; The difference between the<br/></li>
<li></span><span class="Comment"> * second part and the original <a href="network.c.html#L405" title="utils/adt/network.c:405">network_cmp_internal</a>() is that the inclusion<br/></li>
<li></span><span class="Comment"> * operator is considered while comparing the lengths of the network parts.<br/></li>
<li></span><span class="Comment"> * See the <a href="#L905" title="utils/adt/network_selfuncs.c:905">inet_masklen_inclusion_cmp</a>() function below.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L879">&#x200c;</a></span><span class="linkable">inet_inclusion_cmp</span>(inet *left, inet *right, <span class="Type">int</span> opr_codenum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ip_family(left) == ip_family(right))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; order;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; order = <a href="network.c.html#L1569" title="utils/adt/network.c:1569">bitncmp</a>(ip_addr(left), ip_addr(right),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(ip_bits(left), ip_bits(right)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (order != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> order;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L905" title="utils/adt/network_selfuncs.c:905">inet_masklen_inclusion_cmp</a>(left, right, opr_codenum);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ip_family(left) - ip_family(right);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Masklen comparison function for the subnet inclusion/overlap operators<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Compares the lengths of the network parts of the inputs.&nbsp; If the comparison<br/></li>
<li></span><span class="Comment"> * is okay for the specified inclusion operator, the return value will be 0.<br/></li>
<li></span><span class="Comment"> * Otherwise the return value will be less than or greater than 0 as<br/></li>
<li></span><span class="Comment"> * appropriate for the operator.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L905">&#x200c;</a></span><span class="linkable">inet_masklen_inclusion_cmp</span>(inet *left, inet *right, <span class="Type">int</span> opr_codenum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; order;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; order = (<span class="Type">int</span>) ip_bits(left) - (<span class="Type">int</span>) ip_bits(right);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Return 0 if the operator would <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> this combination of masklens.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that opr_codenum zero (overlaps) will <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> all cases.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((order &gt; <span class="Constant">0</span> &amp;&amp; opr_codenum &gt;= <span class="Constant">0</span>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (order == <span class="Constant">0</span> &amp;&amp; opr_codenum &gt;= -<span class="Constant">1</span> &amp;&amp; opr_codenum &lt;= <span class="Constant">1</span>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (order &lt; <span class="Constant">0</span> &amp;&amp; opr_codenum &lt;= <span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Otherwise, return a negative value for sup/supeq (notionally, the RHS<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * needs to have a larger masklen than it has, which would make it sort<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * later), or a positive value for sub/subeq (vice versa).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> opr_codenum;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Inet histogram partial match divider calculation<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * First the families and the lengths of the network parts are compared using<br/></li>
<li></span><span class="Comment"> * the subnet inclusion operator.&nbsp; If those are acceptable for the operator,<br/></li>
<li></span><span class="Comment"> * the divider will be calculated using the masklens and the common bits of<br/></li>
<li></span><span class="Comment"> * the addresses.&nbsp; -1 will be returned if it cannot be calculated.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See commentary for <a href="#L604" title="utils/adt/network_selfuncs.c:604">inet_hist_value_sel</a>() for some rationale for this.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L939">&#x200c;</a></span><span class="linkable">inet_hist_match_divider</span>(inet *boundary, inet *query, <span class="Type">int</span> opr_codenum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ip_family(boundary) == ip_family(query) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L905" title="utils/adt/network_selfuncs.c:905">inet_masklen_inclusion_cmp</a>(boundary, query, opr_codenum) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min_bits,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; decisive_bits;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; min_bits = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(ip_bits(boundary), ip_bits(query));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Set decisive_bits to the masklen of the one that should contain the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * other according to the operator.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (opr_codenum &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; decisive_bits = ip_bits(boundary);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (opr_codenum &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; decisive_bits = ip_bits(query);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; decisive_bits = min_bits;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now return the number of non-common decisive bits.&nbsp; (This will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * zero if the boundary and query in fact match, else positive.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (min_bits &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> decisive_bits - <a href="network.c.html#L1603" title="utils/adt/network.c:1603">bitncommon</a>(ip_addr(boundary),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ip_addr(query),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min_bits);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> decisive_bits;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
