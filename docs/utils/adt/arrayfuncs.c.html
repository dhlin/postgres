<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/adt/arrayfuncs.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/adt/arrayfuncs.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L43">Array_nulls</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L68">ArrayIteratorData</a></li>
<li><a href="#L89">ArrayIteratorData</a></li>
<li><a href="#L65">ArrayToken</a></li>
<li><a href="#L5884">generate_subscripts_fctx</a></li>
<li><a href="#L5889">generate_subscripts_fctx</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L4797">ArrayCast</a></li>
<li><a href="#L4808">ArrayCastAndSet</a></li>
<li><a href="#L961">CopyArrayEls</a></li>
<li><a href="#L1454">ReadArrayBinary</a></li>
<li><a href="#L402">ReadArrayDimensions</a></li>
<li><a href="#L579">ReadArrayStr</a></li>
<li><a href="#L796">ReadArrayToken</a></li>
<li><a href="#L519">ReadDimensionInt</a></li>
<li><a href="#L5331">accumArrayResult</a></li>
<li><a href="#L5808">accumArrayResultAny</a></li>
<li><a href="#L5531">accumArrayResultArr</a></li>
<li><a href="#L4947">array_bitmap_copy</a></li>
<li><a href="#L1790">array_cardinality</a></li>
<li><a href="#L3966">array_cmp</a></li>
<li><a href="#L4362">array_contain_compare</a></li>
<li><a href="#L3748">array_contains_nulls</a></li>
<li><a href="#L4917">array_copy</a></li>
<li><a href="#L4578">array_create_iterator</a></li>
<li><a href="#L1668">array_dims</a></li>
<li><a href="#L3795">array_eq</a></li>
<li><a href="#L5078">array_extract_slice</a></li>
<li><a href="#L6012">array_fill</a></li>
<li><a href="#L6064">array_fill_internal</a></li>
<li><a href="#L5971">array_fill_with_lower_bounds</a></li>
<li><a href="#L4740">array_free_iterator</a></li>
<li><a href="#L3948">array_ge</a></li>
<li><a href="#L1820">array_get_element</a></li>
<li><a href="#L1921">array_get_element_expanded</a></li>
<li><a href="#L4762">array_get_isnull</a></li>
<li><a href="#L2030">array_get_slice</a></li>
<li><a href="#L3936">array_gt</a></li>
<li><a href="#L179">array_in</a></li>
<li><a href="#L5151">array_insert_slice</a></li>
<li><a href="#L4657">array_iterate</a></li>
<li><a href="#L5866">array_larger</a></li>
<li><a href="#L3942">array_le</a></li>
<li><a href="#L1763">array_length</a></li>
<li><a href="#L1706">array_lower</a></li>
<li><a href="#L3930">array_lt</a></li>
<li><a href="#L3194">array_map</a></li>
<li><a href="#L1652">array_ndims</a></li>
<li><a href="#L3924">array_ne</a></li>
<li><a href="#L4895">array_nelems_size</a></li>
<li><a href="#L1016">array_out</a></li>
<li><a href="#L1271">array_recv</a></li>
<li><a href="#L3139">array_ref</a></li>
<li><a href="#L6618">array_remove</a></li>
<li><a href="#L6640">array_replace</a></li>
<li><a href="#L6360">array_replace_internal</a></li>
<li><a href="#L4847">array_seek</a></li>
<li><a href="#L1548">array_send</a></li>
<li><a href="#L3156">array_set</a></li>
<li><a href="#L2201">array_set_element</a></li>
<li><a href="#L2501">array_set_element_expanded</a></li>
<li><a href="#L4779">array_set_isnull</a></li>
<li><a href="#L2806">array_set_slice</a></li>
<li><a href="#L5018">array_slice_size</a></li>
<li><a href="#L5875">array_smaller</a></li>
<li><a href="#L6233">array_unnest</a></li>
<li><a href="#L6324">array_unnest_support</a></li>
<li><a href="#L1733">array_upper</a></li>
<li><a href="#L4541">arraycontained</a></li>
<li><a href="#L4523">arraycontains</a></li>
<li><a href="#L4505">arrayoverlap</a></li>
<li><a href="#L3954">btarraycmp</a></li>
<li><a href="#L3354">construct_array</a></li>
<li><a href="#L3374">construct_array_builtin</a></li>
<li><a href="#L3561">construct_empty_array</a></li>
<li><a href="#L3578">construct_empty_expanded_array</a></li>
<li><a href="#L3475">construct_md_array</a></li>
<li><a href="#L6047">create_array_envelope</a></li>
<li><a href="#L3612">deconstruct_array</a></li>
<li><a href="#L3678">deconstruct_array_builtin</a></li>
<li><a href="#L5896">generate_subscripts</a></li>
<li><a href="#L5960">generate_subscripts_nodir</a></li>
<li><a href="#L4139">hash_array</a></li>
<li><a href="#L4272">hash_array_extended</a></li>
<li><a href="#L5274">initArrayResult</a></li>
<li><a href="#L5763">initArrayResultAny</a></li>
<li><a href="#L5485">initArrayResultArr</a></li>
<li><a href="#L5291">initArrayResultWithSize</a></li>
<li><a href="#L5401">makeArrayResult</a></li>
<li><a href="#L5836">makeArrayResultAny</a></li>
<li><a href="#L5684">makeArrayResultArr</a></li>
<li><a href="#L5433">makeMdArrayResult</a></li>
<li><a href="#L6901">trim_array</a></li>
<li><a href="#L6669">width_bucket_array</a></li>
<li><a href="#L6776">width_bucket_array_fixed</a></li>
<li><a href="#L6732">width_bucket_array_float8</a></li>
<li><a href="#L6831">width_bucket_array_variable</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L50">AARR_FREE_IF_COPY</a></li>
<li><a href="#L1202">APPENDCHAR</a></li>
<li><a href="#L1251">APPENDCHAR</a></li>
<li><a href="#L1201">APPENDSTR</a></li>
<li><a href="#L1250">APPENDSTR</a></li>
<li><a href="#L48">ASSGN</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * arrayfuncs.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Support <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for arrays.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/adt/arrayfuncs.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;ctype.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;math.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/int.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;funcapi.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/pqformat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/nodeFuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/supportnodes.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/optimizer.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/scansup.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;port/pg_bitutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/array.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/arrayaccess.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/datum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgroids.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/selfuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/typcache.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC parameter<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L43">&#x200c;</a></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">Array_nulls</span> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Local definitions<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L48">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ASSGN</span>&nbsp; &nbsp;&nbsp; </span><span class="Constant">&quot;=&quot;<br/></li>
<li></span><br/></li>
<li><a id="L50">&#x200c;</a><span class="PreProc">#define <span class="linkable">AARR_FREE_IF_COPY</span>(array,n) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">do</span><span class="PreProc"> { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="PreProc"> (!VARATT_IS_EXPANDED_HEADER(array)) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_FREE_IF_COPY(array, n); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; } </span><span class="Statement">while</span><span class="PreProc"> (</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* <a href="#L796" title="utils/adt/arrayfuncs.c:796">ReadArrayToken</a> return type */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">enum<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; ATOK_LEVEL_START,<br/></li>
<li>&nbsp; &nbsp; ATOK_LEVEL_END,<br/></li>
<li>&nbsp; &nbsp; ATOK_DELIM,<br/></li>
<li>&nbsp; &nbsp; ATOK_ELEM,<br/></li>
<li>&nbsp; &nbsp; ATOK_ELEM_NULL,<br/></li>
<li>&nbsp; &nbsp; ATOK_ERROR,<br/></li>
<li><a id="L65">&#x200c;</a>} <span class="linkable">ArrayToken</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Working state for <a href="#L4657" title="utils/adt/arrayfuncs.c:4657">array_iterate</a>() */<br/></li>
<li><a id="L68">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">ArrayIteratorData</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* basic info about the array, set up during <a href="#L4578" title="utils/adt/arrayfuncs.c:4578">array_create_iterator</a>() */<br/></li>
<li></span>&nbsp; &nbsp; ArrayType&nbsp; *arr;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* array we're iterating through */<br/></li>
<li></span>&nbsp; &nbsp; bits8&nbsp; &nbsp; &nbsp;&nbsp; *nullbitmap;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* its null bitmap, if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nitems;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* total number of elements in array */<br/></li>
<li></span>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; typlen;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type's length */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; typbyval;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type's byval property */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; typalign;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type's align property */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* information about the requested slice size */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slice_ndim;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* slice dimension, or 0 if not slicing */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slice_len;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* number of elements per slice */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *slice_dims;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* slice dims array */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *slice_lbound;&nbsp; &nbsp; <span class="Comment">/* slice lbound array */<br/></li>
<li></span>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *slice_values;&nbsp; &nbsp; <span class="Comment">/* workspace of length slice_len */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *slice_nulls;&nbsp; &nbsp; <span class="Comment">/* workspace of length slice_len */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* current position information, updated on each iteration */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *data_ptr;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* our current position in the array */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; current_item;&nbsp; &nbsp; <span class="Comment">/* the item # we're at in the array */<br/></li>
<li><a id="L89">&#x200c;</a></span>}&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">ArrayIteratorData</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L402" title="utils/adt/arrayfuncs.c:402">ReadArrayDimensions</a>(<span class="Type">char</span> **srcptr, <span class="Type">int</span> *ndim_p,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> *dim, <span class="Type">int</span> *lBound,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *origStr, Node *escontext);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L519" title="utils/adt/arrayfuncs.c:519">ReadDimensionInt</a>(<span class="Type">char</span> **srcptr, <span class="Type">int</span> *result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *origStr, Node *escontext);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L579" title="utils/adt/arrayfuncs.c:579">ReadArrayStr</a>(<span class="Type">char</span> **srcptr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; FmgrInfo *inputproc, Oid typioparam, int32 typmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">char</span> typdelim,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> typlen, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> typbyval, <span class="Type">char</span> typalign,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> *ndim_p, <span class="Type">int</span> *dim,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> *nitems_p,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum **values_p, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> **nulls_p,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *origStr, Node *escontext);<br/></li>
<li><span class="Type">static</span> <a href="#L65" title="utils/adt/arrayfuncs.c:65">ArrayToken</a> <a href="#L796" title="utils/adt/arrayfuncs.c:796">ReadArrayToken</a>(<span class="Type">char</span> **srcptr, StringInfo elembuf, <span class="Type">char</span> typdelim,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *origStr, Node *escontext);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1454" title="utils/adt/arrayfuncs.c:1454">ReadArrayBinary</a>(StringInfo buf, <span class="Type">int</span> nitems,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FmgrInfo *receiveproc, Oid typioparam, int32 typmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> typlen, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> typbyval, <span class="Type">char</span> typalign,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum *<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *nulls,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *hasnulls, int32 *nbytes);<br/></li>
<li><span class="Type">static</span> Datum <a href="#L1921" title="utils/adt/arrayfuncs.c:1921">array_get_element_expanded</a>(Datum arraydatum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> nSubscripts, <span class="Type">int</span> *indx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> arraytyplen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> elmlen, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> elmbyval, <span class="Type">char</span> elmalign,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isNull);<br/></li>
<li><span class="Type">static</span> Datum <a href="#L2501" title="utils/adt/arrayfuncs.c:2501">array_set_element_expanded</a>(Datum arraydatum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> nSubscripts, <span class="Type">int</span> *indx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum dataValue, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isNull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> arraytyplen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> elmlen, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> elmbyval, <span class="Type">char</span> elmalign);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L4762" title="utils/adt/arrayfuncs.c:4762">array_get_isnull</a>(<span class="Type">const</span> bits8 *nullbitmap, <span class="Type">int</span> offset);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4779" title="utils/adt/arrayfuncs.c:4779">array_set_isnull</a>(bits8 *nullbitmap, <span class="Type">int</span> offset, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isNull);<br/></li>
<li><span class="Type">static</span> Datum <a href="#L4797" title="utils/adt/arrayfuncs.c:4797">ArrayCast</a>(<span class="Type">char</span> *value, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> byval, <span class="Type">int</span> len);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L4808" title="utils/adt/arrayfuncs.c:4808">ArrayCastAndSet</a>(Datum src,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> typlen, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> typbyval, <span class="Type">char</span> typalign,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span> *dest);<br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<a href="#L4847" title="utils/adt/arrayfuncs.c:4847">array_seek</a>(<span class="Type">char</span> *ptr, <span class="Type">int</span> offset, bits8 *nullbitmap, <span class="Type">int</span> nitems,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> typlen, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> typbyval, <span class="Type">char</span> typalign);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L4895" title="utils/adt/arrayfuncs.c:4895">array_nelems_size</a>(<span class="Type">char</span> *ptr, <span class="Type">int</span> offset, bits8 *nullbitmap,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> nitems, <span class="Type">int</span> typlen, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> typbyval, <span class="Type">char</span> typalign);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L4917" title="utils/adt/arrayfuncs.c:4917">array_copy</a>(<span class="Type">char</span> *destptr, <span class="Type">int</span> nitems,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">char</span> *srcptr, <span class="Type">int</span> offset, bits8 *nullbitmap,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> typlen, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> typbyval, <span class="Type">char</span> typalign);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L5018" title="utils/adt/arrayfuncs.c:5018">array_slice_size</a>(<span class="Type">char</span> *arraydataptr, bits8 *arraynullsptr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> ndim, <span class="Type">int</span> *dim, <span class="Type">int</span> *lb,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> *st, <span class="Type">int</span> *endp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> typlen, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> typbyval, <span class="Type">char</span> typalign);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L5078" title="utils/adt/arrayfuncs.c:5078">array_extract_slice</a>(ArrayType *newarray,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> ndim, <span class="Type">int</span> *dim, <span class="Type">int</span> *lb,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span> *arraydataptr, bits8 *arraynullsptr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> *st, <span class="Type">int</span> *endp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> typlen, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> typbyval, <span class="Type">char</span> typalign);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L5151" title="utils/adt/arrayfuncs.c:5151">array_insert_slice</a>(ArrayType *destArray, ArrayType *origArray,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ArrayType *srcArray,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> ndim, <span class="Type">int</span> *dim, <span class="Type">int</span> *lb,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> *st, <span class="Type">int</span> *endp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> typlen, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> typbyval, <span class="Type">char</span> typalign);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L3966" title="utils/adt/arrayfuncs.c:3966">array_cmp</a>(FunctionCallInfo fcinfo);<br/></li>
<li><span class="Type">static</span> ArrayType *<a href="#L6047" title="utils/adt/arrayfuncs.c:6047">create_array_envelope</a>(<span class="Type">int</span> ndims, <span class="Type">int</span> *dimv, <span class="Type">int</span> *lbsv, <span class="Type">int</span> nbytes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid elmtype, <span class="Type">int</span> dataoffset);<br/></li>
<li><span class="Type">static</span> ArrayType *<a href="#L6064" title="utils/adt/arrayfuncs.c:6064">array_fill_internal</a>(ArrayType *dims, ArrayType *lbs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum value, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isnull, Oid elmtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FunctionCallInfo fcinfo);<br/></li>
<li><span class="Type">static</span> ArrayType *<a href="#L6360" title="utils/adt/arrayfuncs.c:6360">array_replace_internal</a>(ArrayType *array,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum search, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> search_isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum replace, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> replace_isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> remove, Oid collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; FunctionCallInfo fcinfo);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L6732" title="utils/adt/arrayfuncs.c:6732">width_bucket_array_float8</a>(Datum operand, ArrayType *thresholds);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L6776" title="utils/adt/arrayfuncs.c:6776">width_bucket_array_fixed</a>(Datum operand,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ArrayType *thresholds,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TypeCacheEntry *typentry);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L6831" title="utils/adt/arrayfuncs.c:6831">width_bucket_array_variable</a>(Datum operand,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ArrayType *thresholds,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TypeCacheEntry *typentry);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L179" title="utils/adt/arrayfuncs.c:179">array_in</a> :<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; converts an array from the external format in &quot;string&quot; to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; its <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> format.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * return value :<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> representation of the input array<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L179">&#x200c;</a><span class="linkable">array_in</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *string = PG_GETARG_CSTRING(<span class="Constant">0</span>);&nbsp; &nbsp; <span class="Comment">/* external form */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; element_type = PG_GETARG_OID(<span class="Constant">1</span>);&nbsp; &nbsp; <span class="Comment">/* type of an array<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> */<br/></li>
<li></span>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; typmod = PG_GETARG_INT32(<span class="Constant">2</span>);&nbsp; &nbsp; <span class="Comment">/* typmod for array elements */<br/></li>
<li></span>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *escontext = fcinfo-&gt;context;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; typbyval;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; typalign;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; typdelim;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typioparam;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *p;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nitems;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *nulls;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; hasnulls;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; nbytes;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; dataoffset;<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *retval;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndim,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dim[MAXDIM],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lBound[MAXDIM];<br/></li>
<li>&nbsp; &nbsp; ArrayMetaState *my_extra;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We arrange to look up info about <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type, including its input<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * conversion proc, only once per series of calls, assuming the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * type doesn't change underneath us.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; my_extra = (ArrayMetaState *) fcinfo-&gt;flinfo-&gt;fn_extra;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (my_extra == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;flinfo-&gt;fn_extra = <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(fcinfo-&gt;flinfo-&gt;fn_mcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ArrayMetaState));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra = (ArrayMetaState *) fcinfo-&gt;flinfo-&gt;fn_extra;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;element_type = ~element_type;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (my_extra-&gt;element_type != element_type)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Get info about <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type, including its input conversion proc<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L2325" title="utils/cache/lsyscache.c:2325">get_type_io_data</a>(element_type, IOFunc_input,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;my_extra-&gt;typlen, &amp;my_extra-&gt;typbyval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;my_extra-&gt;typalign, &amp;my_extra-&gt;typdelim,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;my_extra-&gt;typioparam, &amp;my_extra-&gt;typiofunc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../fmgr/fmgr.c.html#L137" title="utils/fmgr/fmgr.c:137">fmgr_info_cxt</a>(my_extra-&gt;typiofunc, &amp;my_extra-&gt;proc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;flinfo-&gt;fn_mcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;element_type = element_type;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; typlen = my_extra-&gt;typlen;<br/></li>
<li>&nbsp; &nbsp; typbyval = my_extra-&gt;typbyval;<br/></li>
<li>&nbsp; &nbsp; typalign = my_extra-&gt;typalign;<br/></li>
<li>&nbsp; &nbsp; typdelim = my_extra-&gt;typdelim;<br/></li>
<li>&nbsp; &nbsp; typioparam = my_extra-&gt;typioparam;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize dim[] and lBound[] for <a href="#L579" title="utils/adt/arrayfuncs.c:579">ReadArrayStr</a>, in case there is no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * explicit dimension info.&nbsp; (If there is, <a href="#L402" title="utils/adt/arrayfuncs.c:402">ReadArrayDimensions</a> will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * overwrite this.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; MAXDIM; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dim[i] = -<span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* indicates &quot;not yet known&quot; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; lBound[i] = <span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* default <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Start processing the input string.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the input string starts with dimension info, read and use that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Otherwise, we'll determine the dimensions during <a href="#L579" title="utils/adt/arrayfuncs.c:579">ReadArrayStr</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; p = string;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L402" title="utils/adt/arrayfuncs.c:402">ReadArrayDimensions</a>(&amp;p, &amp;ndim, dim, lBound, string, escontext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Datum) <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ndim == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No array dimensions, so <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> character should be a left brace */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*p != <span class="Constant">'{'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;malformed array literal: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, string),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Array value must start with </span><span class="Special">\&quot;</span><span class="Constant">{</span><span class="Special">\&quot;</span><span class="Constant"> or dimension information.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If array dimensions are given, expect '=' operator */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strncmp(p, <a href="#L48" title="utils/adt/arrayfuncs.c:48">ASSGN</a>, strlen(<a href="#L48" title="utils/adt/arrayfuncs.c:48">ASSGN</a>)) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;malformed array literal: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, string),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Missing </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> after array dimensions.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L48" title="utils/adt/arrayfuncs.c:48">ASSGN</a>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; p += strlen(<a href="#L48" title="utils/adt/arrayfuncs.c:48">ASSGN</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Allow whitespace after it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (<a href="../../parser/scansup.c.html#L117" title="parser/scansup.c:117">scanner_isspace</a>(*p))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*p != <span class="Constant">'{'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;malformed array literal: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, string),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Array contents must start with </span><span class="Special">\&quot;</span><span class="Constant">{</span><span class="Special">\&quot;</span><span class="Constant">.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Parse the value part, in the curly braces: { ... } */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L579" title="utils/adt/arrayfuncs.c:579">ReadArrayStr</a>(&amp;p,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;my_extra-&gt;proc, typioparam, typmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typdelim,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typlen, typbyval, typalign,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;ndim,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dim,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;nitems,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, &amp;nulls,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; string,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; escontext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Datum) <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* only whitespace is allowed after the closing brace */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (*p)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../parser/scansup.c.html#L117" title="parser/scansup.c:117">scanner_isspace</a>(*p++))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;malformed array literal: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, string),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Junk after closing right brace.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Empty array? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nitems == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_ARRAYTYPE_P(<a href="#L3561" title="utils/adt/arrayfuncs.c:3561">construct_empty_array</a>(element_type));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check for nulls, compute total data space needed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; hasnulls = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; nbytes = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; nitems; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nulls[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hasnulls = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* let's just make sure data is not toasted */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typlen == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i] = PointerGetDatum(PG_DETOAST_DATUM(<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i]));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbytes = att_addlength_datum(nbytes, typlen, <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbytes = att_align_nominal(nbytes, typalign);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check for overflow of total request */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!AllocSizeIsValid(nbytes))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;array size exceeds the maximum allowed (</span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">int</span>) MaxAllocSize)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (hasnulls)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dataoffset = ARR_OVERHEAD_WITHNULLS(ndim, nitems);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nbytes += dataoffset;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dataoffset = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* marker for no null bitmap */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nbytes += ARR_OVERHEAD_NONULLS(ndim);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Construct the final array datum<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; retval = (ArrayType *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(nbytes);<br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(retval, nbytes);<br/></li>
<li>&nbsp; &nbsp; retval-&gt;ndim = ndim;<br/></li>
<li>&nbsp; &nbsp; retval-&gt;dataoffset = dataoffset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This comes from the array's pg_type.typelem (which points to the base<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * data type's pg_type.oid) and stores system oids in user tables. This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * oid must be preserved by binary upgrades.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; retval-&gt;elemtype = element_type;<br/></li>
<li>&nbsp; &nbsp; memcpy(ARR_DIMS(retval), dim, ndim * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; memcpy(ARR_LBOUND(retval), lBound, ndim * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L961" title="utils/adt/arrayfuncs.c:961">CopyArrayEls</a>(retval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, nulls, nitems,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typlen, typbyval, typalign,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(nulls);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_ARRAYTYPE_P(retval);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L402" title="utils/adt/arrayfuncs.c:402">ReadArrayDimensions</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; parses the array dimensions part of the input and converts the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; to <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> format.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On entry, *srcptr points to the string to <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>. It is advanced to point<br/></li>
<li></span><span class="Comment"> * after whitespace (if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>) and dimension info (if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * *ndim_p, dim[], and lBound[] are output variables. They are filled with the<br/></li>
<li></span><span class="Comment"> * number of dimensions (&lt;= MAXDIM), the lengths of each dimension, and the<br/></li>
<li></span><span class="Comment"> * <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> subscript bounds, respectively.&nbsp; If no dimension info appears,<br/></li>
<li></span><span class="Comment"> * *ndim_p will be set to zero, and dim[] and lBound[] are unchanged.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'origStr' is the original input string, used only in error messages.<br/></li>
<li></span><span class="Comment"> * If *escontext points to an ErrorSaveContext, details of <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> error are<br/></li>
<li></span><span class="Comment"> * reported there.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Result:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; true for success, false for failure (if escontext is provided).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that dim[] and lBound[] are allocated by the caller, and must have<br/></li>
<li></span><span class="Comment"> * MAXDIM elements.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L402">&#x200c;</a></span><span class="linkable">ReadArrayDimensions</span>(<span class="Type">char</span> **srcptr, <span class="Type">int</span> *ndim_p, <span class="Type">int</span> *dim, <span class="Type">int</span> *lBound,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *origStr, Node *escontext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *p = *srcptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndim;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Dimension info takes the form of one or more [n] or [m:n] items.&nbsp; This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * loop iterates once per dimension item.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ndim = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *q;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ub;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: we currently allow whitespace between, but not within,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * dimension items.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (<a href="../../parser/scansup.c.html#L117" title="parser/scansup.c:117">scanner_isspace</a>(*p))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*p != <span class="Constant">'['</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no more dimension items */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; p++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ndim &gt;= MAXDIM)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;number of array dimensions exceeds the maximum allowed (</span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MAXDIM)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; q = p;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L519" title="utils/adt/arrayfuncs.c:519">ReadDimensionInt</a>(&amp;p, &amp;i, origStr, escontext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (p == q)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no digits? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;malformed array literal: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, origStr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;</span><span class="Special">\&quot;</span><span class="Constant">[</span><span class="Special">\&quot;</span><span class="Constant"> must introduce explicitly-specified array dimensions.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*p == <span class="Constant">':'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* [m:n] format */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lBound[ndim] = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; q = p;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L519" title="utils/adt/arrayfuncs.c:519">ReadDimensionInt</a>(&amp;p, &amp;ub, origStr, escontext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (p == q)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no digits? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;malformed array literal: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, origStr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Missing array dimension value.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* [n] format */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lBound[ndim] = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ub = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*p != <span class="Constant">']'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;malformed array literal: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, origStr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Missing </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> after array dimensions.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;]&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; p++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: we could <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> ub = lb-1 to represent a zero-length<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * dimension.&nbsp; However, that would result in an empty array, for which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we don't keep <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> dimension data, so that e.g. [1:0] and [101:100]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * would be equivalent.&nbsp; Given the lack of field demand, there seems<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * little point in allowing such cases.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ub &lt; lBound[ndim])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ARRAY_SUBSCRIPT_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound cannot be less than <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Upper bound of INT_MAX must be disallowed, cf <a href="arrayutils.c.html#L117" title="utils/adt/arrayutils.c:117">ArrayCheckBounds</a>() */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ub == <span class="Constant">INT_MAX</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;array <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound is too large: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, ub)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Compute &quot;ub - lBound[ndim] + 1&quot;, detecting overflow */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pg_sub_s32_overflow(ub, lBound[ndim], &amp;ub) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_add_s32_overflow(ub, <span class="Constant">1</span>, &amp;ub))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;array size exceeds the maximum allowed (</span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">int</span>) MaxArraySize)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dim[ndim] = ub;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ndim++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *srcptr = p;<br/></li>
<li>&nbsp; &nbsp; *ndim_p = ndim;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L519" title="utils/adt/arrayfuncs.c:519">ReadDimensionInt</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> an integer, for the array dimensions<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On entry, *srcptr points to the string to <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>. It is advanced past the<br/></li>
<li></span><span class="Comment"> * digits of the integer. If there are no digits, returns true and leaves<br/></li>
<li></span><span class="Comment"> * *srcptr unchanged.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Result:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; true for success, false for failure (if escontext is provided).<br/></li>
<li></span><span class="Comment"> *&nbsp; On success, the parsed integer is returned in *result.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L519">&#x200c;</a></span><span class="linkable">ReadDimensionInt</span>(<span class="Type">char</span> **srcptr, <span class="Type">int</span> *result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *origStr, Node *escontext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *p = *srcptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* don't <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> leading whitespace */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!isdigit((<span class="Type">unsigned</span> <span class="Type">char</span>) *p) &amp;&amp; *p != <span class="Constant">'-'</span> &amp;&amp; *p != <span class="Constant">'+'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *result = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; l = strtol(p, srcptr, <span class="Constant">10</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">ERANGE</span> || l &gt; PG_INT32_MAX || l &lt; PG_INT32_MIN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;array bound is out of integer <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *result = (<span class="Type">int</span>) l;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L579" title="utils/adt/arrayfuncs.c:579">ReadArrayStr</a> :<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; parses the array string pointed to by *srcptr and converts the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; to <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> format.&nbsp; Determines the array dimensions as it goes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On entry, *srcptr points to the string to <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> (it must point to a '{').<br/></li>
<li></span><span class="Comment"> * On successful return, it is advanced to point past the closing '}'.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If dimensions were specified explicitly, they are passed in *ndim_p and<br/></li>
<li></span><span class="Comment"> * dim[].&nbsp; This function will check that the array <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> match the specified<br/></li>
<li></span><span class="Comment"> * dimensions.&nbsp; If dimensions were not given, caller must pass *ndim_p == 0<br/></li>
<li></span><span class="Comment"> * and <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> all elements of dim[] to -1.&nbsp; Then this function will<br/></li>
<li></span><span class="Comment"> * deduce the dimensions from the structure of the input and store them in<br/></li>
<li></span><span class="Comment"> * *ndim_p and the dim[] array.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Element type information:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; inputproc: type-specific input procedure for <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> datatype.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; typioparam, typmod: auxiliary <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to pass to inputproc.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; typdelim: the value delimiter (type-specific).<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; typlen, typbyval, typalign: storage parameters of <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> datatype.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Outputs:<br/></li>
<li></span><span class="Comment"> *&nbsp; *ndim_p, dim: dimensions deduced from the input structure.<br/></li>
<li></span><span class="Comment"> *&nbsp; *nitems_p: total number of elements.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; *values_p[]: <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d array, filled with converted data <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; *nulls_p[]: <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d array, filled with is-null markers.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'origStr' is the original input string, used only in error messages.<br/></li>
<li></span><span class="Comment"> * If *escontext points to an ErrorSaveContext, details of <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> error are<br/></li>
<li></span><span class="Comment"> * reported there.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Result:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; true for success, false for failure (if escontext is provided).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L579">&#x200c;</a></span><span class="linkable">ReadArrayStr</span>(<span class="Type">char</span> **srcptr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; FmgrInfo *inputproc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid typioparam,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; int32 typmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">char</span> typdelim,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> typlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> typbyval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">char</span> typalign,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> *ndim_p,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> *dim,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> *nitems_p,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum **values_p,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> **nulls_p,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *origStr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Node *escontext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndim = *ndim_p;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; dimensions_specified = (ndim != <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxitems;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *nulls;<br/></li>
<li>&nbsp; &nbsp; StringInfoData elembuf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nest_level;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nitems;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; ndim_frozen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; expect_delim;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nelems[MAXDIM];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allocate some starting output workspace; we'll enlarge as needed */<br/></li>
<li></span>&nbsp; &nbsp; maxitems = <span class="Constant">16</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> = palloc_array(Datum, maxitems);<br/></li>
<li>&nbsp; &nbsp; nulls = palloc_array(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>, maxitems);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allocate workspace to hold (string representation of) one <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> */<br/></li>
<li></span>&nbsp; &nbsp; initStringInfo(&amp;elembuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Loop below assumes first token is ATOK_LEVEL_START */<br/></li>
<li></span>&nbsp; &nbsp; Assert(**srcptr == <span class="Constant">'{'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Parse tokens until we reach the matching right brace */<br/></li>
<li></span>&nbsp; &nbsp; nest_level = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; nitems = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; ndim_frozen = dimensions_specified;<br/></li>
<li>&nbsp; &nbsp; expect_delim = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L65" title="utils/adt/arrayfuncs.c:65">ArrayToken</a>&nbsp; &nbsp; tok;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tok = <a href="#L796" title="utils/adt/arrayfuncs.c:796">ReadArrayToken</a>(srcptr, &amp;elembuf, typdelim, origStr, escontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (tok)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> ATOK_LEVEL_START:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Can't write left brace where delim is expected */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (expect_delim)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;malformed array literal: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, origStr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Unexpected </span><span class="Special">\&quot;%c\&quot;</span><span class="Constant"> character.&quot;</span>, <span class="Constant">'{'</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Initialize <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> counting in the new level */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nest_level &gt;= MAXDIM)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;number of array dimensions exceeds the maximum allowed (</span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MAXDIM)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nelems[nest_level] = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nest_level++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nest_level &gt; ndim)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Can't increase ndim once it's frozen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ndim_frozen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> dimension_error;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndim = nest_level;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> ATOK_LEVEL_END:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Can't get here with nest_level == 0 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(nest_level &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We allow a right brace to terminate an empty sub-array,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * otherwise it must occur where we expect a delimiter.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nelems[nest_level - <span class="Constant">1</span>] &gt; <span class="Constant">0</span> &amp;&amp; !expect_delim)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;malformed array literal: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, origStr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Unexpected </span><span class="Special">\&quot;%c\&quot;</span><span class="Constant"> character.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">'}'</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nest_level--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Nested sub-arrays count as elements of outer level */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nest_level &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nelems[nest_level - <span class="Constant">1</span>]++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: if we had dimensionality info, then dim[nest_level]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is initially non-negative, and we'll check each sub-array's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * length against that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dim[nest_level] &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Save length of first sub-array of this level */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dim[nest_level] = nelems[nest_level];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (nelems[nest_level] != dim[nest_level])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Subsequent sub-arrays must have same length */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> dimension_error;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Must have a delim or another right brace following, unless<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we have reached nest_level 0, where this won't matter.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expect_delim = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> ATOK_DELIM:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!expect_delim)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;malformed array literal: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, origStr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Unexpected </span><span class="Special">\&quot;%c\&quot;</span><span class="Constant"> character.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typdelim)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expect_delim = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> ATOK_ELEM:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> ATOK_ELEM_NULL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Can't get here with nest_level == 0 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(nest_level &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Disallow consecutive ELEM tokens */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (expect_delim)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;malformed array literal: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, origStr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Unexpected array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Enlarge the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>/nulls arrays if needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nitems &gt;= maxitems)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (maxitems &gt;= MaxArraySize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;array size exceeds the maximum allowed (</span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">int</span>) MaxArraySize)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxitems = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(maxitems * <span class="Constant">2</span>, MaxArraySize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> = repalloc_array(<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, Datum, maxitems);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls = repalloc_array(nulls, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>, maxitems);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Read the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>'s value, or check that NULL is allowed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../fmgr/fmgr.c.html#L1585" title="utils/fmgr/fmgr.c:1585">InputFunctionCallSafe</a>(inputproc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (tok == ATOK_ELEM_NULL) ? <span class="Constant">NULL</span> : elembuf.data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typioparam, typmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; escontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[nitems]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[nitems] = (tok == ATOK_ELEM_NULL);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nitems++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Once we have found an <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>, the number of dimensions can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * no longer increase, and subsequent elements must all be at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the same nesting depth.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndim_frozen = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nest_level != ndim)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> dimension_error;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Count the new <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nelems[nest_level - <span class="Constant">1</span>]++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must have a delim or a right brace following */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expect_delim = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> ATOK_ERROR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (nest_level &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Clean up and return results */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(elembuf.data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *ndim_p = ndim;<br/></li>
<li>&nbsp; &nbsp; *nitems_p = nitems;<br/></li>
<li>&nbsp; &nbsp; *values_p = <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>;<br/></li>
<li>&nbsp; &nbsp; *nulls_p = nulls;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li><span class="Statement">dimension_error</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (dimensions_specified)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;malformed array literal: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, origStr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Specified array dimensions do not match array contents.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;malformed array literal: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, origStr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Multidimensional arrays must have sub-arrays with matching dimensions.&quot;</span>)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L796" title="utils/adt/arrayfuncs.c:796">ReadArrayToken</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; read one token from an array value string<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Starts scanning from *srcptr.&nbsp; On non-error return, *srcptr is<br/></li>
<li></span><span class="Comment"> * advanced past the token.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the token is ATOK_ELEM, the de-escaped string is returned in elembuf.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L65" title="utils/adt/arrayfuncs.c:65">ArrayToken</a><br/></li>
<li><a id="L796">&#x200c;</a><span class="linkable">ReadArrayToken</span>(<span class="Type">char</span> **srcptr, StringInfo elembuf, <span class="Type">char</span> typdelim,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *origStr, Node *escontext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *p = *srcptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dstlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; has_escapes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; resetStringInfo(elembuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Identify token type.&nbsp; Loop advances over leading whitespace. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (*p)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Special">'\0'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> ending_error;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'{'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *srcptr = p + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> ATOK_LEVEL_START;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'}'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *srcptr = p + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> ATOK_LEVEL_END;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'&quot;'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> quoted_element;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*p == typdelim)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *srcptr = p + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> ATOK_DELIM;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../parser/scansup.c.html#L117" title="parser/scansup.c:117">scanner_isspace</a>(*p))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> unquoted_element;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="Statement">quoted_element</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (*p)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Special">'\0'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> ending_error;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Special">'\\'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Skip backslash, copy <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> character as-is. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*p == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> ending_error;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(elembuf, *p++);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'&quot;'</span>:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> non-whitespace isn't typdelim or a brace, complain<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * about incorrect quoting.&nbsp; While we could leave such cases<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to be detected as incorrect token sequences, the resulting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * message wouldn't be as helpful.&nbsp; (We could also give the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * incorrect-quoting error when <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> is '{', but treating that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * as a token sequence error seems better.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (*(++p) != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*p == typdelim || *p == <span class="Constant">'}'</span> || *p == <span class="Constant">'{'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *srcptr = p;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> ATOK_ELEM;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../parser/scansup.c.html#L117" title="parser/scansup.c:117">scanner_isspace</a>(*p))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, ATOK_ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;malformed array literal: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, origStr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Incorrectly quoted array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> ending_error;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(elembuf, *p++);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="Statement">unquoted_element</span><span class="cUserCont">:<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't include trailing whitespace in the result.&nbsp; dstlen tracks how<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * much of the output string is known to not be trailing whitespace.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; dstlen = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; has_escapes = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (*p)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Special">'\0'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> ending_error;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'{'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, ATOK_ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;malformed array literal: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, origStr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Unexpected </span><span class="Special">\&quot;%c\&quot;</span><span class="Constant"> character.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">'{'</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'&quot;'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must double-quote all or <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> of an <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, ATOK_ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;malformed array literal: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, origStr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Incorrectly quoted array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Special">'\\'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Skip backslash, copy <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> character as-is. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*p == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> ending_error;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(elembuf, *p++);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dstlen = elembuf-&gt;len;&nbsp; &nbsp; <span class="Comment">/* treat it as non-whitespace */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; has_escapes = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* End of elem? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*p == typdelim || *p == <span class="Constant">'}'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* hack: truncate the output string to dstlen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elembuf-&gt;data[dstlen] = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elembuf-&gt;len = dstlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *srcptr = p;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check if it's unquoted &quot;NULL&quot; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L43" title="utils/adt/arrayfuncs.c:43">Array_nulls</a> &amp;&amp; !has_escapes &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_strcasecmp(elembuf-&gt;data, <span class="Constant">&quot;NULL&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> ATOK_ELEM_NULL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> ATOK_ELEM;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(elembuf, *p);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../parser/scansup.c.html#L117" title="parser/scansup.c:117">scanner_isspace</a>(*p))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dstlen = elembuf-&gt;len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="Statement">ending_error</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; ereturn(escontext, ATOK_ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;malformed array literal: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, origStr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Unexpected end of input.&quot;</span>)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Copy data into an array object from a temporary array of Datums.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * array: array object (with header fields already filled in)<br/></li>
<li></span><span class="Comment"> * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>: array of Datums to be copied<br/></li>
<li></span><span class="Comment"> * nulls: array of is-null flags (can be NULL if no nulls)<br/></li>
<li></span><span class="Comment"> * nitems: number of Datums to be copied<br/></li>
<li></span><span class="Comment"> * typbyval, typlen, typalign: info about <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> datatype<br/></li>
<li></span><span class="Comment"> * freedata: if true and <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type is pass-by-ref, <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a> data <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment"> * referenced by Datums after copying them.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the input data is of varlena type, the caller must have ensured that<br/></li>
<li></span><span class="Comment"> * the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are not toasted.&nbsp; (Doing it here doesn't work since the<br/></li>
<li></span><span class="Comment"> * caller has already allocated space for the array...)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L961">&#x200c;</a></span><span class="linkable">CopyArrayEls</span>(ArrayType *array,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum *<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *nulls,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> nitems,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> typlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> typbyval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">char</span> typalign,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> freedata)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *p = ARR_DATA_PTR(array);<br/></li>
<li>&nbsp; &nbsp; bits8&nbsp; &nbsp; &nbsp;&nbsp; *bitmap = ARR_NULLBITMAP(array);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitval = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitmask = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (typbyval)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; freedata = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nitems; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nulls &amp;&amp; nulls[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!bitmap)&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* shouldn't happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;null array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> where not supported&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* bitmap <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> stays 0 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitval |= bitmask;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p += <a href="#L4808" title="utils/adt/arrayfuncs.c:4808">ArrayCastAndSet</a>(<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i], typlen, typbyval, typalign, p);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (freedata)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(DatumGetPointer(<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i]));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bitmap)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitmask &lt;&lt;= <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bitmask == <span class="Constant">0x100</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *bitmap++ = bitval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitval = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitmask = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (bitmap &amp;&amp; bitmask != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *bitmap = bitval;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1016" title="utils/adt/arrayfuncs.c:1016">array_out</a> :<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; takes the <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> representation of an array and returns a string<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; containing the array in its external format.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1016">&#x200c;</a><span class="linkable">array_out</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; AnyArrayType *v = PG_GETARG_ANY_ARRAY_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; element_type = AARR_ELEMTYPE(v);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; typbyval;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; typalign;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; typdelim;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *p,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *tmp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *retval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; **<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dims_str[(MAXDIM * <span class="Constant">33</span>) + <span class="Constant">2</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 33 per dim since we assume 15 digits per number + ':' +'[]'<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * +2 allows for assignment operator + trailing null<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *needquotes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; needdims = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; overall_length;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nitems,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; k,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indx[MAXDIM];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndim,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *dims,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *lb;<br/></li>
<li>&nbsp; &nbsp; array_iter&nbsp; &nbsp; iter;<br/></li>
<li>&nbsp; &nbsp; ArrayMetaState *my_extra;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We arrange to look up info about <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type, including its output<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * conversion proc, only once per series of calls, assuming the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * type doesn't change underneath us.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; my_extra = (ArrayMetaState *) fcinfo-&gt;flinfo-&gt;fn_extra;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (my_extra == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;flinfo-&gt;fn_extra = <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(fcinfo-&gt;flinfo-&gt;fn_mcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ArrayMetaState));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra = (ArrayMetaState *) fcinfo-&gt;flinfo-&gt;fn_extra;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;element_type = ~element_type;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (my_extra-&gt;element_type != element_type)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Get info about <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type, including its output conversion proc<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L2325" title="utils/cache/lsyscache.c:2325">get_type_io_data</a>(element_type, IOFunc_output,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;my_extra-&gt;typlen, &amp;my_extra-&gt;typbyval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;my_extra-&gt;typalign, &amp;my_extra-&gt;typdelim,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;my_extra-&gt;typioparam, &amp;my_extra-&gt;typiofunc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../fmgr/fmgr.c.html#L137" title="utils/fmgr/fmgr.c:137">fmgr_info_cxt</a>(my_extra-&gt;typiofunc, &amp;my_extra-&gt;proc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;flinfo-&gt;fn_mcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;element_type = element_type;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; typlen = my_extra-&gt;typlen;<br/></li>
<li>&nbsp; &nbsp; typbyval = my_extra-&gt;typbyval;<br/></li>
<li>&nbsp; &nbsp; typalign = my_extra-&gt;typalign;<br/></li>
<li>&nbsp; &nbsp; typdelim = my_extra-&gt;typdelim;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ndim = AARR_NDIM(v);<br/></li>
<li>&nbsp; &nbsp; dims = AARR_DIMS(v);<br/></li>
<li>&nbsp; &nbsp; lb = AARR_LBOUND(v);<br/></li>
<li>&nbsp; &nbsp; nitems = <a href="arrayutils.c.html#L57" title="utils/adt/arrayutils.c:57">ArrayGetNItems</a>(ndim, dims);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nitems == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; retval = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<span class="Constant">&quot;{}&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_CSTRING(retval);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we will need to add explicit dimensions if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> dimension has a <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bound other than one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; ndim; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lb[i] != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; needdims = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Convert all <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to string form, count total space needed (including<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> overhead such as escaping backslashes), and detect whether each<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * item needs double quotes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> = (<span class="Type">char</span> **) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(nitems * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">char</span> *));<br/></li>
<li>&nbsp; &nbsp; needquotes = (<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(nitems * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li>&nbsp; &nbsp; overall_length = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; array_iter_setup(&amp;iter, v);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nitems; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; itemvalue;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; needquote;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get source <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>, checking for NULL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; itemvalue = array_iter_next(&amp;iter, &amp;isnull, i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typlen, typbyval, typalign);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i] = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<span class="Constant">&quot;NULL&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; overall_length += <span class="Constant">4</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; needquote = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i] = <a href="../fmgr/fmgr.c.html#L1683" title="utils/fmgr/fmgr.c:1683">OutputFunctionCall</a>(&amp;my_extra-&gt;proc, itemvalue);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* count data plus backslashes; detect chars needing quotes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i][<span class="Constant">0</span>] == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; needquote = <span class="Constant">true</span>;&nbsp; &nbsp; <span class="Comment">/* force quotes for empty string */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (pg_strcasecmp(<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i], <span class="Constant">&quot;NULL&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; needquote = <span class="Constant">true</span>;&nbsp; &nbsp; <span class="Comment">/* force quotes for literal NULL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; needquote = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (tmp = <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i]; *tmp != <span class="Special">'\0'</span>; tmp++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; ch = *tmp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; overall_length += <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ch == <span class="Constant">'&quot;'</span> || ch == <span class="Special">'\\'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; needquote = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; overall_length += <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (ch == <span class="Constant">'{'</span> || ch == <span class="Constant">'}'</span> || ch == typdelim ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../parser/scansup.c.html#L117" title="parser/scansup.c:117">scanner_isspace</a>(ch))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; needquote = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; needquotes[i] = needquote;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Count the pair of double quotes, if needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (needquote)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; overall_length += <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* and the comma (or other typdelim delimiter) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; overall_length += <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The very last array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> doesn't have a typdelim delimiter after it,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but that's OK; that space is needed for the trailing '\0'.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now count total number of curly brace pairs in output string.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = j = <span class="Constant">0</span>, k = <span class="Constant">1</span>; i &lt; ndim; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; j += k, k *= dims[i];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; overall_length += <span class="Constant">2</span> * j;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Format explicit dimensions if required */<br/></li>
<li></span>&nbsp; &nbsp; dims_str[<span class="Constant">0</span>] = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (needdims)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ptr = dims_str;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; ndim; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sprintf(ptr, <span class="Constant">&quot;[</span><span class="Special">%d</span><span class="Constant">:</span><span class="Special">%d</span><span class="Constant">]&quot;</span>, lb[i], lb[i] + dims[i] - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr += strlen(ptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *ptr++ = *<a href="#L48" title="utils/adt/arrayfuncs.c:48">ASSGN</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *ptr = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; overall_length += ptr - dims_str;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now construct the output string */<br/></li>
<li></span>&nbsp; &nbsp; retval = (<span class="Type">char</span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(overall_length);<br/></li>
<li>&nbsp; &nbsp; p = retval;<br/></li>
<li><br/></li>
<li><a id="L1201">&#x200c;</a><span class="PreProc">#define <span class="linkable">APPENDSTR</span>(str)&nbsp; &nbsp; (strcpy(p, (str)), p += strlen(p))<br/></li>
<li><a id="L1202">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">APPENDCHAR</span>(ch)&nbsp; &nbsp; (*p++ = (ch), *p = </span><span class="Special">'\0'</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (needdims)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1201" title="utils/adt/arrayfuncs.c:1201">APPENDSTR</a>(dims_str);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1202" title="utils/adt/arrayfuncs.c:1202">APPENDCHAR</a>(<span class="Constant">'{'</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; ndim; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indx[i] = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; j = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; k = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = j; i &lt; ndim - <span class="Constant">1</span>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1202" title="utils/adt/arrayfuncs.c:1202">APPENDCHAR</a>(<span class="Constant">'{'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (needquotes[k])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1202" title="utils/adt/arrayfuncs.c:1202">APPENDCHAR</a>(<span class="Constant">'&quot;'</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (tmp = <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[k]; *tmp; tmp++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; ch = *tmp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ch == <span class="Constant">'&quot;'</span> || ch == <span class="Special">'\\'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *p++ = <span class="Special">'\\'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *p++ = ch;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *p = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1202" title="utils/adt/arrayfuncs.c:1202">APPENDCHAR</a>(<span class="Constant">'&quot;'</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1201" title="utils/adt/arrayfuncs.c:1201">APPENDSTR</a>(<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[k]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[k++]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = ndim - <span class="Constant">1</span>; i &gt;= <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (++(indx[i]) &lt; dims[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1202" title="utils/adt/arrayfuncs.c:1202">APPENDCHAR</a>(typdelim);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indx[i] = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1202" title="utils/adt/arrayfuncs.c:1202">APPENDCHAR</a>(<span class="Constant">'}'</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; j = i;<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (j != -<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li><a id="L1250">&#x200c;</a><span class="PreProc">#undef <span class="linkable">APPENDSTR</span><br/></li>
<li><a id="L1251">&#x200c;</a></span><span class="PreProc">#undef <span class="linkable">APPENDCHAR</span><br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Assert that we calculated the string length accurately */<br/></li>
<li></span>&nbsp; &nbsp; Assert(overall_length == (p - retval + <span class="Constant">1</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(needquotes);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CSTRING(retval);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1271" title="utils/adt/arrayfuncs.c:1271">array_recv</a> :<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; converts an array from the external binary format to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; its <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> format.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * return value :<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> representation of the input array<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1271">&#x200c;</a><span class="linkable">array_recv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; buf = (StringInfo) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; spec_element_type = PG_GETARG_OID(<span class="Constant">1</span>);&nbsp; &nbsp; <span class="Comment">/* type of an array<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> */<br/></li>
<li></span>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; typmod = PG_GETARG_INT32(<span class="Constant">2</span>);&nbsp; &nbsp; <span class="Comment">/* typmod for array elements */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; element_type;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; typbyval;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; typalign;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typioparam;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nitems;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *dataPtr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *nullsPtr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; hasnulls;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; nbytes;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; dataoffset;<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *retval;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndim,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dim[MAXDIM],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lBound[MAXDIM];<br/></li>
<li>&nbsp; &nbsp; ArrayMetaState *my_extra;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get the array header information */<br/></li>
<li></span>&nbsp; &nbsp; ndim = <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(buf, <span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ndim &lt; <span class="Constant">0</span>)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we do allow zero-dimension arrays */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_BINARY_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid number of dimensions: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, ndim)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ndim &gt; MAXDIM)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;number of array dimensions (</span><span class="Special">%d</span><span class="Constant">) exceeds the maximum allowed (</span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndim, MAXDIM)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; flags = <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(buf, <span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (flags != <span class="Constant">0</span> &amp;&amp; flags != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_BINARY_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid array flags&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type recorded in the data */<br/></li>
<li></span>&nbsp; &nbsp; element_type = <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(buf, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * From a security standpoint, it doesn't matter whether the input's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type matches what we expect: the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type's receive<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * function has to be robust enough to cope with invalid data.&nbsp; However,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from a user-friendliness standpoint, it's nicer to complain about type<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * mismatches than to throw &quot;improper binary format&quot; errors.&nbsp; But there's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a problem: only built-in types have OIDs that are stable enough to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * believe that a mismatch is a real issue.&nbsp; So complain only if both OIDs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are in the built-in <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.&nbsp; Otherwise, carry on with the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we &quot;should&quot; be getting.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (element_type != spec_element_type)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (element_type &lt; FirstGenbkiObjectId &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; spec_element_type &lt; FirstGenbkiObjectId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;binary data has array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type </span><span class="Special">%u</span><span class="Constant"> (</span><span class="Special">%s</span><span class="Constant">) instead of expected </span><span class="Special">%u</span><span class="Constant"> (</span><span class="Special">%s</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; element_type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="format_type.c.html#L112" title="utils/adt/format_type.c:112">format_type_extended</a>(element_type, -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; FORMAT_TYPE_ALLOW_INVALID),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; spec_element_type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="format_type.c.html#L112" title="utils/adt/format_type.c:112">format_type_extended</a>(spec_element_type, -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; FORMAT_TYPE_ALLOW_INVALID))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; element_type = spec_element_type;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; ndim; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dim[i] = <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(buf, <span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lBound[i] = <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(buf, <span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This checks for overflow of array dimensions */<br/></li>
<li></span>&nbsp; &nbsp; nitems = <a href="arrayutils.c.html#L57" title="utils/adt/arrayutils.c:57">ArrayGetNItems</a>(ndim, dim);<br/></li>
<li>&nbsp; &nbsp; <a href="arrayutils.c.html#L117" title="utils/adt/arrayutils.c:117">ArrayCheckBounds</a>(ndim, dim, lBound);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We arrange to look up info about <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type, including its receive<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * conversion proc, only once per series of calls, assuming the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * type doesn't change underneath us.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; my_extra = (ArrayMetaState *) fcinfo-&gt;flinfo-&gt;fn_extra;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (my_extra == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;flinfo-&gt;fn_extra = <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(fcinfo-&gt;flinfo-&gt;fn_mcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ArrayMetaState));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra = (ArrayMetaState *) fcinfo-&gt;flinfo-&gt;fn_extra;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;element_type = ~element_type;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (my_extra-&gt;element_type != element_type)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get info about <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type, including its receive proc */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L2325" title="utils/cache/lsyscache.c:2325">get_type_io_data</a>(element_type, IOFunc_receive,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;my_extra-&gt;typlen, &amp;my_extra-&gt;typbyval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;my_extra-&gt;typalign, &amp;my_extra-&gt;typdelim,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;my_extra-&gt;typioparam, &amp;my_extra-&gt;typiofunc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(my_extra-&gt;typiofunc))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;no binary input function available for type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(element_type))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../fmgr/fmgr.c.html#L137" title="utils/fmgr/fmgr.c:137">fmgr_info_cxt</a>(my_extra-&gt;typiofunc, &amp;my_extra-&gt;proc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;flinfo-&gt;fn_mcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;element_type = element_type;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nitems == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Return empty array ... but not till we've validated element_type */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_ARRAYTYPE_P(<a href="#L3561" title="utils/adt/arrayfuncs.c:3561">construct_empty_array</a>(element_type));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typlen = my_extra-&gt;typlen;<br/></li>
<li>&nbsp; &nbsp; typbyval = my_extra-&gt;typbyval;<br/></li>
<li>&nbsp; &nbsp; typalign = my_extra-&gt;typalign;<br/></li>
<li>&nbsp; &nbsp; typioparam = my_extra-&gt;typioparam;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dataPtr = (Datum *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(nitems * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li>&nbsp; &nbsp; nullsPtr = (<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(nitems * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li>&nbsp; &nbsp; <a href="#L1454" title="utils/adt/arrayfuncs.c:1454">ReadArrayBinary</a>(buf, nitems,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;my_extra-&gt;proc, typioparam, typmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typlen, typbyval, typalign,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dataPtr, nullsPtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;hasnulls, &amp;nbytes);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (hasnulls)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dataoffset = ARR_OVERHEAD_WITHNULLS(ndim, nitems);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nbytes += dataoffset;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dataoffset = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* marker for no null bitmap */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nbytes += ARR_OVERHEAD_NONULLS(ndim);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; retval = (ArrayType *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(nbytes);<br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(retval, nbytes);<br/></li>
<li>&nbsp; &nbsp; retval-&gt;ndim = ndim;<br/></li>
<li>&nbsp; &nbsp; retval-&gt;dataoffset = dataoffset;<br/></li>
<li>&nbsp; &nbsp; retval-&gt;elemtype = element_type;<br/></li>
<li>&nbsp; &nbsp; memcpy(ARR_DIMS(retval), dim, ndim * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; memcpy(ARR_LBOUND(retval), lBound, ndim * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L961" title="utils/adt/arrayfuncs.c:961">CopyArrayEls</a>(retval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; dataPtr, nullsPtr, nitems,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typlen, typbyval, typalign,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(dataPtr);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(nullsPtr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_ARRAYTYPE_P(retval);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1454" title="utils/adt/arrayfuncs.c:1454">ReadArrayBinary</a>:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; collect the data elements of an array being read in binary style.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Inputs:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; buf: the data buffer to read from.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; nitems: total number of array elements (already read).<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; receiveproc: type-specific receive procedure for <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> datatype.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; typioparam, typmod: auxiliary <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to pass to receiveproc.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; typlen, typbyval, typalign: storage parameters of <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> datatype.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Outputs:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[]: filled with converted data <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; nulls[]: filled with is-null markers.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; *hasnulls: set true iff there are <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> null elements.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; *nbytes: set to total size of data area needed (including alignment<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; padding but not including array header overhead).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[] and nulls[] are allocated by the caller, and must have<br/></li>
<li></span><span class="Comment"> * nitems elements.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1454">&#x200c;</a></span><span class="linkable">ReadArrayBinary</span>(StringInfo buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> nitems,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FmgrInfo *receiveproc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid typioparam,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int32 typmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> typlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> typbyval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span> typalign,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum *<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *nulls,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *hasnulls,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int32 *nbytes)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; hasnull;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; totbytes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nitems; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; StringInfoData elem_buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get and check the item length */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; itemlen = <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(buf, <span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (itemlen &lt; -<span class="Constant">1</span> || itemlen &gt; (buf-&gt;len - buf-&gt;cursor))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_BINARY_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;insufficient data left in message&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (itemlen == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* -1 length means NULL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i] = <a href="../fmgr/fmgr.c.html#L1697" title="utils/fmgr/fmgr.c:1697">ReceiveFunctionCall</a>(receiveproc, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typioparam, typmod);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[i] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Rather than copying data around, we just <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> a StringInfo<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pointing to the correct portion of the message buffer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; initReadOnlyStringInfo(&amp;elem_buf, &amp;buf-&gt;data[buf-&gt;cursor], itemlen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf-&gt;cursor += itemlen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now call the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>'s receiveproc */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i] = <a href="../fmgr/fmgr.c.html#L1697" title="utils/fmgr/fmgr.c:1697">ReceiveFunctionCall</a>(receiveproc, &amp;elem_buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typioparam, typmod);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nulls[i] = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Trouble if it didn't eat the whole buffer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (elem_buf.cursor != itemlen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_BINARY_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;improper binary format in array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i + <span class="Constant">1</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check for nulls, compute total data space needed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; hasnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; totbytes = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nitems; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nulls[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hasnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* let's just make sure data is not toasted */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typlen == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i] = PointerGetDatum(PG_DETOAST_DATUM(<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i]));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; totbytes = att_addlength_datum(totbytes, typlen, <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; totbytes = att_align_nominal(totbytes, typalign);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check for overflow of total request */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!AllocSizeIsValid(totbytes))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;array size exceeds the maximum allowed (</span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">int</span>) MaxAllocSize)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; *hasnulls = hasnull;<br/></li>
<li>&nbsp; &nbsp; *nbytes = totbytes;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1548" title="utils/adt/arrayfuncs.c:1548">array_send</a> :<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; takes the <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> representation of an array and returns a bytea<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; containing the array in its external binary format.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1548">&#x200c;</a><span class="linkable">array_send</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; AnyArrayType *v = PG_GETARG_ANY_ARRAY_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; element_type = AARR_ELEMTYPE(v);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; typbyval;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; typalign;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nitems,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndim,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *dim,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *lb;<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li>&nbsp; &nbsp; array_iter&nbsp; &nbsp; iter;<br/></li>
<li>&nbsp; &nbsp; ArrayMetaState *my_extra;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We arrange to look up info about <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type, including its <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * conversion proc, only once per series of calls, assuming the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * type doesn't change underneath us.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; my_extra = (ArrayMetaState *) fcinfo-&gt;flinfo-&gt;fn_extra;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (my_extra == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;flinfo-&gt;fn_extra = <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(fcinfo-&gt;flinfo-&gt;fn_mcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ArrayMetaState));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra = (ArrayMetaState *) fcinfo-&gt;flinfo-&gt;fn_extra;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;element_type = ~element_type;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (my_extra-&gt;element_type != element_type)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get info about <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type, including its <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> proc */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L2325" title="utils/cache/lsyscache.c:2325">get_type_io_data</a>(element_type, IOFunc_send,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;my_extra-&gt;typlen, &amp;my_extra-&gt;typbyval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;my_extra-&gt;typalign, &amp;my_extra-&gt;typdelim,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;my_extra-&gt;typioparam, &amp;my_extra-&gt;typiofunc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(my_extra-&gt;typiofunc))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;no binary output function available for type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(element_type))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../fmgr/fmgr.c.html#L137" title="utils/fmgr/fmgr.c:137">fmgr_info_cxt</a>(my_extra-&gt;typiofunc, &amp;my_extra-&gt;proc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;flinfo-&gt;fn_mcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;element_type = element_type;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; typlen = my_extra-&gt;typlen;<br/></li>
<li>&nbsp; &nbsp; typbyval = my_extra-&gt;typbyval;<br/></li>
<li>&nbsp; &nbsp; typalign = my_extra-&gt;typalign;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ndim = AARR_NDIM(v);<br/></li>
<li>&nbsp; &nbsp; dim = AARR_DIMS(v);<br/></li>
<li>&nbsp; &nbsp; lb = AARR_LBOUND(v);<br/></li>
<li>&nbsp; &nbsp; nitems = <a href="arrayutils.c.html#L57" title="utils/adt/arrayutils.c:57">ArrayGetNItems</a>(ndim, dim);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L326" title="libpq/pqformat.c:326">pq_begintypsend</a>(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Send the array header information */<br/></li>
<li></span>&nbsp; &nbsp; pq_sendint32(&amp;buf, ndim);<br/></li>
<li>&nbsp; &nbsp; pq_sendint32(&amp;buf, AARR_HASNULL(v) ? <span class="Constant">1</span> : <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; pq_sendint32(&amp;buf, element_type);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; ndim; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pq_sendint32(&amp;buf, dim[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pq_sendint32(&amp;buf, lb[i]);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Send the array elements using the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>'s own sendproc */<br/></li>
<li></span>&nbsp; &nbsp; array_iter_setup(&amp;iter, v);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nitems; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; itemvalue;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get source <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>, checking for NULL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; itemvalue = array_iter_next(&amp;iter, &amp;isnull, i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typlen, typbyval, typalign);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* -1 length means a NULL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pq_sendint32(&amp;buf, -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *outputbytes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outputbytes = <a href="../fmgr/fmgr.c.html#L1744" title="utils/fmgr/fmgr.c:1744">SendFunctionCall</a>(&amp;my_extra-&gt;proc, itemvalue);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pq_sendint32(&amp;buf, VARSIZE(outputbytes) - VARHDRSZ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L126" title="libpq/pqformat.c:126">pq_sendbytes</a>(&amp;buf, VARDATA(outputbytes),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VARSIZE(outputbytes) - VARHDRSZ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(outputbytes);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BYTEA_P(<a href="../../libpq/pqformat.c.html#L346" title="libpq/pqformat.c:346">pq_endtypsend</a>(&amp;buf));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1652" title="utils/adt/arrayfuncs.c:1652">array_ndims</a> :<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; returns the number of dimensions of the array pointed to by &quot;v&quot;<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1652">&#x200c;</a><span class="linkable">array_ndims</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; AnyArrayType *v = PG_GETARG_ANY_ARRAY_P(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Sanity check: does it look like an array at all? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (AARR_NDIM(v) &lt;= <span class="Constant">0</span> || AARR_NDIM(v) &gt; MAXDIM)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(AARR_NDIM(v));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1668" title="utils/adt/arrayfuncs.c:1668">array_dims</a> :<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; returns the dimensions of the array pointed to by &quot;v&quot;, as a &quot;text&quot;<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1668">&#x200c;</a><span class="linkable">array_dims</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; AnyArrayType *v = PG_GETARG_ANY_ARRAY_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *p;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *dimv,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *lb;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 33 since we assume 15 digits per number + ':' +'[]'<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * +1 for trailing null<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; buf[MAXDIM * <span class="Constant">33</span> + <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Sanity check: does it look like an array at all? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (AARR_NDIM(v) &lt;= <span class="Constant">0</span> || AARR_NDIM(v) &gt; MAXDIM)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dimv = AARR_DIMS(v);<br/></li>
<li>&nbsp; &nbsp; lb = AARR_LBOUND(v);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; p = buf;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; AARR_NDIM(v); i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sprintf(p, <span class="Constant">&quot;[</span><span class="Special">%d</span><span class="Constant">:</span><span class="Special">%d</span><span class="Constant">]&quot;</span>, lb[i], dimv[i] + lb[i] - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; p += strlen(p);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(<a href="varlena.c.html#L184" title="utils/adt/varlena.c:184">cstring_to_text</a>(buf));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1706" title="utils/adt/arrayfuncs.c:1706">array_lower</a> :<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; returns the <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> dimension, of the DIM requested, for<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; the array pointed to by &quot;v&quot;, as an int4<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1706">&#x200c;</a><span class="linkable">array_lower</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; AnyArrayType *v = PG_GETARG_ANY_ARRAY_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reqdim = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *lb;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Sanity check: does it look like an array at all? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (AARR_NDIM(v) &lt;= <span class="Constant">0</span> || AARR_NDIM(v) &gt; MAXDIM)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Sanity check: was the requested dim valid */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (reqdim &lt;= <span class="Constant">0</span> || reqdim &gt; AARR_NDIM(v))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; lb = AARR_LBOUND(v);<br/></li>
<li>&nbsp; &nbsp; result = lb[reqdim - <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1733" title="utils/adt/arrayfuncs.c:1733">array_upper</a> :<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; returns the <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> dimension, of the DIM requested, for<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; the array pointed to by &quot;v&quot;, as an int4<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1733">&#x200c;</a><span class="linkable">array_upper</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; AnyArrayType *v = PG_GETARG_ANY_ARRAY_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reqdim = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *dimv,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *lb;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Sanity check: does it look like an array at all? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (AARR_NDIM(v) &lt;= <span class="Constant">0</span> || AARR_NDIM(v) &gt; MAXDIM)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Sanity check: was the requested dim valid */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (reqdim &lt;= <span class="Constant">0</span> || reqdim &gt; AARR_NDIM(v))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; lb = AARR_LBOUND(v);<br/></li>
<li>&nbsp; &nbsp; dimv = AARR_DIMS(v);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = dimv[reqdim - <span class="Constant">1</span>] + lb[reqdim - <span class="Constant">1</span>] - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1763" title="utils/adt/arrayfuncs.c:1763">array_length</a> :<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; returns the length, of the dimension requested, for<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; the array pointed to by &quot;v&quot;, as an int4<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1763">&#x200c;</a><span class="linkable">array_length</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; AnyArrayType *v = PG_GETARG_ANY_ARRAY_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reqdim = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *dimv;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Sanity check: does it look like an array at all? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (AARR_NDIM(v) &lt;= <span class="Constant">0</span> || AARR_NDIM(v) &gt; MAXDIM)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Sanity check: was the requested dim valid */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (reqdim &lt;= <span class="Constant">0</span> || reqdim &gt; AARR_NDIM(v))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dimv = AARR_DIMS(v);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = dimv[reqdim - <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1790" title="utils/adt/arrayfuncs.c:1790">array_cardinality</a>:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; returns the total number of elements in an array<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1790">&#x200c;</a><span class="linkable">array_cardinality</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; AnyArrayType *v = PG_GETARG_ANY_ARRAY_P(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(<a href="arrayutils.c.html#L57" title="utils/adt/arrayutils.c:57">ArrayGetNItems</a>(AARR_NDIM(v), AARR_DIMS(v)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1820" title="utils/adt/arrayfuncs.c:1820">array_get_element</a> :<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; This routine takes an array datum and a subscript array and returns<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; the referenced item as a Datum.&nbsp; Note that for a pass-by-reference<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; datatype, the returned Datum is a pointer into the array object.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This handles both ordinary varlena arrays and fixed-length arrays.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Inputs:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; arraydatum: the array object (mustn't be NULL)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; nSubscripts: number of subscripts supplied<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; indx[]: the subscript <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; arraytyplen: pg_type.typlen for the array type<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; elmlen: pg_type.typlen for the array's <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; elmbyval: pg_type.typbyval for the array's <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; elmalign: pg_type.typalign for the array's <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Outputs:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; The return value is the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> Datum.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; *isNull is set to indicate whether the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> is NULL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1820">&#x200c;</a><span class="linkable">array_get_element</span>(Datum arraydatum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> nSubscripts,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> *indx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> arraytyplen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> elmlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> elmbyval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span> elmalign,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isNull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndim,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *dim,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *lb,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fixedDim[<span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fixedLb[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *arraydataptr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *retptr;<br/></li>
<li>&nbsp; &nbsp; bits8&nbsp; &nbsp; &nbsp;&nbsp; *arraynullsptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (arraytyplen &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fixed-length arrays -- these are assumed to be 1-d, 0-based<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ndim = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fixedDim[<span class="Constant">0</span>] = arraytyplen / elmlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fixedLb[<span class="Constant">0</span>] = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dim = fixedDim;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lb = fixedLb;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; arraydataptr = (<span class="Type">char</span> *) DatumGetPointer(arraydatum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; arraynullsptr = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (VARATT_IS_EXTERNAL_EXPANDED(DatumGetPointer(arraydatum)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* expanded array: let's do this in a separate function */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1921" title="utils/adt/arrayfuncs.c:1921">array_get_element_expanded</a>(arraydatum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nSubscripts,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arraytyplen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmbyval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmalign,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isNull);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* detoast array if necessary, producing normal varlena input */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ArrayType&nbsp; *array = DatumGetArrayTypeP(arraydatum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ndim = ARR_NDIM(array);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dim = ARR_DIMS(array);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lb = ARR_LBOUND(array);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; arraydataptr = ARR_DATA_PTR(array);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; arraynullsptr = ARR_NULLBITMAP(array);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Return NULL for invalid subscript<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ndim != nSubscripts || ndim &lt;= <span class="Constant">0</span> || ndim &gt; MAXDIM)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *isNull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; ndim; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (indx[i] &lt; lb[i] || indx[i] &gt;= (dim[i] + lb[i]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *isNull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Calculate the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> number<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; offset = <a href="arrayutils.c.html#L32" title="utils/adt/arrayutils.c:32">ArrayGetOffset</a>(nSubscripts, dim, lb, indx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check for NULL array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L4762" title="utils/adt/arrayfuncs.c:4762">array_get_isnull</a>(arraynullsptr, offset))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *isNull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * OK, get the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; *isNull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; retptr = <a href="#L4847" title="utils/adt/arrayfuncs.c:4847">array_seek</a>(arraydataptr, <span class="Constant">0</span>, arraynullsptr, offset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmlen, elmbyval, elmalign);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L4797" title="utils/adt/arrayfuncs.c:4797">ArrayCast</a>(retptr, elmbyval, elmlen);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Implementation of <a href="#L1820" title="utils/adt/arrayfuncs.c:1820">array_get_element</a>() for an expanded array<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Datum<br/></li>
<li><a id="L1921">&#x200c;</a><span class="linkable">array_get_element_expanded</span>(Datum arraydatum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> nSubscripts, <span class="Type">int</span> *indx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> arraytyplen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> elmlen, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> elmbyval, <span class="Type">char</span> elmalign,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isNull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ExpandedArrayHeader *eah;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndim,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *dim,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *lb,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offset;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *dvalues;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *dnulls;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; eah = (ExpandedArrayHeader *) <a href="expandeddatum.c.html#L29" title="utils/adt/expandeddatum.c:29">DatumGetEOHP</a>(arraydatum);<br/></li>
<li>&nbsp; &nbsp; Assert(eah-&gt;ea_magic == EA_MAGIC);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sanity-check caller's info against object */<br/></li>
<li></span>&nbsp; &nbsp; Assert(arraytyplen == -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(elmlen == eah-&gt;typlen);<br/></li>
<li>&nbsp; &nbsp; Assert(elmbyval == eah-&gt;typbyval);<br/></li>
<li>&nbsp; &nbsp; Assert(elmalign == eah-&gt;typalign);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ndim = eah-&gt;ndims;<br/></li>
<li>&nbsp; &nbsp; dim = eah-&gt;dims;<br/></li>
<li>&nbsp; &nbsp; lb = eah-&gt;lbound;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Return NULL for invalid subscript<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ndim != nSubscripts || ndim &lt;= <span class="Constant">0</span> || ndim &gt; MAXDIM)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *isNull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; ndim; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (indx[i] &lt; lb[i] || indx[i] &gt;= (dim[i] + lb[i]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *isNull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Calculate the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> number<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; offset = <a href="arrayutils.c.html#L32" title="utils/adt/arrayutils.c:32">ArrayGetOffset</a>(nSubscripts, dim, lb, indx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Deconstruct array if we didn't already.&nbsp; Note that we apply this even<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if the input is nominally read-only: it should be safe enough.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="array_expanded.c.html#L424" title="utils/adt/array_expanded.c:424">deconstruct_expanded_array</a>(eah);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dvalues = eah-&gt;dvalues;<br/></li>
<li>&nbsp; &nbsp; dnulls = eah-&gt;dnulls;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check for NULL array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (dnulls &amp;&amp; dnulls[offset])<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *isNull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * OK, get the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>.&nbsp; It's OK to return a pass-by-ref value as a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pointer into the expanded array, for the same reason that regular<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L1820" title="utils/adt/arrayfuncs.c:1820">array_get_element</a> can return a pointer into flat arrays: the value is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * assumed not to change for as long as the Datum reference can exist.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; *isNull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> dvalues[offset];<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2030" title="utils/adt/arrayfuncs.c:2030">array_get_slice</a> :<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; This routine takes an array and a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of indices (upperIndx and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lowerIndx), creates a new array structure for the referred elements<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; and returns a pointer to it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This handles both ordinary varlena arrays and fixed-length arrays.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Inputs:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; arraydatum: the array object (mustn't be NULL)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; nSubscripts: number of subscripts supplied (must be same for <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>/<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; upperIndx[]: the <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> subscript <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; lowerIndx[]: the <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> subscript <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; upperProvided[]: true for provided <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> subscript <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; lowerProvided[]: true for provided <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> subscript <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; arraytyplen: pg_type.typlen for the array type<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; elmlen: pg_type.typlen for the array's <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; elmbyval: pg_type.typbyval for the array's <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; elmalign: pg_type.typalign for the array's <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Outputs:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; The return value is the new array Datum (it's never NULL)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Omitted <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> and <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> subscript <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are replaced by the corresponding<br/></li>
<li></span><span class="Comment"> * array bound.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: we assume it is OK to scribble on the provided subscript arrays<br/></li>
<li></span><span class="Comment"> * lowerIndx[] and upperIndx[]; also, these arrays must be of size MAXDIM<br/></li>
<li></span><span class="Comment"> * even when nSubscripts is less.&nbsp; These are generally just temporaries.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2030">&#x200c;</a><span class="linkable">array_get_slice</span>(Datum arraydatum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> nSubscripts,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> *upperIndx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> *lowerIndx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *upperProvided,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *lowerProvided,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> arraytyplen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> elmlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> elmbyval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span> elmalign)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *array;<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *newarray;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndim,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *dim,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *lb,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *newlb;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fixedDim[<span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fixedLb[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elemtype;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *arraydataptr;<br/></li>
<li>&nbsp; &nbsp; bits8&nbsp; &nbsp; &nbsp;&nbsp; *arraynullsptr;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; dataoffset;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bytes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; span[MAXDIM];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (arraytyplen &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fixed-length arrays -- currently, cannot slice these because parser<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * labels output as being of the fixed-length array type! Code below<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * shows how we could support it if the parser were changed to label<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * output as a suitable varlena array type.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;slices of fixed-length arrays not implemented&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fixed-length arrays -- these are assumed to be 1-d, 0-based<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> where would we get the correct ELEMTYPE from?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ndim = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fixedDim[<span class="Constant">0</span>] = arraytyplen / elmlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fixedLb[<span class="Constant">0</span>] = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dim = fixedDim;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lb = fixedLb;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elemtype = InvalidOid;&nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">XXX</span><span class="Comment"> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; arraydataptr = (<span class="Type">char</span> *) DatumGetPointer(arraydatum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; arraynullsptr = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* detoast input array if necessary */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; array = DatumGetArrayTypeP(arraydatum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ndim = ARR_NDIM(array);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dim = ARR_DIMS(array);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lb = ARR_LBOUND(array);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elemtype = ARR_ELEMTYPE(array);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; arraydataptr = ARR_DATA_PTR(array);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; arraynullsptr = ARR_NULLBITMAP(array);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check provided subscripts.&nbsp; A slice exceeding the current array limits<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is silently truncated to the array limits.&nbsp; If we end up with an empty<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * slice, return an empty array.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ndim &lt; nSubscripts || ndim &lt;= <span class="Constant">0</span> || ndim &gt; MAXDIM)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PointerGetDatum(<a href="#L3561" title="utils/adt/arrayfuncs.c:3561">construct_empty_array</a>(elemtype));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nSubscripts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!lowerProvided[i] || lowerIndx[i] &lt; lb[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lowerIndx[i] = lb[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!upperProvided[i] || upperIndx[i] &gt;= (dim[i] + lb[i]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upperIndx[i] = dim[i] + lb[i] - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lowerIndx[i] &gt; upperIndx[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PointerGetDatum(<a href="#L3561" title="utils/adt/arrayfuncs.c:3561">construct_empty_array</a>(elemtype));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fill <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> missing subscript positions with full array <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (; i &lt; ndim; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lowerIndx[i] = lb[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; upperIndx[i] = dim[i] + lb[i] - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lowerIndx[i] &gt; upperIndx[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PointerGetDatum(<a href="#L3561" title="utils/adt/arrayfuncs.c:3561">construct_empty_array</a>(elemtype));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="arrayutils.c.html#L153" title="utils/adt/arrayutils.c:153">mda_get_range</a>(ndim, span, lowerIndx, upperIndx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; bytes = <a href="#L5018" title="utils/adt/arrayfuncs.c:5018">array_slice_size</a>(arraydataptr, arraynullsptr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ndim, dim, lb,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lowerIndx, upperIndx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; elmlen, elmbyval, elmalign);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Currently, we put a null bitmap in the result if the source has one;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * could be smarter ...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (arraynullsptr)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dataoffset = ARR_OVERHEAD_WITHNULLS(ndim, <a href="arrayutils.c.html#L57" title="utils/adt/arrayutils.c:57">ArrayGetNItems</a>(ndim, span));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bytes += dataoffset;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dataoffset = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* marker for no null bitmap */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; bytes += ARR_OVERHEAD_NONULLS(ndim);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; newarray = (ArrayType *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(bytes);<br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(newarray, bytes);<br/></li>
<li>&nbsp; &nbsp; newarray-&gt;ndim = ndim;<br/></li>
<li>&nbsp; &nbsp; newarray-&gt;dataoffset = dataoffset;<br/></li>
<li>&nbsp; &nbsp; newarray-&gt;elemtype = elemtype;<br/></li>
<li>&nbsp; &nbsp; memcpy(ARR_DIMS(newarray), span, ndim * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Lower bounds of the new array are set to 1.&nbsp; Formerly (<a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> 7.3) we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * copied the given lowerIndx <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> ... but that seems confusing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; newlb = ARR_LBOUND(newarray);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; ndim; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newlb[i] = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L5078" title="utils/adt/arrayfuncs.c:5078">array_extract_slice</a>(newarray,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndim, dim, lb,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arraydataptr, arraynullsptr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lowerIndx, upperIndx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmlen, elmbyval, elmalign);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> PointerGetDatum(newarray);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2201" title="utils/adt/arrayfuncs.c:2201">array_set_element</a> :<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; This routine sets the value of one array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> (specified by<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a subscript array) to a new value specified by &quot;dataValue&quot;.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This handles both ordinary varlena arrays and fixed-length arrays.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Inputs:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; arraydatum: the initial array object (mustn't be NULL)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; nSubscripts: number of subscripts supplied<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; indx[]: the subscript <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; dataValue: the datum to be inserted at the given position<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; isNull: whether dataValue is NULL<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; arraytyplen: pg_type.typlen for the array type<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; elmlen: pg_type.typlen for the array's <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; elmbyval: pg_type.typbyval for the array's <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; elmalign: pg_type.typalign for the array's <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Result:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; A new array is returned, just like the old except for the one<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; modified entry.&nbsp; The original array object is not changed,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unless what is passed is a read-write reference to an expanded<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; array object; in that case the expanded array is updated in-place.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For one-dimensional arrays only, we allow the array to be extended<br/></li>
<li></span><span class="Comment"> * by assigning to a position outside the existing subscript <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>; <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * positions between the existing elements and the new one are set to NULLs.<br/></li>
<li></span><span class="Comment"> * (</span><span class="Todo">XXX</span><span class="Comment"> </span><span class="Todo">TODO</span><span class="Comment">: allow a corresponding behavior for multidimensional arrays)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: For assignments, we throw an error for invalid subscripts etc,<br/></li>
<li></span><span class="Comment"> * rather than returning a NULL as the fetch operations do.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2201">&#x200c;</a><span class="linkable">array_set_element</span>(Datum arraydatum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> nSubscripts,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> *indx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum dataValue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isNull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> arraytyplen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> elmlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> elmbyval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span> elmalign)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *array;<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *newarray;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndim,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dim[MAXDIM],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lb[MAXDIM],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offset;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *elt_ptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; newhasnulls;<br/></li>
<li>&nbsp; &nbsp; bits8&nbsp; &nbsp; &nbsp;&nbsp; *oldnullbitmap;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldnitems,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newnitems,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; olddatasize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newsize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; olditemlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newitemlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; overheadlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldoverheadlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addedbefore,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addedafter,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lenbefore,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lenafter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (arraytyplen &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fixed-length arrays -- these are assumed to be 1-d, 0-based. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cannot extend them, either.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *resultarray;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nSubscripts != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ARRAY_SUBSCRIPT_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;wrong number of array subscripts&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (indx[<span class="Constant">0</span>] &lt; <span class="Constant">0</span> || indx[<span class="Constant">0</span>] &gt;= arraytyplen / elmlen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ARRAY_SUBSCRIPT_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;array subscript out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NULL_VALUE_NOT_ALLOWED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot assign null value to an <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> of a fixed-length array&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; resultarray = (<span class="Type">char</span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(arraytyplen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(resultarray, DatumGetPointer(arraydatum), arraytyplen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elt_ptr = (<span class="Type">char</span> *) resultarray + indx[<span class="Constant">0</span>] * elmlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4808" title="utils/adt/arrayfuncs.c:4808">ArrayCastAndSet</a>(dataValue, elmlen, elmbyval, elmalign, elt_ptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PointerGetDatum(resultarray);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nSubscripts &lt;= <span class="Constant">0</span> || nSubscripts &gt; MAXDIM)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ARRAY_SUBSCRIPT_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;wrong number of array subscripts&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* make sure item to be inserted is not toasted */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (elmlen == -<span class="Constant">1</span> &amp;&amp; !isNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dataValue = PointerGetDatum(PG_DETOAST_DATUM(dataValue));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (VARATT_IS_EXTERNAL_EXPANDED(DatumGetPointer(arraydatum)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* expanded array: let's do this in a separate function */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2501" title="utils/adt/arrayfuncs.c:2501">array_set_element_expanded</a>(arraydatum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nSubscripts,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dataValue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isNull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arraytyplen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmbyval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmalign);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* detoast input array if necessary */<br/></li>
<li></span>&nbsp; &nbsp; array = DatumGetArrayTypeP(arraydatum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ndim = ARR_NDIM(array);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if number of dims is zero, i.e. an empty array, create an array with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nSubscripts dimensions, and set the <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bounds to the supplied<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * subscripts<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ndim == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmtype = ARR_ELEMTYPE(array);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nSubscripts; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dim[i] = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lb[i] = indx[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PointerGetDatum(<a href="#L3475" title="utils/adt/arrayfuncs.c:3475">construct_md_array</a>(&amp;dataValue, &amp;isNull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nSubscripts, dim, lb,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmlen, elmbyval, elmalign));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ndim != nSubscripts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ARRAY_SUBSCRIPT_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;wrong number of array subscripts&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* copy dim/lb since we may modify them */<br/></li>
<li></span>&nbsp; &nbsp; memcpy(dim, ARR_DIMS(array), ndim * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; memcpy(lb, ARR_LBOUND(array), ndim * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; newhasnulls = (ARR_HASNULL(array) || isNull);<br/></li>
<li>&nbsp; &nbsp; addedbefore = addedafter = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check subscripts.&nbsp; We assume the existing subscripts passed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="arrayutils.c.html#L117" title="utils/adt/arrayutils.c:117">ArrayCheckBounds</a>, so that dim[i] + lb[i] can be computed without<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * overflow.&nbsp; But we must beware of other overflows in our calculations of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * new dim[] <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ndim == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (indx[<span class="Constant">0</span>] &lt; lb[<span class="Constant">0</span>])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* addedbefore = lb[0] - indx[0]; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* dim[0] += addedbefore; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pg_sub_s32_overflow(lb[<span class="Constant">0</span>], indx[<span class="Constant">0</span>], &amp;addedbefore) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_add_s32_overflow(dim[<span class="Constant">0</span>], addedbefore, &amp;dim[<span class="Constant">0</span>]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;array size exceeds the maximum allowed (</span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">int</span>) MaxArraySize)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lb[<span class="Constant">0</span>] = indx[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (addedbefore &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newhasnulls = <span class="Constant">true</span>; <span class="Comment">/* will insert nulls */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (indx[<span class="Constant">0</span>] &gt;= (dim[<span class="Constant">0</span>] + lb[<span class="Constant">0</span>]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* addedafter = indx[0] - (dim[0] + lb[0]) + 1; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* dim[0] += addedafter; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pg_sub_s32_overflow(indx[<span class="Constant">0</span>], dim[<span class="Constant">0</span>] + lb[<span class="Constant">0</span>], &amp;addedafter) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_add_s32_overflow(addedafter, <span class="Constant">1</span>, &amp;addedafter) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_add_s32_overflow(dim[<span class="Constant">0</span>], addedafter, &amp;dim[<span class="Constant">0</span>]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;array size exceeds the maximum allowed (</span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">int</span>) MaxArraySize)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (addedafter &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newhasnulls = <span class="Constant">true</span>; <span class="Comment">/* will insert nulls */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> currently we do not support extending multi-dimensional arrays<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * during assignment<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; ndim; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (indx[i] &lt; lb[i] ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indx[i] &gt;= (dim[i] + lb[i]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ARRAY_SUBSCRIPT_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;array subscript out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This checks for overflow of the array dimensions */<br/></li>
<li></span>&nbsp; &nbsp; newnitems = <a href="arrayutils.c.html#L57" title="utils/adt/arrayutils.c:57">ArrayGetNItems</a>(ndim, dim);<br/></li>
<li>&nbsp; &nbsp; <a href="arrayutils.c.html#L117" title="utils/adt/arrayutils.c:117">ArrayCheckBounds</a>(ndim, dim, lb);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Compute sizes of items and areas to copy<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (newhasnulls)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; overheadlen = ARR_OVERHEAD_WITHNULLS(ndim, newnitems);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; overheadlen = ARR_OVERHEAD_NONULLS(ndim);<br/></li>
<li>&nbsp; &nbsp; oldnitems = <a href="arrayutils.c.html#L57" title="utils/adt/arrayutils.c:57">ArrayGetNItems</a>(ndim, ARR_DIMS(array));<br/></li>
<li>&nbsp; &nbsp; oldnullbitmap = ARR_NULLBITMAP(array);<br/></li>
<li>&nbsp; &nbsp; oldoverheadlen = ARR_DATA_OFFSET(array);<br/></li>
<li>&nbsp; &nbsp; olddatasize = ARR_SIZE(array) - oldoverheadlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (addedbefore)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; offset = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lenbefore = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; olditemlen = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lenafter = olddatasize;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (addedafter)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; offset = oldnitems;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lenbefore = olddatasize;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; olditemlen = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lenafter = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; offset = <a href="arrayutils.c.html#L32" title="utils/adt/arrayutils.c:32">ArrayGetOffset</a>(nSubscripts, dim, lb, indx);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elt_ptr = <a href="#L4847" title="utils/adt/arrayfuncs.c:4847">array_seek</a>(ARR_DATA_PTR(array), <span class="Constant">0</span>, oldnullbitmap, offset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; elmlen, elmbyval, elmalign);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lenbefore = (<span class="Type">int</span>) (elt_ptr - ARR_DATA_PTR(array));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L4762" title="utils/adt/arrayfuncs.c:4762">array_get_isnull</a>(oldnullbitmap, offset))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; olditemlen = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; olditemlen = att_addlength_pointer(<span class="Constant">0</span>, elmlen, elt_ptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; olditemlen = att_align_nominal(olditemlen, elmalign);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lenafter = (<span class="Type">int</span>) (olddatasize - lenbefore - olditemlen);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newitemlen = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newitemlen = att_addlength_datum(<span class="Constant">0</span>, elmlen, dataValue);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newitemlen = att_align_nominal(newitemlen, elmalign);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; newsize = overheadlen + lenbefore + newitemlen + lenafter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * OK, create the new array and fill in header/dimensions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; newarray = (ArrayType *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(newsize);<br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(newarray, newsize);<br/></li>
<li>&nbsp; &nbsp; newarray-&gt;ndim = ndim;<br/></li>
<li>&nbsp; &nbsp; newarray-&gt;dataoffset = newhasnulls ? overheadlen : <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; newarray-&gt;elemtype = ARR_ELEMTYPE(array);<br/></li>
<li>&nbsp; &nbsp; memcpy(ARR_DIMS(newarray), dim, ndim * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; memcpy(ARR_LBOUND(newarray), lb, ndim * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fill in data<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; memcpy((<span class="Type">char</span> *) newarray + overheadlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">char</span> *) array + oldoverheadlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lenbefore);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!isNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4808" title="utils/adt/arrayfuncs.c:4808">ArrayCastAndSet</a>(dataValue, elmlen, elmbyval, elmalign,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">char</span> *) newarray + overheadlen + lenbefore);<br/></li>
<li>&nbsp; &nbsp; memcpy((<span class="Type">char</span> *) newarray + overheadlen + lenbefore + newitemlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">char</span> *) array + oldoverheadlen + lenbefore + olditemlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lenafter);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fill in nulls bitmap if needed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: it's possible we just replaced the last NULL with a non-NULL, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * could get rid of the bitmap.&nbsp; Seems not worth testing for though.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (newhasnulls)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bits8&nbsp; &nbsp; &nbsp;&nbsp; *newnullbitmap = ARR_NULLBITMAP(newarray);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a> above already marked <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> inserted positions as nulls */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fix the inserted value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (addedafter)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4779" title="utils/adt/arrayfuncs.c:4779">array_set_isnull</a>(newnullbitmap, newnitems - <span class="Constant">1</span>, isNull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4779" title="utils/adt/arrayfuncs.c:4779">array_set_isnull</a>(newnullbitmap, offset, isNull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fix the copied <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>(s) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (addedbefore)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4947" title="utils/adt/arrayfuncs.c:4947">array_bitmap_copy</a>(newnullbitmap, addedbefore,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldnullbitmap, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldnitems);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4947" title="utils/adt/arrayfuncs.c:4947">array_bitmap_copy</a>(newnullbitmap, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldnullbitmap, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (addedafter == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4947" title="utils/adt/arrayfuncs.c:4947">array_bitmap_copy</a>(newnullbitmap, offset + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldnullbitmap, offset + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldnitems - offset - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> PointerGetDatum(newarray);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Implementation of <a href="#L2201" title="utils/adt/arrayfuncs.c:2201">array_set_element</a>() for an expanded array<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: as with <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> operation on a read/write expanded object, we must<br/></li>
<li></span><span class="Comment"> * take pains not to leave the object in a corrupt state if we fail partway<br/></li>
<li></span><span class="Comment"> * through.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Datum<br/></li>
<li><a id="L2501">&#x200c;</a><span class="linkable">array_set_element_expanded</span>(Datum arraydatum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> nSubscripts, <span class="Type">int</span> *indx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum dataValue, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isNull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> arraytyplen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> elmlen, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> elmbyval, <span class="Type">char</span> elmalign)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ExpandedArrayHeader *eah;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *dvalues;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *dnulls;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndim,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dim[MAXDIM],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lb[MAXDIM],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offset;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; dimschanged,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newhasnulls;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addedbefore,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addedafter;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *oldValue;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Convert to R/W object if not so already */<br/></li>
<li></span>&nbsp; &nbsp; eah = <a href="array_expanded.c.html#L352" title="utils/adt/array_expanded.c:352">DatumGetExpandedArray</a>(arraydatum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Sanity-check caller's info against object; we don't use it otherwise */<br/></li>
<li></span>&nbsp; &nbsp; Assert(arraytyplen == -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(elmlen == eah-&gt;typlen);<br/></li>
<li>&nbsp; &nbsp; Assert(elmbyval == eah-&gt;typbyval);<br/></li>
<li>&nbsp; &nbsp; Assert(elmalign == eah-&gt;typalign);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Copy dimension info into local storage.&nbsp; This allows us to modify the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * dimensions if needed, while not messing up the expanded value if we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fail partway through.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ndim = eah-&gt;ndims;<br/></li>
<li>&nbsp; &nbsp; Assert(ndim &gt;= <span class="Constant">0</span> &amp;&amp; ndim &lt;= MAXDIM);<br/></li>
<li>&nbsp; &nbsp; memcpy(dim, eah-&gt;dims, ndim * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; memcpy(lb, eah-&gt;lbound, ndim * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; dimschanged = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if number of dims is zero, i.e. an empty array, create an array with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nSubscripts dimensions, and set the <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bounds to the supplied<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * subscripts.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ndim == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Allocate adequate space for new dimension info.&nbsp; This is harmless<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if we fail later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(nSubscripts &gt; <span class="Constant">0</span> &amp;&amp; nSubscripts &lt;= MAXDIM);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; eah-&gt;dims = (<span class="Type">int</span> *) <a href="../mmgr/mcxt.c.html#L1214" title="utils/mmgr/mcxt.c:1214">MemoryContextAllocZero</a>(eah-&gt;hdr.eoh_context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nSubscripts * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; eah-&gt;lbound = (<span class="Type">int</span> *) <a href="../mmgr/mcxt.c.html#L1214" title="utils/mmgr/mcxt.c:1214">MemoryContextAllocZero</a>(eah-&gt;hdr.eoh_context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nSubscripts * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Update local copies of dimension info */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ndim = nSubscripts;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nSubscripts; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dim[i] = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lb[i] = indx[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dimschanged = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (ndim != nSubscripts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ARRAY_SUBSCRIPT_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;wrong number of array subscripts&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Deconstruct array if we didn't already.&nbsp; (Someday maybe add a special<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * case path for fixed-length, no-nulls cases, where we can overwrite an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> in place without ever deconstructing.&nbsp; But today is not that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * day.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="array_expanded.c.html#L424" title="utils/adt/array_expanded.c:424">deconstruct_expanded_array</a>(eah);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Copy new <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> into array's context, if needed (we assume it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already detoasted, so no junk should be created).&nbsp; Doing this <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we've made <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> significant changes ensures that our behavior is sane<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * even when the source is a reference to some <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> of this same array.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we fail further down, this memory is leaked, but that's reasonably<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * harmless.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!eah-&gt;typbyval &amp;&amp; !isNull)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldcxt = MemoryContextSwitchTo(eah-&gt;hdr.eoh_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dataValue = <a href="datum.c.html#L132" title="utils/adt/datum.c:132">datumCopy</a>(dataValue, <span class="Constant">false</span>, eah-&gt;typlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dvalues = eah-&gt;dvalues;<br/></li>
<li>&nbsp; &nbsp; dnulls = eah-&gt;dnulls;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; newhasnulls = ((dnulls != <span class="Constant">NULL</span>) || isNull);<br/></li>
<li>&nbsp; &nbsp; addedbefore = addedafter = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check subscripts (this logic must match <a href="#L2201" title="utils/adt/arrayfuncs.c:2201">array_set_element</a>).&nbsp; We assume<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the existing subscripts passed <a href="arrayutils.c.html#L117" title="utils/adt/arrayutils.c:117">ArrayCheckBounds</a>, so that dim[i] + lb[i]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can be computed without overflow.&nbsp; But we must beware of other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * overflows in our calculations of new dim[] <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ndim == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (indx[<span class="Constant">0</span>] &lt; lb[<span class="Constant">0</span>])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* addedbefore = lb[0] - indx[0]; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* dim[0] += addedbefore; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pg_sub_s32_overflow(lb[<span class="Constant">0</span>], indx[<span class="Constant">0</span>], &amp;addedbefore) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_add_s32_overflow(dim[<span class="Constant">0</span>], addedbefore, &amp;dim[<span class="Constant">0</span>]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;array size exceeds the maximum allowed (</span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">int</span>) MaxArraySize)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lb[<span class="Constant">0</span>] = indx[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dimschanged = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (addedbefore &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newhasnulls = <span class="Constant">true</span>; <span class="Comment">/* will insert nulls */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (indx[<span class="Constant">0</span>] &gt;= (dim[<span class="Constant">0</span>] + lb[<span class="Constant">0</span>]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* addedafter = indx[0] - (dim[0] + lb[0]) + 1; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* dim[0] += addedafter; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pg_sub_s32_overflow(indx[<span class="Constant">0</span>], dim[<span class="Constant">0</span>] + lb[<span class="Constant">0</span>], &amp;addedafter) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_add_s32_overflow(addedafter, <span class="Constant">1</span>, &amp;addedafter) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_add_s32_overflow(dim[<span class="Constant">0</span>], addedafter, &amp;dim[<span class="Constant">0</span>]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;array size exceeds the maximum allowed (</span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">int</span>) MaxArraySize)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dimschanged = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (addedafter &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newhasnulls = <span class="Constant">true</span>; <span class="Comment">/* will insert nulls */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> currently we do not support extending multi-dimensional arrays<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * during assignment<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; ndim; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (indx[i] &lt; lb[i] ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indx[i] &gt;= (dim[i] + lb[i]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ARRAY_SUBSCRIPT_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;array subscript out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for overflow of the array dimensions */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (dimschanged)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="arrayutils.c.html#L57" title="utils/adt/arrayutils.c:57">ArrayGetNItems</a>(ndim, dim);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="arrayutils.c.html#L117" title="utils/adt/arrayutils.c:117">ArrayCheckBounds</a>(ndim, dim, lb);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now we can calculate linear offset of target item in array */<br/></li>
<li></span>&nbsp; &nbsp; offset = <a href="arrayutils.c.html#L32" title="utils/adt/arrayutils.c:32">ArrayGetOffset</a>(nSubscripts, dim, lb, indx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Physically enlarge existing dvalues/dnulls arrays if needed */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (dim[<span class="Constant">0</span>] &gt; eah-&gt;dvalueslen)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We want some extra space if we're enlarging */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newlen = dim[<span class="Constant">0</span>] + dim[<span class="Constant">0</span>] / <span class="Constant">8</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newlen = Max(newlen, dim[<span class="Constant">0</span>]);&nbsp; &nbsp; <span class="Comment">/* integer overflow guard */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; eah-&gt;dvalues = dvalues = (Datum *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(dvalues, newlen * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dnulls)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eah-&gt;dnulls = dnulls = (<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(dnulls, newlen * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; eah-&gt;dvalueslen = newlen;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we need a nulls bitmap and don't already have one, create it, being<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sure to mark all existing entries as not null.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (newhasnulls &amp;&amp; dnulls == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; eah-&gt;dnulls = dnulls = (<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1214" title="utils/mmgr/mcxt.c:1214">MemoryContextAllocZero</a>(eah-&gt;hdr.eoh_context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; eah-&gt;dvalueslen * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> have all the needed space allocated, so we're ready to make<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * irreversible changes.&nbsp; Be very wary of allowing failure below here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Flattened value will no longer represent array accurately */<br/></li>
<li></span>&nbsp; &nbsp; eah-&gt;fvalue = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And we don't know the flattened size either */<br/></li>
<li></span>&nbsp; &nbsp; eah-&gt;flat_size = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Update dimensionality info if needed */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (dimschanged)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; eah-&gt;ndims = ndim;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(eah-&gt;dims, dim, ndim * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(eah-&gt;lbound, lb, ndim * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reposition items if needed, and fill addedbefore items with nulls */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (addedbefore &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memmove(dvalues + addedbefore, dvalues, eah-&gt;nelems * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; addedbefore; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dvalues[i] = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dnulls)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memmove(dnulls + addedbefore, dnulls, eah-&gt;nelems * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; addedbefore; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dnulls[i] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; eah-&gt;nelems += addedbefore;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fill addedafter items with nulls */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (addedafter &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; addedafter; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dvalues[eah-&gt;nelems + i] = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dnulls)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; addedafter; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dnulls[eah-&gt;nelems + i] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; eah-&gt;nelems += addedafter;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Grab old <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> value for <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>'ing, if needed. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!eah-&gt;typbyval &amp;&amp; (dnulls == <span class="Constant">NULL</span> || !dnulls[offset]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldValue = (<span class="Type">char</span> *) DatumGetPointer(dvalues[offset]);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldValue = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And finally we can insert the new <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>. */<br/></li>
<li></span>&nbsp; &nbsp; dvalues[offset] = dataValue;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dnulls)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dnulls[offset] = isNull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Free old <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> if needed; this keeps repeated <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> replacements<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from bloating the array's storage.&nbsp; If the <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a> somehow fails, it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * won't corrupt the array.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (oldValue)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Don't try to <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a> a part of the original flat array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (oldValue &lt; eah-&gt;fstartptr || oldValue &gt;= eah-&gt;fendptr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(oldValue);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Done, return standard TOAST pointer for object */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> EOHPGetRWDatum(&amp;eah-&gt;hdr);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2806" title="utils/adt/arrayfuncs.c:2806">array_set_slice</a> :<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; This routine sets the value of a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of array locations (specified<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; by <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> and <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> subscript <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>) to new <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> passed as<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; another array.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This handles both ordinary varlena arrays and fixed-length arrays.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Inputs:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; arraydatum: the initial array object (mustn't be NULL)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; nSubscripts: number of subscripts supplied (must be same for <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>/<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; upperIndx[]: the <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> subscript <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; lowerIndx[]: the <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> subscript <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; upperProvided[]: true for provided <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> subscript <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; lowerProvided[]: true for provided <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> subscript <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; srcArrayDatum: the source for the inserted <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; isNull: indicates whether srcArrayDatum is NULL<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; arraytyplen: pg_type.typlen for the array type<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; elmlen: pg_type.typlen for the array's <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; elmbyval: pg_type.typbyval for the array's <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; elmalign: pg_type.typalign for the array's <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Result:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; A new array is returned, just like the old except for the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; modified <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.&nbsp; The original array object is not changed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Omitted <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> and <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> subscript <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are replaced by the corresponding<br/></li>
<li></span><span class="Comment"> * array bound.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For one-dimensional arrays only, we allow the array to be extended<br/></li>
<li></span><span class="Comment"> * by assigning to positions outside the existing subscript <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>; <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * positions between the existing elements and the new ones are set to NULLs.<br/></li>
<li></span><span class="Comment"> * (</span><span class="Todo">XXX</span><span class="Comment"> </span><span class="Todo">TODO</span><span class="Comment">: allow a corresponding behavior for multidimensional arrays)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: we assume it is OK to scribble on the provided index arrays<br/></li>
<li></span><span class="Comment"> * lowerIndx[] and upperIndx[]; also, these arrays must be of size MAXDIM<br/></li>
<li></span><span class="Comment"> * even when nSubscripts is less.&nbsp; These are generally just temporaries.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: For assignments, we throw an error for silly subscripts etc,<br/></li>
<li></span><span class="Comment"> * rather than returning a NULL or empty array as the fetch operations do.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2806">&#x200c;</a><span class="linkable">array_set_slice</span>(Datum arraydatum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> nSubscripts,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> *upperIndx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> *lowerIndx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *upperProvided,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *lowerProvided,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum srcArrayDatum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isNull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> arraytyplen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> elmlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> elmbyval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span> elmalign)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *array;<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *srcArray;<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *newarray;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndim,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dim[MAXDIM],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lb[MAXDIM],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; span[MAXDIM];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; newhasnulls;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nitems,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nsrcitems,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; olddatasize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newsize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; olditemsize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newitemsize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; overheadlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldoverheadlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addedbefore,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addedafter,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lenbefore,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lenafter,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemsbefore,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemsafter,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nolditems;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Currently, assignment from a NULL source array is a no-op */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> arraydatum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (arraytyplen &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fixed-length arrays -- not got round to doing this...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;updates on slices of fixed-length arrays not implemented&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* detoast arrays if necessary */<br/></li>
<li></span>&nbsp; &nbsp; array = DatumGetArrayTypeP(arraydatum);<br/></li>
<li>&nbsp; &nbsp; srcArray = DatumGetArrayTypeP(srcArrayDatum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* note: we assume srcArray contains no toasted elements */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; ndim = ARR_NDIM(array);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if number of dims is zero, i.e. an empty array, create an array with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nSubscripts dimensions, and set the <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> and <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bounds to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * supplied subscripts<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ndim == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *dvalues;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *dnulls;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nelems;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmtype = ARR_ELEMTYPE(array);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3612" title="utils/adt/arrayfuncs.c:3612">deconstruct_array</a>(srcArray, elmtype, elmlen, elmbyval, elmalign,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;dvalues, &amp;dnulls, &amp;nelems);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nSubscripts; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!upperProvided[i] || !lowerProvided[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ARRAY_SUBSCRIPT_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;array slice subscript must provide both boundaries&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;When assigning to a slice of an empty array value,&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot; slice boundaries must be fully specified.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dim[i] = <span class="Constant">1</span> + upperIndx[i] - lowerIndx[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lb[i] = lowerIndx[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* complain if too few source items; we ignore extras, however */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nelems &lt; <a href="arrayutils.c.html#L57" title="utils/adt/arrayutils.c:57">ArrayGetNItems</a>(nSubscripts, dim))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ARRAY_SUBSCRIPT_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;source array too small&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PointerGetDatum(<a href="#L3475" title="utils/adt/arrayfuncs.c:3475">construct_md_array</a>(dvalues, dnulls, nSubscripts,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dim, lb, elmtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmlen, elmbyval, elmalign));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ndim &lt; nSubscripts || ndim &lt;= <span class="Constant">0</span> || ndim &gt; MAXDIM)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ARRAY_SUBSCRIPT_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;wrong number of array subscripts&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* copy dim/lb since we may modify them */<br/></li>
<li></span>&nbsp; &nbsp; memcpy(dim, ARR_DIMS(array), ndim * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; memcpy(lb, ARR_LBOUND(array), ndim * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; newhasnulls = (ARR_HASNULL(array) || ARR_HASNULL(srcArray));<br/></li>
<li>&nbsp; &nbsp; addedbefore = addedafter = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check subscripts.&nbsp; We assume the existing subscripts passed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="arrayutils.c.html#L117" title="utils/adt/arrayutils.c:117">ArrayCheckBounds</a>, so that dim[i] + lb[i] can be computed without<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * overflow.&nbsp; But we must beware of other overflows in our calculations of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * new dim[] <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ndim == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(nSubscripts == <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!lowerProvided[<span class="Constant">0</span>])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lowerIndx[<span class="Constant">0</span>] = lb[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!upperProvided[<span class="Constant">0</span>])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upperIndx[<span class="Constant">0</span>] = dim[<span class="Constant">0</span>] + lb[<span class="Constant">0</span>] - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lowerIndx[<span class="Constant">0</span>] &gt; upperIndx[<span class="Constant">0</span>])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ARRAY_SUBSCRIPT_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound cannot be less than <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lowerIndx[<span class="Constant">0</span>] &lt; lb[<span class="Constant">0</span>])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* addedbefore = lb[0] - lowerIndx[0]; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* dim[0] += addedbefore; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pg_sub_s32_overflow(lb[<span class="Constant">0</span>], lowerIndx[<span class="Constant">0</span>], &amp;addedbefore) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_add_s32_overflow(dim[<span class="Constant">0</span>], addedbefore, &amp;dim[<span class="Constant">0</span>]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;array size exceeds the maximum allowed (</span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">int</span>) MaxArraySize)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lb[<span class="Constant">0</span>] = lowerIndx[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (addedbefore &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newhasnulls = <span class="Constant">true</span>; <span class="Comment">/* will insert nulls */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (upperIndx[<span class="Constant">0</span>] &gt;= (dim[<span class="Constant">0</span>] + lb[<span class="Constant">0</span>]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* addedafter = upperIndx[0] - (dim[0] + lb[0]) + 1; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* dim[0] += addedafter; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pg_sub_s32_overflow(upperIndx[<span class="Constant">0</span>], dim[<span class="Constant">0</span>] + lb[<span class="Constant">0</span>], &amp;addedafter) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_add_s32_overflow(addedafter, <span class="Constant">1</span>, &amp;addedafter) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_add_s32_overflow(dim[<span class="Constant">0</span>], addedafter, &amp;dim[<span class="Constant">0</span>]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;array size exceeds the maximum allowed (</span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">int</span>) MaxArraySize)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (addedafter &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newhasnulls = <span class="Constant">true</span>; <span class="Comment">/* will insert nulls */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> currently we do not support extending multi-dimensional arrays<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * during assignment<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nSubscripts; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!lowerProvided[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lowerIndx[i] = lb[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!upperProvided[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upperIndx[i] = dim[i] + lb[i] - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lowerIndx[i] &gt; upperIndx[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ARRAY_SUBSCRIPT_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound cannot be less than <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lowerIndx[i] &lt; lb[i] ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upperIndx[i] &gt;= (dim[i] + lb[i]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ARRAY_SUBSCRIPT_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;array subscript out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fill <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> missing subscript positions with full array <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (; i &lt; ndim; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lowerIndx[i] = lb[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upperIndx[i] = dim[i] + lb[i] - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lowerIndx[i] &gt; upperIndx[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ARRAY_SUBSCRIPT_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound cannot be less than <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Do this mainly to check for overflow */<br/></li>
<li></span>&nbsp; &nbsp; nitems = <a href="arrayutils.c.html#L57" title="utils/adt/arrayutils.c:57">ArrayGetNItems</a>(ndim, dim);<br/></li>
<li>&nbsp; &nbsp; <a href="arrayutils.c.html#L117" title="utils/adt/arrayutils.c:117">ArrayCheckBounds</a>(ndim, dim, lb);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make sure source array has enough entries.&nbsp; Note we ignore the shape of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the source array and just read entries serially.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="arrayutils.c.html#L153" title="utils/adt/arrayutils.c:153">mda_get_range</a>(ndim, span, lowerIndx, upperIndx);<br/></li>
<li>&nbsp; &nbsp; nsrcitems = <a href="arrayutils.c.html#L57" title="utils/adt/arrayutils.c:57">ArrayGetNItems</a>(ndim, span);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nsrcitems &gt; <a href="arrayutils.c.html#L57" title="utils/adt/arrayutils.c:57">ArrayGetNItems</a>(ARR_NDIM(srcArray), ARR_DIMS(srcArray)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ARRAY_SUBSCRIPT_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;source array too small&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Compute space occupied by new entries, space occupied by replaced<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * entries, and required space for new array.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (newhasnulls)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; overheadlen = ARR_OVERHEAD_WITHNULLS(ndim, nitems);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; overheadlen = ARR_OVERHEAD_NONULLS(ndim);<br/></li>
<li>&nbsp; &nbsp; newitemsize = <a href="#L4895" title="utils/adt/arrayfuncs.c:4895">array_nelems_size</a>(ARR_DATA_PTR(srcArray), <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ARR_NULLBITMAP(srcArray), nsrcitems,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmlen, elmbyval, elmalign);<br/></li>
<li>&nbsp; &nbsp; oldoverheadlen = ARR_DATA_OFFSET(array);<br/></li>
<li>&nbsp; &nbsp; olddatasize = ARR_SIZE(array) - oldoverheadlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ndim &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * here we do not need to cope with extension of the array; it would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be a lot more complicated if we had to do so...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; olditemsize = <a href="#L5018" title="utils/adt/arrayfuncs.c:5018">array_slice_size</a>(ARR_DATA_PTR(array),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ARR_NULLBITMAP(array),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ndim, dim, lb,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lowerIndx, upperIndx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; elmlen, elmbyval, elmalign);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lenbefore = lenafter = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; itemsbefore = itemsafter = nolditems = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * here we must allow for possibility of slice larger than orig array<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and/or not adjacent to orig array subscripts<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldlb = ARR_LBOUND(array)[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldub = oldlb + ARR_DIMS(array)[<span class="Constant">0</span>] - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slicelb = Max(oldlb, lowerIndx[<span class="Constant">0</span>]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sliceub = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(oldub, upperIndx[<span class="Constant">0</span>]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *oldarraydata = ARR_DATA_PTR(array);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bits8&nbsp; &nbsp; &nbsp;&nbsp; *oldarraybitmap = ARR_NULLBITMAP(array);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* count/size of old array entries that will go <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the slice */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; itemsbefore = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(slicelb, oldub + <span class="Constant">1</span>) - oldlb;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lenbefore = <a href="#L4895" title="utils/adt/arrayfuncs.c:4895">array_nelems_size</a>(oldarraydata, <span class="Constant">0</span>, oldarraybitmap,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemsbefore,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmlen, elmbyval, elmalign);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* count/size of old array entries that will be replaced by slice */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (slicelb &gt; sliceub)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nolditems = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; olditemsize = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nolditems = sliceub - slicelb + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; olditemsize = <a href="#L4895" title="utils/adt/arrayfuncs.c:4895">array_nelems_size</a>(oldarraydata + lenbefore,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemsbefore, oldarraybitmap,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nolditems,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmlen, elmbyval, elmalign);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* count/size of old array entries that will go after the slice */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; itemsafter = oldub + <span class="Constant">1</span> - Max(sliceub + <span class="Constant">1</span>, oldlb);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lenafter = olddatasize - lenbefore - olditemsize;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; newsize = overheadlen + olddatasize - olditemsize + newitemsize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; newarray = (ArrayType *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(newsize);<br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(newarray, newsize);<br/></li>
<li>&nbsp; &nbsp; newarray-&gt;ndim = ndim;<br/></li>
<li>&nbsp; &nbsp; newarray-&gt;dataoffset = newhasnulls ? overheadlen : <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; newarray-&gt;elemtype = ARR_ELEMTYPE(array);<br/></li>
<li>&nbsp; &nbsp; memcpy(ARR_DIMS(newarray), dim, ndim * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; memcpy(ARR_LBOUND(newarray), lb, ndim * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ndim &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * here we do not need to cope with extension of the array; it would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be a lot more complicated if we had to do so...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5151" title="utils/adt/arrayfuncs.c:5151">array_insert_slice</a>(newarray, array, srcArray,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ndim, dim, lb,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lowerIndx, upperIndx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; elmlen, elmbyval, elmalign);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fill in data */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memcpy((<span class="Type">char</span> *) newarray + overheadlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">char</span> *) array + oldoverheadlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lenbefore);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy((<span class="Type">char</span> *) newarray + overheadlen + lenbefore,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ARR_DATA_PTR(srcArray),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; newitemsize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy((<span class="Type">char</span> *) newarray + overheadlen + lenbefore + newitemsize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">char</span> *) array + oldoverheadlen + lenbefore + olditemsize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lenafter);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fill in nulls bitmap if needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newhasnulls)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bits8&nbsp; &nbsp; &nbsp;&nbsp; *newnullbitmap = ARR_NULLBITMAP(newarray);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bits8&nbsp; &nbsp; &nbsp;&nbsp; *oldnullbitmap = ARR_NULLBITMAP(array);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a> above already marked <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> inserted positions as nulls */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4947" title="utils/adt/arrayfuncs.c:4947">array_bitmap_copy</a>(newnullbitmap, addedbefore,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldnullbitmap, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemsbefore);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4947" title="utils/adt/arrayfuncs.c:4947">array_bitmap_copy</a>(newnullbitmap, lowerIndx[<span class="Constant">0</span>] - lb[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ARR_NULLBITMAP(srcArray), <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nsrcitems);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4947" title="utils/adt/arrayfuncs.c:4947">array_bitmap_copy</a>(newnullbitmap, addedbefore + itemsbefore + nolditems,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldnullbitmap, itemsbefore + nolditems,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemsafter);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> PointerGetDatum(newarray);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3139" title="utils/adt/arrayfuncs.c:3139">array_ref</a> : backwards compatibility wrapper for <a href="#L1820" title="utils/adt/arrayfuncs.c:1820">array_get_element</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This only works for detoasted/flattened varlena arrays, since the array<br/></li>
<li></span><span class="Comment"> * argument is declared as &quot;ArrayType *&quot;.&nbsp; However there's enough code like<br/></li>
<li></span><span class="Comment"> * that to justify preserving this API.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3139">&#x200c;</a><span class="linkable">array_ref</span>(ArrayType *array, <span class="Type">int</span> nSubscripts, <span class="Type">int</span> *indx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> arraytyplen, <span class="Type">int</span> elmlen, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> elmbyval, <span class="Type">char</span> elmalign,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isNull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1820" title="utils/adt/arrayfuncs.c:1820">array_get_element</a>(PointerGetDatum(array), nSubscripts, indx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; arraytyplen, elmlen, elmbyval, elmalign,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; isNull);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3156" title="utils/adt/arrayfuncs.c:3156">array_set</a> : backwards compatibility wrapper for <a href="#L2201" title="utils/adt/arrayfuncs.c:2201">array_set_element</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This only works for detoasted/flattened varlena arrays, since the array<br/></li>
<li></span><span class="Comment"> * argument and result are declared as &quot;ArrayType *&quot;.&nbsp; However there's enough<br/></li>
<li></span><span class="Comment"> * code like that to justify preserving this API.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ArrayType *<br/></li>
<li><a id="L3156">&#x200c;</a><span class="linkable">array_set</span>(ArrayType *array, <span class="Type">int</span> nSubscripts, <span class="Type">int</span> *indx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum dataValue, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isNull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> arraytyplen, <span class="Type">int</span> elmlen, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> elmbyval, <span class="Type">char</span> elmalign)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> DatumGetArrayTypeP(<a href="#L2201" title="utils/adt/arrayfuncs.c:2201">array_set_element</a>(PointerGetDatum(array),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nSubscripts, indx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dataValue, isNull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arraytyplen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmlen, elmbyval, elmalign));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3194" title="utils/adt/arrayfuncs.c:3194">array_map</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Map an array through an arbitrary expression.&nbsp; Return a new array with<br/></li>
<li></span><span class="Comment"> * the same dimensions and each source <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> transformed by the given,<br/></li>
<li></span><span class="Comment"> * already-compiled expression.&nbsp; Each source <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> is placed in the<br/></li>
<li></span><span class="Comment"> * innermost_caseval/innermost_casenull fields of the ExprState.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Parameters are:<br/></li>
<li></span><span class="Comment"> * * arrayd: Datum representing array argument.<br/></li>
<li></span><span class="Comment"> * * exprstate: ExprState representing the per-<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> transformation.<br/></li>
<li></span><span class="Comment"> * * econtext: context for expression evaluation.<br/></li>
<li></span><span class="Comment"> * * retType: OID of <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type of output array.&nbsp; This must be the same as,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; or binary-compatible with, the result type of the expression.&nbsp; It might<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; be different from the input array's <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type.<br/></li>
<li></span><span class="Comment"> * * amstate: workspace for <a href="#L3194" title="utils/adt/arrayfuncs.c:3194">array_map</a>.&nbsp; Must be zeroed by caller <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; first call, and not touched after that.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It is legitimate to pass a freshly-zeroed ArrayMapState on each call,<br/></li>
<li></span><span class="Comment"> * but better performance can be had if the state can be preserved across<br/></li>
<li></span><span class="Comment"> * a series of calls.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: caller must assure that input array is not NULL.&nbsp; NULL elements in<br/></li>
<li></span><span class="Comment"> * the array are OK however.<br/></li>
<li></span><span class="Comment"> * NB: caller should be running in econtext's per-tuple memory context.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3194">&#x200c;</a><span class="linkable">array_map</span>(Datum arrayd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExprState *exprstate, ExprContext *econtext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid retType, ArrayMapState *amstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; AnyArrayType *v = <a href="array_expanded.c.html#L401" title="utils/adt/array_expanded.c:401">DatumGetAnyArrayP</a>(arrayd);<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *nulls;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *dim;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndim;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nitems;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; nbytes = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; dataoffset;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; hasnulls;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inpType;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inp_typlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; inp_typbyval;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; inp_typalign;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; typbyval;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; typalign;<br/></li>
<li>&nbsp; &nbsp; array_iter&nbsp; &nbsp; iter;<br/></li>
<li>&nbsp; &nbsp; ArrayMetaState *inp_extra;<br/></li>
<li>&nbsp; &nbsp; ArrayMetaState *ret_extra;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *transform_source = exprstate-&gt;innermost_caseval;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *transform_source_isnull = exprstate-&gt;innermost_casenull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; inpType = AARR_ELEMTYPE(v);<br/></li>
<li>&nbsp; &nbsp; ndim = AARR_NDIM(v);<br/></li>
<li>&nbsp; &nbsp; dim = AARR_DIMS(v);<br/></li>
<li>&nbsp; &nbsp; nitems = <a href="arrayutils.c.html#L57" title="utils/adt/arrayutils.c:57">ArrayGetNItems</a>(ndim, dim);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for empty array */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nitems &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Return empty array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PointerGetDatum(<a href="#L3561" title="utils/adt/arrayfuncs.c:3561">construct_empty_array</a>(retType));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We arrange to look up info about input and return <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> types only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * once per series of calls, assuming the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type doesn't change<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * underneath us.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; inp_extra = &amp;amstate-&gt;inp_extra;<br/></li>
<li>&nbsp; &nbsp; ret_extra = &amp;amstate-&gt;ret_extra;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (inp_extra-&gt;element_type != inpType)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L2271" title="utils/cache/lsyscache.c:2271">get_typlenbyvalalign</a>(inpType,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;inp_extra-&gt;typlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;inp_extra-&gt;typbyval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;inp_extra-&gt;typalign);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; inp_extra-&gt;element_type = inpType;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; inp_typlen = inp_extra-&gt;typlen;<br/></li>
<li>&nbsp; &nbsp; inp_typbyval = inp_extra-&gt;typbyval;<br/></li>
<li>&nbsp; &nbsp; inp_typalign = inp_extra-&gt;typalign;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ret_extra-&gt;element_type != retType)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L2271" title="utils/cache/lsyscache.c:2271">get_typlenbyvalalign</a>(retType,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;ret_extra-&gt;typlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;ret_extra-&gt;typbyval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;ret_extra-&gt;typalign);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ret_extra-&gt;element_type = retType;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; typlen = ret_extra-&gt;typlen;<br/></li>
<li>&nbsp; &nbsp; typbyval = ret_extra-&gt;typbyval;<br/></li>
<li>&nbsp; &nbsp; typalign = ret_extra-&gt;typalign;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allocate temporary arrays for new <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> = (Datum *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(nitems * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li>&nbsp; &nbsp; nulls = (<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(nitems * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Loop over source data */<br/></li>
<li></span>&nbsp; &nbsp; array_iter_setup(&amp;iter, v);<br/></li>
<li>&nbsp; &nbsp; hasnulls = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nitems; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get source <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>, checking for NULL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *transform_source =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; array_iter_next(&amp;iter, transform_source_isnull, i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inp_typlen, inp_typbyval, inp_typalign);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Apply the given expression to source <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i] = ExecEvalExpr(exprstate, econtext, &amp;nulls[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nulls[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hasnulls = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ensure data is not toasted */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typlen == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i] = PointerGetDatum(PG_DETOAST_DATUM(<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i]));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Update total result size */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbytes = att_addlength_datum(nbytes, typlen, <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbytes = att_align_nominal(nbytes, typalign);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check for overflow of total request */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!AllocSizeIsValid(nbytes))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;array size exceeds the maximum allowed (</span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">int</span>) MaxAllocSize)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allocate and fill the result array */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (hasnulls)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dataoffset = ARR_OVERHEAD_WITHNULLS(ndim, nitems);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nbytes += dataoffset;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dataoffset = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* marker for no null bitmap */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nbytes += ARR_OVERHEAD_NONULLS(ndim);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; result = (ArrayType *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(nbytes);<br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(result, nbytes);<br/></li>
<li>&nbsp; &nbsp; result-&gt;ndim = ndim;<br/></li>
<li>&nbsp; &nbsp; result-&gt;dataoffset = dataoffset;<br/></li>
<li>&nbsp; &nbsp; result-&gt;elemtype = retType;<br/></li>
<li>&nbsp; &nbsp; memcpy(ARR_DIMS(result), AARR_DIMS(v), ndim * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; memcpy(ARR_LBOUND(result), AARR_LBOUND(v), ndim * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L961" title="utils/adt/arrayfuncs.c:961">CopyArrayEls</a>(result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, nulls, nitems,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typlen, typbyval, typalign,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: do not risk trying to <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a> the results of the called expression<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(nulls);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> PointerGetDatum(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3354" title="utils/adt/arrayfuncs.c:3354">construct_array</a>&nbsp; &nbsp; --- simple method for constructing an array object<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * elems: array of Datum items to become the array contents<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (NULL <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are not supported).<br/></li>
<li></span><span class="Comment"> * nelems: number of items<br/></li>
<li></span><span class="Comment"> * elmtype, elmlen, elmbyval, elmalign: info for the datatype of the items<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d 1-D array object is constructed and returned.&nbsp; Note that<br/></li>
<li></span><span class="Comment"> * elem <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> will be copied into the object even if pass-by-ref type.<br/></li>
<li></span><span class="Comment"> * Also note the result will be 0-D not 1-D if nelems = 0.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: it would be cleaner to look up the elmlen/elmbval/elmalign info<br/></li>
<li></span><span class="Comment"> * from the system catalogs, given the elmtype.&nbsp; However, the caller is<br/></li>
<li></span><span class="Comment"> * in a better position to cache this info across multiple uses, or even<br/></li>
<li></span><span class="Comment"> * to hard-wire <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> if the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type is hard-wired.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ArrayType *<br/></li>
<li><a id="L3354">&#x200c;</a><span class="linkable">construct_array</span>(Datum *elems, <span class="Type">int</span> nelems,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid elmtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> elmlen, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> elmbyval, <span class="Type">char</span> elmalign)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dims[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lbs[<span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dims[<span class="Constant">0</span>] = nelems;<br/></li>
<li>&nbsp; &nbsp; lbs[<span class="Constant">0</span>] = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L3475" title="utils/adt/arrayfuncs.c:3475">construct_md_array</a>(elems, <span class="Constant">NULL</span>, <span class="Constant">1</span>, dims, lbs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmtype, elmlen, elmbyval, elmalign);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Like <a href="#L3354" title="utils/adt/arrayfuncs.c:3354">construct_array</a>(), where elmtype must be a built-in type, and<br/></li>
<li></span><span class="Comment"> * elmlen/elmbyval/elmalign is looked up from hardcoded data.&nbsp; This is often<br/></li>
<li></span><span class="Comment"> * useful when manipulating arrays from/for system catalogs.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ArrayType *<br/></li>
<li><a id="L3374">&#x200c;</a><span class="linkable">construct_array_builtin</span>(Datum *elems, <span class="Type">int</span> nelems, Oid elmtype)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; elmbyval;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; elmalign;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (elmtype)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CHAROID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmlen = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmbyval = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmalign = TYPALIGN_CHAR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CSTRINGOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmlen = -<span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmbyval = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmalign = TYPALIGN_CHAR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> FLOAT4OID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmlen = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(float4);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmbyval = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmalign = TYPALIGN_INT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INT2OID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmlen = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int16);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmbyval = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmalign = TYPALIGN_SHORT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INT4OID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmlen = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int32);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmbyval = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmalign = TYPALIGN_INT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INT8OID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmlen = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int64);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmbyval = FLOAT8PASSBYVAL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmalign = TYPALIGN_DOUBLE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> NAMEOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmlen = NAMEDATALEN;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmbyval = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmalign = TYPALIGN_CHAR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OIDOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REGTYPEOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmlen = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmbyval = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmalign = TYPALIGN_INT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TEXTOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmlen = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmbyval = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmalign = TYPALIGN_INT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TIDOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmlen = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemPointerData);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmbyval = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmalign = TYPALIGN_SHORT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;type </span><span class="Special">%u</span><span class="Constant"> not supported by <a href="#L3374" title="utils/adt/arrayfuncs.c:3374">construct_array_builtin</a>()&quot;</span>, elmtype);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmlen = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmbyval = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmalign = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L3354" title="utils/adt/arrayfuncs.c:3354">construct_array</a>(elems, nelems, elmtype, elmlen, elmbyval, elmalign);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3475" title="utils/adt/arrayfuncs.c:3475">construct_md_array</a>&nbsp; &nbsp; --- simple method for constructing an array object<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; with arbitrary dimensions and possible NULLs<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * elems: array of Datum items to become the array contents<br/></li>
<li></span><span class="Comment"> * nulls: array of is-null flags (can be NULL if no nulls)<br/></li>
<li></span><span class="Comment"> * ndims: number of dimensions<br/></li>
<li></span><span class="Comment"> * dims: integer array with size of each dimension<br/></li>
<li></span><span class="Comment"> * lbs: integer array with <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound of each dimension<br/></li>
<li></span><span class="Comment"> * elmtype, elmlen, elmbyval, elmalign: info for the datatype of the items<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d ndims-D array object is constructed and returned.&nbsp; Note that<br/></li>
<li></span><span class="Comment"> * elem <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> will be copied into the object even if pass-by-ref type.<br/></li>
<li></span><span class="Comment"> * Also note the result will be 0-D not ndims-D if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> dims[i] = 0.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: it would be cleaner to look up the elmlen/elmbval/elmalign info<br/></li>
<li></span><span class="Comment"> * from the system catalogs, given the elmtype.&nbsp; However, the caller is<br/></li>
<li></span><span class="Comment"> * in a better position to cache this info across multiple uses, or even<br/></li>
<li></span><span class="Comment"> * to hard-wire <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> if the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type is hard-wired.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ArrayType *<br/></li>
<li><a id="L3475">&#x200c;</a><span class="linkable">construct_md_array</span>(Datum *elems,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *nulls,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> ndims,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> *dims,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> *lbs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid elmtype, <span class="Type">int</span> elmlen, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> elmbyval, <span class="Type">char</span> elmalign)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; hasnulls;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; nbytes;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; dataoffset;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nelems;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ndims &lt; <span class="Constant">0</span>)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we do allow zero-dimension arrays */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid number of dimensions: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, ndims)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ndims &gt; MAXDIM)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;number of array dimensions (</span><span class="Special">%d</span><span class="Constant">) exceeds the maximum allowed (</span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndims, MAXDIM)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This checks for overflow of the array dimensions */<br/></li>
<li></span>&nbsp; &nbsp; nelems = <a href="arrayutils.c.html#L57" title="utils/adt/arrayutils.c:57">ArrayGetNItems</a>(ndims, dims);<br/></li>
<li>&nbsp; &nbsp; <a href="arrayutils.c.html#L117" title="utils/adt/arrayutils.c:117">ArrayCheckBounds</a>(ndims, dims, lbs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if ndims &lt;= 0 or <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> dims[i] == 0, return empty array */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nelems &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L3561" title="utils/adt/arrayfuncs.c:3561">construct_empty_array</a>(elmtype);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* compute required space */<br/></li>
<li></span>&nbsp; &nbsp; nbytes = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; hasnulls = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nelems; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nulls &amp;&amp; nulls[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hasnulls = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* make sure data is not toasted */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (elmlen == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elems[i] = PointerGetDatum(PG_DETOAST_DATUM(elems[i]));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nbytes = att_addlength_datum(nbytes, elmlen, elems[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nbytes = att_align_nominal(nbytes, elmalign);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check for overflow of total request */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!AllocSizeIsValid(nbytes))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;array size exceeds the maximum allowed (</span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">int</span>) MaxAllocSize)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allocate and <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> result array */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (hasnulls)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dataoffset = ARR_OVERHEAD_WITHNULLS(ndims, nelems);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nbytes += dataoffset;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dataoffset = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* marker for no null bitmap */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nbytes += ARR_OVERHEAD_NONULLS(ndims);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; result = (ArrayType *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(nbytes);<br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(result, nbytes);<br/></li>
<li>&nbsp; &nbsp; result-&gt;ndim = ndims;<br/></li>
<li>&nbsp; &nbsp; result-&gt;dataoffset = dataoffset;<br/></li>
<li>&nbsp; &nbsp; result-&gt;elemtype = elmtype;<br/></li>
<li>&nbsp; &nbsp; memcpy(ARR_DIMS(result), dims, ndims * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; memcpy(ARR_LBOUND(result), lbs, ndims * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L961" title="utils/adt/arrayfuncs.c:961">CopyArrayEls</a>(result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; elems, nulls, nelems,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; elmlen, elmbyval, elmalign,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3561" title="utils/adt/arrayfuncs.c:3561">construct_empty_array</a>&nbsp; &nbsp; --- make a zero-dimensional array of given type<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ArrayType *<br/></li>
<li><a id="L3561">&#x200c;</a><span class="linkable">construct_empty_array</span>(Oid elmtype)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (ArrayType *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ArrayType));<br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(result, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ArrayType));<br/></li>
<li>&nbsp; &nbsp; result-&gt;ndim = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; result-&gt;dataoffset = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; result-&gt;elemtype = elmtype;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3578" title="utils/adt/arrayfuncs.c:3578">construct_empty_expanded_array</a>: make an empty expanded array<br/></li>
<li></span><span class="Comment"> * given only type information.&nbsp; (metacache can be NULL if not needed.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ExpandedArrayHeader *<br/></li>
<li><a id="L3578">&#x200c;</a><span class="linkable">construct_empty_expanded_array</span>(Oid element_type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MemoryContext parentcontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ArrayMetaState *metacache)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *array = <a href="#L3561" title="utils/adt/arrayfuncs.c:3561">construct_empty_array</a>(element_type);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; d;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; d = <a href="array_expanded.c.html#L50" title="utils/adt/array_expanded.c:50">expand_array</a>(PointerGetDatum(array), parentcontext, metacache);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(array);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (ExpandedArrayHeader *) <a href="expandeddatum.c.html#L29" title="utils/adt/expandeddatum.c:29">DatumGetEOHP</a>(d);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3612" title="utils/adt/arrayfuncs.c:3612">deconstruct_array</a>&nbsp; --- simple method for extracting data from an array<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * array: array object to examine (must not be NULL)<br/></li>
<li></span><span class="Comment"> * elmtype, elmlen, elmbyval, elmalign: info for the datatype of the items<br/></li>
<li></span><span class="Comment"> * elemsp: return value, set to point to <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d array of Datum <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment"> * nullsp: return value, set to point to <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d array of isnull markers<br/></li>
<li></span><span class="Comment"> * nelemsp: return value, set to number of extracted <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller may pass nullsp == NULL if it does not support NULLs in the<br/></li>
<li></span><span class="Comment"> * array.&nbsp; Note that this produces a very uninformative error message,<br/></li>
<li></span><span class="Comment"> * so do it only in cases where a NULL is really not expected.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If array elements are pass-by-ref data type, the returned Datums will<br/></li>
<li></span><span class="Comment"> * be pointers into the array object.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: it would be cleaner to look up the elmlen/elmbval/elmalign info<br/></li>
<li></span><span class="Comment"> * from the system catalogs, given the elmtype.&nbsp; However, the caller is<br/></li>
<li></span><span class="Comment"> * in a better position to cache this info across multiple uses, or even<br/></li>
<li></span><span class="Comment"> * to hard-wire <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> if the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type is hard-wired.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3612">&#x200c;</a></span><span class="linkable">deconstruct_array</span>(ArrayType *array,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid elmtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> elmlen, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> elmbyval, <span class="Type">char</span> elmalign,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum **elemsp, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> **nullsp, <span class="Type">int</span> *nelemsp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *elems;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *nulls;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nelems;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *p;<br/></li>
<li>&nbsp; &nbsp; bits8&nbsp; &nbsp; &nbsp;&nbsp; *bitmap;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitmask;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(ARR_ELEMTYPE(array) == elmtype);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nelems = <a href="arrayutils.c.html#L57" title="utils/adt/arrayutils.c:57">ArrayGetNItems</a>(ARR_NDIM(array), ARR_DIMS(array));<br/></li>
<li>&nbsp; &nbsp; *elemsp = elems = (Datum *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(nelems * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nullsp)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *nullsp = nulls = (<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(nelems * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; *nelemsp = nelems;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; p = ARR_DATA_PTR(array);<br/></li>
<li>&nbsp; &nbsp; bitmap = ARR_NULLBITMAP(array);<br/></li>
<li>&nbsp; &nbsp; bitmask = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nelems; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get source <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>, checking for NULL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bitmap &amp;&amp; (*bitmap &amp; bitmask) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elems[i] = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nulls)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[i] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NULL_VALUE_NOT_ALLOWED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;null array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> not allowed in this context&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elems[i] = fetch_att(p, elmbyval, elmlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p = att_addlength_pointer(p, elmlen, p);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p = (<span class="Type">char</span> *) att_align_nominal(p, elmalign);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* advance bitmap pointer if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bitmap)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitmask &lt;&lt;= <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bitmask == <span class="Constant">0x100</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitmap++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitmask = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Like <a href="#L3612" title="utils/adt/arrayfuncs.c:3612">deconstruct_array</a>(), where elmtype must be a built-in type, and<br/></li>
<li></span><span class="Comment"> * elmlen/elmbyval/elmalign is looked up from hardcoded data.&nbsp; This is often<br/></li>
<li></span><span class="Comment"> * useful when manipulating arrays from/for system catalogs.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3678">&#x200c;</a></span><span class="linkable">deconstruct_array_builtin</span>(ArrayType *array,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid elmtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum **elemsp, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> **nullsp, <span class="Type">int</span> *nelemsp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; elmbyval;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; elmalign;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (elmtype)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CHAROID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmlen = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmbyval = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmalign = TYPALIGN_CHAR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CSTRINGOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmlen = -<span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmbyval = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmalign = TYPALIGN_CHAR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> FLOAT8OID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmlen = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(float8);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmbyval = FLOAT8PASSBYVAL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmalign = TYPALIGN_DOUBLE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INT2OID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmlen = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int16);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmbyval = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmalign = TYPALIGN_SHORT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OIDOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmlen = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmbyval = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmalign = TYPALIGN_INT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TEXTOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmlen = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmbyval = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmalign = TYPALIGN_INT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TIDOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmlen = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemPointerData);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmbyval = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmalign = TYPALIGN_SHORT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;type </span><span class="Special">%u</span><span class="Constant"> not supported by <a href="#L3678" title="utils/adt/arrayfuncs.c:3678">deconstruct_array_builtin</a>()&quot;</span>, elmtype);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmlen = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmbyval = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmalign = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L3612" title="utils/adt/arrayfuncs.c:3612">deconstruct_array</a>(array, elmtype, elmlen, elmbyval, elmalign, elemsp, nullsp, nelemsp);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3748" title="utils/adt/arrayfuncs.c:3748">array_contains_nulls</a> --- detect whether an array has <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> null elements<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This gives an accurate answer, whereas testing ARR_HASNULL only tells<br/></li>
<li></span><span class="Comment"> * if the array *might* contain a null.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3748">&#x200c;</a></span><span class="linkable">array_contains_nulls</span>(ArrayType *array)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nelems;<br/></li>
<li>&nbsp; &nbsp; bits8&nbsp; &nbsp; &nbsp;&nbsp; *bitmap;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitmask;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Easy answer if there's no null bitmap */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!ARR_HASNULL(array))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nelems = <a href="arrayutils.c.html#L57" title="utils/adt/arrayutils.c:57">ArrayGetNItems</a>(ARR_NDIM(array), ARR_DIMS(array));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; bitmap = ARR_NULLBITMAP(array);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check whole bytes of the bitmap byte-at-a-time */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (nelems &gt;= <span class="Constant">8</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*bitmap != <span class="Constant">0xFF</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bitmap++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nelems -= <span class="Constant">8</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check last partial byte */<br/></li>
<li></span>&nbsp; &nbsp; bitmask = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (nelems &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((*bitmap &amp; bitmask) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bitmask &lt;&lt;= <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nelems--;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3795" title="utils/adt/arrayfuncs.c:3795">array_eq</a> :<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; compares two arrays for equality<br/></li>
<li></span><span class="Comment"> * result :<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; returns true if the arrays are <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>, false otherwise.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: we do not use <a href="#L3966" title="utils/adt/arrayfuncs.c:3966">array_cmp</a> here, since equality may be meaningful in<br/></li>
<li></span><span class="Comment"> * datatypes that don't have a total ordering (and hence no btree support).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3795">&#x200c;</a><span class="linkable">array_eq</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCAL_FCINFO(locfcinfo, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; AnyArrayType *array1 = PG_GETARG_ANY_ARRAY_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; AnyArrayType *array2 = PG_GETARG_ANY_ARRAY_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collation = PG_GET_COLLATION();<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndims1 = AARR_NDIM(array1);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndims2 = AARR_NDIM(array2);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *dims1 = AARR_DIMS(array1);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *dims2 = AARR_DIMS(array2);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *lbs1 = AARR_LBOUND(array1);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *lbs2 = AARR_LBOUND(array2);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; element_type = AARR_ELEMTYPE(array1);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nitems;<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typentry;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; typbyval;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; typalign;<br/></li>
<li>&nbsp; &nbsp; array_iter&nbsp; &nbsp; it1;<br/></li>
<li>&nbsp; &nbsp; array_iter&nbsp; &nbsp; it2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (element_type != AARR_ELEMTYPE(array2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> arrays of different <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> types&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fast path if the arrays do not have the same dimensionality */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ndims1 != ndims2 ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcmp(dims1, dims2, ndims1 * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>)) != <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcmp(lbs1, lbs2, ndims1 * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>)) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We arrange to look up the equality function only once per series of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * calls, assuming the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type doesn't change underneath us.&nbsp; The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * typcache is used so that we have no memory leakage when being used<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * as an index support function.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; typentry = (TypeCacheEntry *) fcinfo-&gt;flinfo-&gt;fn_extra;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typentry == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;type_id != element_type)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typentry = <a href="../cache/typcache.c.html#L346" title="utils/cache/typcache.c:346">lookup_type_cache</a>(element_type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TYPECACHE_EQ_OPR_FINFO);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(typentry-&gt;eq_opr_finfo.fn_oid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not identify an equality operator for type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(element_type))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;flinfo-&gt;fn_extra = (<span class="Type">void</span> *) typentry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typlen = typentry-&gt;typlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typbyval = typentry-&gt;typbyval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typalign = typentry-&gt;typalign;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * apply the operator to each pair of array elements.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; InitFunctionCallInfoData(*locfcinfo, &amp;typentry-&gt;eq_opr_finfo, <span class="Constant">2</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; collation, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Loop over source data */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nitems = <a href="arrayutils.c.html#L57" title="utils/adt/arrayutils.c:57">ArrayGetNItems</a>(ndims1, dims1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; array_iter_setup(&amp;it1, array1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; array_iter_setup(&amp;it2, array2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nitems; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; elt1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; elt2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; oprresult;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get elements, checking for NULL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elt1 = array_iter_next(&amp;it1, &amp;isnull1, i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typlen, typbyval, typalign);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elt2 = array_iter_next(&amp;it2, &amp;isnull2, i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typlen, typbyval, typalign);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We consider two NULLs <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>; NULL and not-NULL are unequal.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnull1 &amp;&amp; isnull2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnull1 || isnull2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Apply the operator to the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> pair; treat NULL as false<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locfcinfo-&gt;args[<span class="Constant">0</span>].value = elt1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locfcinfo-&gt;args[<span class="Constant">0</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locfcinfo-&gt;args[<span class="Constant">1</span>].value = elt2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locfcinfo-&gt;args[<span class="Constant">1</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locfcinfo-&gt;isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oprresult = DatumGetBool(FunctionCallInvoke(locfcinfo));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (locfcinfo-&gt;isnull || !oprresult)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Avoid leaking memory when handed toasted input. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L50" title="utils/adt/arrayfuncs.c:50">AARR_FREE_IF_COPY</a>(array1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L50" title="utils/adt/arrayfuncs.c:50">AARR_FREE_IF_COPY</a>(array2, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*-----------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * array-array <a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a> operators:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Given two arrays, iterate comparison operators<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; over the array. Uses logic similar to text comparison<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, except <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>-by-<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> instead of<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; character-by-character.<br/></li>
<li></span><span class="Comment"> *----------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L3924">&#x200c;</a><span class="linkable">array_ne</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(!DatumGetBool(<a href="#L3795" title="utils/adt/arrayfuncs.c:3795">array_eq</a>(fcinfo)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3930">&#x200c;</a><span class="linkable">array_lt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L3966" title="utils/adt/arrayfuncs.c:3966">array_cmp</a>(fcinfo) &lt; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3936">&#x200c;</a><span class="linkable">array_gt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L3966" title="utils/adt/arrayfuncs.c:3966">array_cmp</a>(fcinfo) &gt; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3942">&#x200c;</a><span class="linkable">array_le</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L3966" title="utils/adt/arrayfuncs.c:3966">array_cmp</a>(fcinfo) &lt;= <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3948">&#x200c;</a><span class="linkable">array_ge</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L3966" title="utils/adt/arrayfuncs.c:3966">array_cmp</a>(fcinfo) &gt;= <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3954">&#x200c;</a><span class="linkable">btarraycmp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(<a href="#L3966" title="utils/adt/arrayfuncs.c:3966">array_cmp</a>(fcinfo));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3966" title="utils/adt/arrayfuncs.c:3966">array_cmp</a>()<br/></li>
<li></span><span class="Comment"> * Internal comparison function for arrays.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns -1, 0 or 1<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L3966">&#x200c;</a></span><span class="linkable">array_cmp</span>(FunctionCallInfo fcinfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCAL_FCINFO(locfcinfo, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; AnyArrayType *array1 = PG_GETARG_ANY_ARRAY_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; AnyArrayType *array2 = PG_GETARG_ANY_ARRAY_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collation = PG_GET_COLLATION();<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndims1 = AARR_NDIM(array1);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndims2 = AARR_NDIM(array2);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *dims1 = AARR_DIMS(array1);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *dims2 = AARR_DIMS(array2);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nitems1 = <a href="arrayutils.c.html#L57" title="utils/adt/arrayutils.c:57">ArrayGetNItems</a>(ndims1, dims1);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nitems2 = <a href="arrayutils.c.html#L57" title="utils/adt/arrayutils.c:57">ArrayGetNItems</a>(ndims2, dims2);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; element_type = AARR_ELEMTYPE(array1);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typentry;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; typbyval;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; typalign;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min_nitems;<br/></li>
<li>&nbsp; &nbsp; array_iter&nbsp; &nbsp; it1;<br/></li>
<li>&nbsp; &nbsp; array_iter&nbsp; &nbsp; it2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (element_type != AARR_ELEMTYPE(array2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> arrays of different <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> types&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We arrange to look up the comparison function only once per series of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * calls, assuming the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type doesn't change underneath us. The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * typcache is used so that we have no memory leakage when being used as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * an index support function.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; typentry = (TypeCacheEntry *) fcinfo-&gt;flinfo-&gt;fn_extra;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (typentry == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;type_id != element_type)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry = <a href="../cache/typcache.c.html#L346" title="utils/cache/typcache.c:346">lookup_type_cache</a>(element_type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TYPECACHE_CMP_PROC_FINFO);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(typentry-&gt;cmp_proc_finfo.fn_oid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not identify a comparison function for type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(element_type))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;flinfo-&gt;fn_extra = (<span class="Type">void</span> *) typentry;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; typlen = typentry-&gt;typlen;<br/></li>
<li>&nbsp; &nbsp; typbyval = typentry-&gt;typbyval;<br/></li>
<li>&nbsp; &nbsp; typalign = typentry-&gt;typalign;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * apply the operator to each pair of array elements.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; InitFunctionCallInfoData(*locfcinfo, &amp;typentry-&gt;cmp_proc_finfo, <span class="Constant">2</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; collation, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Loop over source data */<br/></li>
<li></span>&nbsp; &nbsp; min_nitems = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(nitems1, nitems2);<br/></li>
<li>&nbsp; &nbsp; array_iter_setup(&amp;it1, array1);<br/></li>
<li>&nbsp; &nbsp; array_iter_setup(&amp;it2, array2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; min_nitems; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; elt1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; elt2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; cmpresult;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get elements, checking for NULL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elt1 = array_iter_next(&amp;it1, &amp;isnull1, i, typlen, typbyval, typalign);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elt2 = array_iter_next(&amp;it2, &amp;isnull2, i, typlen, typbyval, typalign);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We consider two NULLs <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>; NULL &gt; not-NULL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnull1 &amp;&amp; isnull2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnull1)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* arg1 is greater than arg2 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnull2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* arg1 is less than arg2 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Compare the pair of elements */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; locfcinfo-&gt;args[<span class="Constant">0</span>].value = elt1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; locfcinfo-&gt;args[<span class="Constant">0</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; locfcinfo-&gt;args[<span class="Constant">1</span>].value = elt2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; locfcinfo-&gt;args[<span class="Constant">1</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cmpresult = DatumGetInt32(FunctionCallInvoke(locfcinfo));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We don't expect comparison support <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> to return null */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!locfcinfo-&gt;isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cmpresult == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cmpresult &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* arg1 is less than arg2 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* arg1 is greater than arg2 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If arrays contain same data (up to end of shorter one), apply<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * additional rules to sort by dimensionality.&nbsp; The relative significance<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of the different bits of information is historical; mainly we just care<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that we don't say &quot;<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>&quot; for arrays of different dimensionality.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (result == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nitems1 != nitems2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = (nitems1 &lt; nitems2) ? -<span class="Constant">1</span> : <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (ndims1 != ndims2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = (ndims1 &lt; ndims2) ? -<span class="Constant">1</span> : <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; ndims1; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dims1[i] != dims2[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = (dims1[i] &lt; dims2[i]) ? -<span class="Constant">1</span> : <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *lbound1 = AARR_LBOUND(array1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *lbound2 = AARR_LBOUND(array2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; ndims1; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lbound1[i] != lbound2[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = (lbound1[i] &lt; lbound2[i]) ? -<span class="Constant">1</span> : <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Avoid leaking memory when handed toasted input. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L50" title="utils/adt/arrayfuncs.c:50">AARR_FREE_IF_COPY</a>(array1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L50" title="utils/adt/arrayfuncs.c:50">AARR_FREE_IF_COPY</a>(array2, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*-----------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * array hashing<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Hash the elements and <a href="../../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> the results.<br/></li>
<li></span><span class="Comment"> *----------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L4139">&#x200c;</a><span class="linkable">hash_array</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCAL_FCINFO(locfcinfo, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; AnyArrayType *array = PG_GETARG_ANY_ARRAY_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndims = AARR_NDIM(array);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *dims = AARR_DIMS(array);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; element_type = AARR_ELEMTYPE(array);<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nitems;<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typentry;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; typbyval;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; typalign;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; array_iter&nbsp; &nbsp; iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We arrange to look up the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> function only once per series of calls,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * assuming the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type doesn't change underneath us.&nbsp; The typcache<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is used so that we have no memory leakage when being used as an index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * support function.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; typentry = (TypeCacheEntry *) fcinfo-&gt;flinfo-&gt;fn_extra;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (typentry == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;type_id != element_type)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry = <a href="../cache/typcache.c.html#L346" title="utils/cache/typcache.c:346">lookup_type_cache</a>(element_type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TYPECACHE_HASH_PROC_FINFO);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(typentry-&gt;hash_proc_finfo.fn_oid) &amp;&amp; element_type != RECORDOID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not identify a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> function for type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(element_type))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The type cache doesn't believe that record is hashable (see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../cache/typcache.c.html#L1521" title="utils/cache/typcache.c:1521">cache_record_field_properties</a>()), but since we're here, we're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * committed to hashing, so we can assume it does.&nbsp; Worst case, if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * components of the record don't support hashing, we will fail at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * execution.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (element_type == RECORDOID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TypeCacheEntry *record_typentry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(fcinfo-&gt;flinfo-&gt;fn_mcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make fake type cache entry structure.&nbsp; Note that we can't just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * modify typentry, since that points directly into the type<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cache.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; record_typentry = <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(*record_typentry));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; record_typentry-&gt;type_id = element_type;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fill in what we need below */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; record_typentry-&gt;typlen = typentry-&gt;typlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; record_typentry-&gt;typbyval = typentry-&gt;typbyval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; record_typentry-&gt;typalign = typentry-&gt;typalign;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../fmgr/fmgr.c.html#L127" title="utils/fmgr/fmgr.c:127">fmgr_info</a>(F_HASH_RECORD, &amp;record_typentry-&gt;hash_proc_finfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typentry = record_typentry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;flinfo-&gt;fn_extra = (<span class="Type">void</span> *) typentry;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typlen = typentry-&gt;typlen;<br/></li>
<li>&nbsp; &nbsp; typbyval = typentry-&gt;typbyval;<br/></li>
<li>&nbsp; &nbsp; typalign = typentry-&gt;typalign;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * apply the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> function to each array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; InitFunctionCallInfoData(*locfcinfo, &amp;typentry-&gt;hash_proc_finfo, <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PG_GET_COLLATION(), <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Loop over source data */<br/></li>
<li></span>&nbsp; &nbsp; nitems = <a href="arrayutils.c.html#L57" title="utils/adt/arrayutils.c:57">ArrayGetNItems</a>(ndims, dims);<br/></li>
<li>&nbsp; &nbsp; array_iter_setup(&amp;iter, array);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nitems; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; elt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; elthash;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>, checking for NULL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elt = array_iter_next(&amp;iter, &amp;isnull, i, typlen, typbyval, typalign);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Treat nulls as having hashvalue 0 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elthash = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Apply the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> function */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locfcinfo-&gt;args[<span class="Constant">0</span>].value = elt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locfcinfo-&gt;args[<span class="Constant">0</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elthash = DatumGetUInt32(FunctionCallInvoke(locfcinfo));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We don't expect <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> to return null */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!locfcinfo-&gt;isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Combine <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of successive elements by multiplying the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * current value by 31 and adding on the new <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>'s <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The result is a sum in which each <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>'s <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> value is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * multiplied by a different power of 31. This is modulo 2^32<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * arithmetic, and the powers of 31 modulo 2^32 form a cyclic group of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * order 2^27. So for arrays of up to 2^27 elements, each <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>'s<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> value is multiplied by a different (odd) number, resulting in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a good mixing of all the elements' <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = (result &lt;&lt; <span class="Constant">5</span>) - result + elthash;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Avoid leaking memory when handed toasted input. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L50" title="utils/adt/arrayfuncs.c:50">AARR_FREE_IF_COPY</a>(array, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_UINT32(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns 64-<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> value by hashing a value to a 64-<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> value, with a seed.<br/></li>
<li></span><span class="Comment"> * Otherwise, similar to <a href="#L4139" title="utils/adt/arrayfuncs.c:4139">hash_array</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4272">&#x200c;</a><span class="linkable">hash_array_extended</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCAL_FCINFO(locfcinfo, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; AnyArrayType *array = PG_GETARG_ANY_ARRAY_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; seed = PG_GETARG_INT64(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndims = AARR_NDIM(array);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *dims = AARR_DIMS(array);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; element_type = AARR_ELEMTYPE(array);<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nitems;<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typentry;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; typbyval;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; typalign;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; array_iter&nbsp; &nbsp; iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typentry = (TypeCacheEntry *) fcinfo-&gt;flinfo-&gt;fn_extra;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (typentry == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;type_id != element_type)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry = <a href="../cache/typcache.c.html#L346" title="utils/cache/typcache.c:346">lookup_type_cache</a>(element_type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TYPECACHE_HASH_EXTENDED_PROC_FINFO);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(typentry-&gt;hash_extended_proc_finfo.fn_oid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not identify an extended <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> function for type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(element_type))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;flinfo-&gt;fn_extra = (<span class="Type">void</span> *) typentry;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; typlen = typentry-&gt;typlen;<br/></li>
<li>&nbsp; &nbsp; typbyval = typentry-&gt;typbyval;<br/></li>
<li>&nbsp; &nbsp; typalign = typentry-&gt;typalign;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; InitFunctionCallInfoData(*locfcinfo, &amp;typentry-&gt;hash_extended_proc_finfo, <span class="Constant">2</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PG_GET_COLLATION(), <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Loop over source data */<br/></li>
<li></span>&nbsp; &nbsp; nitems = <a href="arrayutils.c.html#L57" title="utils/adt/arrayutils.c:57">ArrayGetNItems</a>(ndims, dims);<br/></li>
<li>&nbsp; &nbsp; array_iter_setup(&amp;iter, array);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nitems; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; elt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; elthash;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>, checking for NULL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elt = array_iter_next(&amp;iter, &amp;isnull, i, typlen, typbyval, typalign);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elthash = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Apply the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> function */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locfcinfo-&gt;args[<span class="Constant">0</span>].value = elt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locfcinfo-&gt;args[<span class="Constant">0</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locfcinfo-&gt;args[<span class="Constant">1</span>].value = <a href="../fmgr/fmgr.c.html#L1807" title="utils/fmgr/fmgr.c:1807">Int64GetDatum</a>(seed);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locfcinfo-&gt;args[<span class="Constant">1</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elthash = DatumGetUInt64(FunctionCallInvoke(locfcinfo));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We don't expect <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> to return null */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!locfcinfo-&gt;isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = (result &lt;&lt; <span class="Constant">5</span>) - result + elthash;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L50" title="utils/adt/arrayfuncs.c:50">AARR_FREE_IF_COPY</a>(array, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_UINT64(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*-----------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * array overlap/containment comparisons<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; These use the same methods of comparing array elements as <a href="#L3795" title="utils/adt/arrayfuncs.c:3795">array_eq</a>.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; We consider only the elements of the arrays, ignoring dimensionality.<br/></li>
<li></span><span class="Comment"> *----------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4362" title="utils/adt/arrayfuncs.c:4362">array_contain_compare</a> :<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; compares two arrays for overlap/containment<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When matchall is true, return true if all members of array1 are in array2.<br/></li>
<li></span><span class="Comment"> * When matchall is false, return true if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> members of array1 are in array2.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L4362">&#x200c;</a></span><span class="linkable">array_contain_compare</span>(AnyArrayType *array1, AnyArrayType *array2, Oid collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> matchall, <span class="Type">void</span> **fn_extra)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCAL_FCINFO(locfcinfo, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result = matchall;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; element_type = AARR_ELEMTYPE(array1);<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typentry;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nelems1;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *values2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *nulls2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nelems2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; typbyval;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; typalign;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li>&nbsp; &nbsp; array_iter&nbsp; &nbsp; it1;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (element_type != AARR_ELEMTYPE(array2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> arrays of different <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> types&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We arrange to look up the equality function only once per series of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * calls, assuming the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type doesn't change underneath us.&nbsp; The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * typcache is used so that we have no memory leakage when being used as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * an index support function.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; typentry = (TypeCacheEntry *) *fn_extra;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (typentry == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;type_id != element_type)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry = <a href="../cache/typcache.c.html#L346" title="utils/cache/typcache.c:346">lookup_type_cache</a>(element_type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TYPECACHE_EQ_OPR_FINFO);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(typentry-&gt;eq_opr_finfo.fn_oid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not identify an equality operator for type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(element_type))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *fn_extra = (<span class="Type">void</span> *) typentry;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; typlen = typentry-&gt;typlen;<br/></li>
<li>&nbsp; &nbsp; typbyval = typentry-&gt;typbyval;<br/></li>
<li>&nbsp; &nbsp; typalign = typentry-&gt;typalign;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since we probably will need to scan array2 multiple times, it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * worthwhile to use <a href="#L3612" title="utils/adt/arrayfuncs.c:3612">deconstruct_array</a> on it.&nbsp; We scan array1 the hard way<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * however, since we very likely won't need to look at all of it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (VARATT_IS_EXPANDED_HEADER(array2))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This should be safe even if input is read-only */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="array_expanded.c.html#L424" title="utils/adt/array_expanded.c:424">deconstruct_expanded_array</a>(&amp;(array2-&gt;xpn));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; values2 = array2-&gt;xpn.dvalues;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nulls2 = array2-&gt;xpn.dnulls;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nelems2 = array2-&gt;xpn.nelems;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3612" title="utils/adt/arrayfuncs.c:3612">deconstruct_array</a>((ArrayType *) array2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; element_type, typlen, typbyval, typalign,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;values2, &amp;nulls2, &amp;nelems2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Apply the comparison operator to each pair of array elements.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; InitFunctionCallInfoData(*locfcinfo, &amp;typentry-&gt;eq_opr_finfo, <span class="Constant">2</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; collation, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Loop over source data */<br/></li>
<li></span>&nbsp; &nbsp; nelems1 = <a href="arrayutils.c.html#L57" title="utils/adt/arrayutils.c:57">ArrayGetNItems</a>(AARR_NDIM(array1), AARR_DIMS(array1));<br/></li>
<li>&nbsp; &nbsp; array_iter_setup(&amp;it1, array1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nelems1; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; elt1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull1;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>, checking for NULL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elt1 = array_iter_next(&amp;it1, &amp;isnull1, i, typlen, typbyval, typalign);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We assume that the comparison operator is strict, so a NULL can't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * match anything.&nbsp; </span><span class="Todo">XXX</span><span class="Comment"> this diverges from the &quot;NULL=NULL&quot; behavior of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L3795" title="utils/adt/arrayfuncs.c:3795">array_eq</a>, should we act like that?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnull1)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (matchall)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = <span class="Constant">0</span>; j &lt; nelems2; j++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; elt2 = values2[j];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull2 = nulls2 ? nulls2[j] : <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; oprresult;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnull2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* can't match */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Apply the operator to the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> pair; treat NULL as false<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locfcinfo-&gt;args[<span class="Constant">0</span>].value = elt1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locfcinfo-&gt;args[<span class="Constant">0</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locfcinfo-&gt;args[<span class="Constant">1</span>].value = elt2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locfcinfo-&gt;args[<span class="Constant">1</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locfcinfo-&gt;isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oprresult = DatumGetBool(FunctionCallInvoke(locfcinfo));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!locfcinfo-&gt;isnull &amp;&amp; oprresult)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (j &lt; nelems2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* found a match for elt1 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!matchall)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no match for elt1 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (matchall)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L4505">&#x200c;</a><span class="linkable">arrayoverlap</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; AnyArrayType *array1 = PG_GETARG_ANY_ARRAY_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; AnyArrayType *array2 = PG_GETARG_ANY_ARRAY_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collation = PG_GET_COLLATION();<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L4362" title="utils/adt/arrayfuncs.c:4362">array_contain_compare</a>(array1, array2, collation, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;fcinfo-&gt;flinfo-&gt;fn_extra);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Avoid leaking memory when handed toasted input. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L50" title="utils/adt/arrayfuncs.c:50">AARR_FREE_IF_COPY</a>(array1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L50" title="utils/adt/arrayfuncs.c:50">AARR_FREE_IF_COPY</a>(array2, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L4523">&#x200c;</a><span class="linkable">arraycontains</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; AnyArrayType *array1 = PG_GETARG_ANY_ARRAY_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; AnyArrayType *array2 = PG_GETARG_ANY_ARRAY_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collation = PG_GET_COLLATION();<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L4362" title="utils/adt/arrayfuncs.c:4362">array_contain_compare</a>(array2, array1, collation, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;fcinfo-&gt;flinfo-&gt;fn_extra);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Avoid leaking memory when handed toasted input. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L50" title="utils/adt/arrayfuncs.c:50">AARR_FREE_IF_COPY</a>(array1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L50" title="utils/adt/arrayfuncs.c:50">AARR_FREE_IF_COPY</a>(array2, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L4541">&#x200c;</a><span class="linkable">arraycontained</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; AnyArrayType *array1 = PG_GETARG_ANY_ARRAY_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; AnyArrayType *array2 = PG_GETARG_ANY_ARRAY_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collation = PG_GET_COLLATION();<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L4362" title="utils/adt/arrayfuncs.c:4362">array_contain_compare</a>(array1, array2, collation, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;fcinfo-&gt;flinfo-&gt;fn_extra);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Avoid leaking memory when handed toasted input. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L50" title="utils/adt/arrayfuncs.c:50">AARR_FREE_IF_COPY</a>(array1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L50" title="utils/adt/arrayfuncs.c:50">AARR_FREE_IF_COPY</a>(array2, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*-----------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * Array iteration <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; These <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> are used to iterate efficiently through arrays<br/></li>
<li></span><span class="Comment"> *-----------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4578" title="utils/adt/arrayfuncs.c:4578">array_create_iterator</a> --- set up to iterate through an array<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If slice_ndim is zero, we will iterate <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>-by-<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>; the returned<br/></li>
<li></span><span class="Comment"> * datums are of the array's <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If slice_ndim is 1..ARR_NDIM(arr), we will iterate by slices: the<br/></li>
<li></span><span class="Comment"> * returned datums are of the same array type as 'arr', but of size<br/></li>
<li></span><span class="Comment"> * <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to the rightmost N dimensions of 'arr'.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The passed-in array must remain valid for the lifetime of the iterator.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ArrayIterator<br/></li>
<li><a id="L4578">&#x200c;</a><span class="linkable">array_create_iterator</span>(ArrayType *arr, <span class="Type">int</span> slice_ndim, ArrayMetaState *mstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayIterator iterator = <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L68" title="utils/adt/arrayfuncs.c:68">ArrayIteratorData</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Sanity-check inputs --- caller should have got this right already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(PointerIsValid(arr));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (slice_ndim &lt; <span class="Constant">0</span> || slice_ndim &gt; ARR_NDIM(arr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid arguments to <a href="#L4578" title="utils/adt/arrayfuncs.c:4578">array_create_iterator</a>&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Remember basic info about the array and its <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; iterator-&gt;arr = arr;<br/></li>
<li>&nbsp; &nbsp; iterator-&gt;nullbitmap = ARR_NULLBITMAP(arr);<br/></li>
<li>&nbsp; &nbsp; iterator-&gt;nitems = <a href="arrayutils.c.html#L57" title="utils/adt/arrayutils.c:57">ArrayGetNItems</a>(ARR_NDIM(arr), ARR_DIMS(arr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (mstate != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(mstate-&gt;element_type == ARR_ELEMTYPE(arr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; iterator-&gt;typlen = mstate-&gt;typlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; iterator-&gt;typbyval = mstate-&gt;typbyval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; iterator-&gt;typalign = mstate-&gt;typalign;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L2271" title="utils/cache/lsyscache.c:2271">get_typlenbyvalalign</a>(ARR_ELEMTYPE(arr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;iterator-&gt;typlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;iterator-&gt;typbyval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;iterator-&gt;typalign);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Remember the slicing parameters.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; iterator-&gt;slice_ndim = slice_ndim;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (slice_ndim &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Get pointers into the array's dims and lbound arrays to represent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the dims/lbound arrays of a slice.&nbsp; These are the same as the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rightmost N dimensions of the array.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; iterator-&gt;slice_dims = ARR_DIMS(arr) + ARR_NDIM(arr) - slice_ndim;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; iterator-&gt;slice_lbound = ARR_LBOUND(arr) + ARR_NDIM(arr) - slice_ndim;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Compute number of elements in a slice.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; iterator-&gt;slice_len = <a href="arrayutils.c.html#L57" title="utils/adt/arrayutils.c:57">ArrayGetNItems</a>(slice_ndim,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; iterator-&gt;slice_dims);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Create workspace for building sub-arrays.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; iterator-&gt;slice_values = (Datum *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(iterator-&gt;slice_len * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; iterator-&gt;slice_nulls = (<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(iterator-&gt;slice_len * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize our data pointer and linear <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> number.&nbsp; These will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * advance through the array during <a href="#L4657" title="utils/adt/arrayfuncs.c:4657">array_iterate</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; iterator-&gt;data_ptr = ARR_DATA_PTR(arr);<br/></li>
<li>&nbsp; &nbsp; iterator-&gt;current_item = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> iterator;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Iterate through the array referenced by 'iterator'.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As long as there is another <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> (or slice), return it into<br/></li>
<li></span><span class="Comment"> * *value / *isnull, and return true.&nbsp; Return false when no more data.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L4657">&#x200c;</a></span><span class="linkable">array_iterate</span>(ArrayIterator iterator, Datum *value, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Done if we have reached the end of the array */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (iterator-&gt;current_item &gt;= iterator-&gt;nitems)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (iterator-&gt;slice_ndim == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Scalar case: return one <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L4762" title="utils/adt/arrayfuncs.c:4762">array_get_isnull</a>(iterator-&gt;nullbitmap, iterator-&gt;current_item++))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *isnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *value = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* non-NULL, so fetch the individual Datum to return */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *p = iterator-&gt;data_ptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *value = fetch_att(p, iterator-&gt;typbyval, iterator-&gt;typlen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Move our data pointer forward to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p = att_addlength_pointer(p, iterator-&gt;typlen, p);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p = (<span class="Type">char</span> *) att_align_nominal(p, iterator-&gt;typalign);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iterator-&gt;data_ptr = p;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Slice case: build and return an array of the requested size.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ArrayType&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> = iterator-&gt;slice_values;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *nulls = iterator-&gt;slice_nulls;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *p = iterator-&gt;data_ptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; iterator-&gt;slice_len; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L4762" title="utils/adt/arrayfuncs.c:4762">array_get_isnull</a>(iterator-&gt;nullbitmap,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; iterator-&gt;current_item++))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[i] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i] = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[i] = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i] = fetch_att(p, iterator-&gt;typbyval, iterator-&gt;typlen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Move our data pointer forward to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p = att_addlength_pointer(p, iterator-&gt;typlen, p);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p = (<span class="Type">char</span> *) att_align_nominal(p, iterator-&gt;typalign);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; iterator-&gt;data_ptr = p;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L3475" title="utils/adt/arrayfuncs.c:3475">construct_md_array</a>(<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iterator-&gt;slice_ndim,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iterator-&gt;slice_dims,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iterator-&gt;slice_lbound,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ARR_ELEMTYPE(iterator-&gt;arr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iterator-&gt;typlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iterator-&gt;typbyval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iterator-&gt;typalign);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *value = PointerGetDatum(result);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Release an ArrayIterator data structure<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4740">&#x200c;</a></span><span class="linkable">array_free_iterator</span>(ArrayIterator iterator)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (iterator-&gt;slice_ndim &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(iterator-&gt;slice_values);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(iterator-&gt;slice_nulls);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(iterator);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/***************************************************************************/<br/></li>
<li></span><span class="Comment">/******************|&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Support&nbsp; Routines&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |*****************/<br/></li>
<li></span><span class="Comment">/***************************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check whether a specific array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> is NULL<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * nullbitmap: pointer to array's null bitmap (NULL if <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a>)<br/></li>
<li></span><span class="Comment"> * offset: 0-based linear <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> number of array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L4762">&#x200c;</a></span><span class="linkable">array_get_isnull</span>(<span class="Type">const</span> bits8 *nullbitmap, <span class="Type">int</span> offset)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nullbitmap == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* assume not null */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nullbitmap[offset / <span class="Constant">8</span>] &amp; (<span class="Constant">1</span> &lt;&lt; (offset % <span class="Constant">8</span>)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not null */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Set a specific array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>'s null-bitmap entry<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * nullbitmap: pointer to array's null bitmap (mustn't be NULL)<br/></li>
<li></span><span class="Comment"> * offset: 0-based linear <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> number of array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a><br/></li>
<li></span><span class="Comment"> * isNull: null status to set<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4779">&#x200c;</a></span><span class="linkable">array_set_isnull</span>(bits8 *nullbitmap, <span class="Type">int</span> offset, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isNull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitmask;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nullbitmap += offset / <span class="Constant">8</span>;<br/></li>
<li>&nbsp; &nbsp; bitmask = <span class="Constant">1</span> &lt;&lt; (offset % <span class="Constant">8</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *nullbitmap &amp;= ~bitmask;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *nullbitmap |= bitmask;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Fetch array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> at pointer, converted correctly to a Datum<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller must have handled case of NULL <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Datum<br/></li>
<li><a id="L4797">&#x200c;</a><span class="linkable">ArrayCast</span>(<span class="Type">char</span> *value, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> byval, <span class="Type">int</span> len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> fetch_att(value, byval, len);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Copy datum to *dest and return total space used (including align padding)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller must have handled case of NULL <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L4808">&#x200c;</a></span><span class="linkable">ArrayCastAndSet</span>(Datum src,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> typlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> typbyval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span> typalign,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span> *dest)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (typlen &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typbyval)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; store_att_byval(dest, src, typlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memmove(dest, DatumGetPointer(src), typlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; inc = att_align_nominal(typlen, typalign);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!typbyval);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; inc = att_addlength_datum(<span class="Constant">0</span>, typlen, src);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memmove(dest, DatumGetPointer(src), inc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; inc = att_align_nominal(inc, typalign);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> inc;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Advance ptr over nitems array elements<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * ptr: starting location in array<br/></li>
<li></span><span class="Comment"> * offset: 0-based linear <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> number of first <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> (the one at *ptr)<br/></li>
<li></span><span class="Comment"> * nullbitmap: start of array's null bitmap, or NULL if <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a><br/></li>
<li></span><span class="Comment"> * nitems: number of array elements to advance over (&gt;= 0)<br/></li>
<li></span><span class="Comment"> * typlen, typbyval, typalign: storage parameters of array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> datatype<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It is caller's responsibility to ensure that nitems is within <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L4847">&#x200c;</a><span class="linkable">array_seek</span>(<span class="Type">char</span> *ptr, <span class="Type">int</span> offset, bits8 *nullbitmap, <span class="Type">int</span> nitems,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> typlen, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> typbyval, <span class="Type">char</span> typalign)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitmask;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* easy if fixed-size elements and no NULLs */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (typlen &gt; <span class="Constant">0</span> &amp;&amp; !nullbitmap)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> ptr + nitems * ((Size) att_align_nominal(typlen, typalign));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* seems worth having separate loops for NULL and no-NULLs cases */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nullbitmap)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nullbitmap += offset / <span class="Constant">8</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bitmask = <span class="Constant">1</span> &lt;&lt; (offset % <span class="Constant">8</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nitems; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*nullbitmap &amp; bitmask)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr = att_addlength_pointer(ptr, typlen, ptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr = (<span class="Type">char</span> *) att_align_nominal(ptr, typalign);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitmask &lt;&lt;= <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bitmask == <span class="Constant">0x100</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nullbitmap++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitmask = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nitems; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr = att_addlength_pointer(ptr, typlen, ptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr = (<span class="Type">char</span> *) att_align_nominal(ptr, typalign);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ptr;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute total size of the nitems array elements starting at *ptr<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Parameters same as for <a href="#L4847" title="utils/adt/arrayfuncs.c:4847">array_seek</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L4895">&#x200c;</a></span><span class="linkable">array_nelems_size</span>(<span class="Type">char</span> *ptr, <span class="Type">int</span> offset, bits8 *nullbitmap, <span class="Type">int</span> nitems,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> typlen, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> typbyval, <span class="Type">char</span> typalign)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L4847" title="utils/adt/arrayfuncs.c:4847">array_seek</a>(ptr, offset, nullbitmap, nitems,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typlen, typbyval, typalign) - ptr;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Copy nitems array elements from srcptr to destptr<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * destptr: starting destination location (must be enough room!)<br/></li>
<li></span><span class="Comment"> * nitems: number of array elements to copy (&gt;= 0)<br/></li>
<li></span><span class="Comment"> * srcptr: starting location in source array<br/></li>
<li></span><span class="Comment"> * offset: 0-based linear <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> number of first <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> (the one at *srcptr)<br/></li>
<li></span><span class="Comment"> * nullbitmap: start of source array's null bitmap, or NULL if <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a><br/></li>
<li></span><span class="Comment"> * typlen, typbyval, typalign: storage parameters of array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> datatype<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns number of bytes copied<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: this does not take care of setting up the destination's null bitmap!<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L4917">&#x200c;</a></span><span class="linkable">array_copy</span>(<span class="Type">char</span> *destptr, <span class="Type">int</span> nitems,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">char</span> *srcptr, <span class="Type">int</span> offset, bits8 *nullbitmap,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> typlen, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> typbyval, <span class="Type">char</span> typalign)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numbytes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; numbytes = <a href="#L4895" title="utils/adt/arrayfuncs.c:4895">array_nelems_size</a>(srcptr, offset, nullbitmap, nitems,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typlen, typbyval, typalign);<br/></li>
<li>&nbsp; &nbsp; memcpy(destptr, srcptr, numbytes);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> numbytes;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Copy nitems null-bitmap bits from source to destination<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * destbitmap: start of destination array's null bitmap (mustn't be NULL)<br/></li>
<li></span><span class="Comment"> * destoffset: 0-based linear <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> number of first dest <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a><br/></li>
<li></span><span class="Comment"> * srcbitmap: start of source array's null bitmap, or NULL if <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a><br/></li>
<li></span><span class="Comment"> * srcoffset: 0-based linear <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> number of first source <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a><br/></li>
<li></span><span class="Comment"> * nitems: number of bits to copy (&gt;= 0)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If srcbitmap is NULL then we assume the source is all-non-NULL and<br/></li>
<li></span><span class="Comment"> * fill 1's into the destination bitmap.&nbsp; Note that only the specified<br/></li>
<li></span><span class="Comment"> * bits in the destination map are changed, not <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> or after.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this could certainly be optimized using standard bitblt methods.<br/></li>
<li></span><span class="Comment"> * However, it's not clear that the typical Postgres array has enough elements<br/></li>
<li></span><span class="Comment"> * to make it worth worrying too much.&nbsp; For the moment, KISS.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4947">&#x200c;</a></span><span class="linkable">array_bitmap_copy</span>(bits8 *destbitmap, <span class="Type">int</span> destoffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> bits8 *srcbitmap, <span class="Type">int</span> srcoffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> nitems)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; destbitmask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; destbitval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; srcbitmask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; srcbitval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(destbitmap);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nitems &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* don't risk fetch off end of memory */<br/></li>
<li></span>&nbsp; &nbsp; destbitmap += destoffset / <span class="Constant">8</span>;<br/></li>
<li>&nbsp; &nbsp; destbitmask = <span class="Constant">1</span> &lt;&lt; (destoffset % <span class="Constant">8</span>);<br/></li>
<li>&nbsp; &nbsp; destbitval = *destbitmap;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (srcbitmap)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; srcbitmap += srcoffset / <span class="Constant">8</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; srcbitmask = <span class="Constant">1</span> &lt;&lt; (srcoffset % <span class="Constant">8</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; srcbitval = *srcbitmap;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (nitems-- &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (srcbitval &amp; srcbitmask)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; destbitval |= destbitmask;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; destbitval &amp;= ~destbitmask;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; destbitmask &lt;&lt;= <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (destbitmask == <span class="Constant">0x100</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *destbitmap++ = destbitval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; destbitmask = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nitems &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; destbitval = *destbitmap;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; srcbitmask &lt;&lt;= <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (srcbitmask == <span class="Constant">0x100</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; srcbitmap++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; srcbitmask = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nitems &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; srcbitval = *srcbitmap;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (destbitmask != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *destbitmap = destbitval;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (nitems-- &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; destbitval |= destbitmask;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; destbitmask &lt;&lt;= <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (destbitmask == <span class="Constant">0x100</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *destbitmap++ = destbitval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; destbitmask = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nitems &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; destbitval = *destbitmap;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (destbitmask != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *destbitmap = destbitval;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute space needed for a slice of an array<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We assume the caller has verified that the slice coordinates are valid.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L5018">&#x200c;</a></span><span class="linkable">array_slice_size</span>(<span class="Type">char</span> *arraydataptr, bits8 *arraynullsptr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> ndim, <span class="Type">int</span> *dim, <span class="Type">int</span> *lb,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> *st, <span class="Type">int</span> *endp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> typlen, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> typbyval, <span class="Type">char</span> typalign)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; src_offset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; span[MAXDIM],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prod[MAXDIM],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dist[MAXDIM],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indx[MAXDIM];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="arrayutils.c.html#L153" title="utils/adt/arrayutils.c:153">mda_get_range</a>(ndim, span, st, endp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Pretty easy for fixed <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> length without nulls ... */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (typlen &gt; <span class="Constant">0</span> &amp;&amp; !arraynullsptr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="arrayutils.c.html#L57" title="utils/adt/arrayutils.c:57">ArrayGetNItems</a>(ndim, span) * att_align_nominal(typlen, typalign);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Else gotta do it the hard way */<br/></li>
<li></span>&nbsp; &nbsp; src_offset = <a href="arrayutils.c.html#L32" title="utils/adt/arrayutils.c:32">ArrayGetOffset</a>(ndim, dim, lb, st);<br/></li>
<li>&nbsp; &nbsp; ptr = <a href="#L4847" title="utils/adt/arrayfuncs.c:4847">array_seek</a>(arraydataptr, <span class="Constant">0</span>, arraynullsptr, src_offset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typlen, typbyval, typalign);<br/></li>
<li>&nbsp; &nbsp; <a href="arrayutils.c.html#L167" title="utils/adt/arrayutils.c:167">mda_get_prod</a>(ndim, dim, prod);<br/></li>
<li>&nbsp; &nbsp; <a href="arrayutils.c.html#L183" title="utils/adt/arrayutils.c:183">mda_get_offset_values</a>(ndim, dist, prod, span);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; ndim; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indx[i] = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; j = ndim - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dist[j])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr = <a href="#L4847" title="utils/adt/arrayfuncs.c:4847">array_seek</a>(ptr, src_offset, arraynullsptr, dist[j],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typlen, typbyval, typalign);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; src_offset += dist[j];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L4762" title="utils/adt/arrayfuncs.c:4762">array_get_isnull</a>(arraynullsptr, src_offset))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inc = att_addlength_pointer(<span class="Constant">0</span>, typlen, ptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inc = att_align_nominal(inc, typalign);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr += inc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count += inc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; src_offset++;<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> ((j = <a href="arrayutils.c.html#L208" title="utils/adt/arrayutils.c:208">mda_next_tuple</a>(ndim, indx, span)) != -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> count;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Extract a slice of an array into consecutive elements in the destination<br/></li>
<li></span><span class="Comment"> * array.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We assume the caller has verified that the slice coordinates are valid,<br/></li>
<li></span><span class="Comment"> * allocated enough storage for the result, and initialized the header<br/></li>
<li></span><span class="Comment"> * of the new array.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L5078">&#x200c;</a></span><span class="linkable">array_extract_slice</span>(ArrayType *newarray,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> ndim,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> *dim,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> *lb,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span> *arraydataptr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bits8 *arraynullsptr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> *st,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> *endp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> typlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> typbyval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span> typalign)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *destdataptr = ARR_DATA_PTR(newarray);<br/></li>
<li>&nbsp; &nbsp; bits8&nbsp; &nbsp; &nbsp;&nbsp; *destnullsptr = ARR_NULLBITMAP(newarray);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *srcdataptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; src_offset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dest_offset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prod[MAXDIM],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; span[MAXDIM],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dist[MAXDIM],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indx[MAXDIM];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; src_offset = <a href="arrayutils.c.html#L32" title="utils/adt/arrayutils.c:32">ArrayGetOffset</a>(ndim, dim, lb, st);<br/></li>
<li>&nbsp; &nbsp; srcdataptr = <a href="#L4847" title="utils/adt/arrayfuncs.c:4847">array_seek</a>(arraydataptr, <span class="Constant">0</span>, arraynullsptr, src_offset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typlen, typbyval, typalign);<br/></li>
<li>&nbsp; &nbsp; <a href="arrayutils.c.html#L167" title="utils/adt/arrayutils.c:167">mda_get_prod</a>(ndim, dim, prod);<br/></li>
<li>&nbsp; &nbsp; <a href="arrayutils.c.html#L153" title="utils/adt/arrayutils.c:153">mda_get_range</a>(ndim, span, st, endp);<br/></li>
<li>&nbsp; &nbsp; <a href="arrayutils.c.html#L183" title="utils/adt/arrayutils.c:183">mda_get_offset_values</a>(ndim, dist, prod, span);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; ndim; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indx[i] = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; dest_offset = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; j = ndim - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dist[j])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> unwanted elements */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; srcdataptr = <a href="#L4847" title="utils/adt/arrayfuncs.c:4847">array_seek</a>(srcdataptr, src_offset, arraynullsptr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dist[j],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typlen, typbyval, typalign);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; src_offset += dist[j];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; inc = <a href="#L4917" title="utils/adt/arrayfuncs.c:4917">array_copy</a>(destdataptr, <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; srcdataptr, src_offset, arraynullsptr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typlen, typbyval, typalign);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (destnullsptr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4947" title="utils/adt/arrayfuncs.c:4947">array_bitmap_copy</a>(destnullsptr, dest_offset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arraynullsptr, src_offset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; destdataptr += inc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; srcdataptr += inc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; src_offset++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dest_offset++;<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> ((j = <a href="arrayutils.c.html#L208" title="utils/adt/arrayutils.c:208">mda_next_tuple</a>(ndim, indx, span)) != -<span class="Constant">1</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> a slice into an array.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * ndim/dim[]/lb[] are dimensions of the original array.&nbsp; A new array with<br/></li>
<li></span><span class="Comment"> * those same dimensions is to be constructed.&nbsp; destArray must already<br/></li>
<li></span><span class="Comment"> * have been allocated and its header initialized.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * st[]/endp[] identify the slice to be replaced.&nbsp; Elements within the slice<br/></li>
<li></span><span class="Comment"> * volume are taken from consecutive elements of the srcArray; elements<br/></li>
<li></span><span class="Comment"> * outside it are copied from origArray.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We assume the caller has verified that the slice coordinates are valid.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L5151">&#x200c;</a></span><span class="linkable">array_insert_slice</span>(ArrayType *destArray,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ArrayType *origArray,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ArrayType *srcArray,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> ndim,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> *dim,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> *lb,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> *st,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> *endp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> typlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> typbyval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">char</span> typalign)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *destPtr = ARR_DATA_PTR(destArray);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *origPtr = ARR_DATA_PTR(origArray);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *srcPtr = ARR_DATA_PTR(srcArray);<br/></li>
<li>&nbsp; &nbsp; bits8&nbsp; &nbsp; &nbsp;&nbsp; *destBitmap = ARR_NULLBITMAP(destArray);<br/></li>
<li>&nbsp; &nbsp; bits8&nbsp; &nbsp; &nbsp;&nbsp; *origBitmap = ARR_NULLBITMAP(origArray);<br/></li>
<li>&nbsp; &nbsp; bits8&nbsp; &nbsp; &nbsp;&nbsp; *srcBitmap = ARR_NULLBITMAP(srcArray);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; orignitems = <a href="arrayutils.c.html#L57" title="utils/adt/arrayutils.c:57">ArrayGetNItems</a>(ARR_NDIM(origArray),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ARR_DIMS(origArray));<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dest_offset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; orig_offset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; src_offset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prod[MAXDIM],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; span[MAXDIM],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dist[MAXDIM],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indx[MAXDIM];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dest_offset = <a href="arrayutils.c.html#L32" title="utils/adt/arrayutils.c:32">ArrayGetOffset</a>(ndim, dim, lb, st);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* copy items <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the slice start */<br/></li>
<li></span>&nbsp; &nbsp; inc = <a href="#L4917" title="utils/adt/arrayfuncs.c:4917">array_copy</a>(destPtr, dest_offset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; origPtr, <span class="Constant">0</span>, origBitmap,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typlen, typbyval, typalign);<br/></li>
<li>&nbsp; &nbsp; destPtr += inc;<br/></li>
<li>&nbsp; &nbsp; origPtr += inc;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (destBitmap)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4947" title="utils/adt/arrayfuncs.c:4947">array_bitmap_copy</a>(destBitmap, <span class="Constant">0</span>, origBitmap, <span class="Constant">0</span>, dest_offset);<br/></li>
<li>&nbsp; &nbsp; orig_offset = dest_offset;<br/></li>
<li>&nbsp; &nbsp; <a href="arrayutils.c.html#L167" title="utils/adt/arrayutils.c:167">mda_get_prod</a>(ndim, dim, prod);<br/></li>
<li>&nbsp; &nbsp; <a href="arrayutils.c.html#L153" title="utils/adt/arrayutils.c:153">mda_get_range</a>(ndim, span, st, endp);<br/></li>
<li>&nbsp; &nbsp; <a href="arrayutils.c.html#L183" title="utils/adt/arrayutils.c:183">mda_get_offset_values</a>(ndim, dist, prod, span);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; ndim; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indx[i] = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; src_offset = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; j = ndim - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Copy/advance over elements between here and <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> part of slice */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dist[j])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inc = <a href="#L4917" title="utils/adt/arrayfuncs.c:4917">array_copy</a>(destPtr, dist[j],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; origPtr, orig_offset, origBitmap,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typlen, typbyval, typalign);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; destPtr += inc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; origPtr += inc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (destBitmap)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4947" title="utils/adt/arrayfuncs.c:4947">array_bitmap_copy</a>(destBitmap, dest_offset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; origBitmap, orig_offset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dist[j]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dest_offset += dist[j];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; orig_offset += dist[j];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Copy new <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> at this slice position */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; inc = <a href="#L4917" title="utils/adt/arrayfuncs.c:4917">array_copy</a>(destPtr, <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; srcPtr, src_offset, srcBitmap,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typlen, typbyval, typalign);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (destBitmap)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4947" title="utils/adt/arrayfuncs.c:4947">array_bitmap_copy</a>(destBitmap, dest_offset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; srcBitmap, src_offset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; destPtr += inc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; srcPtr += inc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dest_offset++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; src_offset++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Advance over old <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> at this slice position */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; origPtr = <a href="#L4847" title="utils/adt/arrayfuncs.c:4847">array_seek</a>(origPtr, orig_offset, origBitmap, <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typlen, typbyval, typalign);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; orig_offset++;<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> ((j = <a href="arrayutils.c.html#L208" title="utils/adt/arrayutils.c:208">mda_next_tuple</a>(ndim, indx, span)) != -<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* don't <a href="../../regex/rege_dfa.c.html#L777" title="regex/rege_dfa.c:777">miss</a> <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> data at the end */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4917" title="utils/adt/arrayfuncs.c:4917">array_copy</a>(destPtr, orignitems - orig_offset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; origPtr, orig_offset, origBitmap,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typlen, typbyval, typalign);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (destBitmap)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4947" title="utils/adt/arrayfuncs.c:4947">array_bitmap_copy</a>(destBitmap, dest_offset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; origBitmap, orig_offset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; orignitems - orig_offset);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5274" title="utils/adt/arrayfuncs.c:5274">initArrayResult</a> - <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> an empty ArrayBuildState<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; element_type is the array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type (must be a valid array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; rcontext is where to keep working state<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; subcontext is a flag determining whether to use a separate memory context<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: there are two common schemes for using <a href="#L5331" title="utils/adt/arrayfuncs.c:5331">accumArrayResult</a>().<br/></li>
<li></span><span class="Comment"> * In the older scheme, you start with a NULL ArrayBuildState pointer, and<br/></li>
<li></span><span class="Comment"> * call <a href="#L5331" title="utils/adt/arrayfuncs.c:5331">accumArrayResult</a> once per <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>.&nbsp; In this scheme you end up with<br/></li>
<li></span><span class="Comment"> * a NULL pointer if there were no elements, which you need to special-case.<br/></li>
<li></span><span class="Comment"> * In the newer scheme, call <a href="#L5274" title="utils/adt/arrayfuncs.c:5274">initArrayResult</a> and then call <a href="#L5331" title="utils/adt/arrayfuncs.c:5331">accumArrayResult</a><br/></li>
<li></span><span class="Comment"> * once per <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>.&nbsp; In this scheme you always end with a non-NULL pointer<br/></li>
<li></span><span class="Comment"> * that you can pass to <a href="#L5401" title="utils/adt/arrayfuncs.c:5401">makeArrayResult</a>; you get an empty array if there<br/></li>
<li></span><span class="Comment"> * were no elements.&nbsp; This is preferred if an empty array is what you want.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It's possible to choose whether to create a separate memory context for the<br/></li>
<li></span><span class="Comment"> * array build state, or whether to allocate it directly within rcontext.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When there are many concurrent small states (e.g. array_agg() using <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a><br/></li>
<li></span><span class="Comment"> * aggregation of many small groups), using a separate memory context for each<br/></li>
<li></span><span class="Comment"> * one may result in severe memory bloat. In such cases, use the same memory<br/></li>
<li></span><span class="Comment"> * context to <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> all such array build states, and pass<br/></li>
<li></span><span class="Comment"> * subcontext=false.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In cases when the array build states have different lifetimes, using a<br/></li>
<li></span><span class="Comment"> * single memory context is impractical. Instead, pass subcontext=true so that<br/></li>
<li></span><span class="Comment"> * the array build states can be freed individually.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ArrayBuildState *<br/></li>
<li><a id="L5274">&#x200c;</a><span class="linkable">initArrayResult</span>(Oid element_type, MemoryContext rcontext, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> subcontext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When using a subcontext, we can afford to start with a somewhat larger<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * initial array size.&nbsp; Without subcontexts, we'd better hope that most of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the states stay small ...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L5291" title="utils/adt/arrayfuncs.c:5291">initArrayResultWithSize</a>(element_type, rcontext, subcontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; subcontext ? <span class="Constant">64</span> : <span class="Constant">8</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5291" title="utils/adt/arrayfuncs.c:5291">initArrayResultWithSize</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; As <a href="#L5274" title="utils/adt/arrayfuncs.c:5274">initArrayResult</a>, but allow the initial size of the allocated arrays<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; to be specified.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ArrayBuildState *<br/></li>
<li><a id="L5291">&#x200c;</a><span class="linkable">initArrayResultWithSize</span>(Oid element_type, MemoryContext rcontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> subcontext, <span class="Type">int</span> initsize)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayBuildState *astate;<br/></li>
<li>&nbsp; &nbsp; MemoryContext arr_context = rcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make a temporary context to hold all the junk */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (subcontext)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; arr_context = AllocSetContextCreate(rcontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;<a href="#L5331" title="utils/adt/arrayfuncs.c:5331">accumArrayResult</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; astate = (ArrayBuildState *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(arr_context, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ArrayBuildState));<br/></li>
<li>&nbsp; &nbsp; astate-&gt;mcontext = arr_context;<br/></li>
<li>&nbsp; &nbsp; astate-&gt;private_cxt = subcontext;<br/></li>
<li>&nbsp; &nbsp; astate-&gt;alen = initsize;<br/></li>
<li>&nbsp; &nbsp; astate-&gt;dvalues = (Datum *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(arr_context, astate-&gt;alen * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li>&nbsp; &nbsp; astate-&gt;dnulls = (<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(arr_context, astate-&gt;alen * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li>&nbsp; &nbsp; astate-&gt;nelems = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; astate-&gt;element_type = element_type;<br/></li>
<li>&nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L2271" title="utils/cache/lsyscache.c:2271">get_typlenbyvalalign</a>(element_type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;astate-&gt;typlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;astate-&gt;typbyval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;astate-&gt;typalign);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> astate;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5331" title="utils/adt/arrayfuncs.c:5331">accumArrayResult</a> - accumulate one (more) Datum for an array result<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; astate is working state (can be NULL on first call)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; dvalue/disnull represent the new Datum to append to the array<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; element_type is the Datum's type (must be a valid array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; rcontext is where to keep working state<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ArrayBuildState *<br/></li>
<li><a id="L5331">&#x200c;</a><span class="linkable">accumArrayResult</span>(ArrayBuildState *astate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum dvalue, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> disnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid element_type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MemoryContext rcontext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (astate == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* First time through --- <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; astate = <a href="#L5274" title="utils/adt/arrayfuncs.c:5274">initArrayResult</a>(element_type, rcontext, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(astate-&gt;element_type == element_type);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(astate-&gt;mcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* enlarge dvalues[]/dnulls[] if needed */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (astate-&gt;nelems &gt;= astate-&gt;alen)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; astate-&gt;alen *= <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* give an array-related error if we go past MaxAllocSize */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!AllocSizeIsValid(astate-&gt;alen * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;array size exceeds the maximum allowed (</span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">int</span>) MaxAllocSize)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; astate-&gt;dvalues = (Datum *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(astate-&gt;dvalues, astate-&gt;alen * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; astate-&gt;dnulls = (<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(astate-&gt;dnulls, astate-&gt;alen * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ensure pass-by-ref stuff is copied into mcontext; and detoast it too if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it's varlena.&nbsp; (You might think that detoasting is not needed here<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because <a href="#L3475" title="utils/adt/arrayfuncs.c:3475">construct_md_array</a> can detoast the array elements later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * However, we must not let <a href="#L3475" title="utils/adt/arrayfuncs.c:3475">construct_md_array</a> modify the ArrayBuildState<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because that would mean <a href="array_userfuncs.c.html#L822" title="utils/adt/array_userfuncs.c:822">array_agg_finalfn</a> damages its input, which is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * verboten.&nbsp; Also, this way frequently saves one copying step.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!disnull &amp;&amp; !astate-&gt;typbyval)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (astate-&gt;typlen == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dvalue = PointerGetDatum(PG_DETOAST_DATUM_COPY(dvalue));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dvalue = <a href="datum.c.html#L132" title="utils/adt/datum.c:132">datumCopy</a>(dvalue, astate-&gt;typbyval, astate-&gt;typlen);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; astate-&gt;dvalues[astate-&gt;nelems] = dvalue;<br/></li>
<li>&nbsp; &nbsp; astate-&gt;dnulls[astate-&gt;nelems] = disnull;<br/></li>
<li>&nbsp; &nbsp; astate-&gt;nelems++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> astate;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5401" title="utils/adt/arrayfuncs.c:5401">makeArrayResult</a> - produce 1-D final result of <a href="#L5331" title="utils/adt/arrayfuncs.c:5331">accumArrayResult</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: only releases astate if it was initialized within a separate memory<br/></li>
<li></span><span class="Comment"> * context (i.e. using subcontext=true when calling <a href="#L5274" title="utils/adt/arrayfuncs.c:5274">initArrayResult</a>).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; astate is working state (must not be NULL)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; rcontext is where to construct result<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L5401">&#x200c;</a><span class="linkable">makeArrayResult</span>(ArrayBuildState *astate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContext rcontext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndims;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dims[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lbs[<span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If no elements were presented, we want to create an empty array */<br/></li>
<li></span>&nbsp; &nbsp; ndims = (astate-&gt;nelems &gt; <span class="Constant">0</span>) ? <span class="Constant">1</span> : <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; dims[<span class="Constant">0</span>] = astate-&gt;nelems;<br/></li>
<li>&nbsp; &nbsp; lbs[<span class="Constant">0</span>] = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L5433" title="utils/adt/arrayfuncs.c:5433">makeMdArrayResult</a>(astate, ndims, dims, lbs, rcontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; astate-&gt;private_cxt);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5433" title="utils/adt/arrayfuncs.c:5433">makeMdArrayResult</a> - produce multi-D final result of <a href="#L5331" title="utils/adt/arrayfuncs.c:5331">accumArrayResult</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * beware: no check that specified dimensions match the number of <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment"> * accumulated.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: if the astate was not initialized within a separate memory context<br/></li>
<li></span><span class="Comment"> * (that is, <a href="#L5274" title="utils/adt/arrayfuncs.c:5274">initArrayResult</a> was called with subcontext=false), then using<br/></li>
<li></span><span class="Comment"> * release=true is illegal. Instead, release astate along with the rest of its<br/></li>
<li></span><span class="Comment"> * context when appropriate.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; astate is working state (must not be NULL)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; rcontext is where to construct result<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; release is true if okay to release working state<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L5433">&#x200c;</a><span class="linkable">makeMdArrayResult</span>(ArrayBuildState *astate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> ndims,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> *dims,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> *lbs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContext rcontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> release)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Build the final array result in rcontext */<br/></li>
<li></span>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(rcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L3475" title="utils/adt/arrayfuncs.c:3475">construct_md_array</a>(astate-&gt;dvalues,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; astate-&gt;dnulls,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndims,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dims,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lbs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; astate-&gt;element_type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; astate-&gt;typlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; astate-&gt;typbyval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; astate-&gt;typalign);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Clean up all the junk */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (release)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(astate-&gt;private_cxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(astate-&gt;mcontext);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> PointerGetDatum(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The following three <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> provide essentially the same API as<br/></li>
<li></span><span class="Comment"> * <a href="#L5274" title="utils/adt/arrayfuncs.c:5274">initArrayResult</a>/<a href="#L5331" title="utils/adt/arrayfuncs.c:5331">accumArrayResult</a>/<a href="#L5401" title="utils/adt/arrayfuncs.c:5401">makeArrayResult</a>, but instead of accepting<br/></li>
<li></span><span class="Comment"> * inputs that are array elements, they <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> inputs that are arrays and<br/></li>
<li></span><span class="Comment"> * produce an output array having N+1 dimensions.&nbsp; The inputs must all have<br/></li>
<li></span><span class="Comment"> * identical dimensionality as well as <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5485" title="utils/adt/arrayfuncs.c:5485">initArrayResultArr</a> - <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> an empty ArrayBuildStateArr<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; array_type is the array type (must be a valid varlena array type)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; element_type is the type of the array's elements (lookup if InvalidOid)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; rcontext is where to keep working state<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; subcontext is a flag determining whether to use a separate memory context<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ArrayBuildStateArr *<br/></li>
<li><a id="L5485">&#x200c;</a><span class="linkable">initArrayResultArr</span>(Oid array_type, Oid element_type, MemoryContext rcontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> subcontext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayBuildStateArr *astate;<br/></li>
<li>&nbsp; &nbsp; MemoryContext arr_context = rcontext;&nbsp; &nbsp; <span class="Comment">/* by default use the parent ctx */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Lookup <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type, unless element_type already provided */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(element_type))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; element_type = <a href="../cache/lsyscache.c.html#L2759" title="utils/cache/lsyscache.c:2759">get_element_type</a>(array_type);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(element_type))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;data type </span><span class="Special">%s</span><span class="Constant"> is not an array type&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(array_type))));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make a temporary context to hold all the junk */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (subcontext)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; arr_context = AllocSetContextCreate(rcontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;<a href="#L5531" title="utils/adt/arrayfuncs.c:5531">accumArrayResultArr</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Note we <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> all fields to zero */<br/></li>
<li></span>&nbsp; &nbsp; astate = (ArrayBuildStateArr *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1214" title="utils/mmgr/mcxt.c:1214">MemoryContextAllocZero</a>(arr_context, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ArrayBuildStateArr));<br/></li>
<li>&nbsp; &nbsp; astate-&gt;mcontext = arr_context;<br/></li>
<li>&nbsp; &nbsp; astate-&gt;private_cxt = subcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Save relevant datatype information */<br/></li>
<li></span>&nbsp; &nbsp; astate-&gt;array_type = array_type;<br/></li>
<li>&nbsp; &nbsp; astate-&gt;element_type = element_type;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> astate;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5531" title="utils/adt/arrayfuncs.c:5531">accumArrayResultArr</a> - accumulate one (more) sub-array for an array result<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; astate is working state (can be NULL on first call)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; dvalue/disnull represent the new sub-array to append to the array<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; array_type is the array type (must be a valid varlena array type)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; rcontext is where to keep working state<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ArrayBuildStateArr *<br/></li>
<li><a id="L5531">&#x200c;</a><span class="linkable">accumArrayResultArr</span>(ArrayBuildStateArr *astate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum dvalue, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> disnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid array_type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContext rcontext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *arg;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *dims,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *lbs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndims,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nitems,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndatabytes;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *data;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We disallow accumulating null subarrays.&nbsp; Another plausible definition<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is to ignore them, but callers that want that can just <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> calling<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this function.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (disnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NULL_VALUE_NOT_ALLOWED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot accumulate null arrays&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Detoast input array in caller's context */<br/></li>
<li></span>&nbsp; &nbsp; arg = DatumGetArrayTypeP(dvalue);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (astate == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; astate = <a href="#L5485" title="utils/adt/arrayfuncs.c:5485">initArrayResultArr</a>(array_type, InvalidOid, rcontext, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(astate-&gt;array_type == array_type);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(astate-&gt;mcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Collect this input's dimensions */<br/></li>
<li></span>&nbsp; &nbsp; ndims = ARR_NDIM(arg);<br/></li>
<li>&nbsp; &nbsp; dims = ARR_DIMS(arg);<br/></li>
<li>&nbsp; &nbsp; lbs = ARR_LBOUND(arg);<br/></li>
<li>&nbsp; &nbsp; data = ARR_DATA_PTR(arg);<br/></li>
<li>&nbsp; &nbsp; nitems = <a href="arrayutils.c.html#L57" title="utils/adt/arrayutils.c:57">ArrayGetNItems</a>(ndims, dims);<br/></li>
<li>&nbsp; &nbsp; ndatabytes = ARR_SIZE(arg) - ARR_DATA_OFFSET(arg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (astate-&gt;ndims == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* First input; check/save the dimensionality info */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Should we allow empty inputs and just produce an empty output? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ndims == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ARRAY_SUBSCRIPT_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot accumulate empty arrays&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ndims + <span class="Constant">1</span> &gt; MAXDIM)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;number of array dimensions (</span><span class="Special">%d</span><span class="Constant">) exceeds the maximum allowed (</span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndims + <span class="Constant">1</span>, MAXDIM)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The output array will have n+1 dimensions, with the ones after the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * first matching the input's dimensions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; astate-&gt;ndims = ndims + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; astate-&gt;dims[<span class="Constant">0</span>] = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;astate-&gt;dims[<span class="Constant">1</span>], dims, ndims * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; astate-&gt;lbs[<span class="Constant">0</span>] = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;astate-&gt;lbs[<span class="Constant">1</span>], lbs, ndims * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Allocate at least enough data space for this item */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; astate-&gt;abytes = pg_nextpower2_32(Max(<span class="Constant">1024</span>, ndatabytes + <span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; astate-&gt;data = (<span class="Type">char</span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(astate-&gt;abytes);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Second or later input: must match first input's dimensionality */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (astate-&gt;ndims != ndims + <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ARRAY_SUBSCRIPT_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot accumulate arrays of different dimensionality&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; ndims; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (astate-&gt;dims[i + <span class="Constant">1</span>] != dims[i] || astate-&gt;lbs[i + <span class="Constant">1</span>] != lbs[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ARRAY_SUBSCRIPT_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot accumulate arrays of different dimensionality&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Enlarge data space if needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (astate-&gt;nbytes + ndatabytes &gt; astate-&gt;abytes)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; astate-&gt;abytes = Max(astate-&gt;abytes * <span class="Constant">2</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; astate-&gt;nbytes + ndatabytes);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; astate-&gt;data = (<span class="Type">char</span> *) <a href="../mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(astate-&gt;data, astate-&gt;abytes);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Copy the data portion of the sub-array.&nbsp; Note we assume that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * advertised data length of the sub-array is properly aligned.&nbsp; We do not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have to worry about detoasting elements since whatever's in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sub-array should be OK already.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; memcpy(astate-&gt;data + astate-&gt;nbytes, data, ndatabytes);<br/></li>
<li>&nbsp; &nbsp; astate-&gt;nbytes += ndatabytes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Deal with null bitmap if needed */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (astate-&gt;nullbitmap || ARR_HASNULL(arg))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newnitems = astate-&gt;nitems + nitems;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (astate-&gt;nullbitmap == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * First input with nulls; we must retrospectively handle <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * previous inputs by marking all their items non-null.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; astate-&gt;aitems = pg_nextpower2_32(Max(<span class="Constant">256</span>, newnitems + <span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; astate-&gt;nullbitmap = (bits8 *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>((astate-&gt;aitems + <span class="Constant">7</span>) / <span class="Constant">8</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4947" title="utils/adt/arrayfuncs.c:4947">array_bitmap_copy</a>(astate-&gt;nullbitmap, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; astate-&gt;nitems);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (newnitems &gt; astate-&gt;aitems)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; astate-&gt;aitems = Max(astate-&gt;aitems * <span class="Constant">2</span>, newnitems);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; astate-&gt;nullbitmap = (bits8 *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(astate-&gt;nullbitmap, (astate-&gt;aitems + <span class="Constant">7</span>) / <span class="Constant">8</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4947" title="utils/adt/arrayfuncs.c:4947">array_bitmap_copy</a>(astate-&gt;nullbitmap, astate-&gt;nitems,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ARR_NULLBITMAP(arg), <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nitems);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; astate-&gt;nitems += nitems;<br/></li>
<li>&nbsp; &nbsp; astate-&gt;dims[<span class="Constant">0</span>] += <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Release detoasted copy if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((Pointer) arg != DatumGetPointer(dvalue))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(arg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> astate;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5684" title="utils/adt/arrayfuncs.c:5684">makeArrayResultArr</a> - produce N+1-D final result of <a href="#L5531" title="utils/adt/arrayfuncs.c:5531">accumArrayResultArr</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; astate is working state (must not be NULL)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; rcontext is where to construct result<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; release is true if okay to release working state<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L5684">&#x200c;</a><span class="linkable">makeArrayResultArr</span>(ArrayBuildStateArr *astate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MemoryContext rcontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> release)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Build the final array result in rcontext */<br/></li>
<li></span>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(rcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (astate-&gt;ndims == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No inputs, return empty array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L3561" title="utils/adt/arrayfuncs.c:3561">construct_empty_array</a>(astate-&gt;element_type);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dataoffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbytes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check for overflow of the array dimensions */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="arrayutils.c.html#L57" title="utils/adt/arrayutils.c:57">ArrayGetNItems</a>(astate-&gt;ndims, astate-&gt;dims);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="arrayutils.c.html#L117" title="utils/adt/arrayutils.c:117">ArrayCheckBounds</a>(astate-&gt;ndims, astate-&gt;dims, astate-&gt;lbs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Compute required space */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nbytes = astate-&gt;nbytes;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (astate-&gt;nullbitmap != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dataoffset = ARR_OVERHEAD_WITHNULLS(astate-&gt;ndims, astate-&gt;nitems);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbytes += dataoffset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dataoffset = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbytes += ARR_OVERHEAD_NONULLS(astate-&gt;ndims);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = (ArrayType *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(nbytes);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SET_VARSIZE(result, nbytes);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;ndim = astate-&gt;ndims;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;dataoffset = dataoffset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;elemtype = astate-&gt;element_type;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(ARR_DIMS(result), astate-&gt;dims, astate-&gt;ndims * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(ARR_LBOUND(result), astate-&gt;lbs, astate-&gt;ndims * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(ARR_DATA_PTR(result), astate-&gt;data, astate-&gt;nbytes);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (astate-&gt;nullbitmap != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4947" title="utils/adt/arrayfuncs.c:4947">array_bitmap_copy</a>(ARR_NULLBITMAP(result), <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; astate-&gt;nullbitmap, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; astate-&gt;nitems);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Clean up all the junk */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (release)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(astate-&gt;private_cxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(astate-&gt;mcontext);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> PointerGetDatum(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The following three <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> provide essentially the same API as<br/></li>
<li></span><span class="Comment"> * <a href="#L5274" title="utils/adt/arrayfuncs.c:5274">initArrayResult</a>/<a href="#L5331" title="utils/adt/arrayfuncs.c:5331">accumArrayResult</a>/<a href="#L5401" title="utils/adt/arrayfuncs.c:5401">makeArrayResult</a>, but can <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> either<br/></li>
<li></span><span class="Comment"> * scalar or array inputs, invoking the appropriate set of <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> above.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5763" title="utils/adt/arrayfuncs.c:5763">initArrayResultAny</a> - <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> an empty ArrayBuildStateAny<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; input_type is the input datatype (either <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> or array type)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; rcontext is where to keep working state<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; subcontext is a flag determining whether to use a separate memory context<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ArrayBuildStateAny *<br/></li>
<li><a id="L5763">&#x200c;</a><span class="linkable">initArrayResultAny</span>(Oid input_type, MemoryContext rcontext, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> subcontext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayBuildStateAny *astate;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; element_type = <a href="../cache/lsyscache.c.html#L2759" title="utils/cache/lsyscache.c:2759">get_element_type</a>(input_type);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(element_type))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Array case */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ArrayBuildStateArr *arraystate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; arraystate = <a href="#L5485" title="utils/adt/arrayfuncs.c:5485">initArrayResultArr</a>(input_type, InvalidOid, rcontext, subcontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; astate = (ArrayBuildStateAny *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(arraystate-&gt;mcontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ArrayBuildStateAny));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; astate-&gt;scalarstate = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; astate-&gt;arraystate = arraystate;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Scalar case */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ArrayBuildState *scalarstate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Let's just check that we have a type that can be put into arrays */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(OidIsValid(<a href="../cache/lsyscache.c.html#L2787" title="utils/cache/lsyscache.c:2787">get_array_type</a>(input_type)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scalarstate = <a href="#L5274" title="utils/adt/arrayfuncs.c:5274">initArrayResult</a>(input_type, rcontext, subcontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; astate = (ArrayBuildStateAny *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(scalarstate-&gt;mcontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ArrayBuildStateAny));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; astate-&gt;scalarstate = scalarstate;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; astate-&gt;arraystate = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> astate;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5808" title="utils/adt/arrayfuncs.c:5808">accumArrayResultAny</a> - accumulate one (more) input for an array result<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; astate is working state (can be NULL on first call)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; dvalue/disnull represent the new input to append to the array<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; input_type is the input datatype (either <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> or array type)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; rcontext is where to keep working state<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ArrayBuildStateAny *<br/></li>
<li><a id="L5808">&#x200c;</a><span class="linkable">accumArrayResultAny</span>(ArrayBuildStateAny *astate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum dvalue, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> disnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid input_type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContext rcontext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (astate == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; astate = <a href="#L5763" title="utils/adt/arrayfuncs.c:5763">initArrayResultAny</a>(input_type, rcontext, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (astate-&gt;scalarstate)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L5331" title="utils/adt/arrayfuncs.c:5331">accumArrayResult</a>(astate-&gt;scalarstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dvalue, disnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; input_type, rcontext);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L5531" title="utils/adt/arrayfuncs.c:5531">accumArrayResultArr</a>(astate-&gt;arraystate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; dvalue, disnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; input_type, rcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> astate;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5836" title="utils/adt/arrayfuncs.c:5836">makeArrayResultAny</a> - produce final result of <a href="#L5808" title="utils/adt/arrayfuncs.c:5808">accumArrayResultAny</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; astate is working state (must not be NULL)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; rcontext is where to construct result<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; release is true if okay to release working state<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L5836">&#x200c;</a><span class="linkable">makeArrayResultAny</span>(ArrayBuildStateAny *astate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MemoryContext rcontext, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> release)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (astate-&gt;scalarstate)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must use <a href="#L5433" title="utils/adt/arrayfuncs.c:5433">makeMdArrayResult</a> to support &quot;release&quot; parameter */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndims;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dims[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lbs[<span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If no elements were presented, we want to create an empty array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ndims = (astate-&gt;scalarstate-&gt;nelems &gt; <span class="Constant">0</span>) ? <span class="Constant">1</span> : <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dims[<span class="Constant">0</span>] = astate-&gt;scalarstate-&gt;nelems;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lbs[<span class="Constant">0</span>] = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L5433" title="utils/adt/arrayfuncs.c:5433">makeMdArrayResult</a>(astate-&gt;scalarstate, ndims, dims, lbs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rcontext, release);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L5684" title="utils/adt/arrayfuncs.c:5684">makeArrayResultArr</a>(astate-&gt;arraystate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rcontext, release);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L5866">&#x200c;</a><span class="linkable">array_larger</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3966" title="utils/adt/arrayfuncs.c:3966">array_cmp</a>(fcinfo) &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_DATUM(PG_GETARG_DATUM(<span class="Constant">0</span>));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_DATUM(PG_GETARG_DATUM(<span class="Constant">1</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L5875">&#x200c;</a><span class="linkable">array_smaller</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3966" title="utils/adt/arrayfuncs.c:3966">array_cmp</a>(fcinfo) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_DATUM(PG_GETARG_DATUM(<span class="Constant">0</span>));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_DATUM(PG_GETARG_DATUM(<span class="Constant">1</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L5884">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">generate_subscripts_fctx</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; reverse;<br/></li>
<li><a id="L5889">&#x200c;</a>} <span class="linkable">generate_subscripts_fctx</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5896" title="utils/adt/arrayfuncs.c:5896">generate_subscripts</a>(array <a href="pseudotypes.c.html#L154" title="utils/adt/pseudotypes.c:154">anyarray</a>, dim int [, reverse <a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a>])<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns all subscripts of the array for <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> dimension<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L5896">&#x200c;</a><span class="linkable">generate_subscripts</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FuncCallContext *funcctx;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li>&nbsp; &nbsp; <a href="#L5884" title="utils/adt/arrayfuncs.c:5884">generate_subscripts_fctx</a> *fctx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* stuff done only on the first call of the function */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (SRF_IS_FIRSTCALL())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AnyArrayType *v = PG_GETARG_ANY_ARRAY_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reqdim = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *lb,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *dimv;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* create a function context for cross-call persistence */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; funcctx = SRF_FIRSTCALL_INIT();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Sanity check: does it look like an array at all? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (AARR_NDIM(v) &lt;= <span class="Constant">0</span> || AARR_NDIM(v) &gt; MAXDIM)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SRF_RETURN_DONE(funcctx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Sanity check: was the requested dim valid */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (reqdim &lt;= <span class="Constant">0</span> || reqdim &gt; AARR_NDIM(v))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SRF_RETURN_DONE(funcctx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * switch to memory context appropriate for multiple function calls<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(funcctx-&gt;multi_call_memory_ctx);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fctx = (<a href="#L5884" title="utils/adt/arrayfuncs.c:5884">generate_subscripts_fctx</a> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L5884" title="utils/adt/arrayfuncs.c:5884">generate_subscripts_fctx</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lb = AARR_LBOUND(v);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dimv = AARR_DIMS(v);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fctx-&gt;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> = lb[reqdim - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fctx-&gt;<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> = dimv[reqdim - <span class="Constant">1</span>] + lb[reqdim - <span class="Constant">1</span>] - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fctx-&gt;reverse = (PG_NARGS() &lt; <span class="Constant">3</span>) ? <span class="Constant">false</span> : PG_GETARG_BOOL(<span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; funcctx-&gt;user_fctx = fctx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; funcctx = SRF_PERCALL_SETUP();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fctx = funcctx-&gt;user_fctx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fctx-&gt;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> &lt;= fctx-&gt;<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!fctx-&gt;reverse)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SRF_RETURN_NEXT(funcctx, Int32GetDatum(fctx-&gt;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>++));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SRF_RETURN_NEXT(funcctx, Int32GetDatum(fctx-&gt;<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>--));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* done when there are no more elements left */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; SRF_RETURN_DONE(funcctx);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5960" title="utils/adt/arrayfuncs.c:5960">generate_subscripts_nodir</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Implements the 2-argument version of <a href="#L5896" title="utils/adt/arrayfuncs.c:5896">generate_subscripts</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L5960">&#x200c;</a><span class="linkable">generate_subscripts_nodir</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* just call the other one -- it can handle both cases */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L5896" title="utils/adt/arrayfuncs.c:5896">generate_subscripts</a>(fcinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5971" title="utils/adt/arrayfuncs.c:5971">array_fill_with_lower_bounds</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Create and fill array with defined <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bounds.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L5971">&#x200c;</a><span class="linkable">array_fill_with_lower_bounds</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *dims;<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *lbs;<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmtype;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; value;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PG_ARGISNULL(<span class="Constant">1</span>) || PG_ARGISNULL(<span class="Constant">2</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NULL_VALUE_NOT_ALLOWED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;dimension array or low bound array cannot be null&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dims = PG_GETARG_ARRAYTYPE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; lbs = PG_GETARG_ARRAYTYPE_P(<span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!PG_ARGISNULL(<span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; value = PG_GETARG_DATUM(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; value = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; isnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elmtype = <a href="../fmgr/fmgr.c.html#L1910" title="utils/fmgr/fmgr.c:1910">get_fn_expr_argtype</a>(fcinfo-&gt;flinfo, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(elmtype))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not determine data type of input&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L6064" title="utils/adt/arrayfuncs.c:6064">array_fill_internal</a>(dims, lbs, value, isnull, elmtype, fcinfo);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_ARRAYTYPE_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6012" title="utils/adt/arrayfuncs.c:6012">array_fill</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Create and fill array with default <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bounds.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L6012">&#x200c;</a><span class="linkable">array_fill</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *dims;<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmtype;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; value;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PG_ARGISNULL(<span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NULL_VALUE_NOT_ALLOWED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;dimension array or low bound array cannot be null&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dims = PG_GETARG_ARRAYTYPE_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!PG_ARGISNULL(<span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; value = PG_GETARG_DATUM(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; value = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; isnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elmtype = <a href="../fmgr/fmgr.c.html#L1910" title="utils/fmgr/fmgr.c:1910">get_fn_expr_argtype</a>(fcinfo-&gt;flinfo, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(elmtype))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not determine data type of input&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L6064" title="utils/adt/arrayfuncs.c:6064">array_fill_internal</a>(dims, <span class="Constant">NULL</span>, value, isnull, elmtype, fcinfo);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_ARRAYTYPE_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> ArrayType *<br/></li>
<li><a id="L6047">&#x200c;</a><span class="linkable">create_array_envelope</span>(<span class="Type">int</span> ndims, <span class="Type">int</span> *dimv, <span class="Type">int</span> *lbsv, <span class="Type">int</span> nbytes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid elmtype, <span class="Type">int</span> dataoffset)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (ArrayType *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(nbytes);<br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(result, nbytes);<br/></li>
<li>&nbsp; &nbsp; result-&gt;ndim = ndims;<br/></li>
<li>&nbsp; &nbsp; result-&gt;dataoffset = dataoffset;<br/></li>
<li>&nbsp; &nbsp; result-&gt;elemtype = elmtype;<br/></li>
<li>&nbsp; &nbsp; memcpy(ARR_DIMS(result), dimv, ndims * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; memcpy(ARR_LBOUND(result), lbsv, ndims * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> ArrayType *<br/></li>
<li><a id="L6064">&#x200c;</a><span class="linkable">array_fill_internal</span>(ArrayType *dims, ArrayType *lbs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum value, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isnull, Oid elmtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FunctionCallInfo fcinfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *dimv;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *lbsv;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndims;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nitems;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; deflbs[MAXDIM];<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; elmlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; elmbyval;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; elmalign;<br/></li>
<li>&nbsp; &nbsp; ArrayMetaState *my_extra;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Params checks<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ARR_NDIM(dims) &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ARRAY_SUBSCRIPT_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;wrong number of array subscripts&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Dimension array must be one dimensional.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3748" title="utils/adt/arrayfuncs.c:3748">array_contains_nulls</a>(dims))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NULL_VALUE_NOT_ALLOWED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;dimension <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> cannot be null&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dimv = (<span class="Type">int</span> *) ARR_DATA_PTR(dims);<br/></li>
<li>&nbsp; &nbsp; ndims = (ARR_NDIM(dims) &gt; <span class="Constant">0</span>) ? ARR_DIMS(dims)[<span class="Constant">0</span>] : <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ndims &lt; <span class="Constant">0</span>)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we do allow zero-dimension arrays */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid number of dimensions: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, ndims)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ndims &gt; MAXDIM)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;number of array dimensions (</span><span class="Special">%d</span><span class="Constant">) exceeds the maximum allowed (</span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndims, MAXDIM)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lbs != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ARR_NDIM(lbs) &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ARRAY_SUBSCRIPT_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;wrong number of array subscripts&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Dimension array must be one dimensional.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3748" title="utils/adt/arrayfuncs.c:3748">array_contains_nulls</a>(lbs))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NULL_VALUE_NOT_ALLOWED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;dimension <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> cannot be null&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ndims != ((ARR_NDIM(lbs) &gt; <span class="Constant">0</span>) ? ARR_DIMS(lbs)[<span class="Constant">0</span>] : <span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ARRAY_SUBSCRIPT_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;wrong number of array subscripts&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Low bound array has different size than dimensions array.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lbsv = (<span class="Type">int</span> *) ARR_DATA_PTR(lbs);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; MAXDIM; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; deflbs[i] = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lbsv = deflbs;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This checks for overflow of the array dimensions */<br/></li>
<li></span>&nbsp; &nbsp; nitems = <a href="arrayutils.c.html#L57" title="utils/adt/arrayutils.c:57">ArrayGetNItems</a>(ndims, dimv);<br/></li>
<li>&nbsp; &nbsp; <a href="arrayutils.c.html#L117" title="utils/adt/arrayutils.c:117">ArrayCheckBounds</a>(ndims, dimv, lbsv);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fast track for empty array */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nitems &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L3561" title="utils/adt/arrayfuncs.c:3561">construct_empty_array</a>(elmtype);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We arrange to look up info about <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type only once per series of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * calls, assuming the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type doesn't change underneath us.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; my_extra = (ArrayMetaState *) fcinfo-&gt;flinfo-&gt;fn_extra;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (my_extra == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;flinfo-&gt;fn_extra = <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(fcinfo-&gt;flinfo-&gt;fn_mcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ArrayMetaState));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra = (ArrayMetaState *) fcinfo-&gt;flinfo-&gt;fn_extra;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;element_type = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (my_extra-&gt;element_type != elmtype)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get info about <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L2271" title="utils/cache/lsyscache.c:2271">get_typlenbyvalalign</a>(elmtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;my_extra-&gt;typlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;my_extra-&gt;typbyval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;my_extra-&gt;typalign);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;element_type = elmtype;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elmlen = my_extra-&gt;typlen;<br/></li>
<li>&nbsp; &nbsp; elmbyval = my_extra-&gt;typbyval;<br/></li>
<li>&nbsp; &nbsp; elmalign = my_extra-&gt;typalign;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* compute required space */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!isnull)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *p;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbytes;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; totbytes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* make sure data is not toasted */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (elmlen == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value = PointerGetDatum(PG_DETOAST_DATUM(value));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nbytes = att_addlength_datum(<span class="Constant">0</span>, elmlen, value);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nbytes = att_align_nominal(nbytes, elmalign);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(nbytes &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; totbytes = nbytes * nitems;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check for overflow of multiplication or total request */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (totbytes / nbytes != nitems ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !AllocSizeIsValid(totbytes))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;array size exceeds the maximum allowed (</span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">int</span>) MaxAllocSize)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This addition can't overflow, but it might cause us to go past<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * MaxAllocSize.&nbsp; We leave it to <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a> to complain in that case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; totbytes += ARR_OVERHEAD_NONULLS(ndims);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L6047" title="utils/adt/arrayfuncs.c:6047">create_array_envelope</a>(ndims, dimv, lbsv, totbytes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; elmtype, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; p = ARR_DATA_PTR(result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nitems; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p += <a href="#L4808" title="utils/adt/arrayfuncs.c:4808">ArrayCastAndSet</a>(value, elmlen, elmbyval, elmalign, p);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbytes;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dataoffset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dataoffset = ARR_OVERHEAD_WITHNULLS(ndims, nitems);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nbytes = dataoffset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L6047" title="utils/adt/arrayfuncs.c:6047">create_array_envelope</a>(ndims, dimv, lbsv, nbytes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; elmtype, dataoffset);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L6047" title="utils/adt/arrayfuncs.c:6047">create_array_envelope</a> already zeroed the bitmap, so we're done */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * UNNEST<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L6233">&#x200c;</a><span class="linkable">array_unnest</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; array_iter&nbsp; &nbsp; iter;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextelem;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numelems;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; elmlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; elmbyval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; elmalign;<br/></li>
<li>&nbsp; &nbsp; } array_unnest_fctx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; FuncCallContext *funcctx;<br/></li>
<li>&nbsp; &nbsp; array_unnest_fctx *fctx;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* stuff done only on the first call of the function */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (SRF_IS_FIRSTCALL())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AnyArrayType *arr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* create a function context for cross-call persistence */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; funcctx = SRF_FIRSTCALL_INIT();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * switch to memory context appropriate for multiple function calls<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(funcctx-&gt;multi_call_memory_ctx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Get the array value and detoast if needed.&nbsp; We can't do this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * earlier because if we have to detoast, we want the detoasted copy<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to be in multi_call_memory_ctx, so it will go away when we're done<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and not <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>.&nbsp; (If no detoast happens, we assume the originally<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * passed array will stick around till then.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; arr = PG_GETARG_ANY_ARRAY_P(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* allocate memory for user context */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; fctx = (array_unnest_fctx *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(array_unnest_fctx));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> state */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; array_iter_setup(&amp;fctx-&gt;iter, arr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fctx-&gt;nextelem = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fctx-&gt;numelems = <a href="arrayutils.c.html#L57" title="utils/adt/arrayutils.c:57">ArrayGetNItems</a>(AARR_NDIM(arr), AARR_DIMS(arr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (VARATT_IS_EXPANDED_HEADER(arr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we can just grab the type data from expanded array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fctx-&gt;elmlen = arr-&gt;xpn.typlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fctx-&gt;elmbyval = arr-&gt;xpn.typbyval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fctx-&gt;elmalign = arr-&gt;xpn.typalign;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L2271" title="utils/cache/lsyscache.c:2271">get_typlenbyvalalign</a>(AARR_ELEMTYPE(arr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;fctx-&gt;elmlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;fctx-&gt;elmbyval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;fctx-&gt;elmalign);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; funcctx-&gt;user_fctx = fctx;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* stuff done on every call of the function */<br/></li>
<li></span>&nbsp; &nbsp; funcctx = SRF_PERCALL_SETUP();<br/></li>
<li>&nbsp; &nbsp; fctx = funcctx-&gt;user_fctx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fctx-&gt;nextelem &lt; fctx-&gt;numelems)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offset = fctx-&gt;nextelem++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; elem;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elem = array_iter_next(&amp;fctx-&gt;iter, &amp;fcinfo-&gt;isnull, offset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fctx-&gt;elmlen, fctx-&gt;elmbyval, fctx-&gt;elmalign);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SRF_RETURN_NEXT(funcctx, elem);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* do when there is no more left */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; SRF_RETURN_DONE(funcctx);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Planner support function for <a href="#L6233" title="utils/adt/arrayfuncs.c:6233">array_unnest</a>(<a href="pseudotypes.c.html#L154" title="utils/adt/pseudotypes.c:154">anyarray</a>)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this is <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> also used for information_schema._pg_expandarray(),<br/></li>
<li></span><span class="Comment"> * which is simply a wrapper around <a href="#L6233" title="utils/adt/arrayfuncs.c:6233">array_unnest</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L6324">&#x200c;</a><span class="linkable">array_unnest_support</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *rawreq = (Node *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *ret = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(rawreq, SupportRequestRows))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Try to estimate the number of rows returned */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; SupportRequestRows *req = (SupportRequestRows *) rawreq;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (is_funcclause(req-&gt;node))&nbsp; &nbsp; <span class="Comment">/* be paranoid */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *args = ((FuncExpr *) req-&gt;node)-&gt;args;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *arg1;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We can use estimated argument <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arg1 = <a href="../../optimizer/util/clauses.c.html#L2395" title="optimizer/util/clauses.c:2395">estimate_expression_value</a>(req-&gt;root, linitial(args));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; req-&gt;rows = <a href="selfuncs.c.html#L2136" title="utils/adt/selfuncs.c:2136">estimate_array_length</a>(req-&gt;root, arg1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret = (Node *) req;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(ret);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6640" title="utils/adt/arrayfuncs.c:6640">array_replace</a>/<a href="#L6618" title="utils/adt/arrayfuncs.c:6618">array_remove</a> support<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Find all array entries matching (not distinct from) search/search_isnull,<br/></li>
<li></span><span class="Comment"> * and delete them if remove is true, else replace them with<br/></li>
<li></span><span class="Comment"> * replace/replace_isnull.&nbsp; Comparisons are done using the specified<br/></li>
<li></span><span class="Comment"> * collation.&nbsp; fcinfo is passed only for caching purposes.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ArrayType *<br/></li>
<li><a id="L6360">&#x200c;</a><span class="linkable">array_replace_internal</span>(ArrayType *array,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum search, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> search_isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum replace, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> replace_isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> remove, Oid collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; FunctionCallInfo fcinfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCAL_FCINFO(locfcinfo, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; element_type;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *nulls;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *dim;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndim;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nitems,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nresult;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; nbytes = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; dataoffset;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; hasnulls;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; typbyval;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; typalign;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *arraydataptr;<br/></li>
<li>&nbsp; &nbsp; bits8&nbsp; &nbsp; &nbsp;&nbsp; *bitmap;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitmask;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; changed = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typentry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; element_type = ARR_ELEMTYPE(array);<br/></li>
<li>&nbsp; &nbsp; ndim = ARR_NDIM(array);<br/></li>
<li>&nbsp; &nbsp; dim = ARR_DIMS(array);<br/></li>
<li>&nbsp; &nbsp; nitems = <a href="arrayutils.c.html#L57" title="utils/adt/arrayutils.c:57">ArrayGetNItems</a>(ndim, dim);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Return input array unmodified if it is empty */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nitems &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> array;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can't remove elements from multi-dimensional arrays, since the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * result might not be rectangular.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (remove &amp;&amp; ndim &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;removing elements from multidimensional arrays is not supported&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We arrange to look up the equality function only once per series of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * calls, assuming the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type doesn't change underneath us.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; typentry = (TypeCacheEntry *) fcinfo-&gt;flinfo-&gt;fn_extra;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (typentry == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;type_id != element_type)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry = <a href="../cache/typcache.c.html#L346" title="utils/cache/typcache.c:346">lookup_type_cache</a>(element_type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TYPECACHE_EQ_OPR_FINFO);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(typentry-&gt;eq_opr_finfo.fn_oid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not identify an equality operator for type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(element_type))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;flinfo-&gt;fn_extra = (<span class="Type">void</span> *) typentry;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; typlen = typentry-&gt;typlen;<br/></li>
<li>&nbsp; &nbsp; typbyval = typentry-&gt;typbyval;<br/></li>
<li>&nbsp; &nbsp; typalign = typentry-&gt;typalign;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Detoast <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> if they are toasted.&nbsp; The replacement value must be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * detoasted for insertion into the result array, while detoasting the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * search value only once saves cycles.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (typlen == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!search_isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; search = PointerGetDatum(PG_DETOAST_DATUM(search));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!replace_isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; replace = PointerGetDatum(PG_DETOAST_DATUM(replace));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Prepare to apply the comparison operator */<br/></li>
<li></span>&nbsp; &nbsp; InitFunctionCallInfoData(*locfcinfo, &amp;typentry-&gt;eq_opr_finfo, <span class="Constant">2</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; collation, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allocate temporary arrays for new <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> = (Datum *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(nitems * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li>&nbsp; &nbsp; nulls = (<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(nitems * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Loop over source data */<br/></li>
<li></span>&nbsp; &nbsp; arraydataptr = ARR_DATA_PTR(array);<br/></li>
<li>&nbsp; &nbsp; bitmap = ARR_NULLBITMAP(array);<br/></li>
<li>&nbsp; &nbsp; bitmask = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; hasnulls = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; nresult = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nitems; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; elt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isNull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; oprresult;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get source <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>, checking for NULL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bitmap &amp;&amp; (*bitmap &amp; bitmask) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isNull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If searching for NULL, we have a match */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (search_isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (remove)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; changed = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!replace_isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[nresult] = replace;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isNull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; changed = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isNull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elt = fetch_att(arraydataptr, typbyval, typlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arraydataptr = att_addlength_datum(arraydataptr, typlen, elt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arraydataptr = (<span class="Type">char</span> *) att_align_nominal(arraydataptr, typalign);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (search_isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no match possible, keep <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[nresult] = elt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Apply the operator to the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> pair; treat NULL as false<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locfcinfo-&gt;args[<span class="Constant">0</span>].value = elt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locfcinfo-&gt;args[<span class="Constant">0</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locfcinfo-&gt;args[<span class="Constant">1</span>].value = search;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locfcinfo-&gt;args[<span class="Constant">1</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locfcinfo-&gt;isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oprresult = DatumGetBool(FunctionCallInvoke(locfcinfo));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (locfcinfo-&gt;isnull || !oprresult)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no match, keep <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[nresult] = elt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* match, so replace or delete */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; changed = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (remove)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[nresult] = replace;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isNull = replace_isnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[nresult] = isNull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hasnulls = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Update total result size */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbytes = att_addlength_datum(nbytes, typlen, <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[nresult]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbytes = att_align_nominal(nbytes, typalign);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check for overflow of total request */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!AllocSizeIsValid(nbytes))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;array size exceeds the maximum allowed (</span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">int</span>) MaxAllocSize)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nresult++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* advance bitmap pointer if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bitmap)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitmask &lt;&lt;= <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bitmask == <span class="Constant">0x100</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitmap++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitmask = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If not changed just return the original array<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!changed)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(nulls);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> array;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If all elements were removed return an empty array */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nresult == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(nulls);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L3561" title="utils/adt/arrayfuncs.c:3561">construct_empty_array</a>(element_type);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allocate and <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the result array */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (hasnulls)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dataoffset = ARR_OVERHEAD_WITHNULLS(ndim, nresult);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nbytes += dataoffset;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dataoffset = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* marker for no null bitmap */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nbytes += ARR_OVERHEAD_NONULLS(ndim);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; result = (ArrayType *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(nbytes);<br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(result, nbytes);<br/></li>
<li>&nbsp; &nbsp; result-&gt;ndim = ndim;<br/></li>
<li>&nbsp; &nbsp; result-&gt;dataoffset = dataoffset;<br/></li>
<li>&nbsp; &nbsp; result-&gt;elemtype = element_type;<br/></li>
<li>&nbsp; &nbsp; memcpy(ARR_DIMS(result), ARR_DIMS(array), ndim * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; memcpy(ARR_LBOUND(result), ARR_LBOUND(array), ndim * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (remove)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Adjust the result length */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ARR_DIMS(result)[<span class="Constant">0</span>] = nresult;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> data into result array */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L961" title="utils/adt/arrayfuncs.c:961">CopyArrayEls</a>(result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, nulls, nresult,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typlen, typbyval, typalign,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(nulls);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Remove <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> occurrences of an <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> from an array<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If used on a multi-dimensional array this will raise an error.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L6618">&#x200c;</a><span class="linkable">array_remove</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *array;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; search = PG_GETARG_DATUM(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; search_isnull = PG_ARGISNULL(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PG_ARGISNULL(<span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; array = PG_GETARG_ARRAYTYPE_P(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; array = <a href="#L6360" title="utils/adt/arrayfuncs.c:6360">array_replace_internal</a>(array,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; search, search_isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Datum) <span class="Constant">0</span>, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>, PG_GET_COLLATION(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fcinfo);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_ARRAYTYPE_P(array);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Replace <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> occurrences of an <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> in an array<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L6640">&#x200c;</a><span class="linkable">array_replace</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *array;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; search = PG_GETARG_DATUM(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; search_isnull = PG_ARGISNULL(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; replace = PG_GETARG_DATUM(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; replace_isnull = PG_ARGISNULL(<span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PG_ARGISNULL(<span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; array = PG_GETARG_ARRAYTYPE_P(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; array = <a href="#L6360" title="utils/adt/arrayfuncs.c:6360">array_replace_internal</a>(array,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; search, search_isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; replace, replace_isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>, PG_GET_COLLATION(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fcinfo);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_ARRAYTYPE_P(array);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Implements width_bucket(<a href="pseudotypes.c.html#L374" title="utils/adt/pseudotypes.c:374">anyelement</a>, <a href="pseudotypes.c.html#L154" title="utils/adt/pseudotypes.c:154">anyarray</a>).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'thresholds' is an array containing <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for each bucket;<br/></li>
<li></span><span class="Comment"> * these must be sorted from smallest to largest, or bogus results will be<br/></li>
<li></span><span class="Comment"> * produced.&nbsp; If N thresholds are supplied, the output is from 0 to N:<br/></li>
<li></span><span class="Comment"> * 0 is for inputs &lt; first threshold, N is for inputs &gt;= last threshold.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L6669">&#x200c;</a><span class="linkable">width_bucket_array</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; operand = PG_GETARG_DATUM(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *thresholds = PG_GETARG_ARRAYTYPE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collation = PG_GET_COLLATION();<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; element_type = ARR_ELEMTYPE(thresholds);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check input */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ARR_NDIM(thresholds) &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ARRAY_SUBSCRIPT_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;thresholds must be one-dimensional array&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3748" title="utils/adt/arrayfuncs.c:3748">array_contains_nulls</a>(thresholds))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NULL_VALUE_NOT_ALLOWED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;thresholds array must not contain NULLs&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We have a dedicated implementation for float8 data */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (element_type == FLOAT8OID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L6732" title="utils/adt/arrayfuncs.c:6732">width_bucket_array_float8</a>(operand, thresholds);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TypeCacheEntry *typentry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Cache information about the input type */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; typentry = (TypeCacheEntry *) fcinfo-&gt;flinfo-&gt;fn_extra;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typentry == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;type_id != element_type)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typentry = <a href="../cache/typcache.c.html#L346" title="utils/cache/typcache.c:346">lookup_type_cache</a>(element_type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TYPECACHE_CMP_PROC_FINFO);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(typentry-&gt;cmp_proc_finfo.fn_oid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not identify a comparison function for type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(element_type))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;flinfo-&gt;fn_extra = (<span class="Type">void</span> *) typentry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have separate implementation paths for fixed- and variable-width<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * types, since indexing the array is a lot cheaper in the first case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typentry-&gt;typlen &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L6776" title="utils/adt/arrayfuncs.c:6776">width_bucket_array_fixed</a>(operand, thresholds,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collation, typentry);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L6831" title="utils/adt/arrayfuncs.c:6831">width_bucket_array_variable</a>(operand, thresholds,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; collation, typentry);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Avoid leaking memory when handed toasted input. */<br/></li>
<li></span>&nbsp; &nbsp; PG_FREE_IF_COPY(thresholds, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6669" title="utils/adt/arrayfuncs.c:6669">width_bucket_array</a> for float8 data.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L6732">&#x200c;</a></span><span class="linkable">width_bucket_array_float8</span>(Datum operand, ArrayType *thresholds)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; op = DatumGetFloat8(operand);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp;&nbsp; *thresholds_data;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; left;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; right;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since we know the array contains no NULLs, we can just index it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * directly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; thresholds_data = (float8 *) ARR_DATA_PTR(thresholds);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; left = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; right = <a href="arrayutils.c.html#L57" title="utils/adt/arrayutils.c:57">ArrayGetNItems</a>(ARR_NDIM(thresholds), ARR_DIMS(thresholds));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the probe value is a NaN, it's greater than or <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to all possible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * threshold <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> (including other NaNs), so we need not search.&nbsp; Note<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that this would give the same result as searching even if the array<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * contains multiple NaNs (as long as they're correctly sorted), since the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * loop logic will <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the rightmost of multiple <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> threshold <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isnan(op))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> right;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Find the bucket */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (left &lt; right)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mid = (left + right) / <span class="Constant">2</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnan(thresholds_data[mid]) || op &lt; thresholds_data[mid])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; right = mid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; left = mid + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> left;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6669" title="utils/adt/arrayfuncs.c:6669">width_bucket_array</a> for generic fixed-width data types.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L6776">&#x200c;</a></span><span class="linkable">width_bucket_array_fixed</span>(Datum operand,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ArrayType *thresholds,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TypeCacheEntry *typentry)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCAL_FCINFO(locfcinfo, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *thresholds_data;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typlen = typentry-&gt;typlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; typbyval = typentry-&gt;typbyval;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; left;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; right;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since we know the array contains no NULLs, we can just index it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * directly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; thresholds_data = (<span class="Type">char</span> *) ARR_DATA_PTR(thresholds);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; InitFunctionCallInfoData(*locfcinfo, &amp;typentry-&gt;cmp_proc_finfo, <span class="Constant">2</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; collation, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Find the bucket */<br/></li>
<li></span>&nbsp; &nbsp; left = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; right = <a href="arrayutils.c.html#L57" title="utils/adt/arrayutils.c:57">ArrayGetNItems</a>(ARR_NDIM(thresholds), ARR_DIMS(thresholds));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (left &lt; right)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mid = (left + right) / <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; cmpresult;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr = thresholds_data + mid * typlen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; locfcinfo-&gt;args[<span class="Constant">0</span>].value = operand;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; locfcinfo-&gt;args[<span class="Constant">0</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; locfcinfo-&gt;args[<span class="Constant">1</span>].value = fetch_att(ptr, typbyval, typlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; locfcinfo-&gt;args[<span class="Constant">1</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cmpresult = DatumGetInt32(FunctionCallInvoke(locfcinfo));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We don't expect comparison support <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> to return null */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!locfcinfo-&gt;isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cmpresult &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; right = mid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; left = mid + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> left;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6669" title="utils/adt/arrayfuncs.c:6669">width_bucket_array</a> for generic variable-width data types.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L6831">&#x200c;</a></span><span class="linkable">width_bucket_array_variable</span>(Datum operand,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ArrayType *thresholds,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TypeCacheEntry *typentry)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCAL_FCINFO(locfcinfo, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *thresholds_data;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typlen = typentry-&gt;typlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; typbyval = typentry-&gt;typbyval;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; typalign = typentry-&gt;typalign;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; left;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; right;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; thresholds_data = (<span class="Type">char</span> *) ARR_DATA_PTR(thresholds);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; InitFunctionCallInfoData(*locfcinfo, &amp;typentry-&gt;cmp_proc_finfo, <span class="Constant">2</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; collation, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Find the bucket */<br/></li>
<li></span>&nbsp; &nbsp; left = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; right = <a href="arrayutils.c.html#L57" title="utils/adt/arrayutils.c:57">ArrayGetNItems</a>(ARR_NDIM(thresholds), ARR_DIMS(thresholds));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (left &lt; right)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mid = (left + right) / <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; cmpresult;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Locate mid'th array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> by advancing from left <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ptr = thresholds_data;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = left; i &lt; mid; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr = att_addlength_pointer(ptr, typlen, ptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr = (<span class="Type">char</span> *) att_align_nominal(ptr, typalign);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; locfcinfo-&gt;args[<span class="Constant">0</span>].value = operand;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; locfcinfo-&gt;args[<span class="Constant">0</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; locfcinfo-&gt;args[<span class="Constant">1</span>].value = fetch_att(ptr, typbyval, typlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; locfcinfo-&gt;args[<span class="Constant">1</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cmpresult = DatumGetInt32(FunctionCallInvoke(locfcinfo));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We don't expect comparison support <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> to return null */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!locfcinfo-&gt;isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cmpresult &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; right = mid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; left = mid + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Move the thresholds pointer to match new &quot;left&quot; index, so we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't have to seek over those elements again.&nbsp; This trick<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ensures we do only O(N) array indexing work, not O(N^2).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr = att_addlength_pointer(ptr, typlen, ptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; thresholds_data = (<span class="Type">char</span> *) att_align_nominal(ptr, typalign);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> left;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Trim the last N elements from an array by building an appropriate slice.<br/></li>
<li></span><span class="Comment"> * Only the first dimension is trimmed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L6901">&#x200c;</a><span class="linkable">trim_array</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *v = PG_GETARG_ARRAYTYPE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1763" title="utils/adt/arrayfuncs.c:1763">array_length</a> = (ARR_NDIM(v) &gt; <span class="Constant">0</span>) ? ARR_DIMS(v)[<span class="Constant">0</span>] : <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; elmlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; elmbyval;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; elmalign;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>[MAXDIM];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>[MAXDIM];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; lowerProvided[MAXDIM];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; upperProvided[MAXDIM];<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Per spec, throw an error if out of bounds */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (n &lt; <span class="Constant">0</span> || n &gt; <a href="#L1763" title="utils/adt/arrayfuncs.c:1763">array_length</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ARRAY_ELEMENT_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;number of elements to trim must be between 0 and </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1763" title="utils/adt/arrayfuncs.c:1763">array_length</a>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set all the bounds as unprovided except the first <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound */<br/></li>
<li></span>&nbsp; &nbsp; memset(lowerProvided, <span class="Constant">false</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(lowerProvided));<br/></li>
<li>&nbsp; &nbsp; memset(upperProvided, <span class="Constant">false</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(upperProvided));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ARR_NDIM(v) &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>[<span class="Constant">0</span>] = ARR_LBOUND(v)[<span class="Constant">0</span>] + <a href="#L1763" title="utils/adt/arrayfuncs.c:1763">array_length</a> - n - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; upperProvided[<span class="Constant">0</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fetch the needed information about the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L2271" title="utils/cache/lsyscache.c:2271">get_typlenbyvalalign</a>(ARR_ELEMTYPE(v), &amp;elmlen, &amp;elmbyval, &amp;elmalign);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get the slice */<br/></li>
<li></span>&nbsp; &nbsp; result = <a href="#L2030" title="utils/adt/arrayfuncs.c:2030">array_get_slice</a>(PointerGetDatum(v), <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>, <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, upperProvided, lowerProvided,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; -<span class="Constant">1</span>, elmlen, elmbyval, elmalign);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_DATUM(result);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
