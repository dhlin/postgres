<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/adt/enum.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/adt/enum.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L63">check_safe_enum_use</a></li>
<li><a href="#L378">enum_cmp</a></li>
<li><a href="#L252">enum_cmp_internal</a></li>
<li><a href="#L392">enum_endpoint</a></li>
<li><a href="#L324">enum_eq</a></li>
<li><a href="#L437">enum_first</a></li>
<li><a href="#L342">enum_ge</a></li>
<li><a href="#L351">enum_gt</a></li>
<li><a href="#L109">enum_in</a></li>
<li><a href="#L369">enum_larger</a></li>
<li><a href="#L466">enum_last</a></li>
<li><a href="#L315">enum_le</a></li>
<li><a href="#L306">enum_lt</a></li>
<li><a href="#L333">enum_ne</a></li>
<li><a href="#L155">enum_out</a></li>
<li><a href="#L527">enum_range_all</a></li>
<li><a href="#L496">enum_range_bounds</a></li>
<li><a href="#L547">enum_range_internal</a></li>
<li><a href="#L179">enum_recv</a></li>
<li><a href="#L221">enum_send</a></li>
<li><a href="#L360">enum_smaller</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * enum.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; I/O <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, operators, aggregates etc for enum types<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Copyright (c) 2006-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/adt/enum.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/genam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/table.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_enum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/pqformat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/procarray.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/array.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgroids.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/syscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/typcache.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Type">static</span> Oid&nbsp; &nbsp; <a href="#L392" title="utils/adt/enum.c:392">enum_endpoint</a>(Oid enumtypoid, ScanDirection direction);<br/></li>
<li><span class="Type">static</span> ArrayType *<a href="#L547" title="utils/adt/enum.c:547">enum_range_internal</a>(Oid enumtypoid, Oid <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, Oid <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Disallow use of an uncommitted pg_enum tuple.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We need to make sure that uncommitted enum <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> don't get into indexes.<br/></li>
<li></span><span class="Comment"> * If they did, and if we then rolled back the pg_enum addition, we'd have<br/></li>
<li></span><span class="Comment"> * broken the index because value comparisons will not work reliably without<br/></li>
<li></span><span class="Comment"> * an underlying pg_enum entry.&nbsp; (Note that removal of the heap entry<br/></li>
<li></span><span class="Comment"> * containing an enum value is not sufficient to ensure that it doesn't appear<br/></li>
<li></span><span class="Comment"> * in <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> levels of indexes.)&nbsp; To do this we prevent an uncommitted row from<br/></li>
<li></span><span class="Comment"> * being used for <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> SQL-level purpose.&nbsp; This is stronger than necessary,<br/></li>
<li></span><span class="Comment"> * since the value might not be getting inserted into a table or there might<br/></li>
<li></span><span class="Comment"> * be no index on its column, but it's easy to enforce centrally.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * However, it's okay to allow use of uncommitted <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> belonging to enum<br/></li>
<li></span><span class="Comment"> * types that were themselves created in the same transaction, because then<br/></li>
<li></span><span class="Comment"> * <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> such index would also be new and would go away altogether on rollback.<br/></li>
<li></span><span class="Comment"> * We don't implement that fully right <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, but we do allow free use of enum<br/></li>
<li></span><span class="Comment"> * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> created during CREATE TYPE AS ENUM, which are surely of the same<br/></li>
<li></span><span class="Comment"> * lifespan as the enum type.&nbsp; (This case is required by &quot;pg_restore -1&quot;.)<br/></li>
<li></span><span class="Comment"> * Values added by ALTER TYPE ADD VALUE are also allowed if the enum type<br/></li>
<li></span><span class="Comment"> * is known to have been created earlier in the same transaction.&nbsp; (Note that<br/></li>
<li></span><span class="Comment"> * we have to track that explicitly; comparing tuple xmins is insufficient,<br/></li>
<li></span><span class="Comment"> * because the type tuple might have been updated in the current transaction.<br/></li>
<li></span><span class="Comment"> * Subtransactions also create hazards to be accounted for; currently,<br/></li>
<li></span><span class="Comment"> * pg_enum.c only handles ADD VALUE at the outermost transaction level.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function needs to be called (directly or indirectly) in <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> below that could return an enum value to SQL operations.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L63">&#x200c;</a></span><span class="linkable">check_safe_enum_use</span>(HeapTuple enumval_tup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TransactionId xmin;<br/></li>
<li>&nbsp; &nbsp; Form_pg_enum en = (Form_pg_enum) GETSTRUCT(enumval_tup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the row is hinted as committed, it's surely safe.&nbsp; This provides a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fast path for all normal use-cases.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleHeaderXminCommitted(enumval_tup-&gt;t_data))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Usually, a row would get hinted as committed when it's read or loaded<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * into syscache; but just in case not, let's check the xmin directly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; xmin = HeapTupleHeaderGetXmin(enumval_tup-&gt;t_data);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../storage/ipc/procarray.c.html#L1390" title="storage/ipc/procarray.c:1390">TransactionIdIsInProgress</a>(xmin) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/transam.c.html#L126" title="access/transam/transam.c:126">TransactionIdDidCommit</a>(xmin))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check if the enum value is listed as uncommitted.&nbsp; If not, it's safe,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because it can't be shorter-lived than its owning type.&nbsp; (This'd also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be false for <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> made by other transactions; but the previous tests<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * should have handled all of those.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../catalog/pg_enum.c.html#L708" title="catalog/pg_enum.c:708">EnumUncommitted</a>(en-&gt;oid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * There might well be other tests we could do here to narrow down the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unsafe conditions, but for <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> just raise an exception.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNSAFE_NEW_ENUM_VALUE_USAGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unsafe use of new value </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of enum type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(en-&gt;enumlabel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(en-&gt;enumtypid)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;New enum <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> must be committed <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> they can be used.&quot;</span>)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* Basic I/O support */<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L109">&#x200c;</a><span class="linkable">enum_in</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *name = PG_GETARG_CSTRING(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; enumtypoid = PG_GETARG_OID(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *escontext = fcinfo-&gt;context;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; enumoid;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* must check length to prevent Assert failure within <a href="../cache/syscache.c.html#L205" title="utils/cache/syscache.c:205">SearchSysCache</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (strlen(name) &gt;= NAMEDATALEN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid input value for enum </span><span class="Special">%s</span><span class="Constant">: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(enumtypoid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tup = <a href="../cache/syscache.c.html#L229" title="utils/cache/syscache.c:229">SearchSysCache2</a>(ENUMTYPOIDNAME,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(enumtypoid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CStringGetDatum(name));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid input value for enum </span><span class="Special">%s</span><span class="Constant">: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(enumtypoid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check it's safe to use in SQL.&nbsp; Perhaps we should take the trouble to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * report &quot;unsafe use&quot; softly; but it's unclear that it's worth the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * trouble, or indeed that that is a legitimate bad-input case at all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rather than an implementation shortcoming.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L63" title="utils/adt/enum.c:63">check_safe_enum_use</a>(tup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This comes from pg_enum.oid and stores system oids in user tables. This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * oid must be preserved by binary upgrades.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; enumoid = ((Form_pg_enum) GETSTRUCT(tup))-&gt;oid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_OID(enumoid);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L155">&#x200c;</a><span class="linkable">enum_out</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; enumval = PG_GETARG_OID(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tup;<br/></li>
<li>&nbsp; &nbsp; Form_pg_enum en;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tup = <a href="../cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(ENUMOID, ObjectIdGetDatum(enumval));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_BINARY_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> value for enum: </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; enumval)));<br/></li>
<li>&nbsp; &nbsp; en = (Form_pg_enum) GETSTRUCT(tup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(NameStr(en-&gt;enumlabel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CSTRING(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Binary I/O support */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L179">&#x200c;</a><span class="linkable">enum_recv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; buf = (StringInfo) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; enumtypoid = PG_GETARG_OID(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; enumoid;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tup;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *name;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbytes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; name = <a href="../../libpq/pqformat.c.html#L546" title="libpq/pqformat.c:546">pq_getmsgtext</a>(buf, buf-&gt;len - buf-&gt;cursor, &amp;nbytes);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* must check length to prevent Assert failure within <a href="../cache/syscache.c.html#L205" title="utils/cache/syscache.c:205">SearchSysCache</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (strlen(name) &gt;= NAMEDATALEN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid input value for enum </span><span class="Special">%s</span><span class="Constant">: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(enumtypoid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tup = <a href="../cache/syscache.c.html#L229" title="utils/cache/syscache.c:229">SearchSysCache2</a>(ENUMTYPOIDNAME,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(enumtypoid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CStringGetDatum(name));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid input value for enum </span><span class="Special">%s</span><span class="Constant">: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(enumtypoid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check it's safe to use in SQL */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L63" title="utils/adt/enum.c:63">check_safe_enum_use</a>(tup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; enumoid = ((Form_pg_enum) GETSTRUCT(tup))-&gt;oid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(name);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_OID(enumoid);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L221">&#x200c;</a><span class="linkable">enum_send</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; enumval = PG_GETARG_OID(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tup;<br/></li>
<li>&nbsp; &nbsp; Form_pg_enum en;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tup = <a href="../cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(ENUMOID, ObjectIdGetDatum(enumval));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_BINARY_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> value for enum: </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; enumval)));<br/></li>
<li>&nbsp; &nbsp; en = (Form_pg_enum) GETSTRUCT(tup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L326" title="libpq/pqformat.c:326">pq_begintypsend</a>(&amp;buf);<br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L172" title="libpq/pqformat.c:172">pq_sendtext</a>(&amp;buf, NameStr(en-&gt;enumlabel), strlen(NameStr(en-&gt;enumlabel)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BYTEA_P(<a href="../../libpq/pqformat.c.html#L346" title="libpq/pqformat.c:346">pq_endtypsend</a>(&amp;buf));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Comparison <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> and related */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L252" title="utils/adt/enum.c:252">enum_cmp_internal</a> is the common engine for all the visible comparison<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, except for <a href="#L324" title="utils/adt/enum.c:324">enum_eq</a> and <a href="#L333" title="utils/adt/enum.c:333">enum_ne</a> which can just check for OID<br/></li>
<li></span><span class="Comment"> * equality directly.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L252">&#x200c;</a></span><span class="linkable">enum_cmp_internal</span>(Oid arg1, Oid arg2, FunctionCallInfo fcinfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *tcache;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't need the typcache except in the hopefully-uncommon case that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * one or both Oids are odd.&nbsp; This means that cursory testing of code that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fails to pass flinfo to an enum comparison function might not disclose<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the oversight.&nbsp; To make such errors more obvious, Assert that we have a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * place to cache even when we take a fast-path exit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(fcinfo-&gt;flinfo != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Equal OIDs are <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> no matter what */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (arg1 == arg2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fast path: even-numbered Oids are known to <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> correctly */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((arg1 &amp; <span class="Constant">1</span>) == <span class="Constant">0</span> &amp;&amp; (arg2 &amp; <span class="Constant">1</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (arg1 &lt; arg2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Locate the typcache entry for the enum type */<br/></li>
<li></span>&nbsp; &nbsp; tcache = (TypeCacheEntry *) fcinfo-&gt;flinfo-&gt;fn_extra;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tcache == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; enum_tup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_enum en;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typeoid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get the OID of the enum type containing arg1 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; enum_tup = <a href="../cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(ENUMOID, ObjectIdGetDatum(arg1));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(enum_tup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_BINARY_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> value for enum: </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arg1)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; en = (Form_pg_enum) GETSTRUCT(enum_tup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typeoid = en-&gt;enumtypid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(enum_tup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now locate and remember the typcache entry */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tcache = <a href="../cache/typcache.c.html#L346" title="utils/cache/typcache.c:346">lookup_type_cache</a>(typeoid, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;flinfo-&gt;fn_extra = (<span class="Type">void</span> *) tcache;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The remaining comparison logic is in typcache.c */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../cache/typcache.c.html#L2477" title="utils/cache/typcache.c:2477">compare_values_of_enum</a>(tcache, arg1, arg2);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L306">&#x200c;</a><span class="linkable">enum_lt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a = PG_GETARG_OID(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b = PG_GETARG_OID(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L252" title="utils/adt/enum.c:252">enum_cmp_internal</a>(a, b, fcinfo) &lt; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L315">&#x200c;</a><span class="linkable">enum_le</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a = PG_GETARG_OID(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b = PG_GETARG_OID(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L252" title="utils/adt/enum.c:252">enum_cmp_internal</a>(a, b, fcinfo) &lt;= <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L324">&#x200c;</a><span class="linkable">enum_eq</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a = PG_GETARG_OID(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b = PG_GETARG_OID(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(a == b);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L333">&#x200c;</a><span class="linkable">enum_ne</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a = PG_GETARG_OID(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b = PG_GETARG_OID(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(a != b);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L342">&#x200c;</a><span class="linkable">enum_ge</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a = PG_GETARG_OID(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b = PG_GETARG_OID(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L252" title="utils/adt/enum.c:252">enum_cmp_internal</a>(a, b, fcinfo) &gt;= <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L351">&#x200c;</a><span class="linkable">enum_gt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a = PG_GETARG_OID(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b = PG_GETARG_OID(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L252" title="utils/adt/enum.c:252">enum_cmp_internal</a>(a, b, fcinfo) &gt; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L360">&#x200c;</a><span class="linkable">enum_smaller</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a = PG_GETARG_OID(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b = PG_GETARG_OID(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_OID(<a href="#L252" title="utils/adt/enum.c:252">enum_cmp_internal</a>(a, b, fcinfo) &lt; <span class="Constant">0</span> ? a : b);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L369">&#x200c;</a><span class="linkable">enum_larger</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a = PG_GETARG_OID(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b = PG_GETARG_OID(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_OID(<a href="#L252" title="utils/adt/enum.c:252">enum_cmp_internal</a>(a, b, fcinfo) &gt; <span class="Constant">0</span> ? a : b);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L378">&#x200c;</a><span class="linkable">enum_cmp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a = PG_GETARG_OID(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b = PG_GETARG_OID(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(<a href="#L252" title="utils/adt/enum.c:252">enum_cmp_internal</a>(a, b, fcinfo));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Enum programming support <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L392" title="utils/adt/enum.c:392">enum_endpoint</a>: common code for <a href="#L437" title="utils/adt/enum.c:437">enum_first</a>/<a href="#L466" title="utils/adt/enum.c:466">enum_last</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Oid<br/></li>
<li><a id="L392">&#x200c;</a><span class="linkable">enum_endpoint</span>(Oid enumtypoid, ScanDirection direction)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; enum_rel;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; enum_idx;<br/></li>
<li>&nbsp; &nbsp; SysScanDesc enum_scan;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; enum_tuple;<br/></li>
<li>&nbsp; &nbsp; ScanKeyData skey;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; minmax;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Find the first/last enum member using pg_enum_typid_sortorder_index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note we must not use the syscache.&nbsp; See comments for <a href="../../catalog/pg_enum.c.html#L761" title="catalog/pg_enum.c:761">RenumberEnumType</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in catalog/pg_enum.c for more info.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;skey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_enum_enumtypid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(enumtypoid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; enum_rel = <a href="../../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(EnumRelationId, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; enum_idx = <a href="../../access/index/indexam.c.html#L133" title="access/index/indexam.c:133">index_open</a>(EnumTypIdSortOrderIndexId, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; enum_scan = <a href="../../access/index/genam.c.html#L643" title="access/index/genam.c:643">systable_beginscan_ordered</a>(enum_rel, enum_idx, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">1</span>, &amp;skey);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; enum_tuple = <a href="../../access/index/genam.c.html#L710" title="access/index/genam.c:710">systable_getnext_ordered</a>(enum_scan, direction);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(enum_tuple))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check it's safe to use in SQL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L63" title="utils/adt/enum.c:63">check_safe_enum_use</a>(enum_tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; minmax = ((Form_pg_enum) GETSTRUCT(enum_tuple))-&gt;oid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* should only happen with an empty enum */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; minmax = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../access/index/genam.c.html#L735" title="access/index/genam.c:735">systable_endscan_ordered</a>(enum_scan);<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/index/indexam.c.html#L177" title="access/index/indexam.c:177">index_close</a>(enum_idx, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(enum_rel, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> minmax;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L437">&#x200c;</a><span class="linkable">enum_first</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; enumtypoid;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We rely on being able to get the specific enum type from the calling<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * expression tree.&nbsp; Notice that the actual value of the argument isn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * examined at all; in particular it might be NULL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; enumtypoid = <a href="../fmgr/fmgr.c.html#L1910" title="utils/fmgr/fmgr.c:1910">get_fn_expr_argtype</a>(fcinfo-&gt;flinfo, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (enumtypoid == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not determine actual enum type&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get the OID using the index */<br/></li>
<li></span>&nbsp; &nbsp; min = <a href="#L392" title="utils/adt/enum.c:392">enum_endpoint</a>(enumtypoid, ForwardScanDirection);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(min))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;enum </span><span class="Special">%s</span><span class="Constant"> contains no <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(enumtypoid))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_OID(min);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L466">&#x200c;</a><span class="linkable">enum_last</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; enumtypoid;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We rely on being able to get the specific enum type from the calling<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * expression tree.&nbsp; Notice that the actual value of the argument isn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * examined at all; in particular it might be NULL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; enumtypoid = <a href="../fmgr/fmgr.c.html#L1910" title="utils/fmgr/fmgr.c:1910">get_fn_expr_argtype</a>(fcinfo-&gt;flinfo, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (enumtypoid == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not determine actual enum type&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get the OID using the index */<br/></li>
<li></span>&nbsp; &nbsp; max = <a href="#L392" title="utils/adt/enum.c:392">enum_endpoint</a>(enumtypoid, BackwardScanDirection);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(max))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;enum </span><span class="Special">%s</span><span class="Constant"> contains no <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(enumtypoid))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_OID(max);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* 2-argument variant of enum_range */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L496">&#x200c;</a><span class="linkable">enum_range_bounds</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; enumtypoid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PG_ARGISNULL(<span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> = PG_GETARG_OID(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PG_ARGISNULL(<span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> = PG_GETARG_OID(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We rely on being able to get the specific enum type from the calling<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * expression tree.&nbsp; The generic type mechanism should have ensured that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * both are of the same type.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; enumtypoid = <a href="../fmgr/fmgr.c.html#L1910" title="utils/fmgr/fmgr.c:1910">get_fn_expr_argtype</a>(fcinfo-&gt;flinfo, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (enumtypoid == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not determine actual enum type&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_ARRAYTYPE_P(<a href="#L547" title="utils/adt/enum.c:547">enum_range_internal</a>(enumtypoid, <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* 1-argument variant of enum_range */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L527">&#x200c;</a><span class="linkable">enum_range_all</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; enumtypoid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We rely on being able to get the specific enum type from the calling<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * expression tree.&nbsp; Notice that the actual value of the argument isn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * examined at all; in particular it might be NULL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; enumtypoid = <a href="../fmgr/fmgr.c.html#L1910" title="utils/fmgr/fmgr.c:1910">get_fn_expr_argtype</a>(fcinfo-&gt;flinfo, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (enumtypoid == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not determine actual enum type&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_ARRAYTYPE_P(<a href="#L547" title="utils/adt/enum.c:547">enum_range_internal</a>(enumtypoid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidOid, InvalidOid));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> ArrayType *<br/></li>
<li><a id="L547">&#x200c;</a><span class="linkable">enum_range_internal</span>(Oid enumtypoid, Oid <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, Oid <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; enum_rel;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; enum_idx;<br/></li>
<li>&nbsp; &nbsp; SysScanDesc enum_scan;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; enum_tuple;<br/></li>
<li>&nbsp; &nbsp; ScanKeyData skey;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *elems;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cnt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; left_found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Scan the enum members in order using pg_enum_typid_sortorder_index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note we must not use the syscache.&nbsp; See comments for <a href="../../catalog/pg_enum.c.html#L761" title="catalog/pg_enum.c:761">RenumberEnumType</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in catalog/pg_enum.c for more info.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;skey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_enum_enumtypid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(enumtypoid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; enum_rel = <a href="../../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(EnumRelationId, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; enum_idx = <a href="../../access/index/indexam.c.html#L133" title="access/index/indexam.c:133">index_open</a>(EnumTypIdSortOrderIndexId, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; enum_scan = <a href="../../access/index/genam.c.html#L643" title="access/index/genam.c:643">systable_beginscan_ordered</a>(enum_rel, enum_idx, <span class="Constant">NULL</span>, <span class="Constant">1</span>, &amp;skey);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; max = <span class="Constant">64</span>;<br/></li>
<li>&nbsp; &nbsp; elems = (Datum *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(max * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li>&nbsp; &nbsp; cnt = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; left_found = !OidIsValid(<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (HeapTupleIsValid(enum_tuple = <a href="../../access/index/genam.c.html#L710" title="access/index/genam.c:710">systable_getnext_ordered</a>(enum_scan, ForwardScanDirection)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; enum_oid = ((Form_pg_enum) GETSTRUCT(enum_tuple))-&gt;oid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!left_found &amp;&amp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> == enum_oid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; left_found = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (left_found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check it's safe to use in SQL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L63" title="utils/adt/enum.c:63">check_safe_enum_use</a>(enum_tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cnt &gt;= max)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max *= <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elems = (Datum *) <a href="../mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(elems, max * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elems[cnt++] = ObjectIdGetDatum(enum_oid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>) &amp;&amp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> == enum_oid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../access/index/genam.c.html#L735" title="access/index/genam.c:735">systable_endscan_ordered</a>(enum_scan);<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/index/indexam.c.html#L177" title="access/index/indexam.c:177">index_close</a>(enum_idx, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(enum_rel, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* and build the result array */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* note this hardwires some details about the representation of Oid */<br/></li>
<li></span>&nbsp; &nbsp; result = <a href="arrayfuncs.c.html#L3354" title="utils/adt/arrayfuncs.c:3354">construct_array</a>(elems, cnt, enumtypoid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid), <span class="Constant">true</span>, TYPALIGN_INT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(elems);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
